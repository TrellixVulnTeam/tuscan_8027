<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>isapnptools</title>
<style>
body{
  background-color: #002b36;
  color: #839496;
}
code{
  white-space: pre;
}
div{
  padding: 5px;
  border-radius: 5px;
  position: relative;
  float: left;
  min-width: 99%;
  clear: both;
}

/* Each log block */
.block{
  background-color: #073642;
  margin-bottom: 20px;
}

/* Different log block headers */
.die{
  background-color: #cb4b16;
  color: #002b36;
  font-weight: bold;
}
.command{
  background-color: #6c71c4;
  color: #002b36;
  font-weight: bold;
}
.file{
  background-color: #859900;
  color: #002b36;
  font-weight: bold;
}
.info{
  background-color: #859900;
  color: #002b36;
  font-weight: bold;
}

a{
 color: #2aa198;
  text-decoration: none;
}
a:visited {
  color: #d33682;
  text-decoration: none;
}

/* Log block output */
.output{
  background-color: #002b36;
  color: #839496;
}

/* The word CMD that indicates the header of a log block is a
 * command-line invocation
 */
.prompt{
  color: #002b36;
  text-shadow: -2px -2px 0 #b58900,
                2px -2px 0 #b58900,
                2px  2px 0 #b58900,
               -2px  2px 0 #b58900;
}

/* Formats for lines in command output */
.none{

}
.error{
  background-color: #dc322f;
  color: #002b36;
  font-weight: bold;
  text-decoration: underline;
}

</style>
  </head>
  <body>
    <h1>Build of /var/abs/community/isapnptools
        with <a href="../index.html">android</a>
        toolchain</h1>
    <p>This PKGBUILD creates the following packages:</p>
    <ul>
      
    </ul>
    <p>The build took 00:06:02.</p>
    <p>The return code of the build was 5.</p>
    <h2>Log</h2>
    

      <div class="block">
        <div class="info">
          <code>Found permanent source directory in /sources/isapnptools</code>
        </div>
        
      </div>
      <br />
    

      <div class="block">
        <div class="info">
          <code>Removed vanilla repositories from pacman.conf and added:</code>
        </div>
        
          <div class="output">
            
            <span class="none">
            <code>[tuscan]</code><br />
            </span>
            
            <span class="none">
            <code>Server = file:///toolchain_repo</code><br />
            </span>
            
          </div>
        
      </div>
      <br />
    

      <div class="block">
        <div class="command">
          <code><span class="prompt">CMD: </span>pacman -Syy --noconfirm</code>
        </div>
        
          <div class="output">
            
            <span class="none">
            <code>:: Synchronizing package databases...</code><br />
            </span>
            
            <span class="none">
            <code>downloading tuscan.db...</code><br />
            </span>
            
          </div>
        
      </div>
      <br />
    

      <div class="block">
        <div class="command">
          <code><span class="prompt">CMD: </span>sudo -u tuscan PATH=/toolchain_root/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin CC=arm-linux-androideabi-gcc CXX=arm-linux-androideabi-g++ SYSROOT=/build/android-ndk-r10e/platforms/android-21/arch-arm LIBRARY_PATH=/toolchain_root/usr/lib CPATH=/toolchain_root/usr/include makepkg --noextract --syncdeps --skipinteg --skippgpcheck --skipchecksums --noconfirm --nocolor --log --noprogressbar --nocheck</code>
        </div>
        
          <div class="output">
            
            <span class="none">
            <code>==> Making package: isapnptools 1.27-4 (Mon Dec 14 18:51:58 UTC 2015)</code><br />
            </span>
            
            <span class="none">
            <code>==> Checking runtime dependencies...</code><br />
            </span>
            
            <span class="none">
            <code>==> Checking buildtime dependencies...</code><br />
            </span>
            
            <span class="none">
            <code>==> WARNING: Using existing $srcdir/ tree</code><br />
            </span>
            
            <span class="none">
            <code>==> Starting build()...</code><br />
            </span>
            
            <span class="none">
            <code>configure: WARNING: If you wanted to set the --build type, don't use --host.</code><br />
            </span>
            
            <span class="none">
            <code>    If a cross compiler is detected then cross compile mode will be used.</code><br />
            </span>
            
            <span class="none">
            <code>checking for a BSD-compatible install... /usr/bin/install -c</code><br />
            </span>
            
            <span class="none">
            <code>checking whether build environment is sane... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for a thread-safe mkdir -p... /usr/sbin/mkdir -p</code><br />
            </span>
            
            <span class="none">
            <code>checking for gawk... gawk</code><br />
            </span>
            
            <span class="none">
            <code>checking whether make sets $(MAKE)... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for x86_64-unknown-linux-strip... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for strip... strip</code><br />
            </span>
            
            <span class="none">
            <code>checking for gawk... (cached) gawk</code><br />
            </span>
            
            <span class="none">
            <code>checking for x86_64-unknown-linux-gcc... arm-linux-androideabi-gcc</code><br />
            </span>
            
            <span class="none">
            <code>checking for C compiler default output file name... a.out</code><br />
            </span>
            
            <span class="none">
            <code>checking whether the C compiler works... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking whether we are cross compiling... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for suffix of executables... </code><br />
            </span>
            
            <span class="none">
            <code>checking for suffix of object files... o</code><br />
            </span>
            
            <span class="none">
            <code>checking whether we are using the GNU C compiler... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking whether arm-linux-androideabi-gcc accepts -g... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for arm-linux-androideabi-gcc option to accept ISO C89... none needed</code><br />
            </span>
            
            <span class="none">
            <code>checking for style of include used by make... GNU</code><br />
            </span>
            
            <span class="none">
            <code>checking dependency style of arm-linux-androideabi-gcc... gcc3</code><br />
            </span>
            
            <span class="none">
            <code>checking build system type... x86_64-unknown-linux-gnu</code><br />
            </span>
            
            <span class="none">
            <code>checking host system type... x86_64-unknown-linux-gnu</code><br />
            </span>
            
            <span class="none">
            <code>checking for a sed that does not truncate output... /usr/sbin/sed</code><br />
            </span>
            
            <span class="none">
            <code>checking for grep that handles long lines and -e... /usr/sbin/grep</code><br />
            </span>
            
            <span class="none">
            <code>checking for egrep... /usr/sbin/grep -E</code><br />
            </span>
            
            <span class="none">
            <code>checking for ld used by arm-linux-androideabi-gcc... /toolchain_root/arm-linux-androideabi/bin/ld</code><br />
            </span>
            
            <span class="none">
            <code>checking if the linker (/toolchain_root/arm-linux-androideabi/bin/ld) is GNU ld... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for /toolchain_root/arm-linux-androideabi/bin/ld option to reload object files... -r</code><br />
            </span>
            
            <span class="none">
            <code>checking for BSD-compatible nm... /usr/sbin/nm -B</code><br />
            </span>
            
            <span class="none">
            <code>checking whether ln -s works... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking how to recognise dependent libraries... pass_all</code><br />
            </span>
            
            <span class="none">
            <code>checking how to run the C preprocessor... arm-linux-androideabi-gcc -E</code><br />
            </span>
            
            <span class="none">
            <code>checking for ANSI C header files... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for sys/types.h... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for sys/stat.h... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for stdlib.h... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for string.h... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for memory.h... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for strings.h... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for inttypes.h... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for stdint.h... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for unistd.h... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking dlfcn.h usability... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking dlfcn.h presence... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for dlfcn.h... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking whether we are using the GNU C++ compiler... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking whether arm-linux-androideabi-g++ accepts -g... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking dependency style of arm-linux-androideabi-g++... gcc3</code><br />
            </span>
            
            <span class="none">
            <code>checking how to run the C++ preprocessor... arm-linux-androideabi-g++ -E</code><br />
            </span>
            
            <span class="none">
            <code>checking for x86_64-unknown-linux-g77... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for x86_64-unknown-linux-xlf... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for x86_64-unknown-linux-f77... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for x86_64-unknown-linux-frt... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for x86_64-unknown-linux-pgf77... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for x86_64-unknown-linux-cf77... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for x86_64-unknown-linux-fort77... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for x86_64-unknown-linux-fl32... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for x86_64-unknown-linux-af77... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for x86_64-unknown-linux-xlf90... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for x86_64-unknown-linux-f90... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for x86_64-unknown-linux-pgf90... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for x86_64-unknown-linux-pghpf... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for x86_64-unknown-linux-epcf90... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for x86_64-unknown-linux-gfortran... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for x86_64-unknown-linux-g95... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for x86_64-unknown-linux-xlf95... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for x86_64-unknown-linux-f95... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for x86_64-unknown-linux-fort... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for x86_64-unknown-linux-ifort... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for x86_64-unknown-linux-ifc... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for x86_64-unknown-linux-efc... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for x86_64-unknown-linux-pgf95... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for x86_64-unknown-linux-lf95... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for x86_64-unknown-linux-ftn... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for g77... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for xlf... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for f77... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for frt... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for pgf77... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for cf77... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for fort77... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for fl32... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for af77... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for xlf90... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for f90... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for pgf90... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for pghpf... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for epcf90... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for gfortran... gfortran</code><br />
            </span>
            
            <span class="none">
            <code>configure: WARNING: In the future, Autoconf will not detect cross-tools</code><br />
            </span>
            
            <span class="none">
            <code>whose name does not start with the host triplet.  If you think this</code><br />
            </span>
            
            <span class="none">
            <code>configuration is useful to you, please write to autoconf@gnu.org.</code><br />
            </span>
            
            <span class="none">
            <code>checking whether we are using the GNU Fortran 77 compiler... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking whether gfortran accepts -g... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking the maximum length of command line arguments... 32768</code><br />
            </span>
            
            <span class="none">
            <code>checking command to parse /usr/sbin/nm -B output from arm-linux-androideabi-gcc object... ok</code><br />
            </span>
            
            <span class="none">
            <code>checking for objdir... .libs</code><br />
            </span>
            
            <span class="none">
            <code>checking for x86_64-unknown-linux-ar... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for ar... ar</code><br />
            </span>
            
            <span class="none">
            <code>checking for x86_64-unknown-linux-ranlib... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for ranlib... ranlib</code><br />
            </span>
            
            <span class="none">
            <code>checking for x86_64-unknown-linux-strip... strip</code><br />
            </span>
            
            <span class="none">
            <code>checking for correct ltmain.sh version... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking if arm-linux-androideabi-gcc supports -fno-rtti -fno-exceptions... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for arm-linux-androideabi-gcc option to produce PIC... -fPIC</code><br />
            </span>
            
            <span class="none">
            <code>checking if arm-linux-androideabi-gcc PIC flag -fPIC works... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking if arm-linux-androideabi-gcc static flag -static works... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking if arm-linux-androideabi-gcc supports -c -o file.o... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking whether the arm-linux-androideabi-gcc linker (/toolchain_root/arm-linux-androideabi/bin/ld -m elf_i386) supports shared libraries... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking whether -lc should be explicitly linked in... no</code><br />
            </span>
            
            <span class="none">
            <code>checking dynamic linker characteristics... GNU/Linux ld.so</code><br />
            </span>
            
            <span class="none">
            <code>checking how to hardcode library paths into programs... immediate</code><br />
            </span>
            
            <span class="none">
            <code>checking whether stripping libraries is possible... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking if libtool supports shared libraries... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking whether to build shared libraries... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking whether to build static libraries... yes</code><br />
            </span>
            
            <span class="none">
            <code>configure: creating libtool</code><br />
            </span>
            
            <span class="none">
            <code>appending configuration tag "CXX" to libtool</code><br />
            </span>
            
            <span class="none">
            <code>checking for ld used by arm-linux-androideabi-g++... /toolchain_root/arm-linux-androideabi/bin/ld -m elf_i386</code><br />
            </span>
            
            <span class="none">
            <code>checking if the linker (/toolchain_root/arm-linux-androideabi/bin/ld -m elf_i386) is GNU ld... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking whether the arm-linux-androideabi-g++ linker (/toolchain_root/arm-linux-androideabi/bin/ld -m elf_i386) supports shared libraries... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for arm-linux-androideabi-g++ option to produce PIC... -fPIC</code><br />
            </span>
            
            <span class="none">
            <code>checking if arm-linux-androideabi-g++ PIC flag -fPIC works... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking if arm-linux-androideabi-g++ static flag -static works... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking if arm-linux-androideabi-g++ supports -c -o file.o... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking whether the arm-linux-androideabi-g++ linker (/toolchain_root/arm-linux-androideabi/bin/ld -m elf_i386) supports shared libraries... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking dynamic linker characteristics... GNU/Linux ld.so</code><br />
            </span>
            
            <span class="none">
            <code>checking how to hardcode library paths into programs... immediate</code><br />
            </span>
            
            <span class="none">
            <code>appending configuration tag "F77" to libtool</code><br />
            </span>
            
            <span class="none">
            <code>checking if libtool supports shared libraries... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking whether to build shared libraries... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking whether to build static libraries... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for gfortran option to produce PIC... -fPIC</code><br />
            </span>
            
            <span class="none">
            <code>checking if gfortran PIC flag -fPIC works... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking if gfortran static flag -static works... no</code><br />
            </span>
            
            <span class="none">
            <code>checking if gfortran supports -c -o file.o... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking whether the gfortran linker (/toolchain_root/arm-linux-androideabi/bin/ld -m elf_i386) supports shared libraries... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking dynamic linker characteristics... GNU/Linux ld.so</code><br />
            </span>
            
            <span class="none">
            <code>checking how to hardcode library paths into programs... immediate</code><br />
            </span>
            
            <span class="none">
            <code>checking for flex... flex</code><br />
            </span>
            
            <span class="none">
            <code>checking lex output file root... lex.yy</code><br />
            </span>
            
            <span class="none">
            <code>checking lex library... none needed</code><br />
            </span>
            
            <span class="none">
            <code>checking whether yytext is a pointer... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for a BSD-compatible install... /usr/bin/install -c</code><br />
            </span>
            
            <span class="none">
            <code>checking whether ln -s works... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking whether make sets $(MAKE)... (cached) yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for x86_64-unknown-linux-ranlib... ranlib</code><br />
            </span>
            
            <span class="none">
            <code>checking for ANSI C header files... (cached) yes</code><br />
            </span>
            
            <span class="none">
            <code>checking malloc.h usability... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking malloc.h presence... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for malloc.h... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking sys/time.h usability... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking sys/time.h presence... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for sys/time.h... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for unistd.h... (cached) yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for an ANSI C-conforming const... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for inline... inline</code><br />
            </span>
            
            <span class="none">
            <code>checking for pid_t... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for size_t... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking return type of signal handlers... void</code><br />
            </span>
            
            <span class="none">
            <code>checking for vprintf... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for _doprnt... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for strncmp... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for strdup... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for strerror... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for strtol... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for strtoul... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for nanosleep... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for sched_setscheduler... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for snprintf... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for strncasecmp... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for getdelim... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for memcmp... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for iopl... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for ioperm... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for usleep... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for delay... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for _sleep2... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for alarm... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for memset... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for getopt_long... yes</code><br />
            </span>
            
            <span class="none">
            <code>configure: creating ./config.status</code><br />
            </span>
            
            <span class="none">
            <code>config.status: creating include/Makefile</code><br />
            </span>
            
            <span class="none">
            <code>config.status: creating include/isapnp/Makefile</code><br />
            </span>
            
            <span class="none">
            <code>config.status: creating src/Makefile</code><br />
            </span>
            
            <span class="none">
            <code>config.status: creating demos/Makefile</code><br />
            </span>
            
            <span class="none">
            <code>config.status: creating doc/Makefile</code><br />
            </span>
            
            <span class="none">
            <code>config.status: creating Makefile</code><br />
            </span>
            
            <span class="none">
            <code>config.status: creating include/config.h</code><br />
            </span>
            
            <span class="none">
            <code>config.status: executing depfiles commands</code><br />
            </span>
            
            <span class="none">
            <code>Making all in include</code><br />
            </span>
            
            <span class="none">
            <code>make[1]: Entering directory '/tmp/isapnptools/src/isapnptools-1.27/include'</code><br />
            </span>
            
            <span class="none">
            <code>make  all-recursive</code><br />
            </span>
            
            <span class="none">
            <code>make[2]: Entering directory '/tmp/isapnptools/src/isapnptools-1.27/include'</code><br />
            </span>
            
            <span class="none">
            <code>Making all in isapnp</code><br />
            </span>
            
            <span class="none">
            <code>make[3]: Entering directory '/tmp/isapnptools/src/isapnptools-1.27/include/isapnp'</code><br />
            </span>
            
            <span class="none">
            <code>make[3]: Nothing to be done for 'all'.</code><br />
            </span>
            
            <span class="none">
            <code>make[3]: Leaving directory '/tmp/isapnptools/src/isapnptools-1.27/include/isapnp'</code><br />
            </span>
            
            <span class="none">
            <code>make[3]: Entering directory '/tmp/isapnptools/src/isapnptools-1.27/include'</code><br />
            </span>
            
            <span class="none">
            <code>make[3]: Leaving directory '/tmp/isapnptools/src/isapnptools-1.27/include'</code><br />
            </span>
            
            <span class="none">
            <code>make[2]: Leaving directory '/tmp/isapnptools/src/isapnptools-1.27/include'</code><br />
            </span>
            
            <span class="none">
            <code>make[1]: Leaving directory '/tmp/isapnptools/src/isapnptools-1.27/include'</code><br />
            </span>
            
            <span class="none">
            <code>Making all in src</code><br />
            </span>
            
            <span class="none">
            <code>make[1]: Entering directory '/tmp/isapnptools/src/isapnptools-1.27/src'</code><br />
            </span>
            
            <span class="none">
            <code>arm-linux-androideabi-gcc -DHAVE_CONFIG_H -I. -I../include -I../include     -MT callbacks.o -MD -MP -MF .deps/callbacks.Tpo -c -o callbacks.o callbacks.c</code><br />
            </span>
            
            <span class="none">
            <code>arm-linux-androideabi-gcc -DHAVE_CONFIG_H -I. -I../include -I../include     -MT iopl.o -MD -MP -MF .deps/iopl.Tpo -c -o iopl.o iopl.c</code><br />
            </span>
            
            <span class="none">
            <code>callbacks.c: In function 'normal_fatal_error_callback':</code><br />
            </span>
            
            <span class="none">
            <code>callbacks.c:116:3: warning: incompatible implicit declaration of built-in function 'exit' [enabled by default]</code><br />
            </span>
            
            <span class="none">
            <code>   exit(1);</code><br />
            </span>
            
            <span class="none">
            <code>   ^</code><br />
            </span>
            
            <span class="none">
            <code>callbacks.c: In function 'callbacks_init':</code><br />
            </span>
            
            <span class="none">
            <code>callbacks.c:150:5: warning: incompatible implicit declaration of built-in function 'exit' [enabled by default]</code><br />
            </span>
            
            <span class="none">
            <code>     exit(1);</code><br />
            </span>
            
            <span class="none">
            <code>     ^</code><br />
            </span>
            
            <span class="none">
            <code>In file included from iopl.c:48:0:</code><br />
            </span>
            
            <span class="none">
            <code>../include/isapnp/iopl.h:61:27: fatal error: asm/io.h: No such file or directory</code><br />
            </span>
            
            <span class="none">
            <code> #       include <asm/io.h></code><br />
            </span>
            
            <span class="none">
            <code>                           ^</code><br />
            </span>
            
            <span class="none">
            <code>compilation terminated.</code><br />
            </span>
            
            <span class="none">
            <code>Makefile:345: recipe for target 'iopl.o' failed</code><br />
            </span>
            
            <span class="none">
            <code>make[1]: *** [iopl.o] Error 1</code><br />
            </span>
            
            <span class="none">
            <code>make[1]: *** Waiting for unfinished jobs....</code><br />
            </span>
            
            <span class="none">
            <code>mv -f .deps/callbacks.Tpo .deps/callbacks.Po</code><br />
            </span>
            
            <span class="none">
            <code>make[1]: Leaving directory '/tmp/isapnptools/src/isapnptools-1.27/src'</code><br />
            </span>
            
            <span class="none">
            <code>Makefile:238: recipe for target 'all-recursive' failed</code><br />
            </span>
            
            <span class="none">
            <code>make: *** [all-recursive] Error 1</code><br />
            </span>
            
            <span class="none">
            <code>==> ERROR: A failure occurred in build().</code><br />
            </span>
            
            <span class="none">
            <code>    Aborting...</code><br />
            </span>
            
          </div>
        
      </div>
      <br />
    

      <div class="block">
        <div class="info">
          <code>Printing config.logs</code>
        </div>
        
      </div>
      <br />
    

      <div class="block">
        <div class="command">
          <code><span class="prompt">CMD: </span>Config logfile '/tmp/isapnptools/src/isapnptools-1.27/config.log'</code>
        </div>
        
          <div class="output">
            
            <span class="none">
            <code>This file contains any messages produced by compilers while</code><br />
            </span>
            
            <span class="none">
            <code>running configure, to aid debugging if configure makes a mistake.</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>It was created by configure, which was</code><br />
            </span>
            
            <span class="none">
            <code>generated by GNU Autoconf 2.61.  Invocation command line was</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>$ ./configure --host x86_64-unknown-linux --prefix=/usr --sbindir=/usr/bin</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>## --------- ##</code><br />
            </span>
            
            <span class="none">
            <code>## Platform. ##</code><br />
            </span>
            
            <span class="none">
            <code>## --------- ##</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>hostname = 5e868de1d28e</code><br />
            </span>
            
            <span class="none">
            <code>uname -m = x86_64</code><br />
            </span>
            
            <span class="none">
            <code>uname -r = 3.13.0-67-generic</code><br />
            </span>
            
            <span class="none">
            <code>uname -s = Linux</code><br />
            </span>
            
            <span class="none">
            <code>uname -v = #110-Ubuntu SMP Fri Oct 23 13:24:41 UTC 2015</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>/usr/bin/uname -p = unknown</code><br />
            </span>
            
            <span class="none">
            <code>/bin/uname -X     = unknown</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>/bin/arch              = unknown</code><br />
            </span>
            
            <span class="none">
            <code>/usr/bin/arch -k       = unknown</code><br />
            </span>
            
            <span class="none">
            <code>/usr/convex/getsysinfo = unknown</code><br />
            </span>
            
            <span class="none">
            <code>/usr/bin/hostinfo      = unknown</code><br />
            </span>
            
            <span class="none">
            <code>/bin/machine           = unknown</code><br />
            </span>
            
            <span class="none">
            <code>/usr/bin/oslevel       = unknown</code><br />
            </span>
            
            <span class="none">
            <code>/bin/universe          = unknown</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>PATH: /toolchain_root/bin</code><br />
            </span>
            
            <span class="none">
            <code>PATH: /usr/local/sbin</code><br />
            </span>
            
            <span class="none">
            <code>PATH: /usr/local/bin</code><br />
            </span>
            
            <span class="none">
            <code>PATH: /usr/sbin</code><br />
            </span>
            
            <span class="none">
            <code>PATH: /usr/bin</code><br />
            </span>
            
            <span class="none">
            <code>PATH: /sbin</code><br />
            </span>
            
            <span class="none">
            <code>PATH: /bin</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>## ----------- ##</code><br />
            </span>
            
            <span class="none">
            <code>## Core tests. ##</code><br />
            </span>
            
            <span class="none">
            <code>## ----------- ##</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>configure:1983: checking for a BSD-compatible install</code><br />
            </span>
            
            <span class="none">
            <code>configure:2039: result: /usr/bin/install -c</code><br />
            </span>
            
            <span class="none">
            <code>configure:2050: checking whether build environment is sane</code><br />
            </span>
            
            <span class="none">
            <code>configure:2093: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:2121: checking for a thread-safe mkdir -p</code><br />
            </span>
            
            <span class="none">
            <code>configure:2160: result: /usr/sbin/mkdir -p</code><br />
            </span>
            
            <span class="none">
            <code>configure:2173: checking for gawk</code><br />
            </span>
            
            <span class="none">
            <code>configure:2189: found /usr/sbin/gawk</code><br />
            </span>
            
            <span class="none">
            <code>configure:2200: result: gawk</code><br />
            </span>
            
            <span class="none">
            <code>configure:2211: checking whether make sets $(MAKE)</code><br />
            </span>
            
            <span class="none">
            <code>configure:2232: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:2312: checking for x86_64-unknown-linux-strip</code><br />
            </span>
            
            <span class="none">
            <code>configure:2342: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:2352: checking for strip</code><br />
            </span>
            
            <span class="none">
            <code>configure:2368: found /usr/sbin/strip</code><br />
            </span>
            
            <span class="none">
            <code>configure:2379: result: strip</code><br />
            </span>
            
            <span class="none">
            <code>configure:2428: checking for gawk</code><br />
            </span>
            
            <span class="none">
            <code>configure:2455: result: gawk</code><br />
            </span>
            
            <span class="none">
            <code>configure:2474: checking for x86_64-unknown-linux-gcc</code><br />
            </span>
            
            <span class="none">
            <code>configure:2501: result: arm-linux-androideabi-gcc</code><br />
            </span>
            
            <span class="none">
            <code>configure:2779: checking for C compiler version</code><br />
            </span>
            
            <span class="none">
            <code>configure:2786: arm-linux-androideabi-gcc --version >&5</code><br />
            </span>
            
            <span class="none">
            <code>arm-linux-androideabi-gcc (GCC) 4.8</code><br />
            </span>
            
            <span class="none">
            <code>Copyright (C) 2013 Free Software Foundation, Inc.</code><br />
            </span>
            
            <span class="none">
            <code>This is free software; see the source for copying conditions.  There is NO</code><br />
            </span>
            
            <span class="none">
            <code>warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>configure:2789: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:2796: arm-linux-androideabi-gcc -v >&5</code><br />
            </span>
            
            <span class="none">
            <code>Using built-in specs.</code><br />
            </span>
            
            <span class="none">
            <code>COLLECT_GCC=arm-linux-androideabi-gcc</code><br />
            </span>
            
            <span class="none">
            <code>COLLECT_LTO_WRAPPER=/toolchain_root/bin/../libexec/gcc/arm-linux-androideabi/4.8/lto-wrapper</code><br />
            </span>
            
            <span class="none">
            <code>Target: arm-linux-androideabi</code><br />
            </span>
            
            <span class="none">
            <code>Configured with: /s/ndk-toolchain/src/build/../gcc/gcc-4.8/configure --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --target=arm-linux-androideabi --host=x86_64-linux-gnu --build=x86_64-linux-gnu --with-gnu-as --with-gnu-ld --enable-languages=c,c++ --with-gmp=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpfr=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpc=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-cloog=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-isl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-ppl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --disable-ppl-version-check --disable-cloog-version-check --disable-isl-version-check --enable-cloog-backend=isl --with-host-libstdcxx='-static-libgcc -Wl,-Bstatic,-lstdc++,-Bdynamic -lm' --disable-libssp --enable-threads --disable-nls --disable-libmudflap --disable-libgomp --disable-libstdc__-v3 --disable-sjlj-exceptions --disable-shared --disable-tls --disable-libitm --with-float=soft --with-fpu=vfp --with-arch=armv5te --enable-target-optspace --enable-initfini-array --disable-nls --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --with-sysroot=/tmp/ndk-andrewhsieh/build/toolchain/prefix/sysroot --with-binutils-version=2.25 --with-mpfr-version=3.1.1 --with-mpc-version=1.0.1 --with-gmp-version=5.0.5 --with-gcc-version=4.8 --with-gdb-version=7.7 --with-python=/usr/local/google/home/andrewhsieh/mydroid/ndk/prebuilt/linux-x86_64/bin/python-config.sh --with-gxx-include-dir=/tmp/ndk-andrewhsieh/build/toolchain/prefix/include/c++/4.8 --with-bugurl=http://source.android.com/source/report-bugs.html --enable-languages=c,c++ --disable-bootstrap --enable-plugins --enable-libgomp --enable-gnu-indirect-function --disable-libsanitizer --enable-gold --enable-threads --enable-graphite=yes --with-cloog-version=0.18.0 --with-isl-version=0.11.1 --enable-eh-frame-hdr-for-static --with-arch=armv5te --program-transform-name='s&^&arm-linux-androideabi-&' --enable-gold=default</code><br />
            </span>
            
            <span class="none">
            <code>Thread model: posix</code><br />
            </span>
            
            <span class="none">
            <code>gcc version 4.8 (GCC)</code><br />
            </span>
            
            <span class="none">
            <code>configure:2799: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:2806: arm-linux-androideabi-gcc -V >&5</code><br />
            </span>
            
            <span class="error">
            <code>arm-linux-androideabi-gcc: error: unrecognized command line option '-V'</code><br />
            </span>
            
            <span class="none">
            <code>arm-linux-androideabi-gcc: fatal error: no input files</code><br />
            </span>
            
            <span class="none">
            <code>compilation terminated.</code><br />
            </span>
            
            <span class="none">
            <code>configure:2809: $? = 1</code><br />
            </span>
            
            <span class="none">
            <code>configure:2832: checking for C compiler default output file name</code><br />
            </span>
            
            <span class="none">
            <code>configure:2859: arm-linux-androideabi-gcc    conftest.c  >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:2862: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:2900: result: a.out</code><br />
            </span>
            
            <span class="none">
            <code>configure:2917: checking whether the C compiler works</code><br />
            </span>
            
            <span class="none">
            <code>configure:2927: ./a.out</code><br />
            </span>
            
            <span class="none">
            <code>./configure: line 2928: ./a.out: cannot execute binary file: Exec format error</code><br />
            </span>
            
            <span class="none">
            <code>configure:2930: $? = 126</code><br />
            </span>
            
            <span class="none">
            <code>configure:2947: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:2954: checking whether we are cross compiling</code><br />
            </span>
            
            <span class="none">
            <code>configure:2956: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:2959: checking for suffix of executables</code><br />
            </span>
            
            <span class="none">
            <code>configure:2966: arm-linux-androideabi-gcc -o conftest    conftest.c  >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:2969: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:2993: result:</code><br />
            </span>
            
            <span class="none">
            <code>configure:2999: checking for suffix of object files</code><br />
            </span>
            
            <span class="none">
            <code>configure:3025: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:3028: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:3051: result: o</code><br />
            </span>
            
            <span class="none">
            <code>configure:3055: checking whether we are using the GNU C compiler</code><br />
            </span>
            
            <span class="none">
            <code>configure:3084: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:3090: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:3107: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:3112: checking whether arm-linux-androideabi-gcc accepts -g</code><br />
            </span>
            
            <span class="none">
            <code>configure:3142: arm-linux-androideabi-gcc -c -g  conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:3148: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:3247: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:3264: checking for arm-linux-androideabi-gcc option to accept ISO C89</code><br />
            </span>
            
            <span class="none">
            <code>configure:3338: arm-linux-androideabi-gcc  -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:3344: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:3367: result: none needed</code><br />
            </span>
            
            <span class="none">
            <code>configure:3396: checking for style of include used by make</code><br />
            </span>
            
            <span class="none">
            <code>configure:3424: result: GNU</code><br />
            </span>
            
            <span class="none">
            <code>configure:3449: checking dependency style of arm-linux-androideabi-gcc</code><br />
            </span>
            
            <span class="none">
            <code>configure:3540: result: gcc3</code><br />
            </span>
            
            <span class="none">
            <code>configure:3633: checking build system type</code><br />
            </span>
            
            <span class="none">
            <code>configure:3651: result: x86_64-unknown-linux-gnu</code><br />
            </span>
            
            <span class="none">
            <code>configure:3673: checking host system type</code><br />
            </span>
            
            <span class="none">
            <code>configure:3688: result: x86_64-unknown-linux-gnu</code><br />
            </span>
            
            <span class="none">
            <code>configure:3710: checking for a sed that does not truncate output</code><br />
            </span>
            
            <span class="none">
            <code>configure:3764: result: /usr/sbin/sed</code><br />
            </span>
            
            <span class="none">
            <code>configure:3767: checking for grep that handles long lines and -e</code><br />
            </span>
            
            <span class="none">
            <code>configure:3841: result: /usr/sbin/grep</code><br />
            </span>
            
            <span class="none">
            <code>configure:3846: checking for egrep</code><br />
            </span>
            
            <span class="none">
            <code>configure:3924: result: /usr/sbin/grep -E</code><br />
            </span>
            
            <span class="none">
            <code>configure:3940: checking for ld used by arm-linux-androideabi-gcc</code><br />
            </span>
            
            <span class="none">
            <code>configure:4007: result: /toolchain_root/arm-linux-androideabi/bin/ld</code><br />
            </span>
            
            <span class="none">
            <code>configure:4016: checking if the linker (/toolchain_root/arm-linux-androideabi/bin/ld) is GNU ld</code><br />
            </span>
            
            <span class="none">
            <code>configure:4031: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4036: checking for /toolchain_root/arm-linux-androideabi/bin/ld option to reload object files</code><br />
            </span>
            
            <span class="none">
            <code>configure:4043: result: -r</code><br />
            </span>
            
            <span class="none">
            <code>configure:4061: checking for BSD-compatible nm</code><br />
            </span>
            
            <span class="none">
            <code>configure:4110: result: /usr/sbin/nm -B</code><br />
            </span>
            
            <span class="none">
            <code>configure:4114: checking whether ln -s works</code><br />
            </span>
            
            <span class="none">
            <code>configure:4118: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4125: checking how to recognise dependent libraries</code><br />
            </span>
            
            <span class="none">
            <code>configure:4301: result: pass_all</code><br />
            </span>
            
            <span class="none">
            <code>configure:4389: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:4392: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4535: checking how to run the C preprocessor</code><br />
            </span>
            
            <span class="none">
            <code>configure:4575: arm-linux-androideabi-gcc -E  conftest.c</code><br />
            </span>
            
            <span class="none">
            <code>configure:4581: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4612: arm-linux-androideabi-gcc -E  conftest.c</code><br />
            </span>
            
            <span class="none">
            <code>conftest.c:10:28: fatal error: ac_nonexistent.h: No such file or directory</code><br />
            </span>
            
            <span class="none">
            <code>#include <ac_nonexistent.h></code><br />
            </span>
            
            <span class="none">
            <code>^</code><br />
            </span>
            
            <span class="none">
            <code>compilation terminated.</code><br />
            </span>
            
            <span class="none">
            <code>configure:4618: $? = 1</code><br />
            </span>
            
            <span class="none">
            <code>configure: failed program was:</code><br />
            </span>
            
            <span class="none">
            <code>| /* confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_NAME ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_TARNAME ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_VERSION ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_STRING ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_BUGREPORT ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE "isapnptools"</code><br />
            </span>
            
            <span class="none">
            <code>| #define VERSION "1.27"</code><br />
            </span>
            
            <span class="none">
            <code>| /* end confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #include <ac_nonexistent.h></code><br />
            </span>
            
            <span class="none">
            <code>configure:4651: result: arm-linux-androideabi-gcc -E</code><br />
            </span>
            
            <span class="none">
            <code>configure:4680: arm-linux-androideabi-gcc -E  conftest.c</code><br />
            </span>
            
            <span class="none">
            <code>configure:4686: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4717: arm-linux-androideabi-gcc -E  conftest.c</code><br />
            </span>
            
            <span class="none">
            <code>conftest.c:10:28: fatal error: ac_nonexistent.h: No such file or directory</code><br />
            </span>
            
            <span class="none">
            <code>#include <ac_nonexistent.h></code><br />
            </span>
            
            <span class="none">
            <code>^</code><br />
            </span>
            
            <span class="none">
            <code>compilation terminated.</code><br />
            </span>
            
            <span class="none">
            <code>configure:4723: $? = 1</code><br />
            </span>
            
            <span class="none">
            <code>configure: failed program was:</code><br />
            </span>
            
            <span class="none">
            <code>| /* confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_NAME ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_TARNAME ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_VERSION ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_STRING ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_BUGREPORT ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE "isapnptools"</code><br />
            </span>
            
            <span class="none">
            <code>| #define VERSION "1.27"</code><br />
            </span>
            
            <span class="none">
            <code>| /* end confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #include <ac_nonexistent.h></code><br />
            </span>
            
            <span class="none">
            <code>configure:4761: checking for ANSI C header files</code><br />
            </span>
            
            <span class="none">
            <code>configure:4791: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:4797: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4925: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4949: checking for sys/types.h</code><br />
            </span>
            
            <span class="none">
            <code>configure:4970: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:4976: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4992: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4949: checking for sys/stat.h</code><br />
            </span>
            
            <span class="none">
            <code>configure:4970: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:4976: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4992: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4949: checking for stdlib.h</code><br />
            </span>
            
            <span class="none">
            <code>configure:4970: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:4976: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4992: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4949: checking for string.h</code><br />
            </span>
            
            <span class="none">
            <code>configure:4970: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:4976: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4992: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4949: checking for memory.h</code><br />
            </span>
            
            <span class="none">
            <code>configure:4970: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:4976: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4992: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4949: checking for strings.h</code><br />
            </span>
            
            <span class="none">
            <code>configure:4970: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:4976: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4992: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4949: checking for inttypes.h</code><br />
            </span>
            
            <span class="none">
            <code>configure:4970: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:4976: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4992: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4949: checking for stdint.h</code><br />
            </span>
            
            <span class="none">
            <code>configure:4970: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:4976: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4992: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4949: checking for unistd.h</code><br />
            </span>
            
            <span class="none">
            <code>configure:4970: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:4976: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4992: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:5019: checking dlfcn.h usability</code><br />
            </span>
            
            <span class="none">
            <code>configure:5036: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:5042: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:5056: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:5060: checking dlfcn.h presence</code><br />
            </span>
            
            <span class="none">
            <code>configure:5075: arm-linux-androideabi-gcc -E  conftest.c</code><br />
            </span>
            
            <span class="none">
            <code>configure:5081: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:5095: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:5123: checking for dlfcn.h</code><br />
            </span>
            
            <span class="none">
            <code>configure:5131: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:5260: checking for C++ compiler version</code><br />
            </span>
            
            <span class="none">
            <code>configure:5267: arm-linux-androideabi-g++ --version >&5</code><br />
            </span>
            
            <span class="none">
            <code>arm-linux-androideabi-g++ (GCC) 4.8</code><br />
            </span>
            
            <span class="none">
            <code>Copyright (C) 2013 Free Software Foundation, Inc.</code><br />
            </span>
            
            <span class="none">
            <code>This is free software; see the source for copying conditions.  There is NO</code><br />
            </span>
            
            <span class="none">
            <code>warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>configure:5270: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:5277: arm-linux-androideabi-g++ -v >&5</code><br />
            </span>
            
            <span class="none">
            <code>Using built-in specs.</code><br />
            </span>
            
            <span class="none">
            <code>COLLECT_GCC=arm-linux-androideabi-g++</code><br />
            </span>
            
            <span class="none">
            <code>COLLECT_LTO_WRAPPER=/toolchain_root/bin/../libexec/gcc/arm-linux-androideabi/4.8/lto-wrapper</code><br />
            </span>
            
            <span class="none">
            <code>Target: arm-linux-androideabi</code><br />
            </span>
            
            <span class="none">
            <code>Configured with: /s/ndk-toolchain/src/build/../gcc/gcc-4.8/configure --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --target=arm-linux-androideabi --host=x86_64-linux-gnu --build=x86_64-linux-gnu --with-gnu-as --with-gnu-ld --enable-languages=c,c++ --with-gmp=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpfr=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpc=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-cloog=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-isl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-ppl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --disable-ppl-version-check --disable-cloog-version-check --disable-isl-version-check --enable-cloog-backend=isl --with-host-libstdcxx='-static-libgcc -Wl,-Bstatic,-lstdc++,-Bdynamic -lm' --disable-libssp --enable-threads --disable-nls --disable-libmudflap --disable-libgomp --disable-libstdc__-v3 --disable-sjlj-exceptions --disable-shared --disable-tls --disable-libitm --with-float=soft --with-fpu=vfp --with-arch=armv5te --enable-target-optspace --enable-initfini-array --disable-nls --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --with-sysroot=/tmp/ndk-andrewhsieh/build/toolchain/prefix/sysroot --with-binutils-version=2.25 --with-mpfr-version=3.1.1 --with-mpc-version=1.0.1 --with-gmp-version=5.0.5 --with-gcc-version=4.8 --with-gdb-version=7.7 --with-python=/usr/local/google/home/andrewhsieh/mydroid/ndk/prebuilt/linux-x86_64/bin/python-config.sh --with-gxx-include-dir=/tmp/ndk-andrewhsieh/build/toolchain/prefix/include/c++/4.8 --with-bugurl=http://source.android.com/source/report-bugs.html --enable-languages=c,c++ --disable-bootstrap --enable-plugins --enable-libgomp --enable-gnu-indirect-function --disable-libsanitizer --enable-gold --enable-threads --enable-graphite=yes --with-cloog-version=0.18.0 --with-isl-version=0.11.1 --enable-eh-frame-hdr-for-static --with-arch=armv5te --program-transform-name='s&^&arm-linux-androideabi-&' --enable-gold=default</code><br />
            </span>
            
            <span class="none">
            <code>Thread model: posix</code><br />
            </span>
            
            <span class="none">
            <code>gcc version 4.8 (GCC)</code><br />
            </span>
            
            <span class="none">
            <code>configure:5280: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:5287: arm-linux-androideabi-g++ -V >&5</code><br />
            </span>
            
            <span class="none">
            <code>arm-linux-androideabi-g++: error: unrecognized command line option '-V'</code><br />
            </span>
            
            <span class="none">
            <code>arm-linux-androideabi-g++: fatal error: no input files</code><br />
            </span>
            
            <span class="none">
            <code>compilation terminated.</code><br />
            </span>
            
            <span class="none">
            <code>configure:5290: $? = 1</code><br />
            </span>
            
            <span class="none">
            <code>configure:5293: checking whether we are using the GNU C++ compiler</code><br />
            </span>
            
            <span class="none">
            <code>configure:5322: arm-linux-androideabi-g++ -c   conftest.cpp >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:5328: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:5345: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:5350: checking whether arm-linux-androideabi-g++ accepts -g</code><br />
            </span>
            
            <span class="none">
            <code>configure:5380: arm-linux-androideabi-g++ -c -g  conftest.cpp >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:5386: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:5485: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:5510: checking dependency style of arm-linux-androideabi-g++</code><br />
            </span>
            
            <span class="none">
            <code>configure:5601: result: gcc3</code><br />
            </span>
            
            <span class="none">
            <code>configure:5626: checking how to run the C++ preprocessor</code><br />
            </span>
            
            <span class="none">
            <code>configure:5662: arm-linux-androideabi-g++ -E  conftest.cpp</code><br />
            </span>
            
            <span class="none">
            <code>configure:5668: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:5699: arm-linux-androideabi-g++ -E  conftest.cpp</code><br />
            </span>
            
            <span class="none">
            <code>conftest.cpp:21:28: fatal error: ac_nonexistent.h: No such file or directory</code><br />
            </span>
            
            <span class="none">
            <code>#include <ac_nonexistent.h></code><br />
            </span>
            
            <span class="none">
            <code>^</code><br />
            </span>
            
            <span class="none">
            <code>compilation terminated.</code><br />
            </span>
            
            <span class="none">
            <code>configure:5705: $? = 1</code><br />
            </span>
            
            <span class="none">
            <code>configure: failed program was:</code><br />
            </span>
            
            <span class="none">
            <code>| /* confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_NAME ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_TARNAME ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_VERSION ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_STRING ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_BUGREPORT ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE "isapnptools"</code><br />
            </span>
            
            <span class="none">
            <code>| #define VERSION "1.27"</code><br />
            </span>
            
            <span class="none">
            <code>| #define STDC_HEADERS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_TYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_STAT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDLIB_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRING_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_MEMORY_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRINGS_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_INTTYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDINT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_DLFCN_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| /* end confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #include <ac_nonexistent.h></code><br />
            </span>
            
            <span class="none">
            <code>configure:5738: result: arm-linux-androideabi-g++ -E</code><br />
            </span>
            
            <span class="none">
            <code>configure:5767: arm-linux-androideabi-g++ -E  conftest.cpp</code><br />
            </span>
            
            <span class="none">
            <code>configure:5773: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:5804: arm-linux-androideabi-g++ -E  conftest.cpp</code><br />
            </span>
            
            <span class="none">
            <code>conftest.cpp:21:28: fatal error: ac_nonexistent.h: No such file or directory</code><br />
            </span>
            
            <span class="none">
            <code>#include <ac_nonexistent.h></code><br />
            </span>
            
            <span class="none">
            <code>^</code><br />
            </span>
            
            <span class="none">
            <code>compilation terminated.</code><br />
            </span>
            
            <span class="none">
            <code>configure:5810: $? = 1</code><br />
            </span>
            
            <span class="none">
            <code>configure: failed program was:</code><br />
            </span>
            
            <span class="none">
            <code>| /* confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_NAME ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_TARNAME ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_VERSION ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_STRING ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_BUGREPORT ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE "isapnptools"</code><br />
            </span>
            
            <span class="none">
            <code>| #define VERSION "1.27"</code><br />
            </span>
            
            <span class="none">
            <code>| #define STDC_HEADERS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_TYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_STAT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDLIB_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRING_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_MEMORY_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRINGS_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_INTTYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDINT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_DLFCN_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| /* end confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #include <ac_nonexistent.h></code><br />
            </span>
            
            <span class="none">
            <code>configure:5859: checking for x86_64-unknown-linux-g77</code><br />
            </span>
            
            <span class="none">
            <code>configure:5889: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5859: checking for x86_64-unknown-linux-xlf</code><br />
            </span>
            
            <span class="none">
            <code>configure:5889: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5859: checking for x86_64-unknown-linux-f77</code><br />
            </span>
            
            <span class="none">
            <code>configure:5889: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5859: checking for x86_64-unknown-linux-frt</code><br />
            </span>
            
            <span class="none">
            <code>configure:5889: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5859: checking for x86_64-unknown-linux-pgf77</code><br />
            </span>
            
            <span class="none">
            <code>configure:5889: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5859: checking for x86_64-unknown-linux-cf77</code><br />
            </span>
            
            <span class="none">
            <code>configure:5889: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5859: checking for x86_64-unknown-linux-fort77</code><br />
            </span>
            
            <span class="none">
            <code>configure:5889: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5859: checking for x86_64-unknown-linux-fl32</code><br />
            </span>
            
            <span class="none">
            <code>configure:5889: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5859: checking for x86_64-unknown-linux-af77</code><br />
            </span>
            
            <span class="none">
            <code>configure:5889: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5859: checking for x86_64-unknown-linux-xlf90</code><br />
            </span>
            
            <span class="none">
            <code>configure:5889: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5859: checking for x86_64-unknown-linux-f90</code><br />
            </span>
            
            <span class="none">
            <code>configure:5889: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5859: checking for x86_64-unknown-linux-pgf90</code><br />
            </span>
            
            <span class="none">
            <code>configure:5889: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5859: checking for x86_64-unknown-linux-pghpf</code><br />
            </span>
            
            <span class="none">
            <code>configure:5889: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5859: checking for x86_64-unknown-linux-epcf90</code><br />
            </span>
            
            <span class="none">
            <code>configure:5889: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5859: checking for x86_64-unknown-linux-gfortran</code><br />
            </span>
            
            <span class="none">
            <code>configure:5889: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5859: checking for x86_64-unknown-linux-g95</code><br />
            </span>
            
            <span class="none">
            <code>configure:5889: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5859: checking for x86_64-unknown-linux-xlf95</code><br />
            </span>
            
            <span class="none">
            <code>configure:5889: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5859: checking for x86_64-unknown-linux-f95</code><br />
            </span>
            
            <span class="none">
            <code>configure:5889: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5859: checking for x86_64-unknown-linux-fort</code><br />
            </span>
            
            <span class="none">
            <code>configure:5889: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5859: checking for x86_64-unknown-linux-ifort</code><br />
            </span>
            
            <span class="none">
            <code>configure:5889: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5859: checking for x86_64-unknown-linux-ifc</code><br />
            </span>
            
            <span class="none">
            <code>configure:5889: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5859: checking for x86_64-unknown-linux-efc</code><br />
            </span>
            
            <span class="none">
            <code>configure:5889: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5859: checking for x86_64-unknown-linux-pgf95</code><br />
            </span>
            
            <span class="none">
            <code>configure:5889: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5859: checking for x86_64-unknown-linux-lf95</code><br />
            </span>
            
            <span class="none">
            <code>configure:5889: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5859: checking for x86_64-unknown-linux-ftn</code><br />
            </span>
            
            <span class="none">
            <code>configure:5889: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5903: checking for g77</code><br />
            </span>
            
            <span class="none">
            <code>configure:5933: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5903: checking for xlf</code><br />
            </span>
            
            <span class="none">
            <code>configure:5933: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5903: checking for f77</code><br />
            </span>
            
            <span class="none">
            <code>configure:5933: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5903: checking for frt</code><br />
            </span>
            
            <span class="none">
            <code>configure:5933: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5903: checking for pgf77</code><br />
            </span>
            
            <span class="none">
            <code>configure:5933: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5903: checking for cf77</code><br />
            </span>
            
            <span class="none">
            <code>configure:5933: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5903: checking for fort77</code><br />
            </span>
            
            <span class="none">
            <code>configure:5933: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5903: checking for fl32</code><br />
            </span>
            
            <span class="none">
            <code>configure:5933: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5903: checking for af77</code><br />
            </span>
            
            <span class="none">
            <code>configure:5933: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5903: checking for xlf90</code><br />
            </span>
            
            <span class="none">
            <code>configure:5933: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5903: checking for f90</code><br />
            </span>
            
            <span class="none">
            <code>configure:5933: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5903: checking for pgf90</code><br />
            </span>
            
            <span class="none">
            <code>configure:5933: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5903: checking for pghpf</code><br />
            </span>
            
            <span class="none">
            <code>configure:5933: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5903: checking for epcf90</code><br />
            </span>
            
            <span class="none">
            <code>configure:5933: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5903: checking for gfortran</code><br />
            </span>
            
            <span class="none">
            <code>configure:5919: found /usr/sbin/gfortran</code><br />
            </span>
            
            <span class="none">
            <code>configure:5930: result: gfortran</code><br />
            </span>
            
            <span class="none">
            <code>configure:5948: WARNING: In the future, Autoconf will not detect cross-tools</code><br />
            </span>
            
            <span class="none">
            <code>whose name does not start with the host triplet.  If you think this</code><br />
            </span>
            
            <span class="none">
            <code>configuration is useful to you, please write to autoconf@gnu.org.</code><br />
            </span>
            
            <span class="none">
            <code>configure:5960: checking for Fortran 77 compiler version</code><br />
            </span>
            
            <span class="none">
            <code>configure:5967: gfortran --version >&5</code><br />
            </span>
            
            <span class="none">
            <code>GNU Fortran (GCC) 5.2.0</code><br />
            </span>
            
            <span class="none">
            <code>Copyright (C) 2015 Free Software Foundation, Inc.</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>GNU Fortran comes with NO WARRANTY, to the extent permitted by law.</code><br />
            </span>
            
            <span class="none">
            <code>You may redistribute copies of GNU Fortran</code><br />
            </span>
            
            <span class="none">
            <code>under the terms of the GNU General Public License.</code><br />
            </span>
            
            <span class="none">
            <code>For more information about these matters, see the file named COPYING</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>configure:5970: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:5977: gfortran -v >&5</code><br />
            </span>
            
            <span class="none">
            <code>Using built-in specs.</code><br />
            </span>
            
            <span class="none">
            <code>COLLECT_GCC=gfortran</code><br />
            </span>
            
            <span class="none">
            <code>COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-unknown-linux-gnu/5.2.0/lto-wrapper</code><br />
            </span>
            
            <span class="none">
            <code>Target: x86_64-unknown-linux-gnu</code><br />
            </span>
            
            <span class="none">
            <code>Configured with: /build/gcc/src/gcc-5.2.0/configure --prefix=/usr --libdir=/usr/lib --libexecdir=/usr/lib --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=https://bugs.archlinux.org/ --enable-languages=c,c++,ada,fortran,go,lto,objc,obj-c++ --enable-shared --enable-threads=posix --enable-libmpx --with-system-zlib --with-isl --enable-__cxa_atexit --disable-libunwind-exceptions --enable-clocale=gnu --disable-libstdcxx-pch --disable-libssp --enable-gnu-unique-object --enable-linker-build-id --enable-lto --enable-plugin --enable-install-libiberty --with-linker-hash-style=gnu --enable-gnu-indirect-function --disable-multilib --disable-werror --enable-checking=release --with-default-libstdcxx-abi=gcc4-compatible</code><br />
            </span>
            
            <span class="none">
            <code>Thread model: posix</code><br />
            </span>
            
            <span class="none">
            <code>gcc version 5.2.0 (GCC)</code><br />
            </span>
            
            <span class="none">
            <code>configure:5980: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:5987: gfortran -V >&5</code><br />
            </span>
            
            <span class="none">
            <code>gfortran: error: unrecognized command line option '-V'</code><br />
            </span>
            
            <span class="none">
            <code>gfortran: fatal error: no input files</code><br />
            </span>
            
            <span class="none">
            <code>compilation terminated.</code><br />
            </span>
            
            <span class="none">
            <code>configure:5990: $? = 1</code><br />
            </span>
            
            <span class="none">
            <code>configure:5998: checking whether we are using the GNU Fortran 77 compiler</code><br />
            </span>
            
            <span class="none">
            <code>configure:6017: gfortran -c  conftest.F >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:6023: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:6040: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:6046: checking whether gfortran accepts -g</code><br />
            </span>
            
            <span class="none">
            <code>configure:6063: gfortran -c -g conftest.f >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:6069: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:6085: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:6115: checking the maximum length of command line arguments</code><br />
            </span>
            
            <span class="none">
            <code>configure:6224: result: 32768</code><br />
            </span>
            
            <span class="none">
            <code>configure:6235: checking command to parse /usr/sbin/nm -B output from arm-linux-androideabi-gcc object</code><br />
            </span>
            
            <span class="none">
            <code>configure:6340: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:6343: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:6347: /usr/sbin/nm -B conftest.o \| sed -n -e 's/^.*[ 	]\([ABCDGIRSTW][ABCDGIRSTW]*\)[ 	][ 	]*\([_A-Za-z][_A-Za-z0-9]*\)$/\1 \2 \2/p' \> conftest.nm</code><br />
            </span>
            
            <span class="none">
            <code>configure:6350: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:6402: arm-linux-androideabi-gcc -o conftest    conftest.c conftstm.o >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:6405: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:6443: result: ok</code><br />
            </span>
            
            <span class="none">
            <code>configure:6447: checking for objdir</code><br />
            </span>
            
            <span class="none">
            <code>configure:6462: result: .libs</code><br />
            </span>
            
            <span class="none">
            <code>configure:6514: checking for x86_64-unknown-linux-ar</code><br />
            </span>
            
            <span class="none">
            <code>configure:6544: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:6554: checking for ar</code><br />
            </span>
            
            <span class="none">
            <code>configure:6570: found /usr/sbin/ar</code><br />
            </span>
            
            <span class="none">
            <code>configure:6581: result: ar</code><br />
            </span>
            
            <span class="none">
            <code>configure:6610: checking for x86_64-unknown-linux-ranlib</code><br />
            </span>
            
            <span class="none">
            <code>configure:6640: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:6650: checking for ranlib</code><br />
            </span>
            
            <span class="none">
            <code>configure:6666: found /usr/sbin/ranlib</code><br />
            </span>
            
            <span class="none">
            <code>configure:6677: result: ranlib</code><br />
            </span>
            
            <span class="none">
            <code>configure:6706: checking for x86_64-unknown-linux-strip</code><br />
            </span>
            
            <span class="none">
            <code>configure:6733: result: strip</code><br />
            </span>
            
            <span class="none">
            <code>configure:7010: checking for correct ltmain.sh version</code><br />
            </span>
            
            <span class="none">
            <code>configure:7060: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:7120: checking if arm-linux-androideabi-gcc supports -fno-rtti -fno-exceptions</code><br />
            </span>
            
            <span class="none">
            <code>configure:7138: arm-linux-androideabi-gcc -c   -fno-rtti -fno-exceptions conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>cc1: warning: command line option '-fno-rtti' is valid for C++/ObjC++ but not for C [enabled by default]</code><br />
            </span>
            
            <span class="none">
            <code>configure:7142: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:7155: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:7170: checking for arm-linux-androideabi-gcc option to produce PIC</code><br />
            </span>
            
            <span class="none">
            <code>configure:7380: result: -fPIC</code><br />
            </span>
            
            <span class="none">
            <code>configure:7388: checking if arm-linux-androideabi-gcc PIC flag -fPIC works</code><br />
            </span>
            
            <span class="none">
            <code>configure:7406: arm-linux-androideabi-gcc -c   -fPIC -DPIC conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:7410: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:7423: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:7451: checking if arm-linux-androideabi-gcc static flag -static works</code><br />
            </span>
            
            <span class="none">
            <code>configure:7479: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:7489: checking if arm-linux-androideabi-gcc supports -c -o file.o</code><br />
            </span>
            
            <span class="none">
            <code>configure:7510: arm-linux-androideabi-gcc -c   -o out/conftest2.o conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:7514: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:7536: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:7562: checking whether the arm-linux-androideabi-gcc linker (/toolchain_root/arm-linux-androideabi/bin/ld -m elf_i386) supports shared libraries</code><br />
            </span>
            
            <span class="none">
            <code>configure:8516: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:8537: checking whether -lc should be explicitly linked in</code><br />
            </span>
            
            <span class="none">
            <code>configure:8542: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:8545: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:8560: arm-linux-androideabi-gcc -shared conftest.o  -v -Wl,-soname -Wl,conftest -o conftest 2\>\&1 \| grep  -lc  \>/dev/null 2\>\&1</code><br />
            </span>
            
            <span class="none">
            <code>configure:8563: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:8575: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:8583: checking dynamic linker characteristics</code><br />
            </span>
            
            <span class="none">
            <code>configure:9208: result: GNU/Linux ld.so</code><br />
            </span>
            
            <span class="none">
            <code>configure:9217: checking how to hardcode library paths into programs</code><br />
            </span>
            
            <span class="none">
            <code>configure:9242: result: immediate</code><br />
            </span>
            
            <span class="none">
            <code>configure:9256: checking whether stripping libraries is possible</code><br />
            </span>
            
            <span class="none">
            <code>configure:9261: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:10062: checking if libtool supports shared libraries</code><br />
            </span>
            
            <span class="none">
            <code>configure:10064: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:10067: checking whether to build shared libraries</code><br />
            </span>
            
            <span class="none">
            <code>configure:10088: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:10091: checking whether to build static libraries</code><br />
            </span>
            
            <span class="none">
            <code>configure:10095: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:10187: creating libtool</code><br />
            </span>
            
            <span class="none">
            <code>configure:10775: checking for ld used by arm-linux-androideabi-g++</code><br />
            </span>
            
            <span class="none">
            <code>configure:10842: result: /toolchain_root/arm-linux-androideabi/bin/ld -m elf_i386</code><br />
            </span>
            
            <span class="none">
            <code>configure:10851: checking if the linker (/toolchain_root/arm-linux-androideabi/bin/ld -m elf_i386) is GNU ld</code><br />
            </span>
            
            <span class="none">
            <code>configure:10866: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:10917: checking whether the arm-linux-androideabi-g++ linker (/toolchain_root/arm-linux-androideabi/bin/ld -m elf_i386) supports shared libraries</code><br />
            </span>
            
            <span class="none">
            <code>configure:11851: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:11869: arm-linux-androideabi-g++ -c   conftest.cpp >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:11872: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:11991: checking for arm-linux-androideabi-g++ option to produce PIC</code><br />
            </span>
            
            <span class="none">
            <code>configure:12265: result: -fPIC</code><br />
            </span>
            
            <span class="none">
            <code>configure:12273: checking if arm-linux-androideabi-g++ PIC flag -fPIC works</code><br />
            </span>
            
            <span class="none">
            <code>configure:12291: arm-linux-androideabi-g++ -c   -fPIC -DPIC conftest.cpp >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:12295: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:12308: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:12336: checking if arm-linux-androideabi-g++ static flag -static works</code><br />
            </span>
            
            <span class="none">
            <code>configure:12364: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:12374: checking if arm-linux-androideabi-g++ supports -c -o file.o</code><br />
            </span>
            
            <span class="none">
            <code>configure:12395: arm-linux-androideabi-g++ -c   -o out/conftest2.o conftest.cpp >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:12399: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:12421: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:12447: checking whether the arm-linux-androideabi-g++ linker (/toolchain_root/arm-linux-androideabi/bin/ld -m elf_i386) supports shared libraries</code><br />
            </span>
            
            <span class="none">
            <code>configure:12472: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:12539: checking dynamic linker characteristics</code><br />
            </span>
            
            <span class="none">
            <code>configure:13164: result: GNU/Linux ld.so</code><br />
            </span>
            
            <span class="none">
            <code>configure:13173: checking how to hardcode library paths into programs</code><br />
            </span>
            
            <span class="none">
            <code>configure:13198: result: immediate</code><br />
            </span>
            
            <span class="none">
            <code>configure:13724: checking if libtool supports shared libraries</code><br />
            </span>
            
            <span class="none">
            <code>configure:13726: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:13729: checking whether to build shared libraries</code><br />
            </span>
            
            <span class="none">
            <code>configure:13749: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:13752: checking whether to build static libraries</code><br />
            </span>
            
            <span class="none">
            <code>configure:13756: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:13766: checking for gfortran option to produce PIC</code><br />
            </span>
            
            <span class="none">
            <code>configure:13976: result: -fPIC</code><br />
            </span>
            
            <span class="none">
            <code>configure:13984: checking if gfortran PIC flag -fPIC works</code><br />
            </span>
            
            <span class="none">
            <code>configure:14002: gfortran -c -g -O2 -fPIC conftest.f >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:14006: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:14019: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:14047: checking if gfortran static flag -static works</code><br />
            </span>
            
            <span class="none">
            <code>configure:14075: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:14085: checking if gfortran supports -c -o file.o</code><br />
            </span>
            
            <span class="none">
            <code>configure:14106: gfortran -c -g -O2 -o out/conftest2.o conftest.f >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:14110: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:14132: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:14158: checking whether the gfortran linker (/toolchain_root/arm-linux-androideabi/bin/ld -m elf_i386) supports shared libraries</code><br />
            </span>
            
            <span class="none">
            <code>configure:15092: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:15159: checking dynamic linker characteristics</code><br />
            </span>
            
            <span class="none">
            <code>configure:15784: result: GNU/Linux ld.so</code><br />
            </span>
            
            <span class="none">
            <code>configure:15793: checking how to hardcode library paths into programs</code><br />
            </span>
            
            <span class="none">
            <code>configure:15818: result: immediate</code><br />
            </span>
            
            <span class="none">
            <code>configure:19419: checking for flex</code><br />
            </span>
            
            <span class="none">
            <code>configure:19435: found /usr/sbin/flex</code><br />
            </span>
            
            <span class="none">
            <code>configure:19446: result: flex</code><br />
            </span>
            
            <span class="none">
            <code>configure:19483: flex conftest.l</code><br />
            </span>
            
            <span class="none">
            <code>configure:19486: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:19488: checking lex output file root</code><br />
            </span>
            
            <span class="none">
            <code>configure:19504: result: lex.yy</code><br />
            </span>
            
            <span class="none">
            <code>configure:19509: checking lex library</code><br />
            </span>
            
            <span class="none">
            <code>configure:19528: arm-linux-androideabi-gcc -o conftest    conftest.c   >&5</code><br />
            </span>
            
            <span class="none">
            <code>/tmp/ccju7bOh.o:conftest.c:function yylex: error: undefined reference to 'yywrap'</code><br />
            </span>
            
            <span class="none">
            <code>/tmp/ccju7bOh.o:conftest.c:function input: error: undefined reference to 'yywrap'</code><br />
            </span>
            
            <span class="none">
            <code>/tmp/ccju7bOh.o:conftest.c:function main: error: undefined reference to 'yywrap'</code><br />
            </span>
            
            <span class="none">
            <code>collect2: error: ld returned 1 exit status</code><br />
            </span>
            
            <span class="none">
            <code>configure:19534: $? = 1</code><br />
            </span>
            
            <span class="none">
            <code>configure: failed program was:</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #line 3 "lex.yy.c"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define  YY_INT_ALIGNED short int</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* A lexical scanner generated by flex */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define FLEX_SCANNER</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FLEX_MAJOR_VERSION 2</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FLEX_MINOR_VERSION 5</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FLEX_SUBMINOR_VERSION 39</code><br />
            </span>
            
            <span class="none">
            <code>| #if YY_FLEX_SUBMINOR_VERSION > 0</code><br />
            </span>
            
            <span class="none">
            <code>| #define FLEX_BETA</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* First, we deal with  platform-specific or compiler-specific issues. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* begin standard C headers. */</code><br />
            </span>
            
            <span class="none">
            <code>| #include <stdio.h></code><br />
            </span>
            
            <span class="none">
            <code>| #include <string.h></code><br />
            </span>
            
            <span class="none">
            <code>| #include <errno.h></code><br />
            </span>
            
            <span class="none">
            <code>| #include <stdlib.h></code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* end standard C headers. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* flex integer type definitions */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef FLEXINT_H</code><br />
            </span>
            
            <span class="none">
            <code>| #define FLEXINT_H</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,</code><br />
            </span>
            
            <span class="none">
            <code>|  * if you want the limit (max/min) macros for int types.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef __STDC_LIMIT_MACROS</code><br />
            </span>
            
            <span class="none">
            <code>| #define __STDC_LIMIT_MACROS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #include <inttypes.h></code><br />
            </span>
            
            <span class="none">
            <code>| typedef int8_t flex_int8_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef uint8_t flex_uint8_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef int16_t flex_int16_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef uint16_t flex_uint16_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef int32_t flex_int32_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef uint32_t flex_uint32_t;</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| typedef signed char flex_int8_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef short int flex_int16_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef int flex_int32_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef unsigned char flex_uint8_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef unsigned short int flex_uint16_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef unsigned int flex_uint32_t;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Limits of integral types. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT8_MIN</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT8_MIN               (-128)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT16_MIN</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT16_MIN              (-32767-1)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT32_MIN</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT32_MIN              (-2147483647-1)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT8_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT8_MAX               (127)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT16_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT16_MAX              (32767)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT32_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT32_MAX              (2147483647)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef UINT8_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define UINT8_MAX              (255U)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef UINT16_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define UINT16_MAX             (65535U)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef UINT32_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define UINT32_MAX             (4294967295U)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif /* ! C99 */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif /* ! FLEXINT_H */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* The "const" storage-class-modifier is valid. */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_USE_CONST</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #else	/* ! __cplusplus */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* C99 requires __STDC__ to be defined as 1. */</code><br />
            </span>
            
            <span class="none">
            <code>| #if defined (__STDC__)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_USE_CONST</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif	/* defined (__STDC__) */</code><br />
            </span>
            
            <span class="none">
            <code>| #endif	/* ! __cplusplus */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_USE_CONST</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyconst const</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyconst</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Returned upon end-of-file. */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_NULL 0</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Promotes a possibly negative, possibly signed char to an unsigned</code><br />
            </span>
            
            <span class="none">
            <code>|  * integer for use as an array index.  If the signed char is negative,</code><br />
            </span>
            
            <span class="none">
            <code>|  * we want to instead treat it as an 8-bit unsigned char, hence the</code><br />
            </span>
            
            <span class="none">
            <code>|  * double cast.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Enter a start condition.  This macro really ought to take a parameter,</code><br />
            </span>
            
            <span class="none">
            <code>|  * but we do it the disgusting crufty way forced on us by the ()-less</code><br />
            </span>
            
            <span class="none">
            <code>|  * definition of BEGIN.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define BEGIN (yy_start) = 1 + 2 *</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Translate the current start state into a value that can be later handed</code><br />
            </span>
            
            <span class="none">
            <code>|  * to BEGIN to return to the state.  The YYSTATE alias is for lex</code><br />
            </span>
            
            <span class="none">
            <code>|  * compatibility.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_START (((yy_start) - 1) / 2)</code><br />
            </span>
            
            <span class="none">
            <code>| #define YYSTATE YY_START</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Action number for EOF rule of a given start state. */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Special action meaning "start processing a new file". */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_NEW_FILE yyrestart(yyin  )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_END_OF_BUFFER_CHAR 0</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Size of default input buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_BUF_SIZE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BUF_SIZE 16384</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* The state buf must be large enough to hold one state per character in the main buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_TYPEDEF_YY_BUFFER_STATE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_TYPEDEF_YY_BUFFER_STATE</code><br />
            </span>
            
            <span class="none">
            <code>| typedef struct yy_buffer_state *YY_BUFFER_STATE;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_TYPEDEF_YY_SIZE_T</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_TYPEDEF_YY_SIZE_T</code><br />
            </span>
            
            <span class="none">
            <code>| typedef size_t yy_size_t;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern yy_size_t yyleng;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern FILE *yyin, *yyout;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define EOB_ACT_CONTINUE_SCAN 0</code><br />
            </span>
            
            <span class="none">
            <code>| #define EOB_ACT_END_OF_FILE 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define EOB_ACT_LAST_MATCH 2</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     #define YY_LESS_LINENO(n)</code><br />
            </span>
            
            <span class="none">
            <code>|     #define YY_LINENO_REWIND_TO(ptr)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Return all but the first "n" matched characters back to the input stream. */</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyless(n) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	do \</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Undo effects of setting up yytext. */ \</code><br />
            </span>
            
            <span class="none">
            <code>|         int yyless_macro_arg = (n); \</code><br />
            </span>
            
            <span class="none">
            <code>|         YY_LESS_LINENO(yyless_macro_arg);\</code><br />
            </span>
            
            <span class="none">
            <code>| 		*yy_cp = (yy_hold_char); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_RESTORE_YY_MORE_OFFSET \</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	while ( 0 )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define unput(c) yyunput( c, (yytext_ptr)  )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_STRUCT_YY_BUFFER_STATE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_STRUCT_YY_BUFFER_STATE</code><br />
            </span>
            
            <span class="none">
            <code>| struct yy_buffer_state</code><br />
            </span>
            
            <span class="none">
            <code>| 	{</code><br />
            </span>
            
            <span class="none">
            <code>| 	FILE *yy_input_file;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	char *yy_ch_buf;		/* input buffer */</code><br />
            </span>
            
            <span class="none">
            <code>| 	char *yy_buf_pos;		/* current position in input buffer */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Size of input buffer in bytes, not including room for EOB</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * characters.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t yy_buf_size;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Number of characters read into yy_ch_buf, not including EOB</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * characters.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t yy_n_chars;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Whether we "own" the buffer - i.e., we know we created it,</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * and can realloc() it to grow it, and should free() it to</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * delete it.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_is_our_buffer;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Whether this is an "interactive" input source; if so, and</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * if we're using stdio for input, then we want to use getc()</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * instead of fread(), to make sure we stop fetching input after</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * each newline.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_is_interactive;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Whether we're considered to be at the beginning of a line.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * If so, '^' rules will be active on the next match, otherwise</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * not.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_at_bol;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     int yy_bs_lineno; /**< The line count. */</code><br />
            </span>
            
            <span class="none">
            <code>|     int yy_bs_column; /**< The column count. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Whether to try to fill the input buffer when we reach the</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * end of it.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_fill_buffer;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_buffer_status;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BUFFER_NEW 0</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BUFFER_NORMAL 1</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* When an EOF's been seen but there's still some text to process</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * shouldn't try reading from the input source any more.  We might</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * still have a bunch of tokens to match, though, because of</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * possible backing-up.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 *</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * When we actually see the EOF, we change the status to "new"</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * (via yyrestart()), so that the user can continue scanning by</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * just pointing yyin at a new input file.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BUFFER_EOF_PENDING 2</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	};</code><br />
            </span>
            
            <span class="none">
            <code>| #endif /* !YY_STRUCT_YY_BUFFER_STATE */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Stack of input buffers. */</code><br />
            </span>
            
            <span class="none">
            <code>| static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */</code><br />
            </span>
            
            <span class="none">
            <code>| static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */</code><br />
            </span>
            
            <span class="none">
            <code>| static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* We provide macros for accessing buffer states in case in the</code><br />
            </span>
            
            <span class="none">
            <code>|  * future we want to put the buffer states in a more general</code><br />
            </span>
            
            <span class="none">
            <code>|  * "scanner state".</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * Returns the top of the stack, or NULL.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_CURRENT_BUFFER ( (yy_buffer_stack) \</code><br />
            </span>
            
            <span class="none">
            <code>|                           ? (yy_buffer_stack)[(yy_buffer_stack_top)] \</code><br />
            </span>
            
            <span class="none">
            <code>|                           : NULL)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Same as previous macro, but useful when we know that the buffer stack is not</code><br />
            </span>
            
            <span class="none">
            <code>|  * NULL or when we need an lvalue. For internal use only.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yy_hold_char holds the character lost when yytext is formed. */</code><br />
            </span>
            
            <span class="none">
            <code>| static char yy_hold_char;</code><br />
            </span>
            
            <span class="none">
            <code>| static yy_size_t yy_n_chars;		/* number of characters read into yy_ch_buf */</code><br />
            </span>
            
            <span class="none">
            <code>| yy_size_t yyleng;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Points to current character in buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| static char *yy_c_buf_p = (char *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_init = 0;		/* whether we need to initialize */</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_start = 0;	/* start state number */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Flag which is used to allow yywrap()'s to do buffer switches</code><br />
            </span>
            
            <span class="none">
            <code>|  * instead of setting up a fresh yyin.  A bit of a hack ...</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_did_buffer_switch_on_eof;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyrestart (FILE *input_file  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yy_delete_buffer (YY_BUFFER_STATE b  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yy_flush_buffer (YY_BUFFER_STATE b  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yypop_buffer_state (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static void yyensure_buffer_stack (void );</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_load_buffer_state (void );</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,yy_size_t len  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void *yyalloc (yy_size_t  );</code><br />
            </span>
            
            <span class="none">
            <code>| void *yyrealloc (void *,yy_size_t  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yyfree (void *  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define yy_new_buffer yy_create_buffer</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define yy_set_interactive(is_interactive) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! YY_CURRENT_BUFFER ){ \</code><br />
            </span>
            
            <span class="none">
            <code>|         yyensure_buffer_stack (); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE =    \</code><br />
            </span>
            
            <span class="none">
            <code>|             yy_create_buffer(yyin,YY_BUF_SIZE ); \</code><br />
            </span>
            
            <span class="none">
            <code>| 	} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define yy_set_bol(at_bol) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! YY_CURRENT_BUFFER ){\</code><br />
            </span>
            
            <span class="none">
            <code>|         yyensure_buffer_stack (); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE =    \</code><br />
            </span>
            
            <span class="none">
            <code>|             yy_create_buffer(yyin,YY_BUF_SIZE ); \</code><br />
            </span>
            
            <span class="none">
            <code>| 	} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Begin user sect3 */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| typedef unsigned char YY_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| typedef int yy_state_type;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern int yylineno;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yylineno = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern char *yytext;</code><br />
            </span>
            
            <span class="none">
            <code>| #define yytext_ptr yytext</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yy_state_type yy_get_previous_state (void );</code><br />
            </span>
            
            <span class="none">
            <code>| static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_get_next_buffer (void );</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_fatal_error (yyconst char msg[]  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Done after the current pattern has been matched and before the</code><br />
            </span>
            
            <span class="none">
            <code>|  * corresponding action - sets up yytext.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_DO_BEFORE_ACTION \</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) = yy_bp; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) -= (yy_more_len); \</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyleng = (size_t) (yy_cp - (yytext_ptr)); \</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_hold_char) = *yy_cp; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	*yy_cp = '\0'; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_c_buf_p) = yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_NUM_RULES 8</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_END_OF_BUFFER 9</code><br />
            </span>
            
            <span class="none">
            <code>| /* This struct is not used in this scanner,</code><br />
            </span>
            
            <span class="none">
            <code>|    but its presence is necessary. */</code><br />
            </span>
            
            <span class="none">
            <code>| struct yy_trans_info</code><br />
            </span>
            
            <span class="none">
            <code>| 	{</code><br />
            </span>
            
            <span class="none">
            <code>| 	flex_int32_t yy_verify;</code><br />
            </span>
            
            <span class="none">
            <code>| 	flex_int32_t yy_nxt;</code><br />
            </span>
            
            <span class="none">
            <code>| 	};</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_acclist[23] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         9,    7,    8,    8,    1,    7,    8,    2,    7,    8,</code><br />
            </span>
            
            <span class="none">
            <code>|         3,    7,    8,    4,    7,    8,    5,    7,    8,    6,</code><br />
            </span>
            
            <span class="none">
            <code>|         7,    8</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_accept[14] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    2,    4,    5,    8,   11,   14,   17,</code><br />
            </span>
            
            <span class="none">
            <code>|        20,   23,   23</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int32_t yy_ec[256] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    2,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    3,    4,    5,    6,</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|         7,    8,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int32_t yy_meta[9] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_base[13] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         0,    0,    9,   10,   10,   10,   10,   10,   10,   10,</code><br />
            </span>
            
            <span class="none">
            <code>|        10,   10</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_def[13] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|        12,    1,   12,   12,   12,   12,   12,   12,   12,   12,</code><br />
            </span>
            
            <span class="none">
            <code>|        12,    0</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_nxt[19] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         4,    5,    6,    7,    8,    9,   10,   11,   12,    3,</code><br />
            </span>
            
            <span class="none">
            <code>|        12,   12,   12,   12,   12,   12,   12,   12</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_chk[19] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    3,   12,</code><br />
            </span>
            
            <span class="none">
            <code>|        12,   12,   12,   12,   12,   12,   12,   12</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern int yy_flex_debug;</code><br />
            </span>
            
            <span class="none">
            <code>| int yy_flex_debug = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yy_state_type *yy_state_buf=0, *yy_state_ptr=0;</code><br />
            </span>
            
            <span class="none">
            <code>| static char *yy_full_match;</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_lp;</code><br />
            </span>
            
            <span class="none">
            <code>| #define REJECT \</code><br />
            </span>
            
            <span class="none">
            <code>| { \</code><br />
            </span>
            
            <span class="none">
            <code>| *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */ \</code><br />
            </span>
            
            <span class="none">
            <code>| yy_cp = (yy_full_match); /* restore poss. backed-over text */ \</code><br />
            </span>
            
            <span class="none">
            <code>| ++(yy_lp); \</code><br />
            </span>
            
            <span class="none">
            <code>| goto find_rule; \</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_more_flag = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_more_len = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| #define yymore() ((yy_more_flag) = 1)</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_MORE_ADJ (yy_more_len)</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_RESTORE_YY_MORE_OFFSET</code><br />
            </span>
            
            <span class="none">
            <code>| char *yytext;</code><br />
            </span>
            
            <span class="none">
            <code>| #line 1 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| #line 470 "lex.yy.c"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define INITIAL 0</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_NO_UNISTD_H</code><br />
            </span>
            
            <span class="none">
            <code>| /* Special case for "unistd.h", since it is non-ANSI. We include it way</code><br />
            </span>
            
            <span class="none">
            <code>|  * down here because we want the user's section 1 to have been scanned first.</code><br />
            </span>
            
            <span class="none">
            <code>|  * The user has a chance to override it with an option.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #include <unistd.h></code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_EXTRA_TYPE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_EXTRA_TYPE void *</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_init_globals (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Accessor methods to globals.</code><br />
            </span>
            
            <span class="none">
            <code>|    These are made visible to non-reentrant scanners for convenience. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yylex_destroy (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yyget_debug (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_debug (int debug_flag  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| YY_EXTRA_TYPE yyget_extra (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_extra (YY_EXTRA_TYPE user_defined  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyget_in (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_in  (FILE * in_str  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyget_out (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_out  (FILE * out_str  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| yy_size_t yyget_leng (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| char *yyget_text (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yyget_lineno (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_lineno (int line_number  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Macros after this point can all be overridden by user definitions in</code><br />
            </span>
            
            <span class="none">
            <code>|  * section 1.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_SKIP_YYWRAP</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>| extern "C" int yywrap (void );</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| extern int yywrap (void );</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     static void yyunput (int c,char *buf_ptr  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef yytext_ptr</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_flex_strncpy (char *,yyconst char *,int );</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_NEED_STRLEN</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_flex_strlen (yyconst char * );</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_NO_INPUT</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>| static int yyinput (void );</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| static int input (void );</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Amount of stuff to slurp up with each read. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_READ_BUF_SIZE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_READ_BUF_SIZE 8192</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Copy whatever the last rule matched to the standard output. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef ECHO</code><br />
            </span>
            
            <span class="none">
            <code>| /* This used to be an fputs(), but since the string might contain NUL's,</code><br />
            </span>
            
            <span class="none">
            <code>|  * we now use fwrite().</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,</code><br />
            </span>
            
            <span class="none">
            <code>|  * is returned in "result".</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_INPUT</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_INPUT(buf,result,max_size) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		int c = '*'; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		size_t n; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		for ( n = 0; n < max_size && \</code><br />
            </span>
            
            <span class="none">
            <code>| 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \</code><br />
            </span>
            
            <span class="none">
            <code>| 			buf[n] = (char) c; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( c == '\n' ) \</code><br />
            </span>
            
            <span class="none">
            <code>| 			buf[n++] = (char) c; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( c == EOF && ferror( yyin ) ) \</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "input in flex scanner failed" ); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		result = n; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	else \</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		errno=0; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \</code><br />
            </span>
            
            <span class="none">
            <code>| 			{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 			if( errno != EINTR) \</code><br />
            </span>
            
            <span class="none">
            <code>| 				{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 				YY_FATAL_ERROR( "input in flex scanner failed" ); \</code><br />
            </span>
            
            <span class="none">
            <code>| 				break; \</code><br />
            </span>
            
            <span class="none">
            <code>| 				} \</code><br />
            </span>
            
            <span class="none">
            <code>| 			errno=0; \</code><br />
            </span>
            
            <span class="none">
            <code>| 			clearerr(yyin); \</code><br />
            </span>
            
            <span class="none">
            <code>| 			} \</code><br />
            </span>
            
            <span class="none">
            <code>| 		}\</code><br />
            </span>
            
            <span class="none">
            <code>| \</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* No semi-colon after return; correct usage is to write "yyterminate();" -</code><br />
            </span>
            
            <span class="none">
            <code>|  * we don't want an extra ';' after the "return" because that will cause</code><br />
            </span>
            
            <span class="none">
            <code>|  * some compilers to complain about unreachable statements.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef yyterminate</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyterminate() return YY_NULL</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Number of entries by which start-condition stack grows. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_START_STACK_INCR</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_START_STACK_INCR 25</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Report a fatal error. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_FATAL_ERROR</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* end tables serialization structures and prototypes */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Default declaration of generated scanner - a define so the user can</code><br />
            </span>
            
            <span class="none">
            <code>|  * easily add parameters.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_DECL</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_DECL_IS_OURS 1</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern int yylex (void);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_DECL int yylex (void)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif /* !YY_DECL */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Code executed at the beginning of each rule, after yytext and yyleng</code><br />
            </span>
            
            <span class="none">
            <code>|  * have been set up.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_USER_ACTION</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_USER_ACTION</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Code executed at the end of each rule. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BREAK break;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_RULE_SETUP \</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_USER_ACTION</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** The main scanner function which does all the work.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| YY_DECL</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register yy_state_type yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 	register char *yy_cp, *yy_bp;</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int yy_act;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( !(yy_init) )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_init) = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_USER_INIT</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_USER_INIT;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|         /* Create the reject buffer large enough to save one state per allowed character. */</code><br />
            </span>
            
            <span class="none">
            <code>|         if ( ! (yy_state_buf) )</code><br />
            </span>
            
            <span class="none">
            <code>|             (yy_state_buf) = (yy_state_type *)yyalloc(YY_STATE_BUF_SIZE  );</code><br />
            </span>
            
            <span class="none">
            <code>|             if ( ! (yy_state_buf) )</code><br />
            </span>
            
            <span class="none">
            <code>|                 YY_FATAL_ERROR( "out of dynamic memory in yylex()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! (yy_start) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_start) = 1;	/* first start state */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! yyin )</code><br />
            </span>
            
            <span class="none">
            <code>| 			yyin = stdin;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! yyout )</code><br />
            </span>
            
            <span class="none">
            <code>| 			yyout = stdout;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! YY_CURRENT_BUFFER ) {</code><br />
            </span>
            
            <span class="none">
            <code>| 			yyensure_buffer_stack ();</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE =</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_create_buffer(yyin,YY_BUF_SIZE );</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	{</code><br />
            </span>
            
            <span class="none">
            <code>| #line 1 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #line 687 "lex.yy.c"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	while ( 1 )		/* loops until end-of-file is reached */</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_more_len) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( (yy_more_flag) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_more_len) = (yy_c_buf_p) - (yytext_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_more_flag) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Support of yytext. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		*yy_cp = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* yy_bp points to the position in yy_ch_buf of the start of</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * the current run.</code><br />
            </span>
            
            <span class="none">
            <code>| 		 */</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_bp = yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_current_state = (yy_start);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_state_ptr) = (yy_state_buf);</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| yy_match:</code><br />
            </span>
            
            <span class="none">
            <code>| 		do</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;</code><br />
            </span>
            
            <span class="none">
            <code>| 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_current_state = (int) yy_def[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| 				if ( yy_current_state >= 13 )</code><br />
            </span>
            
            <span class="none">
            <code>| 					yy_c = yy_meta[(unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 			*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 			++yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( yy_base[yy_current_state] != 10 );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| yy_find_action:</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_current_state = *--(yy_state_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_lp) = yy_accept[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| find_rule: /* we branch to this label when backing up */</code><br />
            </span>
            
            <span class="none">
            <code>| 		for ( ; ; ) /* until we find what rule we matched */</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			if ( (yy_lp) && (yy_lp) < yy_accept[yy_current_state + 1] )</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_act = yy_acclist[(yy_lp)];</code><br />
            </span>
            
            <span class="none">
            <code>| 					{</code><br />
            </span>
            
            <span class="none">
            <code>| 					(yy_full_match) = yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| 					break;</code><br />
            </span>
            
            <span class="none">
            <code>| 					}</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>| 			--yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_current_state = *--(yy_state_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_lp) = yy_accept[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_DO_BEFORE_ACTION;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| do_action:	/* This label is used only to access EOF actions. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		switch ( yy_act )</code><br />
            </span>
            
            <span class="none">
            <code>| 	{ /* beginning of action switch */</code><br />
            </span>
            
            <span class="none">
            <code>| case 1:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 2 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { ECHO; }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 2:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 3 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { REJECT; }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 3:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 4 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { yymore (); }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 4:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 5 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { yyless (1); }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 5:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 6 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { yyless (input () != 0); }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 6:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 7 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { unput (yytext[0]); }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 7:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 8 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { BEGIN INITIAL; }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 8:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 9 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| ECHO;</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| #line 793 "lex.yy.c"</code><br />
            </span>
            
            <span class="none">
            <code>| 			case YY_STATE_EOF(INITIAL):</code><br />
            </span>
            
            <span class="none">
            <code>| 				yyterminate();</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	case YY_END_OF_BUFFER:</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Amount of text matched not including the EOB char. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Undo the effects of YY_DO_BEFORE_ACTION. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		*yy_cp = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_RESTORE_YY_MORE_OFFSET</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* We're scanning a new file or input source.  It's</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * possible that this happened because the user</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * just pointed yyin at a new source and called</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * yylex().  If so, then we have to assure</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * consistency between YY_CURRENT_BUFFER and our</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * globals.  Here is the right place to do so, because</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * this is the first action (other than possibly a</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * back-up) that will match for the new input source.</code><br />
            </span>
            
            <span class="none">
            <code>| 			 */</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Note that here we test for yy_c_buf_p "<=" to the position</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * of the first EOB in the buffer, since yy_c_buf_p will</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * already have been incremented past the NUL character</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * (since all states make transitions on EOB to the</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * end-of-buffer state).  Contrast this with the test</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * in input().</code><br />
            </span>
            
            <span class="none">
            <code>| 		 */</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{ /* This was really a NUL. */</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_state_type yy_next_state;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_current_state = yy_get_previous_state(  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* Okay, we're now positioned to make the NUL</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * transition.  We couldn't have</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * yy_get_previous_state() go ahead and do it</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * for us because it doesn't know how to deal</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * with the possibility of jamming (and we don't</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * want to build jamming into it because then it</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * will run more slowly).</code><br />
            </span>
            
            <span class="none">
            <code>| 			 */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_next_state = yy_try_NUL_trans( yy_current_state );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_bp = (yytext_ptr) + YY_MORE_ADJ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			if ( yy_next_state )</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				/* Consume the NUL. */</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_cp = ++(yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_current_state = yy_next_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 				goto yy_match;</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			else</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 				goto yy_find_action;</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		else switch ( yy_get_next_buffer(  ) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			case EOB_ACT_END_OF_FILE:</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				(yy_did_buffer_switch_on_eof) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				if ( yywrap( ) )</code><br />
            </span>
            
            <span class="none">
            <code>| 					{</code><br />
            </span>
            
            <span class="none">
            <code>| 					/* Note: because we've taken care in</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * yy_get_next_buffer() to have set up</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * yytext, we can now set up</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * yy_c_buf_p so that if some total</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * hoser (like flex itself) wants to</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * call the scanner after we return the</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * YY_NULL, it'll still work - another</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * YY_NULL will get returned.</code><br />
            </span>
            
            <span class="none">
            <code>| 					 */</code><br />
            </span>
            
            <span class="none">
            <code>| 					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 					yy_act = YY_STATE_EOF(YY_START);</code><br />
            </span>
            
            <span class="none">
            <code>| 					goto do_action;</code><br />
            </span>
            
            <span class="none">
            <code>| 					}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				else</code><br />
            </span>
            
            <span class="none">
            <code>| 					{</code><br />
            </span>
            
            <span class="none">
            <code>| 					if ( ! (yy_did_buffer_switch_on_eof) )</code><br />
            </span>
            
            <span class="none">
            <code>| 						YY_NEW_FILE;</code><br />
            </span>
            
            <span class="none">
            <code>| 					}</code><br />
            </span>
            
            <span class="none">
            <code>| 				break;</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			case EOB_ACT_CONTINUE_SCAN:</code><br />
            </span>
            
            <span class="none">
            <code>| 				(yy_c_buf_p) =</code><br />
            </span>
            
            <span class="none">
            <code>| 					(yytext_ptr) + yy_amount_of_matched_text;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_current_state = yy_get_previous_state(  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;</code><br />
            </span>
            
            <span class="none">
            <code>| 				goto yy_match;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			case EOB_ACT_LAST_MATCH:</code><br />
            </span>
            
            <span class="none">
            <code>| 				(yy_c_buf_p) =</code><br />
            </span>
            
            <span class="none">
            <code>| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_current_state = yy_get_previous_state(  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;</code><br />
            </span>
            
            <span class="none">
            <code>| 				goto yy_find_action;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		break;</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	default:</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR(</code><br />
            </span>
            
            <span class="none">
            <code>| 			"fatal flex scanner internal error--no action found" );</code><br />
            </span>
            
            <span class="none">
            <code>| 	} /* end of action switch */</code><br />
            </span>
            
            <span class="none">
            <code>| 		} /* end of scanning one token */</code><br />
            </span>
            
            <span class="none">
            <code>| 	} /* end of user's declarations */</code><br />
            </span>
            
            <span class="none">
            <code>| } /* end of yylex */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yy_get_next_buffer - try to read in a new buffer</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * Returns a code representing an action:</code><br />
            </span>
            
            <span class="none">
            <code>|  *	EOB_ACT_LAST_MATCH -</code><br />
            </span>
            
            <span class="none">
            <code>|  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position</code><br />
            </span>
            
            <span class="none">
            <code>|  *	EOB_ACT_END_OF_FILE - end of file</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_get_next_buffer (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;</code><br />
            </span>
            
            <span class="none">
            <code>| 	register char *source = (yytext_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int number_to_move, i;</code><br />
            </span>
            
            <span class="none">
            <code>| 	int ret_val;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR(</code><br />
            </span>
            
            <span class="none">
            <code>| 		"fatal flex scanner internal error--end of buffer missed" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ /* Don't try to fill the buffer, so this is an EOF. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* We matched a single character, the EOB, so</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * treat this as a final EOF.</code><br />
            </span>
            
            <span class="none">
            <code>| 			 */</code><br />
            </span>
            
            <span class="none">
            <code>| 			return EOB_ACT_END_OF_FILE;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		else</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* We matched some text prior to the EOB, first</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * process it.</code><br />
            </span>
            
            <span class="none">
            <code>| 			 */</code><br />
            </span>
            
            <span class="none">
            <code>| 			return EOB_ACT_LAST_MATCH;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Try to read more data. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* First move last chars to start of buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( i = 0; i < number_to_move; ++i )</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(dest++) = *(source++);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* don't do the read, it's not guaranteed to return an EOF,</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * just force an EOF</code><br />
            </span>
            
            <span class="none">
            <code>| 		 */</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	else</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_size_t num_to_read =</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( num_to_read <= 0 )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{ /* Not enough room in the buffer - grow it. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR(</code><br />
            </span>
            
            <span class="none">
            <code>| "input buffer overflow, can't enlarge buffer because scanner uses REJECT" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( num_to_read > YY_READ_BUF_SIZE )</code><br />
            </span>
            
            <span class="none">
            <code>| 			num_to_read = YY_READ_BUF_SIZE;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Read in more data. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_n_chars), num_to_read );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( (yy_n_chars) == 0 )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( number_to_move == YY_MORE_ADJ )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			ret_val = EOB_ACT_END_OF_FILE;</code><br />
            </span>
            
            <span class="none">
            <code>| 			yyrestart(yyin  );</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		else</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			ret_val = EOB_ACT_LAST_MATCH;</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =</code><br />
            </span>
            
            <span class="none">
            <code>| 				YY_BUFFER_EOF_PENDING;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	else</code><br />
            </span>
            
            <span class="none">
            <code>| 		ret_val = EOB_ACT_CONTINUE_SCAN;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Extend the array by 50%, plus the number we really need. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_n_chars) += number_to_move;</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return ret_val;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yy_get_previous_state - get the state just before the EOB char was reached */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     static yy_state_type yy_get_previous_state (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register yy_state_type yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 	register char *yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_current_state = (yy_start);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_state_ptr) = (yy_state_buf);</code><br />
            </span>
            
            <span class="none">
            <code>| 	*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_current_state = (int) yy_def[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| 			if ( yy_current_state >= 13 )</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_c = yy_meta[(unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yy_try_NUL_trans - try to make a transition on the NUL character</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * synopsis</code><br />
            </span>
            
            <span class="none">
            <code>|  *	next_state = yy_try_NUL_trans( current_state );</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int yy_is_jam;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	register YY_CHAR yy_c = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_current_state = (int) yy_def[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( yy_current_state >= 13 )</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_c = yy_meta[(unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_is_jam = (yy_current_state == 12);</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! yy_is_jam )</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		return yy_is_jam ? 0 : yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     static void yyunput (int c, register char * yy_bp )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register char *yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* undo effects of setting up yytext */</code><br />
            </span>
            
            <span class="none">
            <code>| 	*yy_cp = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ /* need to shift things up to make room */</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* +2 for EOB chars. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		register yy_size_t number_to_move = (yy_n_chars) + 2;</code><br />
            </span>
            
            <span class="none">
            <code>| 		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[</code><br />
            </span>
            
            <span class="none">
            <code>| 					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];</code><br />
            </span>
            
            <span class="none">
            <code>| 		register char *source =</code><br />
            </span>
            
            <span class="none">
            <code>| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )</code><br />
            </span>
            
            <span class="none">
            <code>| 			*--dest = *--source;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_cp += (int) (dest - source);</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_bp += (int) (dest - source);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "flex scanner push-back overflow" );</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	*--yy_cp = (char) c;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) = yy_bp;</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_hold_char) = *yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_c_buf_p) = yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_NO_INPUT</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>|     static int yyinput (void)</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>|     static int input  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	int c;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	*(yy_c_buf_p) = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* yy_c_buf_p now points to the character we want to return.</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * If this occurs *before* the EOB characters, then it's a</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * valid NUL; if not, then we've hit the end of the buffer.</code><br />
            </span>
            
            <span class="none">
            <code>| 		 */</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* This was really a NUL. */</code><br />
            </span>
            
            <span class="none">
            <code>| 			*(yy_c_buf_p) = '\0';</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		else</code><br />
            </span>
            
            <span class="none">
            <code>| 			{ /* need more input */</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_size_t offset = (yy_c_buf_p) - (yytext_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 			++(yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			switch ( yy_get_next_buffer(  ) )</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				case EOB_ACT_LAST_MATCH:</code><br />
            </span>
            
            <span class="none">
            <code>| 					/* This happens because yy_g_n_b()</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * sees that we've accumulated a</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * token and flags that we need to</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * try matching the token before</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * proceeding.  But for input(),</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * there's no matching to consider.</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * So convert the EOB_ACT_LAST_MATCH</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * to EOB_ACT_END_OF_FILE.</code><br />
            </span>
            
            <span class="none">
            <code>| 					 */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 					/* Reset buffer status. */</code><br />
            </span>
            
            <span class="none">
            <code>| 					yyrestart(yyin );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 					/*FALLTHROUGH*/</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				case EOB_ACT_END_OF_FILE:</code><br />
            </span>
            
            <span class="none">
            <code>| 					{</code><br />
            </span>
            
            <span class="none">
            <code>| 					if ( yywrap( ) )</code><br />
            </span>
            
            <span class="none">
            <code>| 						return EOF;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 					if ( ! (yy_did_buffer_switch_on_eof) )</code><br />
            </span>
            
            <span class="none">
            <code>| 						YY_NEW_FILE;</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>| 					return yyinput();</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| 					return input();</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| 					}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				case EOB_ACT_CONTINUE_SCAN:</code><br />
            </span>
            
            <span class="none">
            <code>| 					(yy_c_buf_p) = (yytext_ptr) + offset;</code><br />
            </span>
            
            <span class="none">
            <code>| 					break;</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */</code><br />
            </span>
            
            <span class="none">
            <code>| 	*(yy_c_buf_p) = '\0';	/* preserve yytext */</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_hold_char) = *++(yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return c;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>| #endif	/* ifndef YY_NO_INPUT */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Immediately switch to a different input stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param input_file A readable stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @note This function does not reset the start condition to @c INITIAL .</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     void yyrestart  (FILE * input_file )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! YY_CURRENT_BUFFER ){</code><br />
            </span>
            
            <span class="none">
            <code>|         yyensure_buffer_stack ();</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE =</code><br />
            </span>
            
            <span class="none">
            <code>|             yy_create_buffer(yyin,YY_BUF_SIZE );</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_init_buffer(YY_CURRENT_BUFFER,input_file );</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Switch to a different input buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param new_buffer The new input buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* TODO. We should be able to replace this entire function body</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * with</code><br />
            </span>
            
            <span class="none">
            <code>| 	 *		yypop_buffer_state();</code><br />
            </span>
            
            <span class="none">
            <code>| 	 *		yypush_buffer_state(new_buffer);</code><br />
            </span>
            
            <span class="none">
            <code>|      */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyensure_buffer_stack ();</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER == new_buffer )</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Flush out information for old buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_c_buf_p) = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* We don't actually know whether we did this switch during</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * EOF (yywrap()) processing, but the only time this flag</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * is looked at is after yywrap() is called, so it's safe</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * to go ahead and always set it.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_did_buffer_switch_on_eof) = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_load_buffer_state  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_hold_char) = *(yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Allocate and initialize an input buffer state.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param file A readable stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @return the allocated buffer state.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BUFFER_STATE b;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buf_size = size;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* yy_ch_buf has to be 2 characters longer than the size given because</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * we need to put in 2 end-of-buffer characters.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b->yy_ch_buf )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_is_our_buffer = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_init_buffer(b,file );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return b;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Destroy the buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param b a buffer created with yy_create_buffer()</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     void yy_delete_buffer (YY_BUFFER_STATE  b )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( b->yy_is_our_buffer )</code><br />
            </span>
            
            <span class="none">
            <code>| 		yyfree((void *) b->yy_ch_buf  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyfree((void *) b  );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Initializes or reinitializes a buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * This function is sometimes called more than once on the same buffer,</code><br />
            </span>
            
            <span class="none">
            <code>|  * such as during a yyrestart() or at EOF.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	int oerrno = errno;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_flush_buffer(b );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_input_file = file;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_fill_buffer = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     /* If b is the current buffer, then yy_init_buffer was _probably_</code><br />
            </span>
            
            <span class="none">
            <code>|      * called from yyrestart() or through yy_get_next_buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|      * In that case, we don't want to reset the lineno or column.</code><br />
            </span>
            
            <span class="none">
            <code>|      */</code><br />
            </span>
            
            <span class="none">
            <code>|     if (b != YY_CURRENT_BUFFER){</code><br />
            </span>
            
            <span class="none">
            <code>|         b->yy_bs_lineno = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|         b->yy_bs_column = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|         b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	errno = oerrno;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Discard all buffered characters. On the next scan, YY_INPUT will be called.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     void yy_flush_buffer (YY_BUFFER_STATE  b )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_n_chars = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* We always need two end-of-buffer characters.  The first causes</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * a transition to the end-of-buffer state.  The second causes</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * a jam in that state.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buf_pos = &b->yy_ch_buf[0];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_at_bol = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buffer_status = YY_BUFFER_NEW;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( b == YY_CURRENT_BUFFER )</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Pushes the new state onto the stack. The new state becomes</code><br />
            </span>
            
            <span class="none">
            <code>|  *  the current state. This function will allocate the stack</code><br />
            </span>
            
            <span class="none">
            <code>|  *  if necessary.</code><br />
            </span>
            
            <span class="none">
            <code>|  *  @param new_buffer The new state.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| void yypush_buffer_state (YY_BUFFER_STATE new_buffer )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	if (new_buffer == NULL)</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyensure_buffer_stack();</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* This block is copied from yy_switch_to_buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Flush out information for old buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_c_buf_p) = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Only push if top exists. Otherwise, replace top. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	if (YY_CURRENT_BUFFER)</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack_top)++;</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* copied from yy_switch_to_buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_did_buffer_switch_on_eof) = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Removes and deletes the top of the stack, if present.</code><br />
            </span>
            
            <span class="none">
            <code>|  *  The next element becomes the new top.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| void yypop_buffer_state (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	if (!YY_CURRENT_BUFFER)</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_delete_buffer(YY_CURRENT_BUFFER );</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE = NULL;</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ((yy_buffer_stack_top) > 0)</code><br />
            </span>
            
            <span class="none">
            <code>| 		--(yy_buffer_stack_top);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if (YY_CURRENT_BUFFER) {</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_did_buffer_switch_on_eof) = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Allocates the stack if it does not exist.</code><br />
            </span>
            
            <span class="none">
            <code>|  *  Guarantees space for at least one push.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| static void yyensure_buffer_stack (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t num_to_alloc;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if (!(yy_buffer_stack)) {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* First allocation is just for 2 elements, since we don't know if this</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * scanner will even need a stack. We use 2 instead of 1 to avoid an</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * immediate realloc on the next call.</code><br />
            </span>
            
            <span class="none">
            <code>|          */</code><br />
            </span>
            
            <span class="none">
            <code>| 		num_to_alloc = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc</code><br />
            </span>
            
            <span class="none">
            <code>| 								(num_to_alloc * sizeof(struct yy_buffer_state*)</code><br />
            </span>
            
            <span class="none">
            <code>| 								);</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! (yy_buffer_stack) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack_max) = num_to_alloc;</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack_top) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Increase the buffer to prepare for a possible push. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		int grow_size = 8 /* arbitrary grow size */;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		num_to_alloc = (yy_buffer_stack_max) + grow_size;</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc</code><br />
            </span>
            
            <span class="none">
            <code>| 								((yy_buffer_stack),</code><br />
            </span>
            
            <span class="none">
            <code>| 								num_to_alloc * sizeof(struct yy_buffer_state*)</code><br />
            </span>
            
            <span class="none">
            <code>| 								);</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! (yy_buffer_stack) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* zero only the new slots.*/</code><br />
            </span>
            
            <span class="none">
            <code>| 		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack_max) = num_to_alloc;</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Setup the input buffer state to scan directly from a user-specified character buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param base the character buffer</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param size the size in bytes of the character buffer</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @return the newly allocated buffer state object.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BUFFER_STATE b;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( size < 2 ||</code><br />
            </span>
            
            <span class="none">
            <code>| 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||</code><br />
            </span>
            
            <span class="none">
            <code>| 	     base[size-1] != YY_END_OF_BUFFER_CHAR )</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* They forgot to leave room for the EOB's. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		return 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buf_pos = b->yy_ch_buf = base;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_is_our_buffer = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_input_file = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_n_chars = b->yy_buf_size;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_is_interactive = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_at_bol = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_fill_buffer = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buffer_status = YY_BUFFER_NEW;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_switch_to_buffer(b  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return b;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Setup the input buffer state to scan a string. The next call to yylex() will</code><br />
            </span>
            
            <span class="none">
            <code>|  * scan from a @e copy of @a str.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param yystr a NUL-terminated string to scan</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @return the newly allocated buffer state object.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @note If you want to scan bytes that may contain NUL values, then use</code><br />
            </span>
            
            <span class="none">
            <code>|  *       yy_scan_bytes() instead.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return yy_scan_bytes(yystr,strlen(yystr) );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Setup the input buffer state to scan the given bytes. The next call to yylex() will</code><br />
            </span>
            
            <span class="none">
            <code>|  * scan from a @e copy of @a bytes.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param yybytes the byte buffer to scan</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @return the newly allocated buffer state object.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BUFFER_STATE b;</code><br />
            </span>
            
            <span class="none">
            <code>| 	char *buf;</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t n;</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t i;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Get memory for full buffer, including space for trailing EOB's. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	n = _yybytes_len + 2;</code><br />
            </span>
            
            <span class="none">
            <code>| 	buf = (char *) yyalloc(n  );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! buf )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( i = 0; i < _yybytes_len; ++i )</code><br />
            </span>
            
            <span class="none">
            <code>| 		buf[i] = yybytes[i];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b = yy_scan_buffer(buf,n );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* It's okay to grow etc. this buffer, and we should throw it</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * away when we're done.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_is_our_buffer = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return b;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_EXIT_FAILURE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_EXIT_FAILURE 2</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_fatal_error (yyconst char* msg )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	(void) fprintf( stderr, "%s\n", msg );</code><br />
            </span>
            
            <span class="none">
            <code>| 	exit( YY_EXIT_FAILURE );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Redefine yyless() so it works in section 3 code. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #undef yyless</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyless(n) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	do \</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Undo effects of setting up yytext. */ \</code><br />
            </span>
            
            <span class="none">
            <code>|         int yyless_macro_arg = (n); \</code><br />
            </span>
            
            <span class="none">
            <code>|         YY_LESS_LINENO(yyless_macro_arg);\</code><br />
            </span>
            
            <span class="none">
            <code>| 		yytext[yyleng] = (yy_hold_char); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_c_buf_p) = yytext + yyless_macro_arg; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_hold_char) = *(yy_c_buf_p); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_c_buf_p) = '\0'; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		yyleng = yyless_macro_arg; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	while ( 0 )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Accessor  methods (get/set functions) to struct members. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the current line number.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| int yyget_lineno  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     return yylineno;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the input stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyget_in  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yyin;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the output stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyget_out  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yyout;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the length of the current token.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| yy_size_t yyget_leng  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yyleng;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the current token.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| char *yyget_text  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yytext;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Set the current line number.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param line_number</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_lineno (int  line_number )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     yylineno = line_number;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Set the input stream. This does not discard the current</code><br />
            </span>
            
            <span class="none">
            <code>|  * input buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param in_str A readable stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @see yy_switch_to_buffer</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_in (FILE *  in_str )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         yyin = in_str ;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_out (FILE *  out_str )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         yyout = out_str ;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yyget_debug  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yy_flex_debug;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_debug (int  bdebug )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         yy_flex_debug = bdebug ;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_init_globals (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         /* Initialization is the same as for the non-reentrant scanner.</code><br />
            </span>
            
            <span class="none">
            <code>|      * This function is called from yylex_destroy(), so don't allocate here.</code><br />
            </span>
            
            <span class="none">
            <code>|      */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_buffer_stack) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_buffer_stack_top) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_buffer_stack_max) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_c_buf_p) = (char *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_init) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_start) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_state_buf) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_state_ptr) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_full_match) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_lp) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Defined in main.c */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_STDINIT</code><br />
            </span>
            
            <span class="none">
            <code>|     yyin = stdin;</code><br />
            </span>
            
            <span class="none">
            <code>|     yyout = stdout;</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>|     yyin = (FILE *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     yyout = (FILE *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     /* For future reference: Set errno on error, since we are called by</code><br />
            </span>
            
            <span class="none">
            <code>|      * yylex_init()</code><br />
            </span>
            
            <span class="none">
            <code>|      */</code><br />
            </span>
            
            <span class="none">
            <code>|     return 0;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yylex_destroy is for both reentrant and non-reentrant scanners. */</code><br />
            </span>
            
            <span class="none">
            <code>| int yylex_destroy  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     /* Pop the buffer stack, destroying each element. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	while(YY_CURRENT_BUFFER){</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_delete_buffer(YY_CURRENT_BUFFER  );</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE = NULL;</code><br />
            </span>
            
            <span class="none">
            <code>| 		yypop_buffer_state();</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Destroy the stack itself. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyfree((yy_buffer_stack) );</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_buffer_stack) = NULL;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     yyfree ( (yy_state_buf) );</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_state_buf)  = NULL;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     /* Reset the globals. This is important in a non-reentrant scanner so the next time</code><br />
            </span>
            
            <span class="none">
            <code>|      * yylex() is called, initialization will occur. */</code><br />
            </span>
            
            <span class="none">
            <code>|     yy_init_globals( );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     return 0;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /*</code><br />
            </span>
            
            <span class="none">
            <code>|  * Internal utility routines.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef yytext_ptr</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int i;</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( i = 0; i < n; ++i )</code><br />
            </span>
            
            <span class="none">
            <code>| 		s1[i] = s2[i];</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_NEED_STRLEN</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_flex_strlen (yyconst char * s )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int n;</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( n = 0; s[n]; ++n )</code><br />
            </span>
            
            <span class="none">
            <code>| 		;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return n;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void *yyalloc (yy_size_t  size )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	return (void *) malloc( size );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void *yyrealloc  (void * ptr, yy_size_t  size )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* The cast to (char *) in the following accommodates both</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * implementations that use char* generic pointers, and those</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * that use void* generic pointers.  It works with the latter</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * because both ANSI C and C++ allow castless assignment from</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * any pointer type to void*, and deal with argument conversions</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * as though doing an assignment.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	return (void *) realloc( (char *) ptr, size );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyfree (void * ptr )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YYTABLES_NAME "yytables"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #line 9 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YYTEXT_POINTER</code><br />
            </span>
            
            <span class="none">
            <code>| extern char *yytext;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| int</code><br />
            </span>
            
            <span class="none">
            <code>| main (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|   return ! yylex () + ! yywrap ();</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>configure:19528: arm-linux-androideabi-gcc -o conftest    conftest.c -lfl  >&5</code><br />
            </span>
            
            <span class="none">
            <code>/toolchain_root/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld: error: cannot find -lfl</code><br />
            </span>
            
            <span class="none">
            <code>/tmp/ccIIon1i.o:conftest.c:function yylex: error: undefined reference to 'yywrap'</code><br />
            </span>
            
            <span class="none">
            <code>/tmp/ccIIon1i.o:conftest.c:function input: error: undefined reference to 'yywrap'</code><br />
            </span>
            
            <span class="none">
            <code>/tmp/ccIIon1i.o:conftest.c:function main: error: undefined reference to 'yywrap'</code><br />
            </span>
            
            <span class="none">
            <code>collect2: error: ld returned 1 exit status</code><br />
            </span>
            
            <span class="none">
            <code>configure:19534: $? = 1</code><br />
            </span>
            
            <span class="none">
            <code>configure: failed program was:</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #line 3 "lex.yy.c"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define  YY_INT_ALIGNED short int</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* A lexical scanner generated by flex */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define FLEX_SCANNER</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FLEX_MAJOR_VERSION 2</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FLEX_MINOR_VERSION 5</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FLEX_SUBMINOR_VERSION 39</code><br />
            </span>
            
            <span class="none">
            <code>| #if YY_FLEX_SUBMINOR_VERSION > 0</code><br />
            </span>
            
            <span class="none">
            <code>| #define FLEX_BETA</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* First, we deal with  platform-specific or compiler-specific issues. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* begin standard C headers. */</code><br />
            </span>
            
            <span class="none">
            <code>| #include <stdio.h></code><br />
            </span>
            
            <span class="none">
            <code>| #include <string.h></code><br />
            </span>
            
            <span class="none">
            <code>| #include <errno.h></code><br />
            </span>
            
            <span class="none">
            <code>| #include <stdlib.h></code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* end standard C headers. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* flex integer type definitions */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef FLEXINT_H</code><br />
            </span>
            
            <span class="none">
            <code>| #define FLEXINT_H</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,</code><br />
            </span>
            
            <span class="none">
            <code>|  * if you want the limit (max/min) macros for int types.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef __STDC_LIMIT_MACROS</code><br />
            </span>
            
            <span class="none">
            <code>| #define __STDC_LIMIT_MACROS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #include <inttypes.h></code><br />
            </span>
            
            <span class="none">
            <code>| typedef int8_t flex_int8_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef uint8_t flex_uint8_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef int16_t flex_int16_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef uint16_t flex_uint16_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef int32_t flex_int32_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef uint32_t flex_uint32_t;</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| typedef signed char flex_int8_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef short int flex_int16_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef int flex_int32_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef unsigned char flex_uint8_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef unsigned short int flex_uint16_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef unsigned int flex_uint32_t;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Limits of integral types. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT8_MIN</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT8_MIN               (-128)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT16_MIN</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT16_MIN              (-32767-1)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT32_MIN</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT32_MIN              (-2147483647-1)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT8_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT8_MAX               (127)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT16_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT16_MAX              (32767)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT32_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT32_MAX              (2147483647)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef UINT8_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define UINT8_MAX              (255U)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef UINT16_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define UINT16_MAX             (65535U)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef UINT32_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define UINT32_MAX             (4294967295U)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif /* ! C99 */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif /* ! FLEXINT_H */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* The "const" storage-class-modifier is valid. */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_USE_CONST</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #else	/* ! __cplusplus */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* C99 requires __STDC__ to be defined as 1. */</code><br />
            </span>
            
            <span class="none">
            <code>| #if defined (__STDC__)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_USE_CONST</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif	/* defined (__STDC__) */</code><br />
            </span>
            
            <span class="none">
            <code>| #endif	/* ! __cplusplus */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_USE_CONST</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyconst const</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyconst</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Returned upon end-of-file. */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_NULL 0</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Promotes a possibly negative, possibly signed char to an unsigned</code><br />
            </span>
            
            <span class="none">
            <code>|  * integer for use as an array index.  If the signed char is negative,</code><br />
            </span>
            
            <span class="none">
            <code>|  * we want to instead treat it as an 8-bit unsigned char, hence the</code><br />
            </span>
            
            <span class="none">
            <code>|  * double cast.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Enter a start condition.  This macro really ought to take a parameter,</code><br />
            </span>
            
            <span class="none">
            <code>|  * but we do it the disgusting crufty way forced on us by the ()-less</code><br />
            </span>
            
            <span class="none">
            <code>|  * definition of BEGIN.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define BEGIN (yy_start) = 1 + 2 *</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Translate the current start state into a value that can be later handed</code><br />
            </span>
            
            <span class="none">
            <code>|  * to BEGIN to return to the state.  The YYSTATE alias is for lex</code><br />
            </span>
            
            <span class="none">
            <code>|  * compatibility.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_START (((yy_start) - 1) / 2)</code><br />
            </span>
            
            <span class="none">
            <code>| #define YYSTATE YY_START</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Action number for EOF rule of a given start state. */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Special action meaning "start processing a new file". */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_NEW_FILE yyrestart(yyin  )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_END_OF_BUFFER_CHAR 0</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Size of default input buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_BUF_SIZE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BUF_SIZE 16384</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* The state buf must be large enough to hold one state per character in the main buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_TYPEDEF_YY_BUFFER_STATE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_TYPEDEF_YY_BUFFER_STATE</code><br />
            </span>
            
            <span class="none">
            <code>| typedef struct yy_buffer_state *YY_BUFFER_STATE;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_TYPEDEF_YY_SIZE_T</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_TYPEDEF_YY_SIZE_T</code><br />
            </span>
            
            <span class="none">
            <code>| typedef size_t yy_size_t;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern yy_size_t yyleng;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern FILE *yyin, *yyout;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define EOB_ACT_CONTINUE_SCAN 0</code><br />
            </span>
            
            <span class="none">
            <code>| #define EOB_ACT_END_OF_FILE 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define EOB_ACT_LAST_MATCH 2</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     #define YY_LESS_LINENO(n)</code><br />
            </span>
            
            <span class="none">
            <code>|     #define YY_LINENO_REWIND_TO(ptr)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Return all but the first "n" matched characters back to the input stream. */</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyless(n) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	do \</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Undo effects of setting up yytext. */ \</code><br />
            </span>
            
            <span class="none">
            <code>|         int yyless_macro_arg = (n); \</code><br />
            </span>
            
            <span class="none">
            <code>|         YY_LESS_LINENO(yyless_macro_arg);\</code><br />
            </span>
            
            <span class="none">
            <code>| 		*yy_cp = (yy_hold_char); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_RESTORE_YY_MORE_OFFSET \</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	while ( 0 )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define unput(c) yyunput( c, (yytext_ptr)  )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_STRUCT_YY_BUFFER_STATE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_STRUCT_YY_BUFFER_STATE</code><br />
            </span>
            
            <span class="none">
            <code>| struct yy_buffer_state</code><br />
            </span>
            
            <span class="none">
            <code>| 	{</code><br />
            </span>
            
            <span class="none">
            <code>| 	FILE *yy_input_file;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	char *yy_ch_buf;		/* input buffer */</code><br />
            </span>
            
            <span class="none">
            <code>| 	char *yy_buf_pos;		/* current position in input buffer */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Size of input buffer in bytes, not including room for EOB</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * characters.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t yy_buf_size;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Number of characters read into yy_ch_buf, not including EOB</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * characters.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t yy_n_chars;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Whether we "own" the buffer - i.e., we know we created it,</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * and can realloc() it to grow it, and should free() it to</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * delete it.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_is_our_buffer;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Whether this is an "interactive" input source; if so, and</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * if we're using stdio for input, then we want to use getc()</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * instead of fread(), to make sure we stop fetching input after</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * each newline.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_is_interactive;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Whether we're considered to be at the beginning of a line.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * If so, '^' rules will be active on the next match, otherwise</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * not.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_at_bol;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     int yy_bs_lineno; /**< The line count. */</code><br />
            </span>
            
            <span class="none">
            <code>|     int yy_bs_column; /**< The column count. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Whether to try to fill the input buffer when we reach the</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * end of it.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_fill_buffer;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_buffer_status;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BUFFER_NEW 0</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BUFFER_NORMAL 1</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* When an EOF's been seen but there's still some text to process</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * shouldn't try reading from the input source any more.  We might</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * still have a bunch of tokens to match, though, because of</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * possible backing-up.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 *</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * When we actually see the EOF, we change the status to "new"</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * (via yyrestart()), so that the user can continue scanning by</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * just pointing yyin at a new input file.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BUFFER_EOF_PENDING 2</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	};</code><br />
            </span>
            
            <span class="none">
            <code>| #endif /* !YY_STRUCT_YY_BUFFER_STATE */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Stack of input buffers. */</code><br />
            </span>
            
            <span class="none">
            <code>| static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */</code><br />
            </span>
            
            <span class="none">
            <code>| static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */</code><br />
            </span>
            
            <span class="none">
            <code>| static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* We provide macros for accessing buffer states in case in the</code><br />
            </span>
            
            <span class="none">
            <code>|  * future we want to put the buffer states in a more general</code><br />
            </span>
            
            <span class="none">
            <code>|  * "scanner state".</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * Returns the top of the stack, or NULL.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_CURRENT_BUFFER ( (yy_buffer_stack) \</code><br />
            </span>
            
            <span class="none">
            <code>|                           ? (yy_buffer_stack)[(yy_buffer_stack_top)] \</code><br />
            </span>
            
            <span class="none">
            <code>|                           : NULL)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Same as previous macro, but useful when we know that the buffer stack is not</code><br />
            </span>
            
            <span class="none">
            <code>|  * NULL or when we need an lvalue. For internal use only.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yy_hold_char holds the character lost when yytext is formed. */</code><br />
            </span>
            
            <span class="none">
            <code>| static char yy_hold_char;</code><br />
            </span>
            
            <span class="none">
            <code>| static yy_size_t yy_n_chars;		/* number of characters read into yy_ch_buf */</code><br />
            </span>
            
            <span class="none">
            <code>| yy_size_t yyleng;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Points to current character in buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| static char *yy_c_buf_p = (char *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_init = 0;		/* whether we need to initialize */</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_start = 0;	/* start state number */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Flag which is used to allow yywrap()'s to do buffer switches</code><br />
            </span>
            
            <span class="none">
            <code>|  * instead of setting up a fresh yyin.  A bit of a hack ...</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_did_buffer_switch_on_eof;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyrestart (FILE *input_file  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yy_delete_buffer (YY_BUFFER_STATE b  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yy_flush_buffer (YY_BUFFER_STATE b  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yypop_buffer_state (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static void yyensure_buffer_stack (void );</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_load_buffer_state (void );</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,yy_size_t len  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void *yyalloc (yy_size_t  );</code><br />
            </span>
            
            <span class="none">
            <code>| void *yyrealloc (void *,yy_size_t  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yyfree (void *  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define yy_new_buffer yy_create_buffer</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define yy_set_interactive(is_interactive) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! YY_CURRENT_BUFFER ){ \</code><br />
            </span>
            
            <span class="none">
            <code>|         yyensure_buffer_stack (); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE =    \</code><br />
            </span>
            
            <span class="none">
            <code>|             yy_create_buffer(yyin,YY_BUF_SIZE ); \</code><br />
            </span>
            
            <span class="none">
            <code>| 	} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define yy_set_bol(at_bol) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! YY_CURRENT_BUFFER ){\</code><br />
            </span>
            
            <span class="none">
            <code>|         yyensure_buffer_stack (); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE =    \</code><br />
            </span>
            
            <span class="none">
            <code>|             yy_create_buffer(yyin,YY_BUF_SIZE ); \</code><br />
            </span>
            
            <span class="none">
            <code>| 	} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Begin user sect3 */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| typedef unsigned char YY_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| typedef int yy_state_type;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern int yylineno;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yylineno = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern char *yytext;</code><br />
            </span>
            
            <span class="none">
            <code>| #define yytext_ptr yytext</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yy_state_type yy_get_previous_state (void );</code><br />
            </span>
            
            <span class="none">
            <code>| static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_get_next_buffer (void );</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_fatal_error (yyconst char msg[]  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Done after the current pattern has been matched and before the</code><br />
            </span>
            
            <span class="none">
            <code>|  * corresponding action - sets up yytext.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_DO_BEFORE_ACTION \</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) = yy_bp; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) -= (yy_more_len); \</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyleng = (size_t) (yy_cp - (yytext_ptr)); \</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_hold_char) = *yy_cp; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	*yy_cp = '\0'; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_c_buf_p) = yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_NUM_RULES 8</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_END_OF_BUFFER 9</code><br />
            </span>
            
            <span class="none">
            <code>| /* This struct is not used in this scanner,</code><br />
            </span>
            
            <span class="none">
            <code>|    but its presence is necessary. */</code><br />
            </span>
            
            <span class="none">
            <code>| struct yy_trans_info</code><br />
            </span>
            
            <span class="none">
            <code>| 	{</code><br />
            </span>
            
            <span class="none">
            <code>| 	flex_int32_t yy_verify;</code><br />
            </span>
            
            <span class="none">
            <code>| 	flex_int32_t yy_nxt;</code><br />
            </span>
            
            <span class="none">
            <code>| 	};</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_acclist[23] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         9,    7,    8,    8,    1,    7,    8,    2,    7,    8,</code><br />
            </span>
            
            <span class="none">
            <code>|         3,    7,    8,    4,    7,    8,    5,    7,    8,    6,</code><br />
            </span>
            
            <span class="none">
            <code>|         7,    8</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_accept[14] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    2,    4,    5,    8,   11,   14,   17,</code><br />
            </span>
            
            <span class="none">
            <code>|        20,   23,   23</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int32_t yy_ec[256] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    2,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    3,    4,    5,    6,</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|         7,    8,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int32_t yy_meta[9] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_base[13] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         0,    0,    9,   10,   10,   10,   10,   10,   10,   10,</code><br />
            </span>
            
            <span class="none">
            <code>|        10,   10</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_def[13] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|        12,    1,   12,   12,   12,   12,   12,   12,   12,   12,</code><br />
            </span>
            
            <span class="none">
            <code>|        12,    0</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_nxt[19] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         4,    5,    6,    7,    8,    9,   10,   11,   12,    3,</code><br />
            </span>
            
            <span class="none">
            <code>|        12,   12,   12,   12,   12,   12,   12,   12</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_chk[19] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    3,   12,</code><br />
            </span>
            
            <span class="none">
            <code>|        12,   12,   12,   12,   12,   12,   12,   12</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern int yy_flex_debug;</code><br />
            </span>
            
            <span class="none">
            <code>| int yy_flex_debug = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yy_state_type *yy_state_buf=0, *yy_state_ptr=0;</code><br />
            </span>
            
            <span class="none">
            <code>| static char *yy_full_match;</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_lp;</code><br />
            </span>
            
            <span class="none">
            <code>| #define REJECT \</code><br />
            </span>
            
            <span class="none">
            <code>| { \</code><br />
            </span>
            
            <span class="none">
            <code>| *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */ \</code><br />
            </span>
            
            <span class="none">
            <code>| yy_cp = (yy_full_match); /* restore poss. backed-over text */ \</code><br />
            </span>
            
            <span class="none">
            <code>| ++(yy_lp); \</code><br />
            </span>
            
            <span class="none">
            <code>| goto find_rule; \</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_more_flag = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_more_len = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| #define yymore() ((yy_more_flag) = 1)</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_MORE_ADJ (yy_more_len)</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_RESTORE_YY_MORE_OFFSET</code><br />
            </span>
            
            <span class="none">
            <code>| char *yytext;</code><br />
            </span>
            
            <span class="none">
            <code>| #line 1 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| #line 470 "lex.yy.c"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define INITIAL 0</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_NO_UNISTD_H</code><br />
            </span>
            
            <span class="none">
            <code>| /* Special case for "unistd.h", since it is non-ANSI. We include it way</code><br />
            </span>
            
            <span class="none">
            <code>|  * down here because we want the user's section 1 to have been scanned first.</code><br />
            </span>
            
            <span class="none">
            <code>|  * The user has a chance to override it with an option.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #include <unistd.h></code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_EXTRA_TYPE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_EXTRA_TYPE void *</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_init_globals (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Accessor methods to globals.</code><br />
            </span>
            
            <span class="none">
            <code>|    These are made visible to non-reentrant scanners for convenience. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yylex_destroy (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yyget_debug (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_debug (int debug_flag  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| YY_EXTRA_TYPE yyget_extra (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_extra (YY_EXTRA_TYPE user_defined  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyget_in (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_in  (FILE * in_str  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyget_out (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_out  (FILE * out_str  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| yy_size_t yyget_leng (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| char *yyget_text (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yyget_lineno (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_lineno (int line_number  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Macros after this point can all be overridden by user definitions in</code><br />
            </span>
            
            <span class="none">
            <code>|  * section 1.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_SKIP_YYWRAP</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>| extern "C" int yywrap (void );</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| extern int yywrap (void );</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     static void yyunput (int c,char *buf_ptr  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef yytext_ptr</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_flex_strncpy (char *,yyconst char *,int );</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_NEED_STRLEN</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_flex_strlen (yyconst char * );</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_NO_INPUT</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>| static int yyinput (void );</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| static int input (void );</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Amount of stuff to slurp up with each read. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_READ_BUF_SIZE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_READ_BUF_SIZE 8192</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Copy whatever the last rule matched to the standard output. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef ECHO</code><br />
            </span>
            
            <span class="none">
            <code>| /* This used to be an fputs(), but since the string might contain NUL's,</code><br />
            </span>
            
            <span class="none">
            <code>|  * we now use fwrite().</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,</code><br />
            </span>
            
            <span class="none">
            <code>|  * is returned in "result".</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_INPUT</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_INPUT(buf,result,max_size) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		int c = '*'; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		size_t n; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		for ( n = 0; n < max_size && \</code><br />
            </span>
            
            <span class="none">
            <code>| 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \</code><br />
            </span>
            
            <span class="none">
            <code>| 			buf[n] = (char) c; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( c == '\n' ) \</code><br />
            </span>
            
            <span class="none">
            <code>| 			buf[n++] = (char) c; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( c == EOF && ferror( yyin ) ) \</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "input in flex scanner failed" ); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		result = n; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	else \</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		errno=0; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \</code><br />
            </span>
            
            <span class="none">
            <code>| 			{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 			if( errno != EINTR) \</code><br />
            </span>
            
            <span class="none">
            <code>| 				{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 				YY_FATAL_ERROR( "input in flex scanner failed" ); \</code><br />
            </span>
            
            <span class="none">
            <code>| 				break; \</code><br />
            </span>
            
            <span class="none">
            <code>| 				} \</code><br />
            </span>
            
            <span class="none">
            <code>| 			errno=0; \</code><br />
            </span>
            
            <span class="none">
            <code>| 			clearerr(yyin); \</code><br />
            </span>
            
            <span class="none">
            <code>| 			} \</code><br />
            </span>
            
            <span class="none">
            <code>| 		}\</code><br />
            </span>
            
            <span class="none">
            <code>| \</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* No semi-colon after return; correct usage is to write "yyterminate();" -</code><br />
            </span>
            
            <span class="none">
            <code>|  * we don't want an extra ';' after the "return" because that will cause</code><br />
            </span>
            
            <span class="none">
            <code>|  * some compilers to complain about unreachable statements.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef yyterminate</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyterminate() return YY_NULL</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Number of entries by which start-condition stack grows. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_START_STACK_INCR</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_START_STACK_INCR 25</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Report a fatal error. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_FATAL_ERROR</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* end tables serialization structures and prototypes */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Default declaration of generated scanner - a define so the user can</code><br />
            </span>
            
            <span class="none">
            <code>|  * easily add parameters.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_DECL</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_DECL_IS_OURS 1</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern int yylex (void);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_DECL int yylex (void)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif /* !YY_DECL */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Code executed at the beginning of each rule, after yytext and yyleng</code><br />
            </span>
            
            <span class="none">
            <code>|  * have been set up.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_USER_ACTION</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_USER_ACTION</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Code executed at the end of each rule. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BREAK break;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_RULE_SETUP \</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_USER_ACTION</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** The main scanner function which does all the work.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| YY_DECL</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register yy_state_type yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 	register char *yy_cp, *yy_bp;</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int yy_act;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( !(yy_init) )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_init) = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_USER_INIT</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_USER_INIT;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|         /* Create the reject buffer large enough to save one state per allowed character. */</code><br />
            </span>
            
            <span class="none">
            <code>|         if ( ! (yy_state_buf) )</code><br />
            </span>
            
            <span class="none">
            <code>|             (yy_state_buf) = (yy_state_type *)yyalloc(YY_STATE_BUF_SIZE  );</code><br />
            </span>
            
            <span class="none">
            <code>|             if ( ! (yy_state_buf) )</code><br />
            </span>
            
            <span class="none">
            <code>|                 YY_FATAL_ERROR( "out of dynamic memory in yylex()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! (yy_start) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_start) = 1;	/* first start state */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! yyin )</code><br />
            </span>
            
            <span class="none">
            <code>| 			yyin = stdin;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! yyout )</code><br />
            </span>
            
            <span class="none">
            <code>| 			yyout = stdout;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! YY_CURRENT_BUFFER ) {</code><br />
            </span>
            
            <span class="none">
            <code>| 			yyensure_buffer_stack ();</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE =</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_create_buffer(yyin,YY_BUF_SIZE );</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	{</code><br />
            </span>
            
            <span class="none">
            <code>| #line 1 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #line 687 "lex.yy.c"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	while ( 1 )		/* loops until end-of-file is reached */</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_more_len) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( (yy_more_flag) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_more_len) = (yy_c_buf_p) - (yytext_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_more_flag) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Support of yytext. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		*yy_cp = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* yy_bp points to the position in yy_ch_buf of the start of</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * the current run.</code><br />
            </span>
            
            <span class="none">
            <code>| 		 */</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_bp = yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_current_state = (yy_start);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_state_ptr) = (yy_state_buf);</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| yy_match:</code><br />
            </span>
            
            <span class="none">
            <code>| 		do</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;</code><br />
            </span>
            
            <span class="none">
            <code>| 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_current_state = (int) yy_def[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| 				if ( yy_current_state >= 13 )</code><br />
            </span>
            
            <span class="none">
            <code>| 					yy_c = yy_meta[(unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 			*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 			++yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( yy_base[yy_current_state] != 10 );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| yy_find_action:</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_current_state = *--(yy_state_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_lp) = yy_accept[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| find_rule: /* we branch to this label when backing up */</code><br />
            </span>
            
            <span class="none">
            <code>| 		for ( ; ; ) /* until we find what rule we matched */</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			if ( (yy_lp) && (yy_lp) < yy_accept[yy_current_state + 1] )</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_act = yy_acclist[(yy_lp)];</code><br />
            </span>
            
            <span class="none">
            <code>| 					{</code><br />
            </span>
            
            <span class="none">
            <code>| 					(yy_full_match) = yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| 					break;</code><br />
            </span>
            
            <span class="none">
            <code>| 					}</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>| 			--yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_current_state = *--(yy_state_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_lp) = yy_accept[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_DO_BEFORE_ACTION;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| do_action:	/* This label is used only to access EOF actions. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		switch ( yy_act )</code><br />
            </span>
            
            <span class="none">
            <code>| 	{ /* beginning of action switch */</code><br />
            </span>
            
            <span class="none">
            <code>| case 1:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 2 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { ECHO; }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 2:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 3 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { REJECT; }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 3:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 4 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { yymore (); }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 4:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 5 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { yyless (1); }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 5:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 6 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { yyless (input () != 0); }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 6:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 7 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { unput (yytext[0]); }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 7:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 8 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { BEGIN INITIAL; }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 8:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 9 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| ECHO;</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| #line 793 "lex.yy.c"</code><br />
            </span>
            
            <span class="none">
            <code>| 			case YY_STATE_EOF(INITIAL):</code><br />
            </span>
            
            <span class="none">
            <code>| 				yyterminate();</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	case YY_END_OF_BUFFER:</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Amount of text matched not including the EOB char. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Undo the effects of YY_DO_BEFORE_ACTION. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		*yy_cp = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_RESTORE_YY_MORE_OFFSET</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* We're scanning a new file or input source.  It's</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * possible that this happened because the user</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * just pointed yyin at a new source and called</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * yylex().  If so, then we have to assure</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * consistency between YY_CURRENT_BUFFER and our</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * globals.  Here is the right place to do so, because</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * this is the first action (other than possibly a</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * back-up) that will match for the new input source.</code><br />
            </span>
            
            <span class="none">
            <code>| 			 */</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Note that here we test for yy_c_buf_p "<=" to the position</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * of the first EOB in the buffer, since yy_c_buf_p will</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * already have been incremented past the NUL character</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * (since all states make transitions on EOB to the</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * end-of-buffer state).  Contrast this with the test</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * in input().</code><br />
            </span>
            
            <span class="none">
            <code>| 		 */</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{ /* This was really a NUL. */</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_state_type yy_next_state;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_current_state = yy_get_previous_state(  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* Okay, we're now positioned to make the NUL</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * transition.  We couldn't have</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * yy_get_previous_state() go ahead and do it</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * for us because it doesn't know how to deal</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * with the possibility of jamming (and we don't</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * want to build jamming into it because then it</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * will run more slowly).</code><br />
            </span>
            
            <span class="none">
            <code>| 			 */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_next_state = yy_try_NUL_trans( yy_current_state );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_bp = (yytext_ptr) + YY_MORE_ADJ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			if ( yy_next_state )</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				/* Consume the NUL. */</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_cp = ++(yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_current_state = yy_next_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 				goto yy_match;</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			else</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 				goto yy_find_action;</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		else switch ( yy_get_next_buffer(  ) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			case EOB_ACT_END_OF_FILE:</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				(yy_did_buffer_switch_on_eof) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				if ( yywrap( ) )</code><br />
            </span>
            
            <span class="none">
            <code>| 					{</code><br />
            </span>
            
            <span class="none">
            <code>| 					/* Note: because we've taken care in</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * yy_get_next_buffer() to have set up</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * yytext, we can now set up</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * yy_c_buf_p so that if some total</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * hoser (like flex itself) wants to</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * call the scanner after we return the</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * YY_NULL, it'll still work - another</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * YY_NULL will get returned.</code><br />
            </span>
            
            <span class="none">
            <code>| 					 */</code><br />
            </span>
            
            <span class="none">
            <code>| 					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 					yy_act = YY_STATE_EOF(YY_START);</code><br />
            </span>
            
            <span class="none">
            <code>| 					goto do_action;</code><br />
            </span>
            
            <span class="none">
            <code>| 					}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				else</code><br />
            </span>
            
            <span class="none">
            <code>| 					{</code><br />
            </span>
            
            <span class="none">
            <code>| 					if ( ! (yy_did_buffer_switch_on_eof) )</code><br />
            </span>
            
            <span class="none">
            <code>| 						YY_NEW_FILE;</code><br />
            </span>
            
            <span class="none">
            <code>| 					}</code><br />
            </span>
            
            <span class="none">
            <code>| 				break;</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			case EOB_ACT_CONTINUE_SCAN:</code><br />
            </span>
            
            <span class="none">
            <code>| 				(yy_c_buf_p) =</code><br />
            </span>
            
            <span class="none">
            <code>| 					(yytext_ptr) + yy_amount_of_matched_text;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_current_state = yy_get_previous_state(  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;</code><br />
            </span>
            
            <span class="none">
            <code>| 				goto yy_match;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			case EOB_ACT_LAST_MATCH:</code><br />
            </span>
            
            <span class="none">
            <code>| 				(yy_c_buf_p) =</code><br />
            </span>
            
            <span class="none">
            <code>| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_current_state = yy_get_previous_state(  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;</code><br />
            </span>
            
            <span class="none">
            <code>| 				goto yy_find_action;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		break;</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	default:</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR(</code><br />
            </span>
            
            <span class="none">
            <code>| 			"fatal flex scanner internal error--no action found" );</code><br />
            </span>
            
            <span class="none">
            <code>| 	} /* end of action switch */</code><br />
            </span>
            
            <span class="none">
            <code>| 		} /* end of scanning one token */</code><br />
            </span>
            
            <span class="none">
            <code>| 	} /* end of user's declarations */</code><br />
            </span>
            
            <span class="none">
            <code>| } /* end of yylex */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yy_get_next_buffer - try to read in a new buffer</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * Returns a code representing an action:</code><br />
            </span>
            
            <span class="none">
            <code>|  *	EOB_ACT_LAST_MATCH -</code><br />
            </span>
            
            <span class="none">
            <code>|  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position</code><br />
            </span>
            
            <span class="none">
            <code>|  *	EOB_ACT_END_OF_FILE - end of file</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_get_next_buffer (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;</code><br />
            </span>
            
            <span class="none">
            <code>| 	register char *source = (yytext_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int number_to_move, i;</code><br />
            </span>
            
            <span class="none">
            <code>| 	int ret_val;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR(</code><br />
            </span>
            
            <span class="none">
            <code>| 		"fatal flex scanner internal error--end of buffer missed" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ /* Don't try to fill the buffer, so this is an EOF. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* We matched a single character, the EOB, so</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * treat this as a final EOF.</code><br />
            </span>
            
            <span class="none">
            <code>| 			 */</code><br />
            </span>
            
            <span class="none">
            <code>| 			return EOB_ACT_END_OF_FILE;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		else</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* We matched some text prior to the EOB, first</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * process it.</code><br />
            </span>
            
            <span class="none">
            <code>| 			 */</code><br />
            </span>
            
            <span class="none">
            <code>| 			return EOB_ACT_LAST_MATCH;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Try to read more data. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* First move last chars to start of buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( i = 0; i < number_to_move; ++i )</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(dest++) = *(source++);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* don't do the read, it's not guaranteed to return an EOF,</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * just force an EOF</code><br />
            </span>
            
            <span class="none">
            <code>| 		 */</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	else</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_size_t num_to_read =</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( num_to_read <= 0 )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{ /* Not enough room in the buffer - grow it. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR(</code><br />
            </span>
            
            <span class="none">
            <code>| "input buffer overflow, can't enlarge buffer because scanner uses REJECT" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( num_to_read > YY_READ_BUF_SIZE )</code><br />
            </span>
            
            <span class="none">
            <code>| 			num_to_read = YY_READ_BUF_SIZE;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Read in more data. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_n_chars), num_to_read );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( (yy_n_chars) == 0 )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( number_to_move == YY_MORE_ADJ )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			ret_val = EOB_ACT_END_OF_FILE;</code><br />
            </span>
            
            <span class="none">
            <code>| 			yyrestart(yyin  );</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		else</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			ret_val = EOB_ACT_LAST_MATCH;</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =</code><br />
            </span>
            
            <span class="none">
            <code>| 				YY_BUFFER_EOF_PENDING;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	else</code><br />
            </span>
            
            <span class="none">
            <code>| 		ret_val = EOB_ACT_CONTINUE_SCAN;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Extend the array by 50%, plus the number we really need. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_n_chars) += number_to_move;</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return ret_val;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yy_get_previous_state - get the state just before the EOB char was reached */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     static yy_state_type yy_get_previous_state (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register yy_state_type yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 	register char *yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_current_state = (yy_start);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_state_ptr) = (yy_state_buf);</code><br />
            </span>
            
            <span class="none">
            <code>| 	*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_current_state = (int) yy_def[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| 			if ( yy_current_state >= 13 )</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_c = yy_meta[(unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yy_try_NUL_trans - try to make a transition on the NUL character</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * synopsis</code><br />
            </span>
            
            <span class="none">
            <code>|  *	next_state = yy_try_NUL_trans( current_state );</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int yy_is_jam;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	register YY_CHAR yy_c = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_current_state = (int) yy_def[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( yy_current_state >= 13 )</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_c = yy_meta[(unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_is_jam = (yy_current_state == 12);</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! yy_is_jam )</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		return yy_is_jam ? 0 : yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     static void yyunput (int c, register char * yy_bp )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register char *yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* undo effects of setting up yytext */</code><br />
            </span>
            
            <span class="none">
            <code>| 	*yy_cp = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ /* need to shift things up to make room */</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* +2 for EOB chars. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		register yy_size_t number_to_move = (yy_n_chars) + 2;</code><br />
            </span>
            
            <span class="none">
            <code>| 		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[</code><br />
            </span>
            
            <span class="none">
            <code>| 					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];</code><br />
            </span>
            
            <span class="none">
            <code>| 		register char *source =</code><br />
            </span>
            
            <span class="none">
            <code>| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )</code><br />
            </span>
            
            <span class="none">
            <code>| 			*--dest = *--source;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_cp += (int) (dest - source);</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_bp += (int) (dest - source);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "flex scanner push-back overflow" );</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	*--yy_cp = (char) c;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) = yy_bp;</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_hold_char) = *yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_c_buf_p) = yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_NO_INPUT</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>|     static int yyinput (void)</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>|     static int input  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	int c;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	*(yy_c_buf_p) = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* yy_c_buf_p now points to the character we want to return.</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * If this occurs *before* the EOB characters, then it's a</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * valid NUL; if not, then we've hit the end of the buffer.</code><br />
            </span>
            
            <span class="none">
            <code>| 		 */</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* This was really a NUL. */</code><br />
            </span>
            
            <span class="none">
            <code>| 			*(yy_c_buf_p) = '\0';</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		else</code><br />
            </span>
            
            <span class="none">
            <code>| 			{ /* need more input */</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_size_t offset = (yy_c_buf_p) - (yytext_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 			++(yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			switch ( yy_get_next_buffer(  ) )</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				case EOB_ACT_LAST_MATCH:</code><br />
            </span>
            
            <span class="none">
            <code>| 					/* This happens because yy_g_n_b()</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * sees that we've accumulated a</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * token and flags that we need to</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * try matching the token before</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * proceeding.  But for input(),</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * there's no matching to consider.</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * So convert the EOB_ACT_LAST_MATCH</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * to EOB_ACT_END_OF_FILE.</code><br />
            </span>
            
            <span class="none">
            <code>| 					 */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 					/* Reset buffer status. */</code><br />
            </span>
            
            <span class="none">
            <code>| 					yyrestart(yyin );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 					/*FALLTHROUGH*/</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				case EOB_ACT_END_OF_FILE:</code><br />
            </span>
            
            <span class="none">
            <code>| 					{</code><br />
            </span>
            
            <span class="none">
            <code>| 					if ( yywrap( ) )</code><br />
            </span>
            
            <span class="none">
            <code>| 						return EOF;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 					if ( ! (yy_did_buffer_switch_on_eof) )</code><br />
            </span>
            
            <span class="none">
            <code>| 						YY_NEW_FILE;</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>| 					return yyinput();</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| 					return input();</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| 					}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				case EOB_ACT_CONTINUE_SCAN:</code><br />
            </span>
            
            <span class="none">
            <code>| 					(yy_c_buf_p) = (yytext_ptr) + offset;</code><br />
            </span>
            
            <span class="none">
            <code>| 					break;</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */</code><br />
            </span>
            
            <span class="none">
            <code>| 	*(yy_c_buf_p) = '\0';	/* preserve yytext */</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_hold_char) = *++(yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return c;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>| #endif	/* ifndef YY_NO_INPUT */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Immediately switch to a different input stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param input_file A readable stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @note This function does not reset the start condition to @c INITIAL .</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     void yyrestart  (FILE * input_file )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! YY_CURRENT_BUFFER ){</code><br />
            </span>
            
            <span class="none">
            <code>|         yyensure_buffer_stack ();</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE =</code><br />
            </span>
            
            <span class="none">
            <code>|             yy_create_buffer(yyin,YY_BUF_SIZE );</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_init_buffer(YY_CURRENT_BUFFER,input_file );</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Switch to a different input buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param new_buffer The new input buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* TODO. We should be able to replace this entire function body</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * with</code><br />
            </span>
            
            <span class="none">
            <code>| 	 *		yypop_buffer_state();</code><br />
            </span>
            
            <span class="none">
            <code>| 	 *		yypush_buffer_state(new_buffer);</code><br />
            </span>
            
            <span class="none">
            <code>|      */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyensure_buffer_stack ();</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER == new_buffer )</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Flush out information for old buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_c_buf_p) = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* We don't actually know whether we did this switch during</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * EOF (yywrap()) processing, but the only time this flag</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * is looked at is after yywrap() is called, so it's safe</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * to go ahead and always set it.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_did_buffer_switch_on_eof) = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_load_buffer_state  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_hold_char) = *(yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Allocate and initialize an input buffer state.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param file A readable stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @return the allocated buffer state.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BUFFER_STATE b;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buf_size = size;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* yy_ch_buf has to be 2 characters longer than the size given because</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * we need to put in 2 end-of-buffer characters.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b->yy_ch_buf )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_is_our_buffer = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_init_buffer(b,file );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return b;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Destroy the buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param b a buffer created with yy_create_buffer()</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     void yy_delete_buffer (YY_BUFFER_STATE  b )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( b->yy_is_our_buffer )</code><br />
            </span>
            
            <span class="none">
            <code>| 		yyfree((void *) b->yy_ch_buf  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyfree((void *) b  );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Initializes or reinitializes a buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * This function is sometimes called more than once on the same buffer,</code><br />
            </span>
            
            <span class="none">
            <code>|  * such as during a yyrestart() or at EOF.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	int oerrno = errno;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_flush_buffer(b );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_input_file = file;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_fill_buffer = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     /* If b is the current buffer, then yy_init_buffer was _probably_</code><br />
            </span>
            
            <span class="none">
            <code>|      * called from yyrestart() or through yy_get_next_buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|      * In that case, we don't want to reset the lineno or column.</code><br />
            </span>
            
            <span class="none">
            <code>|      */</code><br />
            </span>
            
            <span class="none">
            <code>|     if (b != YY_CURRENT_BUFFER){</code><br />
            </span>
            
            <span class="none">
            <code>|         b->yy_bs_lineno = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|         b->yy_bs_column = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|         b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	errno = oerrno;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Discard all buffered characters. On the next scan, YY_INPUT will be called.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     void yy_flush_buffer (YY_BUFFER_STATE  b )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_n_chars = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* We always need two end-of-buffer characters.  The first causes</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * a transition to the end-of-buffer state.  The second causes</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * a jam in that state.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buf_pos = &b->yy_ch_buf[0];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_at_bol = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buffer_status = YY_BUFFER_NEW;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( b == YY_CURRENT_BUFFER )</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Pushes the new state onto the stack. The new state becomes</code><br />
            </span>
            
            <span class="none">
            <code>|  *  the current state. This function will allocate the stack</code><br />
            </span>
            
            <span class="none">
            <code>|  *  if necessary.</code><br />
            </span>
            
            <span class="none">
            <code>|  *  @param new_buffer The new state.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| void yypush_buffer_state (YY_BUFFER_STATE new_buffer )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	if (new_buffer == NULL)</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyensure_buffer_stack();</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* This block is copied from yy_switch_to_buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Flush out information for old buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_c_buf_p) = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Only push if top exists. Otherwise, replace top. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	if (YY_CURRENT_BUFFER)</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack_top)++;</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* copied from yy_switch_to_buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_did_buffer_switch_on_eof) = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Removes and deletes the top of the stack, if present.</code><br />
            </span>
            
            <span class="none">
            <code>|  *  The next element becomes the new top.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| void yypop_buffer_state (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	if (!YY_CURRENT_BUFFER)</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_delete_buffer(YY_CURRENT_BUFFER );</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE = NULL;</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ((yy_buffer_stack_top) > 0)</code><br />
            </span>
            
            <span class="none">
            <code>| 		--(yy_buffer_stack_top);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if (YY_CURRENT_BUFFER) {</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_did_buffer_switch_on_eof) = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Allocates the stack if it does not exist.</code><br />
            </span>
            
            <span class="none">
            <code>|  *  Guarantees space for at least one push.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| static void yyensure_buffer_stack (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t num_to_alloc;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if (!(yy_buffer_stack)) {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* First allocation is just for 2 elements, since we don't know if this</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * scanner will even need a stack. We use 2 instead of 1 to avoid an</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * immediate realloc on the next call.</code><br />
            </span>
            
            <span class="none">
            <code>|          */</code><br />
            </span>
            
            <span class="none">
            <code>| 		num_to_alloc = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc</code><br />
            </span>
            
            <span class="none">
            <code>| 								(num_to_alloc * sizeof(struct yy_buffer_state*)</code><br />
            </span>
            
            <span class="none">
            <code>| 								);</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! (yy_buffer_stack) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack_max) = num_to_alloc;</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack_top) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Increase the buffer to prepare for a possible push. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		int grow_size = 8 /* arbitrary grow size */;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		num_to_alloc = (yy_buffer_stack_max) + grow_size;</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc</code><br />
            </span>
            
            <span class="none">
            <code>| 								((yy_buffer_stack),</code><br />
            </span>
            
            <span class="none">
            <code>| 								num_to_alloc * sizeof(struct yy_buffer_state*)</code><br />
            </span>
            
            <span class="none">
            <code>| 								);</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! (yy_buffer_stack) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* zero only the new slots.*/</code><br />
            </span>
            
            <span class="none">
            <code>| 		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack_max) = num_to_alloc;</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Setup the input buffer state to scan directly from a user-specified character buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param base the character buffer</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param size the size in bytes of the character buffer</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @return the newly allocated buffer state object.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BUFFER_STATE b;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( size < 2 ||</code><br />
            </span>
            
            <span class="none">
            <code>| 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||</code><br />
            </span>
            
            <span class="none">
            <code>| 	     base[size-1] != YY_END_OF_BUFFER_CHAR )</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* They forgot to leave room for the EOB's. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		return 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buf_pos = b->yy_ch_buf = base;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_is_our_buffer = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_input_file = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_n_chars = b->yy_buf_size;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_is_interactive = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_at_bol = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_fill_buffer = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buffer_status = YY_BUFFER_NEW;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_switch_to_buffer(b  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return b;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Setup the input buffer state to scan a string. The next call to yylex() will</code><br />
            </span>
            
            <span class="none">
            <code>|  * scan from a @e copy of @a str.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param yystr a NUL-terminated string to scan</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @return the newly allocated buffer state object.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @note If you want to scan bytes that may contain NUL values, then use</code><br />
            </span>
            
            <span class="none">
            <code>|  *       yy_scan_bytes() instead.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return yy_scan_bytes(yystr,strlen(yystr) );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Setup the input buffer state to scan the given bytes. The next call to yylex() will</code><br />
            </span>
            
            <span class="none">
            <code>|  * scan from a @e copy of @a bytes.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param yybytes the byte buffer to scan</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @return the newly allocated buffer state object.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BUFFER_STATE b;</code><br />
            </span>
            
            <span class="none">
            <code>| 	char *buf;</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t n;</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t i;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Get memory for full buffer, including space for trailing EOB's. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	n = _yybytes_len + 2;</code><br />
            </span>
            
            <span class="none">
            <code>| 	buf = (char *) yyalloc(n  );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! buf )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( i = 0; i < _yybytes_len; ++i )</code><br />
            </span>
            
            <span class="none">
            <code>| 		buf[i] = yybytes[i];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b = yy_scan_buffer(buf,n );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* It's okay to grow etc. this buffer, and we should throw it</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * away when we're done.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_is_our_buffer = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return b;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_EXIT_FAILURE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_EXIT_FAILURE 2</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_fatal_error (yyconst char* msg )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	(void) fprintf( stderr, "%s\n", msg );</code><br />
            </span>
            
            <span class="none">
            <code>| 	exit( YY_EXIT_FAILURE );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Redefine yyless() so it works in section 3 code. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #undef yyless</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyless(n) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	do \</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Undo effects of setting up yytext. */ \</code><br />
            </span>
            
            <span class="none">
            <code>|         int yyless_macro_arg = (n); \</code><br />
            </span>
            
            <span class="none">
            <code>|         YY_LESS_LINENO(yyless_macro_arg);\</code><br />
            </span>
            
            <span class="none">
            <code>| 		yytext[yyleng] = (yy_hold_char); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_c_buf_p) = yytext + yyless_macro_arg; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_hold_char) = *(yy_c_buf_p); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_c_buf_p) = '\0'; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		yyleng = yyless_macro_arg; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	while ( 0 )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Accessor  methods (get/set functions) to struct members. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the current line number.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| int yyget_lineno  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     return yylineno;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the input stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyget_in  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yyin;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the output stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyget_out  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yyout;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the length of the current token.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| yy_size_t yyget_leng  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yyleng;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the current token.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| char *yyget_text  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yytext;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Set the current line number.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param line_number</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_lineno (int  line_number )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     yylineno = line_number;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Set the input stream. This does not discard the current</code><br />
            </span>
            
            <span class="none">
            <code>|  * input buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param in_str A readable stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @see yy_switch_to_buffer</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_in (FILE *  in_str )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         yyin = in_str ;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_out (FILE *  out_str )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         yyout = out_str ;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yyget_debug  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yy_flex_debug;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_debug (int  bdebug )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         yy_flex_debug = bdebug ;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_init_globals (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         /* Initialization is the same as for the non-reentrant scanner.</code><br />
            </span>
            
            <span class="none">
            <code>|      * This function is called from yylex_destroy(), so don't allocate here.</code><br />
            </span>
            
            <span class="none">
            <code>|      */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_buffer_stack) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_buffer_stack_top) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_buffer_stack_max) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_c_buf_p) = (char *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_init) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_start) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_state_buf) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_state_ptr) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_full_match) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_lp) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Defined in main.c */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_STDINIT</code><br />
            </span>
            
            <span class="none">
            <code>|     yyin = stdin;</code><br />
            </span>
            
            <span class="none">
            <code>|     yyout = stdout;</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>|     yyin = (FILE *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     yyout = (FILE *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     /* For future reference: Set errno on error, since we are called by</code><br />
            </span>
            
            <span class="none">
            <code>|      * yylex_init()</code><br />
            </span>
            
            <span class="none">
            <code>|      */</code><br />
            </span>
            
            <span class="none">
            <code>|     return 0;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yylex_destroy is for both reentrant and non-reentrant scanners. */</code><br />
            </span>
            
            <span class="none">
            <code>| int yylex_destroy  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     /* Pop the buffer stack, destroying each element. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	while(YY_CURRENT_BUFFER){</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_delete_buffer(YY_CURRENT_BUFFER  );</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE = NULL;</code><br />
            </span>
            
            <span class="none">
            <code>| 		yypop_buffer_state();</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Destroy the stack itself. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyfree((yy_buffer_stack) );</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_buffer_stack) = NULL;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     yyfree ( (yy_state_buf) );</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_state_buf)  = NULL;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     /* Reset the globals. This is important in a non-reentrant scanner so the next time</code><br />
            </span>
            
            <span class="none">
            <code>|      * yylex() is called, initialization will occur. */</code><br />
            </span>
            
            <span class="none">
            <code>|     yy_init_globals( );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     return 0;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /*</code><br />
            </span>
            
            <span class="none">
            <code>|  * Internal utility routines.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef yytext_ptr</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int i;</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( i = 0; i < n; ++i )</code><br />
            </span>
            
            <span class="none">
            <code>| 		s1[i] = s2[i];</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_NEED_STRLEN</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_flex_strlen (yyconst char * s )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int n;</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( n = 0; s[n]; ++n )</code><br />
            </span>
            
            <span class="none">
            <code>| 		;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return n;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void *yyalloc (yy_size_t  size )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	return (void *) malloc( size );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void *yyrealloc  (void * ptr, yy_size_t  size )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* The cast to (char *) in the following accommodates both</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * implementations that use char* generic pointers, and those</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * that use void* generic pointers.  It works with the latter</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * because both ANSI C and C++ allow castless assignment from</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * any pointer type to void*, and deal with argument conversions</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * as though doing an assignment.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	return (void *) realloc( (char *) ptr, size );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyfree (void * ptr )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YYTABLES_NAME "yytables"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #line 9 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YYTEXT_POINTER</code><br />
            </span>
            
            <span class="none">
            <code>| extern char *yytext;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| int</code><br />
            </span>
            
            <span class="none">
            <code>| main (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|   return ! yylex () + ! yywrap ();</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>configure:19528: arm-linux-androideabi-gcc -o conftest    conftest.c -ll  >&5</code><br />
            </span>
            
            <span class="none">
            <code>/toolchain_root/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld: error: cannot find -ll</code><br />
            </span>
            
            <span class="none">
            <code>/tmp/cccJrhxZ.o:conftest.c:function yylex: error: undefined reference to 'yywrap'</code><br />
            </span>
            
            <span class="none">
            <code>/tmp/cccJrhxZ.o:conftest.c:function input: error: undefined reference to 'yywrap'</code><br />
            </span>
            
            <span class="none">
            <code>/tmp/cccJrhxZ.o:conftest.c:function main: error: undefined reference to 'yywrap'</code><br />
            </span>
            
            <span class="none">
            <code>collect2: error: ld returned 1 exit status</code><br />
            </span>
            
            <span class="none">
            <code>configure:19534: $? = 1</code><br />
            </span>
            
            <span class="none">
            <code>configure: failed program was:</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #line 3 "lex.yy.c"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define  YY_INT_ALIGNED short int</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* A lexical scanner generated by flex */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define FLEX_SCANNER</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FLEX_MAJOR_VERSION 2</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FLEX_MINOR_VERSION 5</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FLEX_SUBMINOR_VERSION 39</code><br />
            </span>
            
            <span class="none">
            <code>| #if YY_FLEX_SUBMINOR_VERSION > 0</code><br />
            </span>
            
            <span class="none">
            <code>| #define FLEX_BETA</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* First, we deal with  platform-specific or compiler-specific issues. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* begin standard C headers. */</code><br />
            </span>
            
            <span class="none">
            <code>| #include <stdio.h></code><br />
            </span>
            
            <span class="none">
            <code>| #include <string.h></code><br />
            </span>
            
            <span class="none">
            <code>| #include <errno.h></code><br />
            </span>
            
            <span class="none">
            <code>| #include <stdlib.h></code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* end standard C headers. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* flex integer type definitions */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef FLEXINT_H</code><br />
            </span>
            
            <span class="none">
            <code>| #define FLEXINT_H</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,</code><br />
            </span>
            
            <span class="none">
            <code>|  * if you want the limit (max/min) macros for int types.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef __STDC_LIMIT_MACROS</code><br />
            </span>
            
            <span class="none">
            <code>| #define __STDC_LIMIT_MACROS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #include <inttypes.h></code><br />
            </span>
            
            <span class="none">
            <code>| typedef int8_t flex_int8_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef uint8_t flex_uint8_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef int16_t flex_int16_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef uint16_t flex_uint16_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef int32_t flex_int32_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef uint32_t flex_uint32_t;</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| typedef signed char flex_int8_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef short int flex_int16_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef int flex_int32_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef unsigned char flex_uint8_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef unsigned short int flex_uint16_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef unsigned int flex_uint32_t;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Limits of integral types. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT8_MIN</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT8_MIN               (-128)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT16_MIN</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT16_MIN              (-32767-1)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT32_MIN</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT32_MIN              (-2147483647-1)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT8_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT8_MAX               (127)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT16_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT16_MAX              (32767)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT32_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT32_MAX              (2147483647)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef UINT8_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define UINT8_MAX              (255U)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef UINT16_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define UINT16_MAX             (65535U)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef UINT32_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define UINT32_MAX             (4294967295U)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif /* ! C99 */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif /* ! FLEXINT_H */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* The "const" storage-class-modifier is valid. */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_USE_CONST</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #else	/* ! __cplusplus */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* C99 requires __STDC__ to be defined as 1. */</code><br />
            </span>
            
            <span class="none">
            <code>| #if defined (__STDC__)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_USE_CONST</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif	/* defined (__STDC__) */</code><br />
            </span>
            
            <span class="none">
            <code>| #endif	/* ! __cplusplus */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_USE_CONST</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyconst const</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyconst</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Returned upon end-of-file. */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_NULL 0</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Promotes a possibly negative, possibly signed char to an unsigned</code><br />
            </span>
            
            <span class="none">
            <code>|  * integer for use as an array index.  If the signed char is negative,</code><br />
            </span>
            
            <span class="none">
            <code>|  * we want to instead treat it as an 8-bit unsigned char, hence the</code><br />
            </span>
            
            <span class="none">
            <code>|  * double cast.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Enter a start condition.  This macro really ought to take a parameter,</code><br />
            </span>
            
            <span class="none">
            <code>|  * but we do it the disgusting crufty way forced on us by the ()-less</code><br />
            </span>
            
            <span class="none">
            <code>|  * definition of BEGIN.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define BEGIN (yy_start) = 1 + 2 *</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Translate the current start state into a value that can be later handed</code><br />
            </span>
            
            <span class="none">
            <code>|  * to BEGIN to return to the state.  The YYSTATE alias is for lex</code><br />
            </span>
            
            <span class="none">
            <code>|  * compatibility.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_START (((yy_start) - 1) / 2)</code><br />
            </span>
            
            <span class="none">
            <code>| #define YYSTATE YY_START</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Action number for EOF rule of a given start state. */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Special action meaning "start processing a new file". */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_NEW_FILE yyrestart(yyin  )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_END_OF_BUFFER_CHAR 0</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Size of default input buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_BUF_SIZE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BUF_SIZE 16384</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* The state buf must be large enough to hold one state per character in the main buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_TYPEDEF_YY_BUFFER_STATE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_TYPEDEF_YY_BUFFER_STATE</code><br />
            </span>
            
            <span class="none">
            <code>| typedef struct yy_buffer_state *YY_BUFFER_STATE;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_TYPEDEF_YY_SIZE_T</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_TYPEDEF_YY_SIZE_T</code><br />
            </span>
            
            <span class="none">
            <code>| typedef size_t yy_size_t;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern yy_size_t yyleng;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern FILE *yyin, *yyout;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define EOB_ACT_CONTINUE_SCAN 0</code><br />
            </span>
            
            <span class="none">
            <code>| #define EOB_ACT_END_OF_FILE 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define EOB_ACT_LAST_MATCH 2</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     #define YY_LESS_LINENO(n)</code><br />
            </span>
            
            <span class="none">
            <code>|     #define YY_LINENO_REWIND_TO(ptr)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Return all but the first "n" matched characters back to the input stream. */</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyless(n) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	do \</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Undo effects of setting up yytext. */ \</code><br />
            </span>
            
            <span class="none">
            <code>|         int yyless_macro_arg = (n); \</code><br />
            </span>
            
            <span class="none">
            <code>|         YY_LESS_LINENO(yyless_macro_arg);\</code><br />
            </span>
            
            <span class="none">
            <code>| 		*yy_cp = (yy_hold_char); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_RESTORE_YY_MORE_OFFSET \</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	while ( 0 )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define unput(c) yyunput( c, (yytext_ptr)  )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_STRUCT_YY_BUFFER_STATE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_STRUCT_YY_BUFFER_STATE</code><br />
            </span>
            
            <span class="none">
            <code>| struct yy_buffer_state</code><br />
            </span>
            
            <span class="none">
            <code>| 	{</code><br />
            </span>
            
            <span class="none">
            <code>| 	FILE *yy_input_file;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	char *yy_ch_buf;		/* input buffer */</code><br />
            </span>
            
            <span class="none">
            <code>| 	char *yy_buf_pos;		/* current position in input buffer */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Size of input buffer in bytes, not including room for EOB</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * characters.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t yy_buf_size;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Number of characters read into yy_ch_buf, not including EOB</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * characters.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t yy_n_chars;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Whether we "own" the buffer - i.e., we know we created it,</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * and can realloc() it to grow it, and should free() it to</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * delete it.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_is_our_buffer;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Whether this is an "interactive" input source; if so, and</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * if we're using stdio for input, then we want to use getc()</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * instead of fread(), to make sure we stop fetching input after</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * each newline.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_is_interactive;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Whether we're considered to be at the beginning of a line.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * If so, '^' rules will be active on the next match, otherwise</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * not.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_at_bol;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     int yy_bs_lineno; /**< The line count. */</code><br />
            </span>
            
            <span class="none">
            <code>|     int yy_bs_column; /**< The column count. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Whether to try to fill the input buffer when we reach the</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * end of it.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_fill_buffer;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_buffer_status;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BUFFER_NEW 0</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BUFFER_NORMAL 1</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* When an EOF's been seen but there's still some text to process</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * shouldn't try reading from the input source any more.  We might</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * still have a bunch of tokens to match, though, because of</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * possible backing-up.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 *</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * When we actually see the EOF, we change the status to "new"</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * (via yyrestart()), so that the user can continue scanning by</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * just pointing yyin at a new input file.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BUFFER_EOF_PENDING 2</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	};</code><br />
            </span>
            
            <span class="none">
            <code>| #endif /* !YY_STRUCT_YY_BUFFER_STATE */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Stack of input buffers. */</code><br />
            </span>
            
            <span class="none">
            <code>| static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */</code><br />
            </span>
            
            <span class="none">
            <code>| static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */</code><br />
            </span>
            
            <span class="none">
            <code>| static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* We provide macros for accessing buffer states in case in the</code><br />
            </span>
            
            <span class="none">
            <code>|  * future we want to put the buffer states in a more general</code><br />
            </span>
            
            <span class="none">
            <code>|  * "scanner state".</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * Returns the top of the stack, or NULL.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_CURRENT_BUFFER ( (yy_buffer_stack) \</code><br />
            </span>
            
            <span class="none">
            <code>|                           ? (yy_buffer_stack)[(yy_buffer_stack_top)] \</code><br />
            </span>
            
            <span class="none">
            <code>|                           : NULL)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Same as previous macro, but useful when we know that the buffer stack is not</code><br />
            </span>
            
            <span class="none">
            <code>|  * NULL or when we need an lvalue. For internal use only.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yy_hold_char holds the character lost when yytext is formed. */</code><br />
            </span>
            
            <span class="none">
            <code>| static char yy_hold_char;</code><br />
            </span>
            
            <span class="none">
            <code>| static yy_size_t yy_n_chars;		/* number of characters read into yy_ch_buf */</code><br />
            </span>
            
            <span class="none">
            <code>| yy_size_t yyleng;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Points to current character in buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| static char *yy_c_buf_p = (char *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_init = 0;		/* whether we need to initialize */</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_start = 0;	/* start state number */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Flag which is used to allow yywrap()'s to do buffer switches</code><br />
            </span>
            
            <span class="none">
            <code>|  * instead of setting up a fresh yyin.  A bit of a hack ...</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_did_buffer_switch_on_eof;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyrestart (FILE *input_file  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yy_delete_buffer (YY_BUFFER_STATE b  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yy_flush_buffer (YY_BUFFER_STATE b  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yypop_buffer_state (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static void yyensure_buffer_stack (void );</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_load_buffer_state (void );</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,yy_size_t len  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void *yyalloc (yy_size_t  );</code><br />
            </span>
            
            <span class="none">
            <code>| void *yyrealloc (void *,yy_size_t  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yyfree (void *  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define yy_new_buffer yy_create_buffer</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define yy_set_interactive(is_interactive) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! YY_CURRENT_BUFFER ){ \</code><br />
            </span>
            
            <span class="none">
            <code>|         yyensure_buffer_stack (); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE =    \</code><br />
            </span>
            
            <span class="none">
            <code>|             yy_create_buffer(yyin,YY_BUF_SIZE ); \</code><br />
            </span>
            
            <span class="none">
            <code>| 	} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define yy_set_bol(at_bol) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! YY_CURRENT_BUFFER ){\</code><br />
            </span>
            
            <span class="none">
            <code>|         yyensure_buffer_stack (); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE =    \</code><br />
            </span>
            
            <span class="none">
            <code>|             yy_create_buffer(yyin,YY_BUF_SIZE ); \</code><br />
            </span>
            
            <span class="none">
            <code>| 	} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Begin user sect3 */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| typedef unsigned char YY_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| typedef int yy_state_type;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern int yylineno;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yylineno = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern char *yytext;</code><br />
            </span>
            
            <span class="none">
            <code>| #define yytext_ptr yytext</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yy_state_type yy_get_previous_state (void );</code><br />
            </span>
            
            <span class="none">
            <code>| static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_get_next_buffer (void );</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_fatal_error (yyconst char msg[]  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Done after the current pattern has been matched and before the</code><br />
            </span>
            
            <span class="none">
            <code>|  * corresponding action - sets up yytext.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_DO_BEFORE_ACTION \</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) = yy_bp; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) -= (yy_more_len); \</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyleng = (size_t) (yy_cp - (yytext_ptr)); \</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_hold_char) = *yy_cp; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	*yy_cp = '\0'; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_c_buf_p) = yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_NUM_RULES 8</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_END_OF_BUFFER 9</code><br />
            </span>
            
            <span class="none">
            <code>| /* This struct is not used in this scanner,</code><br />
            </span>
            
            <span class="none">
            <code>|    but its presence is necessary. */</code><br />
            </span>
            
            <span class="none">
            <code>| struct yy_trans_info</code><br />
            </span>
            
            <span class="none">
            <code>| 	{</code><br />
            </span>
            
            <span class="none">
            <code>| 	flex_int32_t yy_verify;</code><br />
            </span>
            
            <span class="none">
            <code>| 	flex_int32_t yy_nxt;</code><br />
            </span>
            
            <span class="none">
            <code>| 	};</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_acclist[23] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         9,    7,    8,    8,    1,    7,    8,    2,    7,    8,</code><br />
            </span>
            
            <span class="none">
            <code>|         3,    7,    8,    4,    7,    8,    5,    7,    8,    6,</code><br />
            </span>
            
            <span class="none">
            <code>|         7,    8</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_accept[14] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    2,    4,    5,    8,   11,   14,   17,</code><br />
            </span>
            
            <span class="none">
            <code>|        20,   23,   23</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int32_t yy_ec[256] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    2,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    3,    4,    5,    6,</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|         7,    8,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int32_t yy_meta[9] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_base[13] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         0,    0,    9,   10,   10,   10,   10,   10,   10,   10,</code><br />
            </span>
            
            <span class="none">
            <code>|        10,   10</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_def[13] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|        12,    1,   12,   12,   12,   12,   12,   12,   12,   12,</code><br />
            </span>
            
            <span class="none">
            <code>|        12,    0</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_nxt[19] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         4,    5,    6,    7,    8,    9,   10,   11,   12,    3,</code><br />
            </span>
            
            <span class="none">
            <code>|        12,   12,   12,   12,   12,   12,   12,   12</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_chk[19] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    3,   12,</code><br />
            </span>
            
            <span class="none">
            <code>|        12,   12,   12,   12,   12,   12,   12,   12</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern int yy_flex_debug;</code><br />
            </span>
            
            <span class="none">
            <code>| int yy_flex_debug = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yy_state_type *yy_state_buf=0, *yy_state_ptr=0;</code><br />
            </span>
            
            <span class="none">
            <code>| static char *yy_full_match;</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_lp;</code><br />
            </span>
            
            <span class="none">
            <code>| #define REJECT \</code><br />
            </span>
            
            <span class="none">
            <code>| { \</code><br />
            </span>
            
            <span class="none">
            <code>| *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */ \</code><br />
            </span>
            
            <span class="none">
            <code>| yy_cp = (yy_full_match); /* restore poss. backed-over text */ \</code><br />
            </span>
            
            <span class="none">
            <code>| ++(yy_lp); \</code><br />
            </span>
            
            <span class="none">
            <code>| goto find_rule; \</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_more_flag = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_more_len = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| #define yymore() ((yy_more_flag) = 1)</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_MORE_ADJ (yy_more_len)</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_RESTORE_YY_MORE_OFFSET</code><br />
            </span>
            
            <span class="none">
            <code>| char *yytext;</code><br />
            </span>
            
            <span class="none">
            <code>| #line 1 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| #line 470 "lex.yy.c"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define INITIAL 0</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_NO_UNISTD_H</code><br />
            </span>
            
            <span class="none">
            <code>| /* Special case for "unistd.h", since it is non-ANSI. We include it way</code><br />
            </span>
            
            <span class="none">
            <code>|  * down here because we want the user's section 1 to have been scanned first.</code><br />
            </span>
            
            <span class="none">
            <code>|  * The user has a chance to override it with an option.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #include <unistd.h></code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_EXTRA_TYPE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_EXTRA_TYPE void *</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_init_globals (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Accessor methods to globals.</code><br />
            </span>
            
            <span class="none">
            <code>|    These are made visible to non-reentrant scanners for convenience. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yylex_destroy (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yyget_debug (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_debug (int debug_flag  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| YY_EXTRA_TYPE yyget_extra (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_extra (YY_EXTRA_TYPE user_defined  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyget_in (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_in  (FILE * in_str  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyget_out (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_out  (FILE * out_str  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| yy_size_t yyget_leng (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| char *yyget_text (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yyget_lineno (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_lineno (int line_number  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Macros after this point can all be overridden by user definitions in</code><br />
            </span>
            
            <span class="none">
            <code>|  * section 1.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_SKIP_YYWRAP</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>| extern "C" int yywrap (void );</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| extern int yywrap (void );</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     static void yyunput (int c,char *buf_ptr  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef yytext_ptr</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_flex_strncpy (char *,yyconst char *,int );</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_NEED_STRLEN</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_flex_strlen (yyconst char * );</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_NO_INPUT</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>| static int yyinput (void );</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| static int input (void );</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Amount of stuff to slurp up with each read. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_READ_BUF_SIZE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_READ_BUF_SIZE 8192</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Copy whatever the last rule matched to the standard output. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef ECHO</code><br />
            </span>
            
            <span class="none">
            <code>| /* This used to be an fputs(), but since the string might contain NUL's,</code><br />
            </span>
            
            <span class="none">
            <code>|  * we now use fwrite().</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,</code><br />
            </span>
            
            <span class="none">
            <code>|  * is returned in "result".</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_INPUT</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_INPUT(buf,result,max_size) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		int c = '*'; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		size_t n; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		for ( n = 0; n < max_size && \</code><br />
            </span>
            
            <span class="none">
            <code>| 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \</code><br />
            </span>
            
            <span class="none">
            <code>| 			buf[n] = (char) c; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( c == '\n' ) \</code><br />
            </span>
            
            <span class="none">
            <code>| 			buf[n++] = (char) c; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( c == EOF && ferror( yyin ) ) \</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "input in flex scanner failed" ); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		result = n; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	else \</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		errno=0; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \</code><br />
            </span>
            
            <span class="none">
            <code>| 			{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 			if( errno != EINTR) \</code><br />
            </span>
            
            <span class="none">
            <code>| 				{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 				YY_FATAL_ERROR( "input in flex scanner failed" ); \</code><br />
            </span>
            
            <span class="none">
            <code>| 				break; \</code><br />
            </span>
            
            <span class="none">
            <code>| 				} \</code><br />
            </span>
            
            <span class="none">
            <code>| 			errno=0; \</code><br />
            </span>
            
            <span class="none">
            <code>| 			clearerr(yyin); \</code><br />
            </span>
            
            <span class="none">
            <code>| 			} \</code><br />
            </span>
            
            <span class="none">
            <code>| 		}\</code><br />
            </span>
            
            <span class="none">
            <code>| \</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* No semi-colon after return; correct usage is to write "yyterminate();" -</code><br />
            </span>
            
            <span class="none">
            <code>|  * we don't want an extra ';' after the "return" because that will cause</code><br />
            </span>
            
            <span class="none">
            <code>|  * some compilers to complain about unreachable statements.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef yyterminate</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyterminate() return YY_NULL</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Number of entries by which start-condition stack grows. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_START_STACK_INCR</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_START_STACK_INCR 25</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Report a fatal error. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_FATAL_ERROR</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* end tables serialization structures and prototypes */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Default declaration of generated scanner - a define so the user can</code><br />
            </span>
            
            <span class="none">
            <code>|  * easily add parameters.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_DECL</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_DECL_IS_OURS 1</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern int yylex (void);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_DECL int yylex (void)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif /* !YY_DECL */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Code executed at the beginning of each rule, after yytext and yyleng</code><br />
            </span>
            
            <span class="none">
            <code>|  * have been set up.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_USER_ACTION</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_USER_ACTION</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Code executed at the end of each rule. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BREAK break;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_RULE_SETUP \</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_USER_ACTION</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** The main scanner function which does all the work.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| YY_DECL</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register yy_state_type yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 	register char *yy_cp, *yy_bp;</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int yy_act;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( !(yy_init) )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_init) = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_USER_INIT</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_USER_INIT;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|         /* Create the reject buffer large enough to save one state per allowed character. */</code><br />
            </span>
            
            <span class="none">
            <code>|         if ( ! (yy_state_buf) )</code><br />
            </span>
            
            <span class="none">
            <code>|             (yy_state_buf) = (yy_state_type *)yyalloc(YY_STATE_BUF_SIZE  );</code><br />
            </span>
            
            <span class="none">
            <code>|             if ( ! (yy_state_buf) )</code><br />
            </span>
            
            <span class="none">
            <code>|                 YY_FATAL_ERROR( "out of dynamic memory in yylex()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! (yy_start) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_start) = 1;	/* first start state */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! yyin )</code><br />
            </span>
            
            <span class="none">
            <code>| 			yyin = stdin;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! yyout )</code><br />
            </span>
            
            <span class="none">
            <code>| 			yyout = stdout;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! YY_CURRENT_BUFFER ) {</code><br />
            </span>
            
            <span class="none">
            <code>| 			yyensure_buffer_stack ();</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE =</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_create_buffer(yyin,YY_BUF_SIZE );</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	{</code><br />
            </span>
            
            <span class="none">
            <code>| #line 1 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #line 687 "lex.yy.c"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	while ( 1 )		/* loops until end-of-file is reached */</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_more_len) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( (yy_more_flag) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_more_len) = (yy_c_buf_p) - (yytext_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_more_flag) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Support of yytext. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		*yy_cp = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* yy_bp points to the position in yy_ch_buf of the start of</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * the current run.</code><br />
            </span>
            
            <span class="none">
            <code>| 		 */</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_bp = yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_current_state = (yy_start);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_state_ptr) = (yy_state_buf);</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| yy_match:</code><br />
            </span>
            
            <span class="none">
            <code>| 		do</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;</code><br />
            </span>
            
            <span class="none">
            <code>| 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_current_state = (int) yy_def[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| 				if ( yy_current_state >= 13 )</code><br />
            </span>
            
            <span class="none">
            <code>| 					yy_c = yy_meta[(unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 			*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 			++yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( yy_base[yy_current_state] != 10 );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| yy_find_action:</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_current_state = *--(yy_state_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_lp) = yy_accept[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| find_rule: /* we branch to this label when backing up */</code><br />
            </span>
            
            <span class="none">
            <code>| 		for ( ; ; ) /* until we find what rule we matched */</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			if ( (yy_lp) && (yy_lp) < yy_accept[yy_current_state + 1] )</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_act = yy_acclist[(yy_lp)];</code><br />
            </span>
            
            <span class="none">
            <code>| 					{</code><br />
            </span>
            
            <span class="none">
            <code>| 					(yy_full_match) = yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| 					break;</code><br />
            </span>
            
            <span class="none">
            <code>| 					}</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>| 			--yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_current_state = *--(yy_state_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_lp) = yy_accept[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_DO_BEFORE_ACTION;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| do_action:	/* This label is used only to access EOF actions. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		switch ( yy_act )</code><br />
            </span>
            
            <span class="none">
            <code>| 	{ /* beginning of action switch */</code><br />
            </span>
            
            <span class="none">
            <code>| case 1:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 2 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { ECHO; }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 2:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 3 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { REJECT; }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 3:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 4 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { yymore (); }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 4:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 5 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { yyless (1); }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 5:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 6 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { yyless (input () != 0); }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 6:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 7 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { unput (yytext[0]); }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 7:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 8 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { BEGIN INITIAL; }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 8:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 9 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| ECHO;</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| #line 793 "lex.yy.c"</code><br />
            </span>
            
            <span class="none">
            <code>| 			case YY_STATE_EOF(INITIAL):</code><br />
            </span>
            
            <span class="none">
            <code>| 				yyterminate();</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	case YY_END_OF_BUFFER:</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Amount of text matched not including the EOB char. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Undo the effects of YY_DO_BEFORE_ACTION. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		*yy_cp = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_RESTORE_YY_MORE_OFFSET</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* We're scanning a new file or input source.  It's</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * possible that this happened because the user</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * just pointed yyin at a new source and called</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * yylex().  If so, then we have to assure</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * consistency between YY_CURRENT_BUFFER and our</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * globals.  Here is the right place to do so, because</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * this is the first action (other than possibly a</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * back-up) that will match for the new input source.</code><br />
            </span>
            
            <span class="none">
            <code>| 			 */</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Note that here we test for yy_c_buf_p "<=" to the position</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * of the first EOB in the buffer, since yy_c_buf_p will</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * already have been incremented past the NUL character</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * (since all states make transitions on EOB to the</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * end-of-buffer state).  Contrast this with the test</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * in input().</code><br />
            </span>
            
            <span class="none">
            <code>| 		 */</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{ /* This was really a NUL. */</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_state_type yy_next_state;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_current_state = yy_get_previous_state(  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* Okay, we're now positioned to make the NUL</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * transition.  We couldn't have</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * yy_get_previous_state() go ahead and do it</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * for us because it doesn't know how to deal</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * with the possibility of jamming (and we don't</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * want to build jamming into it because then it</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * will run more slowly).</code><br />
            </span>
            
            <span class="none">
            <code>| 			 */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_next_state = yy_try_NUL_trans( yy_current_state );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_bp = (yytext_ptr) + YY_MORE_ADJ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			if ( yy_next_state )</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				/* Consume the NUL. */</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_cp = ++(yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_current_state = yy_next_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 				goto yy_match;</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			else</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 				goto yy_find_action;</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		else switch ( yy_get_next_buffer(  ) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			case EOB_ACT_END_OF_FILE:</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				(yy_did_buffer_switch_on_eof) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				if ( yywrap( ) )</code><br />
            </span>
            
            <span class="none">
            <code>| 					{</code><br />
            </span>
            
            <span class="none">
            <code>| 					/* Note: because we've taken care in</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * yy_get_next_buffer() to have set up</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * yytext, we can now set up</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * yy_c_buf_p so that if some total</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * hoser (like flex itself) wants to</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * call the scanner after we return the</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * YY_NULL, it'll still work - another</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * YY_NULL will get returned.</code><br />
            </span>
            
            <span class="none">
            <code>| 					 */</code><br />
            </span>
            
            <span class="none">
            <code>| 					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 					yy_act = YY_STATE_EOF(YY_START);</code><br />
            </span>
            
            <span class="none">
            <code>| 					goto do_action;</code><br />
            </span>
            
            <span class="none">
            <code>| 					}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				else</code><br />
            </span>
            
            <span class="none">
            <code>| 					{</code><br />
            </span>
            
            <span class="none">
            <code>| 					if ( ! (yy_did_buffer_switch_on_eof) )</code><br />
            </span>
            
            <span class="none">
            <code>| 						YY_NEW_FILE;</code><br />
            </span>
            
            <span class="none">
            <code>| 					}</code><br />
            </span>
            
            <span class="none">
            <code>| 				break;</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			case EOB_ACT_CONTINUE_SCAN:</code><br />
            </span>
            
            <span class="none">
            <code>| 				(yy_c_buf_p) =</code><br />
            </span>
            
            <span class="none">
            <code>| 					(yytext_ptr) + yy_amount_of_matched_text;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_current_state = yy_get_previous_state(  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;</code><br />
            </span>
            
            <span class="none">
            <code>| 				goto yy_match;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			case EOB_ACT_LAST_MATCH:</code><br />
            </span>
            
            <span class="none">
            <code>| 				(yy_c_buf_p) =</code><br />
            </span>
            
            <span class="none">
            <code>| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_current_state = yy_get_previous_state(  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;</code><br />
            </span>
            
            <span class="none">
            <code>| 				goto yy_find_action;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		break;</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	default:</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR(</code><br />
            </span>
            
            <span class="none">
            <code>| 			"fatal flex scanner internal error--no action found" );</code><br />
            </span>
            
            <span class="none">
            <code>| 	} /* end of action switch */</code><br />
            </span>
            
            <span class="none">
            <code>| 		} /* end of scanning one token */</code><br />
            </span>
            
            <span class="none">
            <code>| 	} /* end of user's declarations */</code><br />
            </span>
            
            <span class="none">
            <code>| } /* end of yylex */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yy_get_next_buffer - try to read in a new buffer</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * Returns a code representing an action:</code><br />
            </span>
            
            <span class="none">
            <code>|  *	EOB_ACT_LAST_MATCH -</code><br />
            </span>
            
            <span class="none">
            <code>|  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position</code><br />
            </span>
            
            <span class="none">
            <code>|  *	EOB_ACT_END_OF_FILE - end of file</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_get_next_buffer (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;</code><br />
            </span>
            
            <span class="none">
            <code>| 	register char *source = (yytext_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int number_to_move, i;</code><br />
            </span>
            
            <span class="none">
            <code>| 	int ret_val;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR(</code><br />
            </span>
            
            <span class="none">
            <code>| 		"fatal flex scanner internal error--end of buffer missed" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ /* Don't try to fill the buffer, so this is an EOF. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* We matched a single character, the EOB, so</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * treat this as a final EOF.</code><br />
            </span>
            
            <span class="none">
            <code>| 			 */</code><br />
            </span>
            
            <span class="none">
            <code>| 			return EOB_ACT_END_OF_FILE;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		else</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* We matched some text prior to the EOB, first</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * process it.</code><br />
            </span>
            
            <span class="none">
            <code>| 			 */</code><br />
            </span>
            
            <span class="none">
            <code>| 			return EOB_ACT_LAST_MATCH;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Try to read more data. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* First move last chars to start of buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( i = 0; i < number_to_move; ++i )</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(dest++) = *(source++);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* don't do the read, it's not guaranteed to return an EOF,</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * just force an EOF</code><br />
            </span>
            
            <span class="none">
            <code>| 		 */</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	else</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_size_t num_to_read =</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( num_to_read <= 0 )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{ /* Not enough room in the buffer - grow it. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR(</code><br />
            </span>
            
            <span class="none">
            <code>| "input buffer overflow, can't enlarge buffer because scanner uses REJECT" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( num_to_read > YY_READ_BUF_SIZE )</code><br />
            </span>
            
            <span class="none">
            <code>| 			num_to_read = YY_READ_BUF_SIZE;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Read in more data. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_n_chars), num_to_read );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( (yy_n_chars) == 0 )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( number_to_move == YY_MORE_ADJ )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			ret_val = EOB_ACT_END_OF_FILE;</code><br />
            </span>
            
            <span class="none">
            <code>| 			yyrestart(yyin  );</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		else</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			ret_val = EOB_ACT_LAST_MATCH;</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =</code><br />
            </span>
            
            <span class="none">
            <code>| 				YY_BUFFER_EOF_PENDING;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	else</code><br />
            </span>
            
            <span class="none">
            <code>| 		ret_val = EOB_ACT_CONTINUE_SCAN;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Extend the array by 50%, plus the number we really need. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_n_chars) += number_to_move;</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return ret_val;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yy_get_previous_state - get the state just before the EOB char was reached */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     static yy_state_type yy_get_previous_state (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register yy_state_type yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 	register char *yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_current_state = (yy_start);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_state_ptr) = (yy_state_buf);</code><br />
            </span>
            
            <span class="none">
            <code>| 	*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_current_state = (int) yy_def[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| 			if ( yy_current_state >= 13 )</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_c = yy_meta[(unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yy_try_NUL_trans - try to make a transition on the NUL character</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * synopsis</code><br />
            </span>
            
            <span class="none">
            <code>|  *	next_state = yy_try_NUL_trans( current_state );</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int yy_is_jam;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	register YY_CHAR yy_c = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_current_state = (int) yy_def[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( yy_current_state >= 13 )</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_c = yy_meta[(unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_is_jam = (yy_current_state == 12);</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! yy_is_jam )</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		return yy_is_jam ? 0 : yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     static void yyunput (int c, register char * yy_bp )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register char *yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* undo effects of setting up yytext */</code><br />
            </span>
            
            <span class="none">
            <code>| 	*yy_cp = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ /* need to shift things up to make room */</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* +2 for EOB chars. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		register yy_size_t number_to_move = (yy_n_chars) + 2;</code><br />
            </span>
            
            <span class="none">
            <code>| 		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[</code><br />
            </span>
            
            <span class="none">
            <code>| 					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];</code><br />
            </span>
            
            <span class="none">
            <code>| 		register char *source =</code><br />
            </span>
            
            <span class="none">
            <code>| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )</code><br />
            </span>
            
            <span class="none">
            <code>| 			*--dest = *--source;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_cp += (int) (dest - source);</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_bp += (int) (dest - source);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "flex scanner push-back overflow" );</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	*--yy_cp = (char) c;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) = yy_bp;</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_hold_char) = *yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_c_buf_p) = yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_NO_INPUT</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>|     static int yyinput (void)</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>|     static int input  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	int c;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	*(yy_c_buf_p) = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* yy_c_buf_p now points to the character we want to return.</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * If this occurs *before* the EOB characters, then it's a</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * valid NUL; if not, then we've hit the end of the buffer.</code><br />
            </span>
            
            <span class="none">
            <code>| 		 */</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* This was really a NUL. */</code><br />
            </span>
            
            <span class="none">
            <code>| 			*(yy_c_buf_p) = '\0';</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		else</code><br />
            </span>
            
            <span class="none">
            <code>| 			{ /* need more input */</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_size_t offset = (yy_c_buf_p) - (yytext_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 			++(yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			switch ( yy_get_next_buffer(  ) )</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				case EOB_ACT_LAST_MATCH:</code><br />
            </span>
            
            <span class="none">
            <code>| 					/* This happens because yy_g_n_b()</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * sees that we've accumulated a</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * token and flags that we need to</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * try matching the token before</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * proceeding.  But for input(),</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * there's no matching to consider.</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * So convert the EOB_ACT_LAST_MATCH</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * to EOB_ACT_END_OF_FILE.</code><br />
            </span>
            
            <span class="none">
            <code>| 					 */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 					/* Reset buffer status. */</code><br />
            </span>
            
            <span class="none">
            <code>| 					yyrestart(yyin );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 					/*FALLTHROUGH*/</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				case EOB_ACT_END_OF_FILE:</code><br />
            </span>
            
            <span class="none">
            <code>| 					{</code><br />
            </span>
            
            <span class="none">
            <code>| 					if ( yywrap( ) )</code><br />
            </span>
            
            <span class="none">
            <code>| 						return EOF;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 					if ( ! (yy_did_buffer_switch_on_eof) )</code><br />
            </span>
            
            <span class="none">
            <code>| 						YY_NEW_FILE;</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>| 					return yyinput();</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| 					return input();</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| 					}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				case EOB_ACT_CONTINUE_SCAN:</code><br />
            </span>
            
            <span class="none">
            <code>| 					(yy_c_buf_p) = (yytext_ptr) + offset;</code><br />
            </span>
            
            <span class="none">
            <code>| 					break;</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */</code><br />
            </span>
            
            <span class="none">
            <code>| 	*(yy_c_buf_p) = '\0';	/* preserve yytext */</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_hold_char) = *++(yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return c;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>| #endif	/* ifndef YY_NO_INPUT */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Immediately switch to a different input stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param input_file A readable stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @note This function does not reset the start condition to @c INITIAL .</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     void yyrestart  (FILE * input_file )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! YY_CURRENT_BUFFER ){</code><br />
            </span>
            
            <span class="none">
            <code>|         yyensure_buffer_stack ();</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE =</code><br />
            </span>
            
            <span class="none">
            <code>|             yy_create_buffer(yyin,YY_BUF_SIZE );</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_init_buffer(YY_CURRENT_BUFFER,input_file );</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Switch to a different input buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param new_buffer The new input buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* TODO. We should be able to replace this entire function body</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * with</code><br />
            </span>
            
            <span class="none">
            <code>| 	 *		yypop_buffer_state();</code><br />
            </span>
            
            <span class="none">
            <code>| 	 *		yypush_buffer_state(new_buffer);</code><br />
            </span>
            
            <span class="none">
            <code>|      */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyensure_buffer_stack ();</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER == new_buffer )</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Flush out information for old buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_c_buf_p) = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* We don't actually know whether we did this switch during</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * EOF (yywrap()) processing, but the only time this flag</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * is looked at is after yywrap() is called, so it's safe</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * to go ahead and always set it.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_did_buffer_switch_on_eof) = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_load_buffer_state  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_hold_char) = *(yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Allocate and initialize an input buffer state.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param file A readable stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @return the allocated buffer state.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BUFFER_STATE b;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buf_size = size;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* yy_ch_buf has to be 2 characters longer than the size given because</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * we need to put in 2 end-of-buffer characters.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b->yy_ch_buf )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_is_our_buffer = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_init_buffer(b,file );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return b;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Destroy the buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param b a buffer created with yy_create_buffer()</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     void yy_delete_buffer (YY_BUFFER_STATE  b )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( b->yy_is_our_buffer )</code><br />
            </span>
            
            <span class="none">
            <code>| 		yyfree((void *) b->yy_ch_buf  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyfree((void *) b  );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Initializes or reinitializes a buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * This function is sometimes called more than once on the same buffer,</code><br />
            </span>
            
            <span class="none">
            <code>|  * such as during a yyrestart() or at EOF.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	int oerrno = errno;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_flush_buffer(b );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_input_file = file;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_fill_buffer = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     /* If b is the current buffer, then yy_init_buffer was _probably_</code><br />
            </span>
            
            <span class="none">
            <code>|      * called from yyrestart() or through yy_get_next_buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|      * In that case, we don't want to reset the lineno or column.</code><br />
            </span>
            
            <span class="none">
            <code>|      */</code><br />
            </span>
            
            <span class="none">
            <code>|     if (b != YY_CURRENT_BUFFER){</code><br />
            </span>
            
            <span class="none">
            <code>|         b->yy_bs_lineno = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|         b->yy_bs_column = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|         b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	errno = oerrno;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Discard all buffered characters. On the next scan, YY_INPUT will be called.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     void yy_flush_buffer (YY_BUFFER_STATE  b )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_n_chars = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* We always need two end-of-buffer characters.  The first causes</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * a transition to the end-of-buffer state.  The second causes</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * a jam in that state.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buf_pos = &b->yy_ch_buf[0];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_at_bol = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buffer_status = YY_BUFFER_NEW;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( b == YY_CURRENT_BUFFER )</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Pushes the new state onto the stack. The new state becomes</code><br />
            </span>
            
            <span class="none">
            <code>|  *  the current state. This function will allocate the stack</code><br />
            </span>
            
            <span class="none">
            <code>|  *  if necessary.</code><br />
            </span>
            
            <span class="none">
            <code>|  *  @param new_buffer The new state.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| void yypush_buffer_state (YY_BUFFER_STATE new_buffer )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	if (new_buffer == NULL)</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyensure_buffer_stack();</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* This block is copied from yy_switch_to_buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Flush out information for old buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_c_buf_p) = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Only push if top exists. Otherwise, replace top. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	if (YY_CURRENT_BUFFER)</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack_top)++;</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* copied from yy_switch_to_buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_did_buffer_switch_on_eof) = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Removes and deletes the top of the stack, if present.</code><br />
            </span>
            
            <span class="none">
            <code>|  *  The next element becomes the new top.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| void yypop_buffer_state (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	if (!YY_CURRENT_BUFFER)</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_delete_buffer(YY_CURRENT_BUFFER );</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE = NULL;</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ((yy_buffer_stack_top) > 0)</code><br />
            </span>
            
            <span class="none">
            <code>| 		--(yy_buffer_stack_top);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if (YY_CURRENT_BUFFER) {</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_did_buffer_switch_on_eof) = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Allocates the stack if it does not exist.</code><br />
            </span>
            
            <span class="none">
            <code>|  *  Guarantees space for at least one push.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| static void yyensure_buffer_stack (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t num_to_alloc;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if (!(yy_buffer_stack)) {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* First allocation is just for 2 elements, since we don't know if this</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * scanner will even need a stack. We use 2 instead of 1 to avoid an</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * immediate realloc on the next call.</code><br />
            </span>
            
            <span class="none">
            <code>|          */</code><br />
            </span>
            
            <span class="none">
            <code>| 		num_to_alloc = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc</code><br />
            </span>
            
            <span class="none">
            <code>| 								(num_to_alloc * sizeof(struct yy_buffer_state*)</code><br />
            </span>
            
            <span class="none">
            <code>| 								);</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! (yy_buffer_stack) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack_max) = num_to_alloc;</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack_top) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Increase the buffer to prepare for a possible push. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		int grow_size = 8 /* arbitrary grow size */;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		num_to_alloc = (yy_buffer_stack_max) + grow_size;</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc</code><br />
            </span>
            
            <span class="none">
            <code>| 								((yy_buffer_stack),</code><br />
            </span>
            
            <span class="none">
            <code>| 								num_to_alloc * sizeof(struct yy_buffer_state*)</code><br />
            </span>
            
            <span class="none">
            <code>| 								);</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! (yy_buffer_stack) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* zero only the new slots.*/</code><br />
            </span>
            
            <span class="none">
            <code>| 		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack_max) = num_to_alloc;</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Setup the input buffer state to scan directly from a user-specified character buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param base the character buffer</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param size the size in bytes of the character buffer</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @return the newly allocated buffer state object.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BUFFER_STATE b;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( size < 2 ||</code><br />
            </span>
            
            <span class="none">
            <code>| 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||</code><br />
            </span>
            
            <span class="none">
            <code>| 	     base[size-1] != YY_END_OF_BUFFER_CHAR )</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* They forgot to leave room for the EOB's. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		return 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buf_pos = b->yy_ch_buf = base;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_is_our_buffer = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_input_file = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_n_chars = b->yy_buf_size;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_is_interactive = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_at_bol = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_fill_buffer = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buffer_status = YY_BUFFER_NEW;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_switch_to_buffer(b  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return b;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Setup the input buffer state to scan a string. The next call to yylex() will</code><br />
            </span>
            
            <span class="none">
            <code>|  * scan from a @e copy of @a str.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param yystr a NUL-terminated string to scan</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @return the newly allocated buffer state object.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @note If you want to scan bytes that may contain NUL values, then use</code><br />
            </span>
            
            <span class="none">
            <code>|  *       yy_scan_bytes() instead.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return yy_scan_bytes(yystr,strlen(yystr) );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Setup the input buffer state to scan the given bytes. The next call to yylex() will</code><br />
            </span>
            
            <span class="none">
            <code>|  * scan from a @e copy of @a bytes.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param yybytes the byte buffer to scan</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @return the newly allocated buffer state object.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BUFFER_STATE b;</code><br />
            </span>
            
            <span class="none">
            <code>| 	char *buf;</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t n;</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t i;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Get memory for full buffer, including space for trailing EOB's. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	n = _yybytes_len + 2;</code><br />
            </span>
            
            <span class="none">
            <code>| 	buf = (char *) yyalloc(n  );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! buf )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( i = 0; i < _yybytes_len; ++i )</code><br />
            </span>
            
            <span class="none">
            <code>| 		buf[i] = yybytes[i];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b = yy_scan_buffer(buf,n );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* It's okay to grow etc. this buffer, and we should throw it</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * away when we're done.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_is_our_buffer = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return b;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_EXIT_FAILURE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_EXIT_FAILURE 2</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_fatal_error (yyconst char* msg )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	(void) fprintf( stderr, "%s\n", msg );</code><br />
            </span>
            
            <span class="none">
            <code>| 	exit( YY_EXIT_FAILURE );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Redefine yyless() so it works in section 3 code. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #undef yyless</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyless(n) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	do \</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Undo effects of setting up yytext. */ \</code><br />
            </span>
            
            <span class="none">
            <code>|         int yyless_macro_arg = (n); \</code><br />
            </span>
            
            <span class="none">
            <code>|         YY_LESS_LINENO(yyless_macro_arg);\</code><br />
            </span>
            
            <span class="none">
            <code>| 		yytext[yyleng] = (yy_hold_char); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_c_buf_p) = yytext + yyless_macro_arg; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_hold_char) = *(yy_c_buf_p); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_c_buf_p) = '\0'; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		yyleng = yyless_macro_arg; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	while ( 0 )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Accessor  methods (get/set functions) to struct members. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the current line number.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| int yyget_lineno  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     return yylineno;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the input stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyget_in  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yyin;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the output stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyget_out  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yyout;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the length of the current token.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| yy_size_t yyget_leng  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yyleng;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the current token.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| char *yyget_text  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yytext;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Set the current line number.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param line_number</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_lineno (int  line_number )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     yylineno = line_number;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Set the input stream. This does not discard the current</code><br />
            </span>
            
            <span class="none">
            <code>|  * input buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param in_str A readable stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @see yy_switch_to_buffer</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_in (FILE *  in_str )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         yyin = in_str ;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_out (FILE *  out_str )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         yyout = out_str ;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yyget_debug  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yy_flex_debug;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_debug (int  bdebug )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         yy_flex_debug = bdebug ;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_init_globals (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         /* Initialization is the same as for the non-reentrant scanner.</code><br />
            </span>
            
            <span class="none">
            <code>|      * This function is called from yylex_destroy(), so don't allocate here.</code><br />
            </span>
            
            <span class="none">
            <code>|      */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_buffer_stack) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_buffer_stack_top) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_buffer_stack_max) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_c_buf_p) = (char *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_init) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_start) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_state_buf) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_state_ptr) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_full_match) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_lp) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Defined in main.c */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_STDINIT</code><br />
            </span>
            
            <span class="none">
            <code>|     yyin = stdin;</code><br />
            </span>
            
            <span class="none">
            <code>|     yyout = stdout;</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>|     yyin = (FILE *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     yyout = (FILE *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     /* For future reference: Set errno on error, since we are called by</code><br />
            </span>
            
            <span class="none">
            <code>|      * yylex_init()</code><br />
            </span>
            
            <span class="none">
            <code>|      */</code><br />
            </span>
            
            <span class="none">
            <code>|     return 0;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yylex_destroy is for both reentrant and non-reentrant scanners. */</code><br />
            </span>
            
            <span class="none">
            <code>| int yylex_destroy  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     /* Pop the buffer stack, destroying each element. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	while(YY_CURRENT_BUFFER){</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_delete_buffer(YY_CURRENT_BUFFER  );</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE = NULL;</code><br />
            </span>
            
            <span class="none">
            <code>| 		yypop_buffer_state();</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Destroy the stack itself. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyfree((yy_buffer_stack) );</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_buffer_stack) = NULL;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     yyfree ( (yy_state_buf) );</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_state_buf)  = NULL;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     /* Reset the globals. This is important in a non-reentrant scanner so the next time</code><br />
            </span>
            
            <span class="none">
            <code>|      * yylex() is called, initialization will occur. */</code><br />
            </span>
            
            <span class="none">
            <code>|     yy_init_globals( );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     return 0;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /*</code><br />
            </span>
            
            <span class="none">
            <code>|  * Internal utility routines.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef yytext_ptr</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int i;</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( i = 0; i < n; ++i )</code><br />
            </span>
            
            <span class="none">
            <code>| 		s1[i] = s2[i];</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_NEED_STRLEN</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_flex_strlen (yyconst char * s )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int n;</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( n = 0; s[n]; ++n )</code><br />
            </span>
            
            <span class="none">
            <code>| 		;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return n;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void *yyalloc (yy_size_t  size )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	return (void *) malloc( size );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void *yyrealloc  (void * ptr, yy_size_t  size )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* The cast to (char *) in the following accommodates both</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * implementations that use char* generic pointers, and those</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * that use void* generic pointers.  It works with the latter</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * because both ANSI C and C++ allow castless assignment from</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * any pointer type to void*, and deal with argument conversions</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * as though doing an assignment.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	return (void *) realloc( (char *) ptr, size );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyfree (void * ptr )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YYTABLES_NAME "yytables"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #line 9 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YYTEXT_POINTER</code><br />
            </span>
            
            <span class="none">
            <code>| extern char *yytext;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| int</code><br />
            </span>
            
            <span class="none">
            <code>| main (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|   return ! yylex () + ! yywrap ();</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>configure:19555: result: none needed</code><br />
            </span>
            
            <span class="none">
            <code>configure:19561: checking whether yytext is a pointer</code><br />
            </span>
            
            <span class="none">
            <code>configure:19582: arm-linux-androideabi-gcc -o conftest    conftest.c   >&5</code><br />
            </span>
            
            <span class="none">
            <code>/tmp/cc0GSgqG.o:conftest.c:function yylex: error: undefined reference to 'yywrap'</code><br />
            </span>
            
            <span class="none">
            <code>/tmp/cc0GSgqG.o:conftest.c:function input: error: undefined reference to 'yywrap'</code><br />
            </span>
            
            <span class="none">
            <code>/tmp/cc0GSgqG.o:conftest.c:function main: error: undefined reference to 'yywrap'</code><br />
            </span>
            
            <span class="none">
            <code>collect2: error: ld returned 1 exit status</code><br />
            </span>
            
            <span class="none">
            <code>configure:19588: $? = 1</code><br />
            </span>
            
            <span class="none">
            <code>configure: failed program was:</code><br />
            </span>
            
            <span class="none">
            <code>| #define YYTEXT_POINTER 1</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #line 3 "lex.yy.c"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define  YY_INT_ALIGNED short int</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* A lexical scanner generated by flex */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define FLEX_SCANNER</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FLEX_MAJOR_VERSION 2</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FLEX_MINOR_VERSION 5</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FLEX_SUBMINOR_VERSION 39</code><br />
            </span>
            
            <span class="none">
            <code>| #if YY_FLEX_SUBMINOR_VERSION > 0</code><br />
            </span>
            
            <span class="none">
            <code>| #define FLEX_BETA</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* First, we deal with  platform-specific or compiler-specific issues. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* begin standard C headers. */</code><br />
            </span>
            
            <span class="none">
            <code>| #include <stdio.h></code><br />
            </span>
            
            <span class="none">
            <code>| #include <string.h></code><br />
            </span>
            
            <span class="none">
            <code>| #include <errno.h></code><br />
            </span>
            
            <span class="none">
            <code>| #include <stdlib.h></code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* end standard C headers. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* flex integer type definitions */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef FLEXINT_H</code><br />
            </span>
            
            <span class="none">
            <code>| #define FLEXINT_H</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,</code><br />
            </span>
            
            <span class="none">
            <code>|  * if you want the limit (max/min) macros for int types.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef __STDC_LIMIT_MACROS</code><br />
            </span>
            
            <span class="none">
            <code>| #define __STDC_LIMIT_MACROS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #include <inttypes.h></code><br />
            </span>
            
            <span class="none">
            <code>| typedef int8_t flex_int8_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef uint8_t flex_uint8_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef int16_t flex_int16_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef uint16_t flex_uint16_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef int32_t flex_int32_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef uint32_t flex_uint32_t;</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| typedef signed char flex_int8_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef short int flex_int16_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef int flex_int32_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef unsigned char flex_uint8_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef unsigned short int flex_uint16_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef unsigned int flex_uint32_t;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Limits of integral types. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT8_MIN</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT8_MIN               (-128)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT16_MIN</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT16_MIN              (-32767-1)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT32_MIN</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT32_MIN              (-2147483647-1)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT8_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT8_MAX               (127)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT16_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT16_MAX              (32767)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT32_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT32_MAX              (2147483647)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef UINT8_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define UINT8_MAX              (255U)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef UINT16_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define UINT16_MAX             (65535U)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef UINT32_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define UINT32_MAX             (4294967295U)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif /* ! C99 */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif /* ! FLEXINT_H */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* The "const" storage-class-modifier is valid. */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_USE_CONST</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #else	/* ! __cplusplus */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* C99 requires __STDC__ to be defined as 1. */</code><br />
            </span>
            
            <span class="none">
            <code>| #if defined (__STDC__)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_USE_CONST</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif	/* defined (__STDC__) */</code><br />
            </span>
            
            <span class="none">
            <code>| #endif	/* ! __cplusplus */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_USE_CONST</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyconst const</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyconst</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Returned upon end-of-file. */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_NULL 0</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Promotes a possibly negative, possibly signed char to an unsigned</code><br />
            </span>
            
            <span class="none">
            <code>|  * integer for use as an array index.  If the signed char is negative,</code><br />
            </span>
            
            <span class="none">
            <code>|  * we want to instead treat it as an 8-bit unsigned char, hence the</code><br />
            </span>
            
            <span class="none">
            <code>|  * double cast.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Enter a start condition.  This macro really ought to take a parameter,</code><br />
            </span>
            
            <span class="none">
            <code>|  * but we do it the disgusting crufty way forced on us by the ()-less</code><br />
            </span>
            
            <span class="none">
            <code>|  * definition of BEGIN.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define BEGIN (yy_start) = 1 + 2 *</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Translate the current start state into a value that can be later handed</code><br />
            </span>
            
            <span class="none">
            <code>|  * to BEGIN to return to the state.  The YYSTATE alias is for lex</code><br />
            </span>
            
            <span class="none">
            <code>|  * compatibility.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_START (((yy_start) - 1) / 2)</code><br />
            </span>
            
            <span class="none">
            <code>| #define YYSTATE YY_START</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Action number for EOF rule of a given start state. */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Special action meaning "start processing a new file". */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_NEW_FILE yyrestart(yyin  )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_END_OF_BUFFER_CHAR 0</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Size of default input buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_BUF_SIZE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BUF_SIZE 16384</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* The state buf must be large enough to hold one state per character in the main buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_TYPEDEF_YY_BUFFER_STATE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_TYPEDEF_YY_BUFFER_STATE</code><br />
            </span>
            
            <span class="none">
            <code>| typedef struct yy_buffer_state *YY_BUFFER_STATE;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_TYPEDEF_YY_SIZE_T</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_TYPEDEF_YY_SIZE_T</code><br />
            </span>
            
            <span class="none">
            <code>| typedef size_t yy_size_t;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern yy_size_t yyleng;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern FILE *yyin, *yyout;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define EOB_ACT_CONTINUE_SCAN 0</code><br />
            </span>
            
            <span class="none">
            <code>| #define EOB_ACT_END_OF_FILE 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define EOB_ACT_LAST_MATCH 2</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     #define YY_LESS_LINENO(n)</code><br />
            </span>
            
            <span class="none">
            <code>|     #define YY_LINENO_REWIND_TO(ptr)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Return all but the first "n" matched characters back to the input stream. */</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyless(n) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	do \</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Undo effects of setting up yytext. */ \</code><br />
            </span>
            
            <span class="none">
            <code>|         int yyless_macro_arg = (n); \</code><br />
            </span>
            
            <span class="none">
            <code>|         YY_LESS_LINENO(yyless_macro_arg);\</code><br />
            </span>
            
            <span class="none">
            <code>| 		*yy_cp = (yy_hold_char); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_RESTORE_YY_MORE_OFFSET \</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	while ( 0 )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define unput(c) yyunput( c, (yytext_ptr)  )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_STRUCT_YY_BUFFER_STATE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_STRUCT_YY_BUFFER_STATE</code><br />
            </span>
            
            <span class="none">
            <code>| struct yy_buffer_state</code><br />
            </span>
            
            <span class="none">
            <code>| 	{</code><br />
            </span>
            
            <span class="none">
            <code>| 	FILE *yy_input_file;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	char *yy_ch_buf;		/* input buffer */</code><br />
            </span>
            
            <span class="none">
            <code>| 	char *yy_buf_pos;		/* current position in input buffer */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Size of input buffer in bytes, not including room for EOB</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * characters.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t yy_buf_size;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Number of characters read into yy_ch_buf, not including EOB</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * characters.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t yy_n_chars;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Whether we "own" the buffer - i.e., we know we created it,</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * and can realloc() it to grow it, and should free() it to</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * delete it.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_is_our_buffer;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Whether this is an "interactive" input source; if so, and</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * if we're using stdio for input, then we want to use getc()</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * instead of fread(), to make sure we stop fetching input after</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * each newline.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_is_interactive;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Whether we're considered to be at the beginning of a line.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * If so, '^' rules will be active on the next match, otherwise</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * not.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_at_bol;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     int yy_bs_lineno; /**< The line count. */</code><br />
            </span>
            
            <span class="none">
            <code>|     int yy_bs_column; /**< The column count. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Whether to try to fill the input buffer when we reach the</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * end of it.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_fill_buffer;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_buffer_status;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BUFFER_NEW 0</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BUFFER_NORMAL 1</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* When an EOF's been seen but there's still some text to process</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * shouldn't try reading from the input source any more.  We might</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * still have a bunch of tokens to match, though, because of</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * possible backing-up.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 *</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * When we actually see the EOF, we change the status to "new"</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * (via yyrestart()), so that the user can continue scanning by</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * just pointing yyin at a new input file.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BUFFER_EOF_PENDING 2</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	};</code><br />
            </span>
            
            <span class="none">
            <code>| #endif /* !YY_STRUCT_YY_BUFFER_STATE */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Stack of input buffers. */</code><br />
            </span>
            
            <span class="none">
            <code>| static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */</code><br />
            </span>
            
            <span class="none">
            <code>| static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */</code><br />
            </span>
            
            <span class="none">
            <code>| static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* We provide macros for accessing buffer states in case in the</code><br />
            </span>
            
            <span class="none">
            <code>|  * future we want to put the buffer states in a more general</code><br />
            </span>
            
            <span class="none">
            <code>|  * "scanner state".</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * Returns the top of the stack, or NULL.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_CURRENT_BUFFER ( (yy_buffer_stack) \</code><br />
            </span>
            
            <span class="none">
            <code>|                           ? (yy_buffer_stack)[(yy_buffer_stack_top)] \</code><br />
            </span>
            
            <span class="none">
            <code>|                           : NULL)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Same as previous macro, but useful when we know that the buffer stack is not</code><br />
            </span>
            
            <span class="none">
            <code>|  * NULL or when we need an lvalue. For internal use only.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yy_hold_char holds the character lost when yytext is formed. */</code><br />
            </span>
            
            <span class="none">
            <code>| static char yy_hold_char;</code><br />
            </span>
            
            <span class="none">
            <code>| static yy_size_t yy_n_chars;		/* number of characters read into yy_ch_buf */</code><br />
            </span>
            
            <span class="none">
            <code>| yy_size_t yyleng;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Points to current character in buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| static char *yy_c_buf_p = (char *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_init = 0;		/* whether we need to initialize */</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_start = 0;	/* start state number */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Flag which is used to allow yywrap()'s to do buffer switches</code><br />
            </span>
            
            <span class="none">
            <code>|  * instead of setting up a fresh yyin.  A bit of a hack ...</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_did_buffer_switch_on_eof;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyrestart (FILE *input_file  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yy_delete_buffer (YY_BUFFER_STATE b  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yy_flush_buffer (YY_BUFFER_STATE b  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yypop_buffer_state (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static void yyensure_buffer_stack (void );</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_load_buffer_state (void );</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,yy_size_t len  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void *yyalloc (yy_size_t  );</code><br />
            </span>
            
            <span class="none">
            <code>| void *yyrealloc (void *,yy_size_t  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yyfree (void *  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define yy_new_buffer yy_create_buffer</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define yy_set_interactive(is_interactive) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! YY_CURRENT_BUFFER ){ \</code><br />
            </span>
            
            <span class="none">
            <code>|         yyensure_buffer_stack (); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE =    \</code><br />
            </span>
            
            <span class="none">
            <code>|             yy_create_buffer(yyin,YY_BUF_SIZE ); \</code><br />
            </span>
            
            <span class="none">
            <code>| 	} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define yy_set_bol(at_bol) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! YY_CURRENT_BUFFER ){\</code><br />
            </span>
            
            <span class="none">
            <code>|         yyensure_buffer_stack (); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE =    \</code><br />
            </span>
            
            <span class="none">
            <code>|             yy_create_buffer(yyin,YY_BUF_SIZE ); \</code><br />
            </span>
            
            <span class="none">
            <code>| 	} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Begin user sect3 */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| typedef unsigned char YY_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| typedef int yy_state_type;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern int yylineno;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yylineno = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern char *yytext;</code><br />
            </span>
            
            <span class="none">
            <code>| #define yytext_ptr yytext</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yy_state_type yy_get_previous_state (void );</code><br />
            </span>
            
            <span class="none">
            <code>| static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_get_next_buffer (void );</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_fatal_error (yyconst char msg[]  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Done after the current pattern has been matched and before the</code><br />
            </span>
            
            <span class="none">
            <code>|  * corresponding action - sets up yytext.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_DO_BEFORE_ACTION \</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) = yy_bp; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) -= (yy_more_len); \</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyleng = (size_t) (yy_cp - (yytext_ptr)); \</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_hold_char) = *yy_cp; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	*yy_cp = '\0'; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_c_buf_p) = yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_NUM_RULES 8</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_END_OF_BUFFER 9</code><br />
            </span>
            
            <span class="none">
            <code>| /* This struct is not used in this scanner,</code><br />
            </span>
            
            <span class="none">
            <code>|    but its presence is necessary. */</code><br />
            </span>
            
            <span class="none">
            <code>| struct yy_trans_info</code><br />
            </span>
            
            <span class="none">
            <code>| 	{</code><br />
            </span>
            
            <span class="none">
            <code>| 	flex_int32_t yy_verify;</code><br />
            </span>
            
            <span class="none">
            <code>| 	flex_int32_t yy_nxt;</code><br />
            </span>
            
            <span class="none">
            <code>| 	};</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_acclist[23] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         9,    7,    8,    8,    1,    7,    8,    2,    7,    8,</code><br />
            </span>
            
            <span class="none">
            <code>|         3,    7,    8,    4,    7,    8,    5,    7,    8,    6,</code><br />
            </span>
            
            <span class="none">
            <code>|         7,    8</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_accept[14] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    2,    4,    5,    8,   11,   14,   17,</code><br />
            </span>
            
            <span class="none">
            <code>|        20,   23,   23</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int32_t yy_ec[256] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    2,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    3,    4,    5,    6,</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|         7,    8,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int32_t yy_meta[9] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_base[13] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         0,    0,    9,   10,   10,   10,   10,   10,   10,   10,</code><br />
            </span>
            
            <span class="none">
            <code>|        10,   10</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_def[13] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|        12,    1,   12,   12,   12,   12,   12,   12,   12,   12,</code><br />
            </span>
            
            <span class="none">
            <code>|        12,    0</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_nxt[19] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         4,    5,    6,    7,    8,    9,   10,   11,   12,    3,</code><br />
            </span>
            
            <span class="none">
            <code>|        12,   12,   12,   12,   12,   12,   12,   12</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_chk[19] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    3,   12,</code><br />
            </span>
            
            <span class="none">
            <code>|        12,   12,   12,   12,   12,   12,   12,   12</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern int yy_flex_debug;</code><br />
            </span>
            
            <span class="none">
            <code>| int yy_flex_debug = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yy_state_type *yy_state_buf=0, *yy_state_ptr=0;</code><br />
            </span>
            
            <span class="none">
            <code>| static char *yy_full_match;</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_lp;</code><br />
            </span>
            
            <span class="none">
            <code>| #define REJECT \</code><br />
            </span>
            
            <span class="none">
            <code>| { \</code><br />
            </span>
            
            <span class="none">
            <code>| *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */ \</code><br />
            </span>
            
            <span class="none">
            <code>| yy_cp = (yy_full_match); /* restore poss. backed-over text */ \</code><br />
            </span>
            
            <span class="none">
            <code>| ++(yy_lp); \</code><br />
            </span>
            
            <span class="none">
            <code>| goto find_rule; \</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_more_flag = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_more_len = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| #define yymore() ((yy_more_flag) = 1)</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_MORE_ADJ (yy_more_len)</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_RESTORE_YY_MORE_OFFSET</code><br />
            </span>
            
            <span class="none">
            <code>| char *yytext;</code><br />
            </span>
            
            <span class="none">
            <code>| #line 1 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| #line 470 "lex.yy.c"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define INITIAL 0</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_NO_UNISTD_H</code><br />
            </span>
            
            <span class="none">
            <code>| /* Special case for "unistd.h", since it is non-ANSI. We include it way</code><br />
            </span>
            
            <span class="none">
            <code>|  * down here because we want the user's section 1 to have been scanned first.</code><br />
            </span>
            
            <span class="none">
            <code>|  * The user has a chance to override it with an option.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #include <unistd.h></code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_EXTRA_TYPE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_EXTRA_TYPE void *</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_init_globals (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Accessor methods to globals.</code><br />
            </span>
            
            <span class="none">
            <code>|    These are made visible to non-reentrant scanners for convenience. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yylex_destroy (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yyget_debug (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_debug (int debug_flag  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| YY_EXTRA_TYPE yyget_extra (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_extra (YY_EXTRA_TYPE user_defined  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyget_in (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_in  (FILE * in_str  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyget_out (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_out  (FILE * out_str  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| yy_size_t yyget_leng (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| char *yyget_text (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yyget_lineno (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_lineno (int line_number  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Macros after this point can all be overridden by user definitions in</code><br />
            </span>
            
            <span class="none">
            <code>|  * section 1.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_SKIP_YYWRAP</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>| extern "C" int yywrap (void );</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| extern int yywrap (void );</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     static void yyunput (int c,char *buf_ptr  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef yytext_ptr</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_flex_strncpy (char *,yyconst char *,int );</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_NEED_STRLEN</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_flex_strlen (yyconst char * );</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_NO_INPUT</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>| static int yyinput (void );</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| static int input (void );</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Amount of stuff to slurp up with each read. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_READ_BUF_SIZE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_READ_BUF_SIZE 8192</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Copy whatever the last rule matched to the standard output. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef ECHO</code><br />
            </span>
            
            <span class="none">
            <code>| /* This used to be an fputs(), but since the string might contain NUL's,</code><br />
            </span>
            
            <span class="none">
            <code>|  * we now use fwrite().</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,</code><br />
            </span>
            
            <span class="none">
            <code>|  * is returned in "result".</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_INPUT</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_INPUT(buf,result,max_size) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		int c = '*'; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		size_t n; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		for ( n = 0; n < max_size && \</code><br />
            </span>
            
            <span class="none">
            <code>| 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \</code><br />
            </span>
            
            <span class="none">
            <code>| 			buf[n] = (char) c; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( c == '\n' ) \</code><br />
            </span>
            
            <span class="none">
            <code>| 			buf[n++] = (char) c; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( c == EOF && ferror( yyin ) ) \</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "input in flex scanner failed" ); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		result = n; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	else \</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		errno=0; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \</code><br />
            </span>
            
            <span class="none">
            <code>| 			{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 			if( errno != EINTR) \</code><br />
            </span>
            
            <span class="none">
            <code>| 				{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 				YY_FATAL_ERROR( "input in flex scanner failed" ); \</code><br />
            </span>
            
            <span class="none">
            <code>| 				break; \</code><br />
            </span>
            
            <span class="none">
            <code>| 				} \</code><br />
            </span>
            
            <span class="none">
            <code>| 			errno=0; \</code><br />
            </span>
            
            <span class="none">
            <code>| 			clearerr(yyin); \</code><br />
            </span>
            
            <span class="none">
            <code>| 			} \</code><br />
            </span>
            
            <span class="none">
            <code>| 		}\</code><br />
            </span>
            
            <span class="none">
            <code>| \</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* No semi-colon after return; correct usage is to write "yyterminate();" -</code><br />
            </span>
            
            <span class="none">
            <code>|  * we don't want an extra ';' after the "return" because that will cause</code><br />
            </span>
            
            <span class="none">
            <code>|  * some compilers to complain about unreachable statements.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef yyterminate</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyterminate() return YY_NULL</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Number of entries by which start-condition stack grows. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_START_STACK_INCR</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_START_STACK_INCR 25</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Report a fatal error. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_FATAL_ERROR</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* end tables serialization structures and prototypes */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Default declaration of generated scanner - a define so the user can</code><br />
            </span>
            
            <span class="none">
            <code>|  * easily add parameters.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_DECL</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_DECL_IS_OURS 1</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern int yylex (void);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_DECL int yylex (void)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif /* !YY_DECL */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Code executed at the beginning of each rule, after yytext and yyleng</code><br />
            </span>
            
            <span class="none">
            <code>|  * have been set up.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_USER_ACTION</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_USER_ACTION</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Code executed at the end of each rule. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BREAK break;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_RULE_SETUP \</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_USER_ACTION</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** The main scanner function which does all the work.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| YY_DECL</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register yy_state_type yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 	register char *yy_cp, *yy_bp;</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int yy_act;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( !(yy_init) )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_init) = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_USER_INIT</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_USER_INIT;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|         /* Create the reject buffer large enough to save one state per allowed character. */</code><br />
            </span>
            
            <span class="none">
            <code>|         if ( ! (yy_state_buf) )</code><br />
            </span>
            
            <span class="none">
            <code>|             (yy_state_buf) = (yy_state_type *)yyalloc(YY_STATE_BUF_SIZE  );</code><br />
            </span>
            
            <span class="none">
            <code>|             if ( ! (yy_state_buf) )</code><br />
            </span>
            
            <span class="none">
            <code>|                 YY_FATAL_ERROR( "out of dynamic memory in yylex()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! (yy_start) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_start) = 1;	/* first start state */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! yyin )</code><br />
            </span>
            
            <span class="none">
            <code>| 			yyin = stdin;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! yyout )</code><br />
            </span>
            
            <span class="none">
            <code>| 			yyout = stdout;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! YY_CURRENT_BUFFER ) {</code><br />
            </span>
            
            <span class="none">
            <code>| 			yyensure_buffer_stack ();</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE =</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_create_buffer(yyin,YY_BUF_SIZE );</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	{</code><br />
            </span>
            
            <span class="none">
            <code>| #line 1 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #line 687 "lex.yy.c"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	while ( 1 )		/* loops until end-of-file is reached */</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_more_len) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( (yy_more_flag) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_more_len) = (yy_c_buf_p) - (yytext_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_more_flag) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Support of yytext. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		*yy_cp = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* yy_bp points to the position in yy_ch_buf of the start of</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * the current run.</code><br />
            </span>
            
            <span class="none">
            <code>| 		 */</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_bp = yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_current_state = (yy_start);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_state_ptr) = (yy_state_buf);</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| yy_match:</code><br />
            </span>
            
            <span class="none">
            <code>| 		do</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;</code><br />
            </span>
            
            <span class="none">
            <code>| 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_current_state = (int) yy_def[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| 				if ( yy_current_state >= 13 )</code><br />
            </span>
            
            <span class="none">
            <code>| 					yy_c = yy_meta[(unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 			*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 			++yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( yy_base[yy_current_state] != 10 );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| yy_find_action:</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_current_state = *--(yy_state_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_lp) = yy_accept[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| find_rule: /* we branch to this label when backing up */</code><br />
            </span>
            
            <span class="none">
            <code>| 		for ( ; ; ) /* until we find what rule we matched */</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			if ( (yy_lp) && (yy_lp) < yy_accept[yy_current_state + 1] )</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_act = yy_acclist[(yy_lp)];</code><br />
            </span>
            
            <span class="none">
            <code>| 					{</code><br />
            </span>
            
            <span class="none">
            <code>| 					(yy_full_match) = yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| 					break;</code><br />
            </span>
            
            <span class="none">
            <code>| 					}</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>| 			--yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_current_state = *--(yy_state_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_lp) = yy_accept[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_DO_BEFORE_ACTION;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| do_action:	/* This label is used only to access EOF actions. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		switch ( yy_act )</code><br />
            </span>
            
            <span class="none">
            <code>| 	{ /* beginning of action switch */</code><br />
            </span>
            
            <span class="none">
            <code>| case 1:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 2 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { ECHO; }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 2:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 3 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { REJECT; }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 3:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 4 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { yymore (); }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 4:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 5 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { yyless (1); }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 5:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 6 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { yyless (input () != 0); }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 6:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 7 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { unput (yytext[0]); }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 7:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 8 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { BEGIN INITIAL; }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 8:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 9 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| ECHO;</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| #line 793 "lex.yy.c"</code><br />
            </span>
            
            <span class="none">
            <code>| 			case YY_STATE_EOF(INITIAL):</code><br />
            </span>
            
            <span class="none">
            <code>| 				yyterminate();</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	case YY_END_OF_BUFFER:</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Amount of text matched not including the EOB char. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Undo the effects of YY_DO_BEFORE_ACTION. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		*yy_cp = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_RESTORE_YY_MORE_OFFSET</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* We're scanning a new file or input source.  It's</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * possible that this happened because the user</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * just pointed yyin at a new source and called</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * yylex().  If so, then we have to assure</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * consistency between YY_CURRENT_BUFFER and our</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * globals.  Here is the right place to do so, because</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * this is the first action (other than possibly a</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * back-up) that will match for the new input source.</code><br />
            </span>
            
            <span class="none">
            <code>| 			 */</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Note that here we test for yy_c_buf_p "<=" to the position</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * of the first EOB in the buffer, since yy_c_buf_p will</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * already have been incremented past the NUL character</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * (since all states make transitions on EOB to the</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * end-of-buffer state).  Contrast this with the test</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * in input().</code><br />
            </span>
            
            <span class="none">
            <code>| 		 */</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{ /* This was really a NUL. */</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_state_type yy_next_state;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_current_state = yy_get_previous_state(  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* Okay, we're now positioned to make the NUL</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * transition.  We couldn't have</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * yy_get_previous_state() go ahead and do it</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * for us because it doesn't know how to deal</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * with the possibility of jamming (and we don't</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * want to build jamming into it because then it</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * will run more slowly).</code><br />
            </span>
            
            <span class="none">
            <code>| 			 */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_next_state = yy_try_NUL_trans( yy_current_state );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_bp = (yytext_ptr) + YY_MORE_ADJ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			if ( yy_next_state )</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				/* Consume the NUL. */</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_cp = ++(yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_current_state = yy_next_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 				goto yy_match;</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			else</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 				goto yy_find_action;</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		else switch ( yy_get_next_buffer(  ) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			case EOB_ACT_END_OF_FILE:</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				(yy_did_buffer_switch_on_eof) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				if ( yywrap( ) )</code><br />
            </span>
            
            <span class="none">
            <code>| 					{</code><br />
            </span>
            
            <span class="none">
            <code>| 					/* Note: because we've taken care in</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * yy_get_next_buffer() to have set up</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * yytext, we can now set up</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * yy_c_buf_p so that if some total</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * hoser (like flex itself) wants to</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * call the scanner after we return the</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * YY_NULL, it'll still work - another</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * YY_NULL will get returned.</code><br />
            </span>
            
            <span class="none">
            <code>| 					 */</code><br />
            </span>
            
            <span class="none">
            <code>| 					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 					yy_act = YY_STATE_EOF(YY_START);</code><br />
            </span>
            
            <span class="none">
            <code>| 					goto do_action;</code><br />
            </span>
            
            <span class="none">
            <code>| 					}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				else</code><br />
            </span>
            
            <span class="none">
            <code>| 					{</code><br />
            </span>
            
            <span class="none">
            <code>| 					if ( ! (yy_did_buffer_switch_on_eof) )</code><br />
            </span>
            
            <span class="none">
            <code>| 						YY_NEW_FILE;</code><br />
            </span>
            
            <span class="none">
            <code>| 					}</code><br />
            </span>
            
            <span class="none">
            <code>| 				break;</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			case EOB_ACT_CONTINUE_SCAN:</code><br />
            </span>
            
            <span class="none">
            <code>| 				(yy_c_buf_p) =</code><br />
            </span>
            
            <span class="none">
            <code>| 					(yytext_ptr) + yy_amount_of_matched_text;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_current_state = yy_get_previous_state(  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;</code><br />
            </span>
            
            <span class="none">
            <code>| 				goto yy_match;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			case EOB_ACT_LAST_MATCH:</code><br />
            </span>
            
            <span class="none">
            <code>| 				(yy_c_buf_p) =</code><br />
            </span>
            
            <span class="none">
            <code>| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_current_state = yy_get_previous_state(  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;</code><br />
            </span>
            
            <span class="none">
            <code>| 				goto yy_find_action;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		break;</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	default:</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR(</code><br />
            </span>
            
            <span class="none">
            <code>| 			"fatal flex scanner internal error--no action found" );</code><br />
            </span>
            
            <span class="none">
            <code>| 	} /* end of action switch */</code><br />
            </span>
            
            <span class="none">
            <code>| 		} /* end of scanning one token */</code><br />
            </span>
            
            <span class="none">
            <code>| 	} /* end of user's declarations */</code><br />
            </span>
            
            <span class="none">
            <code>| } /* end of yylex */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yy_get_next_buffer - try to read in a new buffer</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * Returns a code representing an action:</code><br />
            </span>
            
            <span class="none">
            <code>|  *	EOB_ACT_LAST_MATCH -</code><br />
            </span>
            
            <span class="none">
            <code>|  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position</code><br />
            </span>
            
            <span class="none">
            <code>|  *	EOB_ACT_END_OF_FILE - end of file</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_get_next_buffer (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;</code><br />
            </span>
            
            <span class="none">
            <code>| 	register char *source = (yytext_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int number_to_move, i;</code><br />
            </span>
            
            <span class="none">
            <code>| 	int ret_val;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR(</code><br />
            </span>
            
            <span class="none">
            <code>| 		"fatal flex scanner internal error--end of buffer missed" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ /* Don't try to fill the buffer, so this is an EOF. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* We matched a single character, the EOB, so</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * treat this as a final EOF.</code><br />
            </span>
            
            <span class="none">
            <code>| 			 */</code><br />
            </span>
            
            <span class="none">
            <code>| 			return EOB_ACT_END_OF_FILE;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		else</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* We matched some text prior to the EOB, first</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * process it.</code><br />
            </span>
            
            <span class="none">
            <code>| 			 */</code><br />
            </span>
            
            <span class="none">
            <code>| 			return EOB_ACT_LAST_MATCH;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Try to read more data. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* First move last chars to start of buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( i = 0; i < number_to_move; ++i )</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(dest++) = *(source++);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* don't do the read, it's not guaranteed to return an EOF,</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * just force an EOF</code><br />
            </span>
            
            <span class="none">
            <code>| 		 */</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	else</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_size_t num_to_read =</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( num_to_read <= 0 )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{ /* Not enough room in the buffer - grow it. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR(</code><br />
            </span>
            
            <span class="none">
            <code>| "input buffer overflow, can't enlarge buffer because scanner uses REJECT" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( num_to_read > YY_READ_BUF_SIZE )</code><br />
            </span>
            
            <span class="none">
            <code>| 			num_to_read = YY_READ_BUF_SIZE;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Read in more data. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_n_chars), num_to_read );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( (yy_n_chars) == 0 )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( number_to_move == YY_MORE_ADJ )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			ret_val = EOB_ACT_END_OF_FILE;</code><br />
            </span>
            
            <span class="none">
            <code>| 			yyrestart(yyin  );</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		else</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			ret_val = EOB_ACT_LAST_MATCH;</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =</code><br />
            </span>
            
            <span class="none">
            <code>| 				YY_BUFFER_EOF_PENDING;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	else</code><br />
            </span>
            
            <span class="none">
            <code>| 		ret_val = EOB_ACT_CONTINUE_SCAN;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Extend the array by 50%, plus the number we really need. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_n_chars) += number_to_move;</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return ret_val;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yy_get_previous_state - get the state just before the EOB char was reached */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     static yy_state_type yy_get_previous_state (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register yy_state_type yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 	register char *yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_current_state = (yy_start);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_state_ptr) = (yy_state_buf);</code><br />
            </span>
            
            <span class="none">
            <code>| 	*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_current_state = (int) yy_def[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| 			if ( yy_current_state >= 13 )</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_c = yy_meta[(unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yy_try_NUL_trans - try to make a transition on the NUL character</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * synopsis</code><br />
            </span>
            
            <span class="none">
            <code>|  *	next_state = yy_try_NUL_trans( current_state );</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int yy_is_jam;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	register YY_CHAR yy_c = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_current_state = (int) yy_def[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( yy_current_state >= 13 )</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_c = yy_meta[(unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_is_jam = (yy_current_state == 12);</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! yy_is_jam )</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		return yy_is_jam ? 0 : yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     static void yyunput (int c, register char * yy_bp )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register char *yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* undo effects of setting up yytext */</code><br />
            </span>
            
            <span class="none">
            <code>| 	*yy_cp = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ /* need to shift things up to make room */</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* +2 for EOB chars. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		register yy_size_t number_to_move = (yy_n_chars) + 2;</code><br />
            </span>
            
            <span class="none">
            <code>| 		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[</code><br />
            </span>
            
            <span class="none">
            <code>| 					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];</code><br />
            </span>
            
            <span class="none">
            <code>| 		register char *source =</code><br />
            </span>
            
            <span class="none">
            <code>| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )</code><br />
            </span>
            
            <span class="none">
            <code>| 			*--dest = *--source;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_cp += (int) (dest - source);</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_bp += (int) (dest - source);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "flex scanner push-back overflow" );</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	*--yy_cp = (char) c;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) = yy_bp;</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_hold_char) = *yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_c_buf_p) = yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_NO_INPUT</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>|     static int yyinput (void)</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>|     static int input  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	int c;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	*(yy_c_buf_p) = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* yy_c_buf_p now points to the character we want to return.</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * If this occurs *before* the EOB characters, then it's a</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * valid NUL; if not, then we've hit the end of the buffer.</code><br />
            </span>
            
            <span class="none">
            <code>| 		 */</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* This was really a NUL. */</code><br />
            </span>
            
            <span class="none">
            <code>| 			*(yy_c_buf_p) = '\0';</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		else</code><br />
            </span>
            
            <span class="none">
            <code>| 			{ /* need more input */</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_size_t offset = (yy_c_buf_p) - (yytext_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 			++(yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			switch ( yy_get_next_buffer(  ) )</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				case EOB_ACT_LAST_MATCH:</code><br />
            </span>
            
            <span class="none">
            <code>| 					/* This happens because yy_g_n_b()</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * sees that we've accumulated a</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * token and flags that we need to</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * try matching the token before</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * proceeding.  But for input(),</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * there's no matching to consider.</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * So convert the EOB_ACT_LAST_MATCH</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * to EOB_ACT_END_OF_FILE.</code><br />
            </span>
            
            <span class="none">
            <code>| 					 */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 					/* Reset buffer status. */</code><br />
            </span>
            
            <span class="none">
            <code>| 					yyrestart(yyin );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 					/*FALLTHROUGH*/</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				case EOB_ACT_END_OF_FILE:</code><br />
            </span>
            
            <span class="none">
            <code>| 					{</code><br />
            </span>
            
            <span class="none">
            <code>| 					if ( yywrap( ) )</code><br />
            </span>
            
            <span class="none">
            <code>| 						return EOF;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 					if ( ! (yy_did_buffer_switch_on_eof) )</code><br />
            </span>
            
            <span class="none">
            <code>| 						YY_NEW_FILE;</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>| 					return yyinput();</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| 					return input();</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| 					}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				case EOB_ACT_CONTINUE_SCAN:</code><br />
            </span>
            
            <span class="none">
            <code>| 					(yy_c_buf_p) = (yytext_ptr) + offset;</code><br />
            </span>
            
            <span class="none">
            <code>| 					break;</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */</code><br />
            </span>
            
            <span class="none">
            <code>| 	*(yy_c_buf_p) = '\0';	/* preserve yytext */</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_hold_char) = *++(yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return c;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>| #endif	/* ifndef YY_NO_INPUT */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Immediately switch to a different input stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param input_file A readable stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @note This function does not reset the start condition to @c INITIAL .</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     void yyrestart  (FILE * input_file )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! YY_CURRENT_BUFFER ){</code><br />
            </span>
            
            <span class="none">
            <code>|         yyensure_buffer_stack ();</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE =</code><br />
            </span>
            
            <span class="none">
            <code>|             yy_create_buffer(yyin,YY_BUF_SIZE );</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_init_buffer(YY_CURRENT_BUFFER,input_file );</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Switch to a different input buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param new_buffer The new input buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* TODO. We should be able to replace this entire function body</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * with</code><br />
            </span>
            
            <span class="none">
            <code>| 	 *		yypop_buffer_state();</code><br />
            </span>
            
            <span class="none">
            <code>| 	 *		yypush_buffer_state(new_buffer);</code><br />
            </span>
            
            <span class="none">
            <code>|      */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyensure_buffer_stack ();</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER == new_buffer )</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Flush out information for old buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_c_buf_p) = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* We don't actually know whether we did this switch during</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * EOF (yywrap()) processing, but the only time this flag</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * is looked at is after yywrap() is called, so it's safe</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * to go ahead and always set it.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_did_buffer_switch_on_eof) = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_load_buffer_state  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_hold_char) = *(yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Allocate and initialize an input buffer state.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param file A readable stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @return the allocated buffer state.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BUFFER_STATE b;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buf_size = size;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* yy_ch_buf has to be 2 characters longer than the size given because</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * we need to put in 2 end-of-buffer characters.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b->yy_ch_buf )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_is_our_buffer = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_init_buffer(b,file );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return b;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Destroy the buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param b a buffer created with yy_create_buffer()</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     void yy_delete_buffer (YY_BUFFER_STATE  b )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( b->yy_is_our_buffer )</code><br />
            </span>
            
            <span class="none">
            <code>| 		yyfree((void *) b->yy_ch_buf  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyfree((void *) b  );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Initializes or reinitializes a buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * This function is sometimes called more than once on the same buffer,</code><br />
            </span>
            
            <span class="none">
            <code>|  * such as during a yyrestart() or at EOF.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	int oerrno = errno;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_flush_buffer(b );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_input_file = file;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_fill_buffer = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     /* If b is the current buffer, then yy_init_buffer was _probably_</code><br />
            </span>
            
            <span class="none">
            <code>|      * called from yyrestart() or through yy_get_next_buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|      * In that case, we don't want to reset the lineno or column.</code><br />
            </span>
            
            <span class="none">
            <code>|      */</code><br />
            </span>
            
            <span class="none">
            <code>|     if (b != YY_CURRENT_BUFFER){</code><br />
            </span>
            
            <span class="none">
            <code>|         b->yy_bs_lineno = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|         b->yy_bs_column = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|         b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	errno = oerrno;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Discard all buffered characters. On the next scan, YY_INPUT will be called.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     void yy_flush_buffer (YY_BUFFER_STATE  b )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_n_chars = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* We always need two end-of-buffer characters.  The first causes</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * a transition to the end-of-buffer state.  The second causes</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * a jam in that state.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buf_pos = &b->yy_ch_buf[0];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_at_bol = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buffer_status = YY_BUFFER_NEW;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( b == YY_CURRENT_BUFFER )</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Pushes the new state onto the stack. The new state becomes</code><br />
            </span>
            
            <span class="none">
            <code>|  *  the current state. This function will allocate the stack</code><br />
            </span>
            
            <span class="none">
            <code>|  *  if necessary.</code><br />
            </span>
            
            <span class="none">
            <code>|  *  @param new_buffer The new state.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| void yypush_buffer_state (YY_BUFFER_STATE new_buffer )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	if (new_buffer == NULL)</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyensure_buffer_stack();</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* This block is copied from yy_switch_to_buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Flush out information for old buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_c_buf_p) = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Only push if top exists. Otherwise, replace top. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	if (YY_CURRENT_BUFFER)</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack_top)++;</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* copied from yy_switch_to_buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_did_buffer_switch_on_eof) = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Removes and deletes the top of the stack, if present.</code><br />
            </span>
            
            <span class="none">
            <code>|  *  The next element becomes the new top.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| void yypop_buffer_state (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	if (!YY_CURRENT_BUFFER)</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_delete_buffer(YY_CURRENT_BUFFER );</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE = NULL;</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ((yy_buffer_stack_top) > 0)</code><br />
            </span>
            
            <span class="none">
            <code>| 		--(yy_buffer_stack_top);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if (YY_CURRENT_BUFFER) {</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_did_buffer_switch_on_eof) = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Allocates the stack if it does not exist.</code><br />
            </span>
            
            <span class="none">
            <code>|  *  Guarantees space for at least one push.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| static void yyensure_buffer_stack (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t num_to_alloc;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if (!(yy_buffer_stack)) {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* First allocation is just for 2 elements, since we don't know if this</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * scanner will even need a stack. We use 2 instead of 1 to avoid an</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * immediate realloc on the next call.</code><br />
            </span>
            
            <span class="none">
            <code>|          */</code><br />
            </span>
            
            <span class="none">
            <code>| 		num_to_alloc = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc</code><br />
            </span>
            
            <span class="none">
            <code>| 								(num_to_alloc * sizeof(struct yy_buffer_state*)</code><br />
            </span>
            
            <span class="none">
            <code>| 								);</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! (yy_buffer_stack) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack_max) = num_to_alloc;</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack_top) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Increase the buffer to prepare for a possible push. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		int grow_size = 8 /* arbitrary grow size */;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		num_to_alloc = (yy_buffer_stack_max) + grow_size;</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc</code><br />
            </span>
            
            <span class="none">
            <code>| 								((yy_buffer_stack),</code><br />
            </span>
            
            <span class="none">
            <code>| 								num_to_alloc * sizeof(struct yy_buffer_state*)</code><br />
            </span>
            
            <span class="none">
            <code>| 								);</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! (yy_buffer_stack) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* zero only the new slots.*/</code><br />
            </span>
            
            <span class="none">
            <code>| 		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack_max) = num_to_alloc;</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Setup the input buffer state to scan directly from a user-specified character buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param base the character buffer</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param size the size in bytes of the character buffer</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @return the newly allocated buffer state object.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BUFFER_STATE b;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( size < 2 ||</code><br />
            </span>
            
            <span class="none">
            <code>| 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||</code><br />
            </span>
            
            <span class="none">
            <code>| 	     base[size-1] != YY_END_OF_BUFFER_CHAR )</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* They forgot to leave room for the EOB's. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		return 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buf_pos = b->yy_ch_buf = base;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_is_our_buffer = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_input_file = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_n_chars = b->yy_buf_size;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_is_interactive = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_at_bol = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_fill_buffer = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buffer_status = YY_BUFFER_NEW;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_switch_to_buffer(b  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return b;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Setup the input buffer state to scan a string. The next call to yylex() will</code><br />
            </span>
            
            <span class="none">
            <code>|  * scan from a @e copy of @a str.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param yystr a NUL-terminated string to scan</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @return the newly allocated buffer state object.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @note If you want to scan bytes that may contain NUL values, then use</code><br />
            </span>
            
            <span class="none">
            <code>|  *       yy_scan_bytes() instead.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return yy_scan_bytes(yystr,strlen(yystr) );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Setup the input buffer state to scan the given bytes. The next call to yylex() will</code><br />
            </span>
            
            <span class="none">
            <code>|  * scan from a @e copy of @a bytes.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param yybytes the byte buffer to scan</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @return the newly allocated buffer state object.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BUFFER_STATE b;</code><br />
            </span>
            
            <span class="none">
            <code>| 	char *buf;</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t n;</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t i;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Get memory for full buffer, including space for trailing EOB's. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	n = _yybytes_len + 2;</code><br />
            </span>
            
            <span class="none">
            <code>| 	buf = (char *) yyalloc(n  );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! buf )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( i = 0; i < _yybytes_len; ++i )</code><br />
            </span>
            
            <span class="none">
            <code>| 		buf[i] = yybytes[i];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b = yy_scan_buffer(buf,n );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* It's okay to grow etc. this buffer, and we should throw it</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * away when we're done.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_is_our_buffer = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return b;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_EXIT_FAILURE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_EXIT_FAILURE 2</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_fatal_error (yyconst char* msg )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	(void) fprintf( stderr, "%s\n", msg );</code><br />
            </span>
            
            <span class="none">
            <code>| 	exit( YY_EXIT_FAILURE );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Redefine yyless() so it works in section 3 code. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #undef yyless</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyless(n) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	do \</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Undo effects of setting up yytext. */ \</code><br />
            </span>
            
            <span class="none">
            <code>|         int yyless_macro_arg = (n); \</code><br />
            </span>
            
            <span class="none">
            <code>|         YY_LESS_LINENO(yyless_macro_arg);\</code><br />
            </span>
            
            <span class="none">
            <code>| 		yytext[yyleng] = (yy_hold_char); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_c_buf_p) = yytext + yyless_macro_arg; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_hold_char) = *(yy_c_buf_p); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_c_buf_p) = '\0'; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		yyleng = yyless_macro_arg; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	while ( 0 )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Accessor  methods (get/set functions) to struct members. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the current line number.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| int yyget_lineno  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     return yylineno;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the input stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyget_in  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yyin;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the output stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyget_out  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yyout;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the length of the current token.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| yy_size_t yyget_leng  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yyleng;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the current token.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| char *yyget_text  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yytext;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Set the current line number.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param line_number</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_lineno (int  line_number )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     yylineno = line_number;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Set the input stream. This does not discard the current</code><br />
            </span>
            
            <span class="none">
            <code>|  * input buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param in_str A readable stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @see yy_switch_to_buffer</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_in (FILE *  in_str )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         yyin = in_str ;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_out (FILE *  out_str )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         yyout = out_str ;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yyget_debug  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yy_flex_debug;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_debug (int  bdebug )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         yy_flex_debug = bdebug ;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_init_globals (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         /* Initialization is the same as for the non-reentrant scanner.</code><br />
            </span>
            
            <span class="none">
            <code>|      * This function is called from yylex_destroy(), so don't allocate here.</code><br />
            </span>
            
            <span class="none">
            <code>|      */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_buffer_stack) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_buffer_stack_top) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_buffer_stack_max) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_c_buf_p) = (char *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_init) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_start) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_state_buf) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_state_ptr) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_full_match) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_lp) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Defined in main.c */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_STDINIT</code><br />
            </span>
            
            <span class="none">
            <code>|     yyin = stdin;</code><br />
            </span>
            
            <span class="none">
            <code>|     yyout = stdout;</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>|     yyin = (FILE *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     yyout = (FILE *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     /* For future reference: Set errno on error, since we are called by</code><br />
            </span>
            
            <span class="none">
            <code>|      * yylex_init()</code><br />
            </span>
            
            <span class="none">
            <code>|      */</code><br />
            </span>
            
            <span class="none">
            <code>|     return 0;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yylex_destroy is for both reentrant and non-reentrant scanners. */</code><br />
            </span>
            
            <span class="none">
            <code>| int yylex_destroy  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     /* Pop the buffer stack, destroying each element. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	while(YY_CURRENT_BUFFER){</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_delete_buffer(YY_CURRENT_BUFFER  );</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE = NULL;</code><br />
            </span>
            
            <span class="none">
            <code>| 		yypop_buffer_state();</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Destroy the stack itself. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyfree((yy_buffer_stack) );</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_buffer_stack) = NULL;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     yyfree ( (yy_state_buf) );</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_state_buf)  = NULL;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     /* Reset the globals. This is important in a non-reentrant scanner so the next time</code><br />
            </span>
            
            <span class="none">
            <code>|      * yylex() is called, initialization will occur. */</code><br />
            </span>
            
            <span class="none">
            <code>|     yy_init_globals( );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     return 0;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /*</code><br />
            </span>
            
            <span class="none">
            <code>|  * Internal utility routines.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef yytext_ptr</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int i;</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( i = 0; i < n; ++i )</code><br />
            </span>
            
            <span class="none">
            <code>| 		s1[i] = s2[i];</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_NEED_STRLEN</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_flex_strlen (yyconst char * s )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int n;</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( n = 0; s[n]; ++n )</code><br />
            </span>
            
            <span class="none">
            <code>| 		;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return n;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void *yyalloc (yy_size_t  size )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	return (void *) malloc( size );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void *yyrealloc  (void * ptr, yy_size_t  size )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* The cast to (char *) in the following accommodates both</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * implementations that use char* generic pointers, and those</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * that use void* generic pointers.  It works with the latter</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * because both ANSI C and C++ allow castless assignment from</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * any pointer type to void*, and deal with argument conversions</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * as though doing an assignment.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	return (void *) realloc( (char *) ptr, size );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyfree (void * ptr )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YYTABLES_NAME "yytables"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #line 9 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YYTEXT_POINTER</code><br />
            </span>
            
            <span class="none">
            <code>| extern char *yytext;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| int</code><br />
            </span>
            
            <span class="none">
            <code>| main (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|   return ! yylex () + ! yywrap ();</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>configure:19607: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:19636: checking for a BSD-compatible install</code><br />
            </span>
            
            <span class="none">
            <code>configure:19692: result: /usr/bin/install -c</code><br />
            </span>
            
            <span class="none">
            <code>configure:19703: checking whether ln -s works</code><br />
            </span>
            
            <span class="none">
            <code>configure:19707: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:19714: checking whether make sets $(MAKE)</code><br />
            </span>
            
            <span class="none">
            <code>configure:19735: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:19747: checking for x86_64-unknown-linux-ranlib</code><br />
            </span>
            
            <span class="none">
            <code>configure:19774: result: ranlib</code><br />
            </span>
            
            <span class="none">
            <code>configure:19842: checking for ANSI C header files</code><br />
            </span>
            
            <span class="none">
            <code>configure:20006: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:20033: checking malloc.h usability</code><br />
            </span>
            
            <span class="none">
            <code>configure:20050: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:20056: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:20070: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:20074: checking malloc.h presence</code><br />
            </span>
            
            <span class="none">
            <code>configure:20089: arm-linux-androideabi-gcc -E  conftest.c</code><br />
            </span>
            
            <span class="none">
            <code>configure:20095: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:20109: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:20137: checking for malloc.h</code><br />
            </span>
            
            <span class="none">
            <code>configure:20145: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:20033: checking sys/time.h usability</code><br />
            </span>
            
            <span class="none">
            <code>configure:20050: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:20056: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:20070: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:20074: checking sys/time.h presence</code><br />
            </span>
            
            <span class="none">
            <code>configure:20089: arm-linux-androideabi-gcc -E  conftest.c</code><br />
            </span>
            
            <span class="none">
            <code>configure:20095: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:20109: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:20137: checking for sys/time.h</code><br />
            </span>
            
            <span class="none">
            <code>configure:20145: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:20023: checking for unistd.h</code><br />
            </span>
            
            <span class="none">
            <code>configure:20029: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:20159: checking for an ANSI C-conforming const</code><br />
            </span>
            
            <span class="none">
            <code>configure:20234: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:20240: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:20255: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:20265: checking for inline</code><br />
            </span>
            
            <span class="none">
            <code>configure:20291: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:20297: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:20315: result: inline</code><br />
            </span>
            
            <span class="none">
            <code>configure:20334: checking for pid_t</code><br />
            </span>
            
            <span class="none">
            <code>configure:20364: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:20370: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:20385: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:20397: checking for size_t</code><br />
            </span>
            
            <span class="none">
            <code>configure:20427: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:20433: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:20448: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:20461: checking return type of signal handlers</code><br />
            </span>
            
            <span class="none">
            <code>configure:20489: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>conftest.c: In function 'main':</code><br />
            </span>
            
            <span class="none">
            <code>conftest.c:31:1: error: void value not ignored as it ought to be</code><br />
            </span>
            
            <span class="none">
            <code>return *(signal (0, 0)) (0) == 1;</code><br />
            </span>
            
            <span class="none">
            <code>^</code><br />
            </span>
            
            <span class="none">
            <code>configure:20495: $? = 1</code><br />
            </span>
            
            <span class="none">
            <code>configure: failed program was:</code><br />
            </span>
            
            <span class="none">
            <code>| /* confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_NAME ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_TARNAME ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_VERSION ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_STRING ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_BUGREPORT ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE "isapnptools"</code><br />
            </span>
            
            <span class="none">
            <code>| #define VERSION "1.27"</code><br />
            </span>
            
            <span class="none">
            <code>| #define STDC_HEADERS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_TYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_STAT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDLIB_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRING_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_MEMORY_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRINGS_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_INTTYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDINT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_DLFCN_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define STDC_HEADERS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_MALLOC_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_TIME_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| /* end confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #include <sys/types.h></code><br />
            </span>
            
            <span class="none">
            <code>| #include <signal.h></code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int</code><br />
            </span>
            
            <span class="none">
            <code>| main ()</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| return *(signal (0, 0)) (0) == 1;</code><br />
            </span>
            
            <span class="none">
            <code>|   ;</code><br />
            </span>
            
            <span class="none">
            <code>|   return 0;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>configure:20510: result: void</code><br />
            </span>
            
            <span class="none">
            <code>configure:20522: checking for vprintf</code><br />
            </span>
            
            <span class="none">
            <code>configure:20578: arm-linux-androideabi-gcc -o conftest    conftest.c  >&5</code><br />
            </span>
            
            <span class="none">
            <code>conftest.c:49:6: warning: conflicting types for built-in function 'vprintf' [enabled by default]</code><br />
            </span>
            
            <span class="none">
            <code>char vprintf ();</code><br />
            </span>
            
            <span class="none">
            <code>^</code><br />
            </span>
            
            <span class="none">
            <code>configure:20584: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:20602: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:20609: checking for _doprnt</code><br />
            </span>
            
            <span class="none">
            <code>configure:20665: arm-linux-androideabi-gcc -o conftest    conftest.c  >&5</code><br />
            </span>
            
            <span class="none">
            <code>/tmp/ccmLr3CD.o:conftest.c:function main: error: undefined reference to '_doprnt'</code><br />
            </span>
            
            <span class="none">
            <code>collect2: error: ld returned 1 exit status</code><br />
            </span>
            
            <span class="none">
            <code>configure:20671: $? = 1</code><br />
            </span>
            
            <span class="none">
            <code>configure: failed program was:</code><br />
            </span>
            
            <span class="none">
            <code>| /* confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_NAME ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_TARNAME ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_VERSION ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_STRING ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_BUGREPORT ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE "isapnptools"</code><br />
            </span>
            
            <span class="none">
            <code>| #define VERSION "1.27"</code><br />
            </span>
            
            <span class="none">
            <code>| #define STDC_HEADERS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_TYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_STAT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDLIB_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRING_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_MEMORY_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRINGS_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_INTTYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDINT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_DLFCN_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define STDC_HEADERS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_MALLOC_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_TIME_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define RETSIGTYPE void</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_VPRINTF 1</code><br />
            </span>
            
            <span class="none">
            <code>| /* end confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>| /* Define _doprnt to an innocuous variant, in case <limits.h> declares _doprnt.</code><br />
            </span>
            
            <span class="none">
            <code>|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define _doprnt innocuous__doprnt</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* System header to define __stub macros and hopefully few prototypes,</code><br />
            </span>
            
            <span class="none">
            <code>|     which can conflict with char _doprnt (); below.</code><br />
            </span>
            
            <span class="none">
            <code>|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since</code><br />
            </span>
            
            <span class="none">
            <code>|     <limits.h> exists even on freestanding compilers.  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __STDC__</code><br />
            </span>
            
            <span class="none">
            <code>| # include <limits.h></code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| # include <assert.h></code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #undef _doprnt</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Override any GCC internal prototype to avoid an error.</code><br />
            </span>
            
            <span class="none">
            <code>|    Use char because int might match the return type of a GCC</code><br />
            </span>
            
            <span class="none">
            <code>|    builtin and then its argument prototype would still apply.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>| extern "C"</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| char _doprnt ();</code><br />
            </span>
            
            <span class="none">
            <code>| /* The GNU C library defines this for functions which it implements</code><br />
            </span>
            
            <span class="none">
            <code>|     to always fail with ENOSYS.  Some functions are actually named</code><br />
            </span>
            
            <span class="none">
            <code>|     something starting with __ and the normal name is an alias.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #if defined __stub__doprnt || defined __stub____doprnt</code><br />
            </span>
            
            <span class="none">
            <code>| choke me</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int</code><br />
            </span>
            
            <span class="none">
            <code>| main ()</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| return _doprnt ();</code><br />
            </span>
            
            <span class="none">
            <code>|   ;</code><br />
            </span>
            
            <span class="none">
            <code>|   return 0;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>configure:20688: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:20711: checking for strncmp</code><br />
            </span>
            
            <span class="none">
            <code>configure:20767: arm-linux-androideabi-gcc -o conftest    conftest.c  >&5</code><br />
            </span>
            
            <span class="none">
            <code>conftest.c:50:6: warning: conflicting types for built-in function 'strncmp' [enabled by default]</code><br />
            </span>
            
            <span class="none">
            <code>char strncmp ();</code><br />
            </span>
            
            <span class="none">
            <code>^</code><br />
            </span>
            
            <span class="none">
            <code>configure:20773: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:20791: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:20814: checking for strdup</code><br />
            </span>
            
            <span class="none">
            <code>configure:20870: arm-linux-androideabi-gcc -o conftest    conftest.c  >&5</code><br />
            </span>
            
            <span class="none">
            <code>conftest.c:51:6: warning: conflicting types for built-in function 'strdup' [enabled by default]</code><br />
            </span>
            
            <span class="none">
            <code>char strdup ();</code><br />
            </span>
            
            <span class="none">
            <code>^</code><br />
            </span>
            
            <span class="none">
            <code>configure:20876: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:20894: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:20814: checking for strerror</code><br />
            </span>
            
            <span class="none">
            <code>configure:20870: arm-linux-androideabi-gcc -o conftest    conftest.c  >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:20876: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:20894: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:20814: checking for strtol</code><br />
            </span>
            
            <span class="none">
            <code>configure:20870: arm-linux-androideabi-gcc -o conftest    conftest.c  >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:20876: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:20894: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:20814: checking for strtoul</code><br />
            </span>
            
            <span class="none">
            <code>configure:20870: arm-linux-androideabi-gcc -o conftest    conftest.c  >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:20876: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:20894: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:20814: checking for nanosleep</code><br />
            </span>
            
            <span class="none">
            <code>configure:20870: arm-linux-androideabi-gcc -o conftest    conftest.c  >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:20876: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:20894: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:20814: checking for sched_setscheduler</code><br />
            </span>
            
            <span class="none">
            <code>configure:20870: arm-linux-androideabi-gcc -o conftest    conftest.c  >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:20876: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:20894: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:20814: checking for snprintf</code><br />
            </span>
            
            <span class="none">
            <code>configure:20870: arm-linux-androideabi-gcc -o conftest    conftest.c  >&5</code><br />
            </span>
            
            <span class="none">
            <code>conftest.c:57:6: warning: conflicting types for built-in function 'snprintf' [enabled by default]</code><br />
            </span>
            
            <span class="none">
            <code>char snprintf ();</code><br />
            </span>
            
            <span class="none">
            <code>^</code><br />
            </span>
            
            <span class="none">
            <code>configure:20876: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:20894: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:20814: checking for strncasecmp</code><br />
            </span>
            
            <span class="none">
            <code>configure:20870: arm-linux-androideabi-gcc -o conftest    conftest.c  >&5</code><br />
            </span>
            
            <span class="none">
            <code>conftest.c:58:6: warning: conflicting types for built-in function 'strncasecmp' [enabled by default]</code><br />
            </span>
            
            <span class="none">
            <code>char strncasecmp ();</code><br />
            </span>
            
            <span class="none">
            <code>^</code><br />
            </span>
            
            <span class="none">
            <code>configure:20876: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:20894: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:20814: checking for getdelim</code><br />
            </span>
            
            <span class="none">
            <code>configure:20870: arm-linux-androideabi-gcc -o conftest    conftest.c  >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:20876: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:20894: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:20814: checking for memcmp</code><br />
            </span>
            
            <span class="none">
            <code>configure:20870: arm-linux-androideabi-gcc -o conftest    conftest.c  >&5</code><br />
            </span>
            
            <span class="none">
            <code>conftest.c:60:6: warning: conflicting types for built-in function 'memcmp' [enabled by default]</code><br />
            </span>
            
            <span class="none">
            <code>char memcmp ();</code><br />
            </span>
            
            <span class="none">
            <code>^</code><br />
            </span>
            
            <span class="none">
            <code>configure:20876: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:20894: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:20912: checking for iopl</code><br />
            </span>
            
            <span class="none">
            <code>configure:20968: arm-linux-androideabi-gcc -o conftest    conftest.c  >&5</code><br />
            </span>
            
            <span class="none">
            <code>/tmp/ccAVKv1i.o:conftest.c:function main: error: undefined reference to 'iopl'</code><br />
            </span>
            
            <span class="none">
            <code>collect2: error: ld returned 1 exit status</code><br />
            </span>
            
            <span class="none">
            <code>configure:20974: $? = 1</code><br />
            </span>
            
            <span class="none">
            <code>configure: failed program was:</code><br />
            </span>
            
            <span class="none">
            <code>| /* confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_NAME ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_TARNAME ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_VERSION ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_STRING ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_BUGREPORT ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE "isapnptools"</code><br />
            </span>
            
            <span class="none">
            <code>| #define VERSION "1.27"</code><br />
            </span>
            
            <span class="none">
            <code>| #define STDC_HEADERS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_TYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_STAT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDLIB_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRING_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_MEMORY_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRINGS_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_INTTYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDINT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_DLFCN_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define STDC_HEADERS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_MALLOC_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_TIME_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define RETSIGTYPE void</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_VPRINTF 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRNCMP 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRDUP 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRERROR 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRTOL 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRTOUL 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_NANOSLEEP 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SCHED_SETSCHEDULER 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SNPRINTF 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRNCASECMP 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_GETDELIM 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_MEMCMP 1</code><br />
            </span>
            
            <span class="none">
            <code>| /* end confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>| /* Define iopl to an innocuous variant, in case <limits.h> declares iopl.</code><br />
            </span>
            
            <span class="none">
            <code>|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define iopl innocuous_iopl</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* System header to define __stub macros and hopefully few prototypes,</code><br />
            </span>
            
            <span class="none">
            <code>|     which can conflict with char iopl (); below.</code><br />
            </span>
            
            <span class="none">
            <code>|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since</code><br />
            </span>
            
            <span class="none">
            <code>|     <limits.h> exists even on freestanding compilers.  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __STDC__</code><br />
            </span>
            
            <span class="none">
            <code>| # include <limits.h></code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| # include <assert.h></code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #undef iopl</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Override any GCC internal prototype to avoid an error.</code><br />
            </span>
            
            <span class="none">
            <code>|    Use char because int might match the return type of a GCC</code><br />
            </span>
            
            <span class="none">
            <code>|    builtin and then its argument prototype would still apply.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>| extern "C"</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| char iopl ();</code><br />
            </span>
            
            <span class="none">
            <code>| /* The GNU C library defines this for functions which it implements</code><br />
            </span>
            
            <span class="none">
            <code>|     to always fail with ENOSYS.  Some functions are actually named</code><br />
            </span>
            
            <span class="none">
            <code>|     something starting with __ and the normal name is an alias.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #if defined __stub_iopl || defined __stub___iopl</code><br />
            </span>
            
            <span class="none">
            <code>| choke me</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int</code><br />
            </span>
            
            <span class="none">
            <code>| main ()</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| return iopl ();</code><br />
            </span>
            
            <span class="none">
            <code>|   ;</code><br />
            </span>
            
            <span class="none">
            <code>|   return 0;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>configure:20992: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:20912: checking for ioperm</code><br />
            </span>
            
            <span class="none">
            <code>configure:20968: arm-linux-androideabi-gcc -o conftest    conftest.c  >&5</code><br />
            </span>
            
            <span class="none">
            <code>/tmp/ccclfG0z.o:conftest.c:function main: error: undefined reference to 'ioperm'</code><br />
            </span>
            
            <span class="none">
            <code>collect2: error: ld returned 1 exit status</code><br />
            </span>
            
            <span class="none">
            <code>configure:20974: $? = 1</code><br />
            </span>
            
            <span class="none">
            <code>configure: failed program was:</code><br />
            </span>
            
            <span class="none">
            <code>| /* confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_NAME ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_TARNAME ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_VERSION ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_STRING ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_BUGREPORT ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE "isapnptools"</code><br />
            </span>
            
            <span class="none">
            <code>| #define VERSION "1.27"</code><br />
            </span>
            
            <span class="none">
            <code>| #define STDC_HEADERS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_TYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_STAT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDLIB_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRING_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_MEMORY_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRINGS_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_INTTYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDINT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_DLFCN_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define STDC_HEADERS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_MALLOC_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_TIME_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define RETSIGTYPE void</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_VPRINTF 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRNCMP 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRDUP 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRERROR 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRTOL 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRTOUL 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_NANOSLEEP 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SCHED_SETSCHEDULER 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SNPRINTF 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRNCASECMP 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_GETDELIM 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_MEMCMP 1</code><br />
            </span>
            
            <span class="none">
            <code>| /* end confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>| /* Define ioperm to an innocuous variant, in case <limits.h> declares ioperm.</code><br />
            </span>
            
            <span class="none">
            <code>|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define ioperm innocuous_ioperm</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* System header to define __stub macros and hopefully few prototypes,</code><br />
            </span>
            
            <span class="none">
            <code>|     which can conflict with char ioperm (); below.</code><br />
            </span>
            
            <span class="none">
            <code>|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since</code><br />
            </span>
            
            <span class="none">
            <code>|     <limits.h> exists even on freestanding compilers.  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __STDC__</code><br />
            </span>
            
            <span class="none">
            <code>| # include <limits.h></code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| # include <assert.h></code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #undef ioperm</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Override any GCC internal prototype to avoid an error.</code><br />
            </span>
            
            <span class="none">
            <code>|    Use char because int might match the return type of a GCC</code><br />
            </span>
            
            <span class="none">
            <code>|    builtin and then its argument prototype would still apply.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>| extern "C"</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| char ioperm ();</code><br />
            </span>
            
            <span class="none">
            <code>| /* The GNU C library defines this for functions which it implements</code><br />
            </span>
            
            <span class="none">
            <code>|     to always fail with ENOSYS.  Some functions are actually named</code><br />
            </span>
            
            <span class="none">
            <code>|     something starting with __ and the normal name is an alias.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #if defined __stub_ioperm || defined __stub___ioperm</code><br />
            </span>
            
            <span class="none">
            <code>| choke me</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int</code><br />
            </span>
            
            <span class="none">
            <code>| main ()</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| return ioperm ();</code><br />
            </span>
            
            <span class="none">
            <code>|   ;</code><br />
            </span>
            
            <span class="none">
            <code>|   return 0;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>configure:20992: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:20912: checking for usleep</code><br />
            </span>
            
            <span class="none">
            <code>configure:20968: arm-linux-androideabi-gcc -o conftest    conftest.c  >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:20974: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:20992: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:20912: checking for delay</code><br />
            </span>
            
            <span class="none">
            <code>configure:20968: arm-linux-androideabi-gcc -o conftest    conftest.c  >&5</code><br />
            </span>
            
            <span class="none">
            <code>/tmp/ccqu83I6.o:conftest.c:function main: error: undefined reference to 'delay'</code><br />
            </span>
            
            <span class="none">
            <code>collect2: error: ld returned 1 exit status</code><br />
            </span>
            
            <span class="none">
            <code>configure:20974: $? = 1</code><br />
            </span>
            
            <span class="none">
            <code>configure: failed program was:</code><br />
            </span>
            
            <span class="none">
            <code>| /* confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_NAME ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_TARNAME ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_VERSION ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_STRING ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_BUGREPORT ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE "isapnptools"</code><br />
            </span>
            
            <span class="none">
            <code>| #define VERSION "1.27"</code><br />
            </span>
            
            <span class="none">
            <code>| #define STDC_HEADERS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_TYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_STAT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDLIB_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRING_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_MEMORY_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRINGS_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_INTTYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDINT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_DLFCN_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define STDC_HEADERS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_MALLOC_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_TIME_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define RETSIGTYPE void</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_VPRINTF 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRNCMP 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRDUP 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRERROR 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRTOL 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRTOUL 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_NANOSLEEP 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SCHED_SETSCHEDULER 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SNPRINTF 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRNCASECMP 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_GETDELIM 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_MEMCMP 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_USLEEP 1</code><br />
            </span>
            
            <span class="none">
            <code>| /* end confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>| /* Define delay to an innocuous variant, in case <limits.h> declares delay.</code><br />
            </span>
            
            <span class="none">
            <code>|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define delay innocuous_delay</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* System header to define __stub macros and hopefully few prototypes,</code><br />
            </span>
            
            <span class="none">
            <code>|     which can conflict with char delay (); below.</code><br />
            </span>
            
            <span class="none">
            <code>|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since</code><br />
            </span>
            
            <span class="none">
            <code>|     <limits.h> exists even on freestanding compilers.  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __STDC__</code><br />
            </span>
            
            <span class="none">
            <code>| # include <limits.h></code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| # include <assert.h></code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #undef delay</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Override any GCC internal prototype to avoid an error.</code><br />
            </span>
            
            <span class="none">
            <code>|    Use char because int might match the return type of a GCC</code><br />
            </span>
            
            <span class="none">
            <code>|    builtin and then its argument prototype would still apply.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>| extern "C"</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| char delay ();</code><br />
            </span>
            
            <span class="none">
            <code>| /* The GNU C library defines this for functions which it implements</code><br />
            </span>
            
            <span class="none">
            <code>|     to always fail with ENOSYS.  Some functions are actually named</code><br />
            </span>
            
            <span class="none">
            <code>|     something starting with __ and the normal name is an alias.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #if defined __stub_delay || defined __stub___delay</code><br />
            </span>
            
            <span class="none">
            <code>| choke me</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int</code><br />
            </span>
            
            <span class="none">
            <code>| main ()</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| return delay ();</code><br />
            </span>
            
            <span class="none">
            <code>|   ;</code><br />
            </span>
            
            <span class="none">
            <code>|   return 0;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>configure:20992: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:20912: checking for _sleep2</code><br />
            </span>
            
            <span class="none">
            <code>configure:20968: arm-linux-androideabi-gcc -o conftest    conftest.c  >&5</code><br />
            </span>
            
            <span class="none">
            <code>/tmp/ccoLgwxn.o:conftest.c:function main: error: undefined reference to '_sleep2'</code><br />
            </span>
            
            <span class="none">
            <code>collect2: error: ld returned 1 exit status</code><br />
            </span>
            
            <span class="none">
            <code>configure:20974: $? = 1</code><br />
            </span>
            
            <span class="none">
            <code>configure: failed program was:</code><br />
            </span>
            
            <span class="none">
            <code>| /* confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_NAME ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_TARNAME ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_VERSION ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_STRING ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_BUGREPORT ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE "isapnptools"</code><br />
            </span>
            
            <span class="none">
            <code>| #define VERSION "1.27"</code><br />
            </span>
            
            <span class="none">
            <code>| #define STDC_HEADERS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_TYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_STAT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDLIB_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRING_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_MEMORY_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRINGS_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_INTTYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDINT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_DLFCN_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define STDC_HEADERS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_MALLOC_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_TIME_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define RETSIGTYPE void</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_VPRINTF 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRNCMP 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRDUP 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRERROR 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRTOL 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRTOUL 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_NANOSLEEP 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SCHED_SETSCHEDULER 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SNPRINTF 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRNCASECMP 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_GETDELIM 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_MEMCMP 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_USLEEP 1</code><br />
            </span>
            
            <span class="none">
            <code>| /* end confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>| /* Define _sleep2 to an innocuous variant, in case <limits.h> declares _sleep2.</code><br />
            </span>
            
            <span class="none">
            <code>|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define _sleep2 innocuous__sleep2</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* System header to define __stub macros and hopefully few prototypes,</code><br />
            </span>
            
            <span class="none">
            <code>|     which can conflict with char _sleep2 (); below.</code><br />
            </span>
            
            <span class="none">
            <code>|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since</code><br />
            </span>
            
            <span class="none">
            <code>|     <limits.h> exists even on freestanding compilers.  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __STDC__</code><br />
            </span>
            
            <span class="none">
            <code>| # include <limits.h></code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| # include <assert.h></code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #undef _sleep2</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Override any GCC internal prototype to avoid an error.</code><br />
            </span>
            
            <span class="none">
            <code>|    Use char because int might match the return type of a GCC</code><br />
            </span>
            
            <span class="none">
            <code>|    builtin and then its argument prototype would still apply.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>| extern "C"</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| char _sleep2 ();</code><br />
            </span>
            
            <span class="none">
            <code>| /* The GNU C library defines this for functions which it implements</code><br />
            </span>
            
            <span class="none">
            <code>|     to always fail with ENOSYS.  Some functions are actually named</code><br />
            </span>
            
            <span class="none">
            <code>|     something starting with __ and the normal name is an alias.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #if defined __stub__sleep2 || defined __stub____sleep2</code><br />
            </span>
            
            <span class="none">
            <code>| choke me</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int</code><br />
            </span>
            
            <span class="none">
            <code>| main ()</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| return _sleep2 ();</code><br />
            </span>
            
            <span class="none">
            <code>|   ;</code><br />
            </span>
            
            <span class="none">
            <code>|   return 0;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>configure:20992: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:21006: checking for alarm</code><br />
            </span>
            
            <span class="none">
            <code>configure:21062: arm-linux-androideabi-gcc -o conftest    conftest.c  >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:21068: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:21086: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:21100: checking for memset</code><br />
            </span>
            
            <span class="none">
            <code>configure:21156: arm-linux-androideabi-gcc -o conftest    conftest.c  >&5</code><br />
            </span>
            
            <span class="none">
            <code>conftest.c:63:6: warning: conflicting types for built-in function 'memset' [enabled by default]</code><br />
            </span>
            
            <span class="none">
            <code>char memset ();</code><br />
            </span>
            
            <span class="none">
            <code>^</code><br />
            </span>
            
            <span class="none">
            <code>configure:21162: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:21180: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:21194: checking for getopt_long</code><br />
            </span>
            
            <span class="none">
            <code>configure:21250: arm-linux-androideabi-gcc -o conftest    conftest.c  >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:21256: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:21274: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:21662: creating ./config.status</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>## ---------------------- ##</code><br />
            </span>
            
            <span class="none">
            <code>## Running config.status. ##</code><br />
            </span>
            
            <span class="none">
            <code>## ---------------------- ##</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>This file was extended by config.status, which was</code><br />
            </span>
            
            <span class="none">
            <code>generated by GNU Autoconf 2.61.  Invocation command line was</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>CONFIG_FILES    =</code><br />
            </span>
            
            <span class="none">
            <code>CONFIG_HEADERS  =</code><br />
            </span>
            
            <span class="none">
            <code>CONFIG_LINKS    =</code><br />
            </span>
            
            <span class="none">
            <code>CONFIG_COMMANDS =</code><br />
            </span>
            
            <span class="none">
            <code>$ ./config.status</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>on 5e868de1d28e</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>config.status:670: creating include/Makefile</code><br />
            </span>
            
            <span class="none">
            <code>config.status:670: creating include/isapnp/Makefile</code><br />
            </span>
            
            <span class="none">
            <code>config.status:670: creating src/Makefile</code><br />
            </span>
            
            <span class="none">
            <code>config.status:670: creating demos/Makefile</code><br />
            </span>
            
            <span class="none">
            <code>config.status:670: creating doc/Makefile</code><br />
            </span>
            
            <span class="none">
            <code>config.status:670: creating Makefile</code><br />
            </span>
            
            <span class="none">
            <code>config.status:670: creating include/config.h</code><br />
            </span>
            
            <span class="none">
            <code>config.status:968: executing depfiles commands</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>## ---------------- ##</code><br />
            </span>
            
            <span class="none">
            <code>## Cache variables. ##</code><br />
            </span>
            
            <span class="none">
            <code>## ---------------- ##</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_build=x86_64-unknown-linux-gnu</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_c_compiler_gnu=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_c_const=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_c_inline=inline</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_cxx_compiler_gnu=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_CCC_set=</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_CCC_value=</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_CC_set=set</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_CC_value=arm-linux-androideabi-gcc</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_CFLAGS_set=set</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_CFLAGS_value=</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_CPPFLAGS_set=set</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_CPPFLAGS_value=</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_CPP_set=</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_CPP_value=</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_CXXCPP_set=</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_CXXCPP_value=</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_CXXFLAGS_set=set</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_CXXFLAGS_value=</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_CXX_set=set</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_CXX_value=arm-linux-androideabi-g++</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_F77_set=</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_F77_value=</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_FFLAGS_set=</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_FFLAGS_value=</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_LDFLAGS_set=set</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_LDFLAGS_value=</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_LIBS_set=</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_LIBS_value=</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_build_alias_set=</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_build_alias_value=</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_host_alias_set=set</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_host_alias_value=x86_64-unknown-linux</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_target_alias_set=</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_target_alias_value=</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_f77_compiler_gnu=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func__doprnt=no</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func__sleep2=no</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_alarm=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_delay=no</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_getdelim=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_getopt_long=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_ioperm=no</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_iopl=no</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_memcmp=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_memset=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_nanosleep=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_sched_setscheduler=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_snprintf=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_strdup=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_strerror=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_strncasecmp=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_strncmp=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_strtol=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_strtoul=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_usleep=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_vprintf=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_header_dlfcn_h=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_header_inttypes_h=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_header_malloc_h=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_header_memory_h=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_header_stdc=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_header_stdint_h=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_header_stdlib_h=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_header_string_h=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_header_strings_h=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_header_sys_stat_h=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_header_sys_time_h=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_header_sys_types_h=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_header_unistd_h=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_host=x86_64-unknown-linux-gnu</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_lib_lex='none needed'</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_objext=o</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_path_EGREP='/usr/sbin/grep -E'</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_path_GREP=/usr/sbin/grep</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_path_install='/usr/bin/install -c'</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_path_mkdir=/usr/sbin/mkdir</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_prog_AWK=gawk</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_prog_CC=arm-linux-androideabi-gcc</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_prog_CPP='arm-linux-androideabi-gcc -E'</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_prog_CXXCPP='arm-linux-androideabi-g++ -E'</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_prog_LEX=flex</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_prog_RANLIB=ranlib</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_prog_STRIP=strip</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_prog_ac_ct_AR=ar</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_prog_ac_ct_F77=gfortran</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_prog_ac_ct_RANLIB=ranlib</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_prog_ac_ct_STRIP=strip</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_prog_cc_c89=</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_prog_cc_g=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_prog_cxx_g=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_prog_f77_g=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_prog_lex_root=lex.yy</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_prog_lex_yytext_pointer=no</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_prog_make_make_set=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_type_pid_t=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_type_signal=void</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_type_size_t=yes</code><br />
            </span>
            
            <span class="none">
            <code>am_cv_CC_dependencies_compiler_type=gcc3</code><br />
            </span>
            
            <span class="none">
            <code>am_cv_CXX_dependencies_compiler_type=gcc3</code><br />
            </span>
            
            <span class="none">
            <code>lt_cv_deplibs_check_method=pass_all</code><br />
            </span>
            
            <span class="none">
            <code>lt_cv_file_magic_cmd='$MAGIC_CMD'</code><br />
            </span>
            
            <span class="none">
            <code>lt_cv_file_magic_test_file=</code><br />
            </span>
            
            <span class="none">
            <code>lt_cv_ld_reload_flag=-r</code><br />
            </span>
            
            <span class="none">
            <code>lt_cv_objdir=.libs</code><br />
            </span>
            
            <span class="none">
            <code>lt_cv_path_LD=/toolchain_root/arm-linux-androideabi/bin/ld</code><br />
            </span>
            
            <span class="none">
            <code>lt_cv_path_LDCXX='/toolchain_root/arm-linux-androideabi/bin/ld -m elf_i386'</code><br />
            </span>
            
            <span class="none">
            <code>lt_cv_path_NM='/usr/sbin/nm -B'</code><br />
            </span>
            
            <span class="none">
            <code>lt_cv_path_SED=/usr/sbin/sed</code><br />
            </span>
            
            <span class="none">
            <code>lt_cv_prog_compiler_c_o=yes</code><br />
            </span>
            
            <span class="none">
            <code>lt_cv_prog_compiler_c_o_CXX=yes</code><br />
            </span>
            
            <span class="none">
            <code>lt_cv_prog_compiler_c_o_F77=yes</code><br />
            </span>
            
            <span class="none">
            <code>lt_cv_prog_compiler_rtti_exceptions=no</code><br />
            </span>
            
            <span class="none">
            <code>lt_cv_prog_gnu_ld=yes</code><br />
            </span>
            
            <span class="none">
            <code>lt_cv_prog_gnu_ldcxx=yes</code><br />
            </span>
            
            <span class="none">
            <code>lt_cv_sys_global_symbol_pipe='sed -n -e '\''s/^.*[ 	]\([ABCDGIRSTW][ABCDGIRSTW]*\)[ 	][ 	]*\([_A-Za-z][_A-Za-z0-9]*\)$/\1 \2 \2/p'\'''</code><br />
            </span>
            
            <span class="none">
            <code>lt_cv_sys_global_symbol_to_c_name_address='sed -n -e '\''s/^: \([^ ]*\) $/  {\"\1\", (lt_ptr) 0},/p'\'' -e '\''s/^[BCDEGRST] \([^ ]*\) \([^ ]*\)$/  {"\2", (lt_ptr) \&\2},/p'\'''</code><br />
            </span>
            
            <span class="none">
            <code>lt_cv_sys_global_symbol_to_cdecl='sed -n -e '\''s/^. .* \(.*\)$/extern int \1;/p'\'''</code><br />
            </span>
            
            <span class="none">
            <code>lt_cv_sys_max_cmd_len=32768</code><br />
            </span>
            
            <span class="none">
            <code>lt_lt_cv_prog_compiler_c_o='"yes"'</code><br />
            </span>
            
            <span class="none">
            <code>lt_lt_cv_prog_compiler_c_o_CXX='"yes"'</code><br />
            </span>
            
            <span class="none">
            <code>lt_lt_cv_prog_compiler_c_o_F77='"yes"'</code><br />
            </span>
            
            <span class="none">
            <code>lt_lt_cv_sys_global_symbol_pipe='"sed -n -e '\''s/^.*[ 	]\\([ABCDGIRSTW][ABCDGIRSTW]*\\)[ 	][ 	]*\\([_A-Za-z][_A-Za-z0-9]*\\)\$/\\1 \\2 \\2/p'\''"'</code><br />
            </span>
            
            <span class="none">
            <code>lt_lt_cv_sys_global_symbol_to_c_name_address='"sed -n -e '\''s/^: \\([^ ]*\\) \$/  {\\\"\\1\\\", (lt_ptr) 0},/p'\'' -e '\''s/^[BCDEGRST] \\([^ ]*\\) \\([^ ]*\\)\$/  {\"\\2\", (lt_ptr) \\&\\2},/p'\''"'</code><br />
            </span>
            
            <span class="none">
            <code>lt_lt_cv_sys_global_symbol_to_cdecl='"sed -n -e '\''s/^. .* \\(.*\\)\$/extern int \\1;/p'\''"'</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>## ----------------- ##</code><br />
            </span>
            
            <span class="none">
            <code>## Output variables. ##</code><br />
            </span>
            
            <span class="none">
            <code>## ----------------- ##</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>ACLOCAL='${SHELL} /tmp/isapnptools/src/isapnptools-1.27/missing --run aclocal-1.10'</code><br />
            </span>
            
            <span class="none">
            <code>AMDEPBACKSLASH='\'</code><br />
            </span>
            
            <span class="none">
            <code>AMDEP_FALSE='#'</code><br />
            </span>
            
            <span class="none">
            <code>AMDEP_TRUE=''</code><br />
            </span>
            
            <span class="none">
            <code>AMTAR='${SHELL} /tmp/isapnptools/src/isapnptools-1.27/missing --run tar'</code><br />
            </span>
            
            <span class="none">
            <code>AR='ar'</code><br />
            </span>
            
            <span class="none">
            <code>AUTOCONF='${SHELL} /tmp/isapnptools/src/isapnptools-1.27/missing --run autoconf'</code><br />
            </span>
            
            <span class="none">
            <code>AUTOHEADER='${SHELL} /tmp/isapnptools/src/isapnptools-1.27/missing --run autoheader'</code><br />
            </span>
            
            <span class="none">
            <code>AUTOMAKE='${SHELL} /tmp/isapnptools/src/isapnptools-1.27/missing --run automake-1.10'</code><br />
            </span>
            
            <span class="none">
            <code>AWK='gawk'</code><br />
            </span>
            
            <span class="none">
            <code>CC='arm-linux-androideabi-gcc'</code><br />
            </span>
            
            <span class="none">
            <code>CCDEPMODE='depmode=gcc3'</code><br />
            </span>
            
            <span class="none">
            <code>CFLAGS=''</code><br />
            </span>
            
            <span class="none">
            <code>CPP='arm-linux-androideabi-gcc -E'</code><br />
            </span>
            
            <span class="none">
            <code>CPPFLAGS=''</code><br />
            </span>
            
            <span class="none">
            <code>CXX='arm-linux-androideabi-g++'</code><br />
            </span>
            
            <span class="none">
            <code>CXXCPP='arm-linux-androideabi-g++ -E'</code><br />
            </span>
            
            <span class="none">
            <code>CXXDEPMODE='depmode=gcc3'</code><br />
            </span>
            
            <span class="none">
            <code>CXXFLAGS=''</code><br />
            </span>
            
            <span class="none">
            <code>CYGPATH_W='echo'</code><br />
            </span>
            
            <span class="none">
            <code>DEFS='-DHAVE_CONFIG_H'</code><br />
            </span>
            
            <span class="none">
            <code>DEPDIR='.deps'</code><br />
            </span>
            
            <span class="none">
            <code>ECHO='echo'</code><br />
            </span>
            
            <span class="none">
            <code>ECHO_C=''</code><br />
            </span>
            
            <span class="none">
            <code>ECHO_N='-n'</code><br />
            </span>
            
            <span class="none">
            <code>ECHO_T=''</code><br />
            </span>
            
            <span class="none">
            <code>EGREP='/usr/sbin/grep -E'</code><br />
            </span>
            
            <span class="none">
            <code>EXEEXT=''</code><br />
            </span>
            
            <span class="none">
            <code>F77='gfortran'</code><br />
            </span>
            
            <span class="none">
            <code>FFLAGS='-g -O2'</code><br />
            </span>
            
            <span class="none">
            <code>GREP='/usr/sbin/grep'</code><br />
            </span>
            
            <span class="none">
            <code>INSTALL_DATA='${INSTALL} -m 644'</code><br />
            </span>
            
            <span class="none">
            <code>INSTALL_PROGRAM='${INSTALL}'</code><br />
            </span>
            
            <span class="none">
            <code>INSTALL_SCRIPT='${INSTALL}'</code><br />
            </span>
            
            <span class="none">
            <code>INSTALL_STRIP_PROGRAM='$(install_sh) -c -s'</code><br />
            </span>
            
            <span class="none">
            <code>LDFLAGS=' -static'</code><br />
            </span>
            
            <span class="none">
            <code>LEX='flex'</code><br />
            </span>
            
            <span class="none">
            <code>LEXLIB=''</code><br />
            </span>
            
            <span class="none">
            <code>LEX_OUTPUT_ROOT='lex.yy'</code><br />
            </span>
            
            <span class="none">
            <code>LIBOBJS=''</code><br />
            </span>
            
            <span class="none">
            <code>LIBOBJS=''</code><br />
            </span>
            
            <span class="none">
            <code>LIBS=''</code><br />
            </span>
            
            <span class="none">
            <code>LIBTOOL='$(SHELL) $(top_builddir)/libtool'</code><br />
            </span>
            
            <span class="none">
            <code>LN_S='ln -s'</code><br />
            </span>
            
            <span class="none">
            <code>LTLIBOBJS=''</code><br />
            </span>
            
            <span class="none">
            <code>MAKEINFO='${SHELL} /tmp/isapnptools/src/isapnptools-1.27/missing --run makeinfo'</code><br />
            </span>
            
            <span class="none">
            <code>OBJEXT='o'</code><br />
            </span>
            
            <span class="none">
            <code>PACKAGE='isapnptools'</code><br />
            </span>
            
            <span class="none">
            <code>PACKAGE_BUGREPORT=''</code><br />
            </span>
            
            <span class="none">
            <code>PACKAGE_NAME=''</code><br />
            </span>
            
            <span class="none">
            <code>PACKAGE_STRING=''</code><br />
            </span>
            
            <span class="none">
            <code>PACKAGE_TARNAME=''</code><br />
            </span>
            
            <span class="none">
            <code>PACKAGE_VERSION=''</code><br />
            </span>
            
            <span class="none">
            <code>PATH_SEPARATOR=':'</code><br />
            </span>
            
            <span class="none">
            <code>RANLIB='ranlib'</code><br />
            </span>
            
            <span class="none">
            <code>SET_MAKE=''</code><br />
            </span>
            
            <span class="none">
            <code>SHELL='/bin/sh'</code><br />
            </span>
            
            <span class="none">
            <code>STRIP='strip'</code><br />
            </span>
            
            <span class="none">
            <code>VERSION='1.27'</code><br />
            </span>
            
            <span class="none">
            <code>ac_ct_CC=''</code><br />
            </span>
            
            <span class="none">
            <code>ac_ct_CXX=''</code><br />
            </span>
            
            <span class="none">
            <code>ac_ct_F77='gfortran'</code><br />
            </span>
            
            <span class="none">
            <code>am__fastdepCC_FALSE='#'</code><br />
            </span>
            
            <span class="none">
            <code>am__fastdepCC_TRUE=''</code><br />
            </span>
            
            <span class="none">
            <code>am__fastdepCXX_FALSE='#'</code><br />
            </span>
            
            <span class="none">
            <code>am__fastdepCXX_TRUE=''</code><br />
            </span>
            
            <span class="none">
            <code>am__include='include'</code><br />
            </span>
            
            <span class="none">
            <code>am__isrc=''</code><br />
            </span>
            
            <span class="none">
            <code>am__leading_dot='.'</code><br />
            </span>
            
            <span class="none">
            <code>am__quote=''</code><br />
            </span>
            
            <span class="none">
            <code>am__tar='${AMTAR} chof - "$$tardir"'</code><br />
            </span>
            
            <span class="none">
            <code>am__untar='${AMTAR} xf -'</code><br />
            </span>
            
            <span class="none">
            <code>bindir='${exec_prefix}/bin'</code><br />
            </span>
            
            <span class="none">
            <code>build='x86_64-unknown-linux-gnu'</code><br />
            </span>
            
            <span class="none">
            <code>build_alias=''</code><br />
            </span>
            
            <span class="none">
            <code>build_cpu='x86_64'</code><br />
            </span>
            
            <span class="none">
            <code>build_os='linux-gnu'</code><br />
            </span>
            
            <span class="none">
            <code>build_vendor='unknown'</code><br />
            </span>
            
            <span class="none">
            <code>datadir='${datarootdir}'</code><br />
            </span>
            
            <span class="none">
            <code>datarootdir='${prefix}/share'</code><br />
            </span>
            
            <span class="none">
            <code>docdir='${datarootdir}/doc/${PACKAGE}'</code><br />
            </span>
            
            <span class="none">
            <code>dvidir='${docdir}'</code><br />
            </span>
            
            <span class="none">
            <code>exec_prefix='${prefix}'</code><br />
            </span>
            
            <span class="none">
            <code>host='x86_64-unknown-linux-gnu'</code><br />
            </span>
            
            <span class="none">
            <code>host_alias='x86_64-unknown-linux'</code><br />
            </span>
            
            <span class="none">
            <code>host_cpu='x86_64'</code><br />
            </span>
            
            <span class="none">
            <code>host_os='linux-gnu'</code><br />
            </span>
            
            <span class="none">
            <code>host_vendor='unknown'</code><br />
            </span>
            
            <span class="none">
            <code>htmldir='${docdir}'</code><br />
            </span>
            
            <span class="none">
            <code>includedir='${prefix}/include'</code><br />
            </span>
            
            <span class="none">
            <code>infodir='${datarootdir}/info'</code><br />
            </span>
            
            <span class="none">
            <code>install_sh='$(SHELL) /tmp/isapnptools/src/isapnptools-1.27/install-sh'</code><br />
            </span>
            
            <span class="none">
            <code>libdir='${exec_prefix}/lib'</code><br />
            </span>
            
            <span class="none">
            <code>libexecdir='${exec_prefix}/libexec'</code><br />
            </span>
            
            <span class="none">
            <code>localedir='${datarootdir}/locale'</code><br />
            </span>
            
            <span class="none">
            <code>localstatedir='${prefix}/var'</code><br />
            </span>
            
            <span class="none">
            <code>mandir='${datarootdir}/man'</code><br />
            </span>
            
            <span class="none">
            <code>mkdir_p='/usr/sbin/mkdir -p'</code><br />
            </span>
            
            <span class="none">
            <code>oldincludedir='/usr/include'</code><br />
            </span>
            
            <span class="none">
            <code>pdfdir='${docdir}'</code><br />
            </span>
            
            <span class="none">
            <code>prefix='/usr'</code><br />
            </span>
            
            <span class="none">
            <code>program_transform_name='s,x,x,'</code><br />
            </span>
            
            <span class="none">
            <code>psdir='${docdir}'</code><br />
            </span>
            
            <span class="none">
            <code>sbindir='/usr/bin'</code><br />
            </span>
            
            <span class="none">
            <code>sharedstatedir='${prefix}/com'</code><br />
            </span>
            
            <span class="none">
            <code>sysconfdir='${prefix}/etc'</code><br />
            </span>
            
            <span class="none">
            <code>target_alias=''</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>## ----------- ##</code><br />
            </span>
            
            <span class="none">
            <code>## confdefs.h. ##</code><br />
            </span>
            
            <span class="none">
            <code>## ----------- ##</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>#define PACKAGE_NAME ""</code><br />
            </span>
            
            <span class="none">
            <code>#define PACKAGE_TARNAME ""</code><br />
            </span>
            
            <span class="none">
            <code>#define PACKAGE_VERSION ""</code><br />
            </span>
            
            <span class="none">
            <code>#define PACKAGE_STRING ""</code><br />
            </span>
            
            <span class="none">
            <code>#define PACKAGE_BUGREPORT ""</code><br />
            </span>
            
            <span class="none">
            <code>#define PACKAGE "isapnptools"</code><br />
            </span>
            
            <span class="none">
            <code>#define VERSION "1.27"</code><br />
            </span>
            
            <span class="none">
            <code>#define STDC_HEADERS 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_SYS_TYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_SYS_STAT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_STDLIB_H 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_STRING_H 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_MEMORY_H 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_STRINGS_H 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_INTTYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_STDINT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_DLFCN_H 1</code><br />
            </span>
            
            <span class="none">
            <code>#define STDC_HEADERS 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_MALLOC_H 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_SYS_TIME_H 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>#define RETSIGTYPE void</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_VPRINTF 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_STRNCMP 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_STRDUP 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_STRERROR 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_STRTOL 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_STRTOUL 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_NANOSLEEP 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_SCHED_SETSCHEDULER 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_SNPRINTF 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_STRNCASECMP 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_GETDELIM 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_MEMCMP 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_USLEEP 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_ALARM 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_MEMSET 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_GETOPT_LONG 1</code><br />
            </span>
            
            <span class="none">
            <code>#define REALTIME 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_PROC 1</code><br />
            </span>
            
            <span class="none">
            <code>#define ENABLE_PCI 1</code><br />
            </span>
            
            <span class="none">
            <code>#define WANT_TO_VALIDATE 1</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>configure: exit 0</code><br />
            </span>
            
          </div>
        
      </div>
      <br />
    
  </body>
</html>