        <html><head></head><body>
        <h1>Report for mingw-w64-binutils on toolchain
            <a href="index.html">android</a>
        </h1>
        <p>Return code: 5</p>
        <p>Time to run: 00:01:54</p>
        <p>Log output:</p>
        <code><pre><docker run --rm -v /tuscan_data --volumes-from tuscan_data -v /sources --volumes-from sources -v /var/cache/pacman/pkg --volumes-from pkg_cache_android -v logs:/logs make_package_container --sources-directory /sources --shared-directory /tuscan_data mingw-w64-binutils
:: Synchronizing package databases...
downloading repo.db...
downloading core.db...
downloading extra.db...
downloading community.db...
Found 1825 packages in cache
===> sudo -u tuscan makepkg --nobuild --syncdeps --skipinteg --skippgpcheck --skipchecksums --noconfirm --nocolor --log --noprogressbar --nocheck
==> Making package: mingw-w64-binutils 2.25.1-1 (Fri Nov 13 23:46:54 UTC 2015)
==> Checking runtime dependencies...
==> Checking buildtime dependencies...
==> Retrieving sources...
  -> Downloading binutils-2.25.1.tar.gz...
  -> Found binutils-2.24-CVE-2014-8484.patch
  -> Found binutils-2.24-CVE-2014-8485.patch
  -> Found binutils-2.24-CVE-2014-8501.patch
  -> Found binutils-2.24-CVE-2014-8502.patch
  -> Found binutils-2.24-CVE-2014-8502-pre.patch
  -> Found binutils-2.24-CVE-2014-8503.patch
  -> Found binutils-2.24-CVE-2014-8504.patch
  -> Found binutils-2.24-CVE-2014-8737.patch
  -> Found binutils-2.24-CVE-2014-8738.patch
  -> Found binutils-2.24-strings-all-default.patch
==> WARNING: Skipping all source file integrity checks.
==> Extracting sources...
  -> Extracting binutils-2.25.1.tar.gz with bsdtar
==> Starting prepare()...
==> Sources are ready.
Copied source directory to /sources/mingw-w64-binutils
===> sudo -u tuscan PATH=/tmp/toolchain/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin CC=arm-linux-androideabi-gcc CXX=arm-linux-androideabi-g++ SYSROOT=/build/android-ndk-r10e/platforms/android-21/arch-arm makepkg --noextract --syncdeps --skipinteg --skippgpcheck --skipchecksums --noconfirm --nocolor --log --noprogressbar --nocheck
==> Making package: mingw-w64-binutils 2.25.1-1 (Fri Nov 13 23:47:15 UTC 2015)
==> Checking runtime dependencies...
==> Checking buildtime dependencies...
==> WARNING: Using existing $srcdir/ tree
==> Starting build()...
==> Building i686-w64-mingw32 cross binutils
configure: WARNING: If you wanted to set the --build type, don't use --host.
    If a cross compiler is detected then cross compile mode will be used.
checking build system type... x86_64-unknown-linux-gnu
checking host system type... x86_64-unknown-linux-gnu
checking target system type... i686-w64-mingw32
checking for a BSD-compatible install... /usr/bin/install -c
checking whether ln works... yes
checking whether ln -s works... yes
checking for a sed that does not truncate output... /usr/sbin/sed
checking for gawk... gawk
checking for x86_64-unknown-linux-gcc... arm-linux-androideabi-gcc
checking for C compiler default output file name... a.out
checking whether the C compiler works... yes
checking whether we are cross compiling... yes
checking for suffix of executables... 
checking for suffix of object files... o
checking whether we are using the GNU C compiler... yes
checking whether arm-linux-androideabi-gcc accepts -g... yes
checking for arm-linux-androideabi-gcc option to accept ISO C89... none needed
checking whether we are using the GNU C++ compiler... yes
checking whether arm-linux-androideabi-g++ accepts -g... yes
checking whether g++ accepts -static-libstdc++ -static-libgcc... yes
checking for x86_64-unknown-linux-gnatbind... no
checking for gnatbind... no
checking for x86_64-unknown-linux-gnatmake... no
checking for gnatmake... no
checking whether compiler driver understands Ada... no
checking how to compare bootstrapped objects... cmp --ignore-initial=16 $$f1 $$f2
checking for objdir... .libs
checking for version 0.10 of ISL... yes
checking for version 0.17.0 of CLooG... no
checking for version 0.18.0 of CLooG... no
checking for default BUILD_CONFIG... 
checking for --enable-vtable-verify... no
checking for bison... bison -y
checking for bison... bison
checking for gm4... no
checking for gnum4... no
checking for m4... m4
checking for flex... flex
checking for flex... flex
checking for makeinfo... makeinfo
checking for expect... no
checking for runtest... no
checking for x86_64-unknown-linux-ar... no
checking for ar... ar
checking for x86_64-unknown-linux-as... no
checking for as... as
checking for x86_64-unknown-linux-dlltool... no
checking for dlltool... no
checking for ld... (cached) /tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld
checking for x86_64-unknown-linux-ld... (cached) /tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld
checking for x86_64-unknown-linux-lipo... no
checking for lipo... no
checking for x86_64-unknown-linux-nm... no
checking for nm... nm
checking for x86_64-unknown-linux-ranlib... no
checking for ranlib... ranlib
checking for x86_64-unknown-linux-strip... no
checking for strip... strip
checking for x86_64-unknown-linux-windres... no
checking for windres... no
checking for x86_64-unknown-linux-windmc... no
checking for windmc... no
checking for x86_64-unknown-linux-objcopy... no
checking for objcopy... objcopy
checking for x86_64-unknown-linux-objdump... no
checking for objdump... objdump
checking for x86_64-unknown-linux-readelf... no
checking for readelf... readelf
checking for i686-w64-mingw32-cc... no
checking for i686-w64-mingw32-gcc... no
checking for i686-w64-mingw32-c++... no
checking for i686-w64-mingw32-g++... no
checking for i686-w64-mingw32-cxx... no
checking for i686-w64-mingw32-gxx... no
checking for i686-w64-mingw32-gcc... no
checking for i686-w64-mingw32-gcj... no
checking for i686-w64-mingw32-gfortran... no
checking for i686-w64-mingw32-gccgo... no
checking for i686-w64-mingw32-ar... no
checking for i686-w64-mingw32-as... no
checking for i686-w64-mingw32-dlltool... no
checking for i686-w64-mingw32-ld... no
checking for i686-w64-mingw32-lipo... no
checking for i686-w64-mingw32-nm... no
checking for i686-w64-mingw32-objdump... no
checking for i686-w64-mingw32-ranlib... no
checking for i686-w64-mingw32-readelf... no
checking for i686-w64-mingw32-strip... no
checking for i686-w64-mingw32-windres... no
checking for i686-w64-mingw32-windmc... no
checking where to find the target ar... just compiled
checking where to find the target as... just compiled
checking where to find the target cc... pre-installed
checking where to find the target c++... pre-installed
checking where to find the target c++ for libstdc++... pre-installed
checking where to find the target dlltool... just compiled
checking where to find the target gcc... pre-installed
checking where to find the target gcj... pre-installed
checking where to find the target gfortran... pre-installed
checking where to find the target gccgo... pre-installed
checking where to find the target ld... just compiled
checking where to find the target lipo... pre-installed
checking where to find the target nm... just compiled
checking where to find the target objdump... just compiled
checking where to find the target ranlib... just compiled
checking where to find the target readelf... just compiled
checking where to find the target strip... just compiled
checking where to find the target windres... just compiled
checking where to find the target windmc... just compiled
checking whether to enable maintainer-specific portions of Makefiles... no
configure: creating ./config.status
config.status: creating Makefile
make[1]: Entering directory '/tmp/mingw-w64-binutils/src/binutils-i686-w64-mingw32'
mkdir -p -- ./libiberty
Configuring in ./libiberty
mkdir -p -- ./intl
Configuring in ./intl
configure: creating cache ./config.cache
checking whether make sets $(MAKE)... configure: creating cache ./config.cache
checking whether to enable maintainer-specific portions of Makefiles... no
checking for makeinfo... makeinfo --split-size=5000000
yes
checking for a BSD-compatible install... /usr/bin/install -c
checking whether NLS is requested... no
checking for msgfmt... /usr/sbin/msgfmt
checking for gmsgfmt... /usr/sbin/msgfmt
checking for xgettext... /usr/sbin/xgettext
checking for msgmerge... /usr/sbin/msgmerge
checking for x86_64-unknown-linux-gcc... arm-linux-androideabi-gcc
checking for C compiler default output file name... a.out
checking whether the C compiler works... yes
checking whether we are cross compiling... yes
checking for suffix of executables... 
checking for suffix of object files... checking for perl... perl
checking build system type... o
checking whether we are using the GNU C compiler... x86_64-unknown-linux-gnu
checking host system type... yes
checking whether arm-linux-androideabi-gcc accepts -g... yes
checking for arm-linux-androideabi-gcc option to accept ISO C89... x86_64-unknown-linux-gnu
checking for x86_64-unknown-linux-ar... ar
checking for x86_64-unknown-linux-ranlib... ranlib
checking whether to install libiberty headers and static library... no
configure: target_header_dir = 
checking for x86_64-unknown-linux-gcc... arm-linux-androideabi-gcc
none needed
checking build system type... x86_64-unknown-linux-gnu
checking host system type... x86_64-unknown-linux-gnu
checking for x86_64-unknown-linux-ranlib... ranlib
checking for library containing strerror... checking for C compiler default output file name... none required
checking how to run the C preprocessor... a.out
checking whether the C compiler works... yes
checking whether we are cross compiling... yes
checking for suffix of executables... arm-linux-androideabi-gcc -E

checking for suffix of object files... checking for grep that handles long lines and -e... /usr/sbin/grep
checking for egrep... /usr/sbin/grep -E
checking for ANSI C header files... o
checking whether we are using the GNU C compiler... yes
checking whether arm-linux-androideabi-gcc accepts -g... yes
checking for arm-linux-androideabi-gcc option to accept ISO C89... yes
checking for an ANSI C-conforming const... yes
checking for inline... none needed
checking for special C compiler options needed for large files... no
checking for _FILE_OFFSET_BITS value needed for large files... inline
checking for sys/types.h... yes
checking for sys/stat.h... unknown
checking for _LARGE_FILES value needed for large files... yes
checking for stdlib.h... yes
checking for string.h... unknown
checking how to run the C preprocessor... arm-linux-androideabi-gcc -E
yes
checking for memory.h... yes
checking whether arm-linux-androideabi-gcc supports -W... checking for strings.h... yes
checking whether arm-linux-androideabi-gcc supports -Wall... yes
yes
checking whether arm-linux-androideabi-gcc supports -Wwrite-strings... checking for inttypes.h... yes
checking whether arm-linux-androideabi-gcc supports -Wc++-compat... yes
checking for stdint.h... yes
yes
checking whether arm-linux-androideabi-gcc supports -Wstrict-prototypes... checking for unistd.h... yes
yes
checking whether arm-linux-androideabi-gcc supports -pedantic ... checking for off_t... yes
checking whether arm-linux-androideabi-gcc and cc understand -c and -o together... yes
checking for size_t... yes
checking for working alloca.h... yes
checking for alloca... yes
checking for an ANSI C-conforming const... yes
checking for inline... yes
checking for stdlib.h... (cached) yes
checking for unistd.h... (cached) yes
checking for getpagesize... inline
checking for grep that handles long lines and -e... /usr/sbin/grep
checking for egrep... /usr/sbin/grep -E
checking for ANSI C header files... yes
checking for working mmap... no
checking whether we are using the GNU C Library 2.1 or newer... no
checking whether integer division by zero raises SIGFPE... guessing no
checking for inttypes.h... yes
checking for sys/types.h... yes
checking for stdint.h... yes
checking for sys/stat.h... yes
checking for unsigned long long... yes
checking for stdlib.h... yes
yes
checking for inttypes.h... checking for string.h... yes
checking for memory.h... yes
yes
checking whether the inttypes.h PRIxNN macros are broken... checking for strings.h... yes
checking for inttypes.h... no
checking for ld used by GCC... yes
/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld
checking if the linker (/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld) is GNU ld... yes
checking for shared library run path origin... checking for stdint.h... yes
checking for unistd.h... done
checking argz.h usability... yes
checking whether byte ordering is bigendian... no
checking argz.h presence... no
checking for argz.h... no
checking limits.h usability... yes
checking limits.h presence... yes
checking for limits.h... yes
checking locale.h usability... no
checking for a BSD-compatible install... /usr/bin/install -c
checking for sys/file.h... yes
checking locale.h presence... yes
checking for sys/param.h... yes
checking for locale.h... yes
checking nl_types.h usability... yes
checking for limits.h... yes
checking for stdlib.h... (cached) yes
checking for malloc.h... yes
checking for string.h... (cached) yes
no
checking nl_types.h presence... checking for unistd.h... (cached) yes
checking for strings.h... (cached) yes
no
checking for nl_types.h... no
checking malloc.h usability... checking for sys/time.h... yes
checking for time.h... yes
checking malloc.h presence... yes
checking for malloc.h... yes
checking stddef.h usability... yes
checking for sys/resource.h... yes
checking for sys/stat.h... (cached) yes
yes
checking stddef.h presence... checking for sys/mman.h... yes
checking for stddef.h... yes
yes
checking for stdlib.h... (cached) yes
checking for fcntl.h... checking for string.h... (cached) yes
checking for unistd.h... (cached) yes
checking sys/param.h usability... yes
checking for alloca.h... yes
checking for sys/pstat.h... no
checking for sys/sysmp.h... no
checking for sys/sysinfo.h... yes
yes
checking sys/param.h presence... checking for machine/hal_sysinfo.h... yes
checking for sys/param.h... yes
checking for feof_unlocked... no
checking for sys/table.h... no
checking for sys/sysctl.h... no
checking for fgets_unlocked... no
checking for sys/systemcfg.h... no
checking for stdint.h... (cached) yes
checking for stdio_ext.h... no
checking for getc_unlocked... no
checking for process.h... no
yes
checking for sys/prctl.h... checking for getcwd... yes
checking for sys/wait.h that is POSIX.1 compatible... yes
checking whether time.h and sys/time.h may both be included... yes
checking for getegid... yes
checking whether errno must be declared... yes
checking for geteuid... no
checking size of int... yes
checking for getgid... yes
checking for getuid... yes
checking for mempcpy... no
checking for munmap... yes
checking for putenv... yes
checking for setenv... yes
checking for setlocale... 4
checking for a 64-bit type... yes
checking for stpcpy... uint64_t
checking for intptr_t... yes
checking for strcasecmp... yes
checking for uintptr_t... yes
checking for strdup... yes
checking for strtoul... yes
checking for tsearch... yes
checking for ssize_t... yes
checking for __argz_count... no
checking for __argz_stringify... yes
checking for pid_t... no
checking for __argz_next... no
yes
checking for __fsetlocking... checking for library containing strerror... none required
checking for asprintf... no
checking for iconv... yes
checking for atexit... no, consider installing GNU libiconv
checking for nl_langinfo and CODESET... yes
checking for basename... no
checking for LC_MESSAGES... yes
yes
checking for bison... bison
checking version of bison... checking for bcmp... 3.0.4, ok
checking whether NLS is requested... no
checking whether to use NLS... no
checking for aclocal... aclocal
checking for autoconf... autoconf
checking for autoheader... autoheader
configure: updating cache ./config.cache
configure: creating ./config.status
no
checking for bcopy... yes
checking for bsearch... yes
checking for bzero... config.status: creating Makefile
config.status: creating config.intl
config.status: creating config.h
config.status: executing default-1 commands
yes
checking for calloc... make[1]: Nothing to be done for 'all-target'.
yes
mkdir -p -- ./etc
Configuring in ./etc
checking for clock... yes
checking for ffs... yes
checking for getcwd... yes
configure: creating cache ./config.cache
checking for a BSD-compatible install... /usr/bin/install -c
checking for getpagesize... configure: updating cache ./config.cache
configure: creating ./config.status
yes
checking for gettimeofday... yes
checking for index... config.status: creating Makefile
make[2]: Entering directory '/tmp/mingw-w64-binutils/src/binutils-i686-w64-mingw32/intl'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/tmp/mingw-w64-binutils/src/binutils-i686-w64-mingw32/intl'
mkdir -p -- ./binutils
Configuring in ./binutils
yes
checking for insque... configure: creating cache ./config.cache
yes
checking build system type... checking for memchr... x86_64-unknown-linux-gnu
checking host system type... x86_64-unknown-linux-gnu
checking target system type... i686-w64-mingw32
checking for x86_64-unknown-linux-gcc... arm-linux-androideabi-gcc
yes
checking for memcmp... checking for C compiler default output file name... a.out
checking whether the C compiler works... yes
yes
checking whether we are cross compiling... yes
checking for suffix of executables... checking for memcpy... 
checking for suffix of object files... yes
o
checking whether we are using the GNU C compiler... checking for memmem... yes
checking whether arm-linux-androideabi-gcc accepts -g... yes
checking for memmove... yes
checking for arm-linux-androideabi-gcc option to accept ISO C89... yes
none needed
checking for library containing strerror... checking for mempcpy... none required
checking for a BSD-compatible install... /usr/bin/install -c
checking whether build environment is sane... no
checking for memset... yes
checking for mkstemps... yes
checking for putenv... yes
checking for random... yes
checking for rename... yes
checking for rindex... no
checking for setenv... yes
checking for snprintf... yes
checking for sigsetmask... yes
checking for x86_64-unknown-linux-strip... no
checking for strip... strip
configure: WARNING: using cross tools not prefixed with host triplet
checking for a thread-safe mkdir -p... /usr/sbin/mkdir -p
checking for gawk... gawk
checking whether make sets $(MAKE)... yes
checking for stpcpy... yes
checking for style of include used by make... GNU
checking dependency style of arm-linux-androideabi-gcc... yes
checking for stpncpy... gcc3
checking for x86_64-unknown-linux-gcc... (cached) arm-linux-androideabi-gcc
yes
checking for strcasecmp... checking whether we are using the GNU C compiler... (cached) yes
checking whether arm-linux-androideabi-gcc accepts -g... (cached) yes
checking for arm-linux-androideabi-gcc option to accept ISO C89... (cached) none needed
checking how to run the C preprocessor... yes
arm-linux-androideabi-gcc -E
checking for strchr... checking for grep that handles long lines and -e... /usr/sbin/grep
checking for egrep... /usr/sbin/grep -E
checking for ANSI C header files... yes
checking for strdup... yes
checking for strncasecmp... yes
checking for sys/types.h... yes
yes
checking for strndup... checking for sys/stat.h... yes
yes
checking for stdlib.h... checking for strnlen... yes
yes
checking for string.h... checking for strrchr... yes
checking for memory.h... yes
checking for strstr... yes
checking for strings.h... yes
checking for strtod... yes
checking for inttypes.h... yes
checking for strtol... yes
yes
checking for strtoul... checking for stdint.h... yes
yes
checking for unistd.h... checking for strverscmp... yes
no
checking for tmpnam... checking minix/config.h usability... yes
checking for vasprintf... no
checking minix/config.h presence... no
checking for minix/config.h... no
checking whether it is safe to define __EXTENSIONS__... yes
checking for vfprintf... yes
checking how to print strings... printf
checking for a sed that does not truncate output... /usr/sbin/sed
yes
checking for fgrep... /usr/sbin/grep -F
checking for ld used by arm-linux-androideabi-gcc... checking for vprintf... /tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld
checking if the linker (/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld) is GNU ld... yes
checking for BSD- or MS-compatible name lister (nm)... nm
checking the name lister (nm) interface... yes
checking for vsnprintf... BSD nm
checking whether ln -s works... yes
checking the maximum length of command line arguments... 1572864
checking whether the shell understands some XSI constructs... yes
checking whether the shell understands "+="... yes
checking for /tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld option to reload object files... -r
checking for x86_64-unknown-linux-objdump... objdump
checking how to recognize dependent libraries... pass_all
checking for x86_64-unknown-linux-ar... ar
yes
checking for x86_64-unknown-linux-strip... strip
checking for x86_64-unknown-linux-ranlib... ranlib
checking command to parse nm output from arm-linux-androideabi-gcc object... checking for vsprintf... yes
checking for waitpid... ok
yes
checking for dlfcn.h... checking for setproctitle... no
checking whether alloca needs Cray hooks... yes
checking for objdir... no
checking stack direction for C alloca... 0
.libs
checking for vfork.h... no
checking for fork... checking if arm-linux-androideabi-gcc supports -fno-rtti -fno-exceptions... yes
no
checking for arm-linux-androideabi-gcc option to produce PIC... -fPIC -DPIC
checking if arm-linux-androideabi-gcc PIC flag -fPIC -DPIC works... checking for vfork... yes
yes
checking if arm-linux-androideabi-gcc static flag -static works... checking for working fork... cross
configure: WARNING: result yes guessed because of cross compilation
checking for working vfork... (cached) yes
checking for _doprnt... yes
checking if arm-linux-androideabi-gcc supports -c -o file.o... no
checking for sys_errlist... yes
checking if arm-linux-androideabi-gcc supports -c -o file.o... (cached) yes
checking whether the arm-linux-androideabi-gcc linker (/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld -m elf_i386) supports shared libraries... yes
checking whether -lc should be explicitly linked in... no
checking for sys_nerr... no
checking dynamic linker characteristics... no
checking for sys_siglist... yes
checking for external symbol _system_configuration... GNU/Linux ld.so
checking how to hardcode library paths into programs... immediate
checking whether stripping libraries is possible... yes
checking if libtool supports shared libraries... yes
checking whether to build shared libraries... yes
checking whether to build static libraries... yes
checking for dlfcn.h... (cached) yes
checking for windows.h... no
checking for __fsetlocking... no
checking for library containing dlopen... no
checking for canonicalize_file_name... none required
checking for special C compiler options needed for large files... no
checking for _FILE_OFFSET_BITS value needed for large files... no
checking for dup3... unknown
checking for _LARGE_FILES value needed for large files... yes
checking for getrlimit... yes
unknown
checking for getrusage... Setting warning flags = -W -Wall -Wstrict-prototypes -Wmissing-prototypes -Wshadow
checking for bison... bison -y
checking for flex... flex
checking lex output file root... lex.yy
checking lex library... yes
checking for getsysinfo... no
checking for gettimeofday... (cached) yes
checking for on_exit... no
checking for psignal... yes
checking for pstat_getdynamic... no
checking for pstat_getstatic... none needed
checking whether yytext is a pointer... no
checking for realpath... yes
checking for setrlimit... yes
checking for sbrk... no
checking whether NLS is requested... no
checking whether NLS is requested... no
yes
checking for msgfmt... checking for spawnve... /usr/sbin/msgfmt
checking for gmsgfmt... /usr/sbin/msgfmt
checking for xgettext... /usr/sbin/xgettext
checking for msgmerge... /usr/sbin/msgmerge
no
checking for spawnvpe... checking whether to enable maintainer-specific portions of Makefiles... no
checking for x86_64-unknown-linux-ranlib... (cached) ranlib
checking for build system executable suffix... no
checking size of long... no
checking for strerror... yes
checking for strsignal... yes
checking for sysconf... yes
checking for sysctl... no
checking for sysmp... no
checking for table... no
checking for times... yes
checking for wait3... 4
checking for long long... yes
checking for wait4... yes
checking whether basename is declared... yes
checking size of long long... no
checking whether ffs is declared... yes
checking whether asprintf is declared... yes
checking whether vasprintf is declared... yes
checking whether snprintf is declared... yes
checking whether vsnprintf is declared... yes
checking whether calloc is declared... yes
checking whether getenv is declared... yes
checking whether getopt is declared... 8
checking for string.h... (cached) yes
checking for strings.h... (cached) yes
yes
checking whether malloc is declared... checking for stdlib.h... (cached) yes
checking for unistd.h... (cached) yes
checking fcntl.h usability... yes
checking fcntl.h presence... yes
checking whether realloc is declared... yes
checking for fcntl.h... yes
checking sys/file.h usability... yes
yes
checking sys/file.h presence... checking whether sbrk is declared... yes
checking for sys/file.h... yes
checking limits.h usability... yes
checking whether strverscmp is declared... yes
checking limits.h presence... yes
checking for limits.h... yes
checking locale.h usability... no
checking whether canonicalize_file_name must be declared... yes
checking locale.h presence... yes
checking for locale.h... yes
yes
checking for stdlib.h... (cached) yes
checking sys/param.h usability... checking for unistd.h... (cached) yes
checking for getpagesize... (cached) yes
checking for working mmap... no
checking for working strncmp... yes
yes
checking sys/param.h presence... configure: updating cache ./config.cache
yes
checking for sys/param.h... yes
checking wchar.h usability... configure: creating ./config.status
yes
checking wchar.h presence... yes
checking for wchar.h... yes
checking for sys/wait.h that is POSIX.1 compatible... yes
checking whether string.h and strings.h may both be included... config.status: creating Makefile
config.status: creating testsuite/Makefile
yes
checking for working alloca.h... config.status: creating config.h
config.status: executing default commands
yes
checking for alloca... mkdir -p -- ./gas
Configuring in ./gas
yes
checking for sbrk... yes
checking for utimes... yes
checking for setmode... configure: creating cache ./config.cache
no
checking build system type... checking for getc_unlocked... x86_64-unknown-linux-gnu
checking host system type... x86_64-unknown-linux-gnu
checking target system type... yes
i686-w64-mingw32
checking for x86_64-unknown-linux-gcc... arm-linux-androideabi-gcc
checking for C compiler default output file name... a.out
checking whether the C compiler works... yes
checking whether we are cross compiling... yes
checking for suffix of executables... checking for strcoll... 
checking for suffix of object files... o
checking whether we are using the GNU C compiler... yes
checking for setlocale... yes
checking whether arm-linux-androideabi-gcc accepts -g... yes
yes
checking for arm-linux-androideabi-gcc option to accept ISO C89... checking for mkstemp... yes
checking for mkdtemp... none needed
checking for library containing strerror... none required
checking for a BSD-compatible install... /usr/bin/install -c
checking whether build environment is sane... yes
checking for mbstate_t... yes
checking for library containing frexp... yes
checking for x86_64-unknown-linux-strip... no
checking for strip... strip
configure: WARNING: using cross tools not prefixed with host triplet
checking for a thread-safe mkdir -p... /usr/sbin/mkdir -p
checking for gawk... gawk
checking whether make sets $(MAKE)... yes
checking for style of include used by make... GNU
checking dependency style of arm-linux-androideabi-gcc... gcc3
checking for x86_64-unknown-linux-gcc... (cached) arm-linux-androideabi-gcc
checking whether we are using the GNU C compiler... (cached) yes
checking whether arm-linux-androideabi-gcc accepts -g... (cached) yes
checking for arm-linux-androideabi-gcc option to accept ISO C89... (cached) none needed
checking how to run the C preprocessor... arm-linux-androideabi-gcc -E
checking for grep that handles long lines and -e... /usr/sbin/grep
checking for egrep... /usr/sbin/grep -E
checking for ANSI C header files... yes
checking for sys/types.h... yes
checking for sys/stat.h... yes
checking for stdlib.h... yes
checking for string.h... yes
checking for memory.h... yes
checking for strings.h... yes
checking for inttypes.h... yes
-lm
checking for LC_MESSAGES... checking for stdint.h... yes
yes
checking for time_t in time.h... checking for unistd.h... yes
checking for time_t in sys/types.h... yes
yes
checking for a known getopt prototype in unistd.h... checking minix/config.h usability... yes
checking for utime.h... no
checking minix/config.h presence... no
checking for minix/config.h... no
checking whether it is safe to define __EXTENSIONS__... yes
checking whether environ is declared... yes
checking how to print strings... printf
checking for a sed that does not truncate output... /usr/sbin/sed
checking for fgrep... /usr/sbin/grep -F
checking for ld used by arm-linux-androideabi-gcc... yes
checking whether fprintf is declared... /tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld
checking if the linker (/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld) is GNU ld... yes
checking for BSD- or MS-compatible name lister (nm)... nm
checking the name lister (nm) interface... yes
checking whether getc_unlocked is declared... BSD nm
checking whether ln -s works... yes
checking the maximum length of command line arguments... 1572864
checking whether the shell understands some XSI constructs... yes
checking whether the shell understands "+="... yes
yes
checking for /tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld option to reload object files... -r
checking for x86_64-unknown-linux-objdump... objdump
checking how to recognize dependent libraries... pass_all
checking for x86_64-unknown-linux-ar... ar
checking for x86_64-unknown-linux-strip... strip
checking for x86_64-unknown-linux-ranlib... ranlib
checking command to parse nm output from arm-linux-androideabi-gcc object... checking whether getenv is declared... yes
checking whether sbrk is declared... ok
yes
checking whether snprintf is declared... checking for dlfcn.h... yes
checking whether stpcpy is declared... yes
checking for objdir... .libs
yes
checking whether strnlen is declared... checking if arm-linux-androideabi-gcc supports -fno-rtti -fno-exceptions... yes
no
checking for arm-linux-androideabi-gcc option to produce PIC... -fPIC -DPIC
checking if arm-linux-androideabi-gcc PIC flag -fPIC -DPIC works... checking whether strstr is declared... yes
checking if arm-linux-androideabi-gcc static flag -static works... yes
checking whether vsnprintf is declared... yes
checking if arm-linux-androideabi-gcc supports -c -o file.o... yes
checking for library containing zlibVersion... yes
checking if arm-linux-androideabi-gcc supports -c -o file.o... (cached) yes
checking whether the arm-linux-androideabi-gcc linker (/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld -m elf_i386) supports shared libraries... yes
checking whether -lc should be explicitly linked in... no
checking dynamic linker characteristics... -lz
checking zlib.h usability... yes
checking zlib.h presence... yes
checking for zlib.h... yes
checking iconv.h usability... GNU/Linux ld.so
checking how to hardcode library paths into programs... immediate
checking whether stripping libraries is possible... yes
checking if libtool supports shared libraries... yes
checking whether to build shared libraries... yes
checking whether to build static libraries... yes
checking for dlfcn.h... (cached) yes
checking for windows.h... no
checking iconv.h presence... no
checking for library containing dlopen... no
checking for iconv.h... no
checking for ld used by GCC... none required
checking for special C compiler options needed for large files... no
checking for _FILE_OFFSET_BITS value needed for large files... /tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld -m elf_i386
checking if the linker (/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld -m elf_i386) is GNU ld... yes
checking for shared library run path origin... done
checking for iconv... unknown
checking for _LARGE_FILES value needed for large files... no, consider installing GNU libiconv
unknown
Setting warning flags = -W -Wall -Wstrict-prototypes -Wmissing-prototypes -Wshadow
checking whether byte ordering is bigendian... configure: updating cache ./config.cache
configure: creating ./config.status
no
checking for bison... bison -y
checking for flex... flex
checking lex output file root... lex.yy
checking lex library... none needed
checking whether yytext is a pointer... config.status: creating Makefile
config.status: creating doc/Makefile
config.status: creating po/Makefile.in
no
checking whether NLS is requested... no
checking whether NLS is requested... no
checking for msgfmt... /usr/sbin/msgfmt
checking for gmsgfmt... /usr/sbin/msgfmt
checking for xgettext... /usr/sbin/xgettext
config.status: creating config.h
checking for msgmerge... config.status: executing depfiles commands
/usr/sbin/msgmerge
checking whether to enable maintainer-specific portions of Makefiles... no
checking for string.h... (cached) yes
checking for stdlib.h... (cached) yes
checking for memory.h... (cached) yes
checking for strings.h... (cached) yes
checking for unistd.h... (cached) yes
checking errno.h usability... yes
checking errno.h presence... yes
checking for errno.h... yes
checking for sys/types.h... (cached) yes
checking limits.h usability... yes
checking limits.h presence... config.status: executing libtool commands
yes
checking for limits.h... yes
checking locale.h usability... config.status: executing default-1 commands
config.status: creating po/POTFILES
config.status: creating po/Makefile
yes
checking locale.h presence... yes
checking for locale.h... yes
checking time.h usability... make[2]: Entering directory '/tmp/mingw-w64-binutils/src/binutils-i686-w64-mingw32/etc'
make[2]: Nothing to be done for 'all'.
make[2]: Leaving directory '/tmp/mingw-w64-binutils/src/binutils-i686-w64-mingw32/etc'
mkdir -p -- ./gprof
Configuring in ./gprof
yes
checking time.h presence... yes
checking for time.h... yes
checking for sys/stat.h... (cached) yes
checking whether string.h and strings.h may both be included... yes
checking whether compiling a cross-assembler... yes
checking for working alloca.h... yes
checking for alloca... yes
checking for inline... configure: creating cache ./config.cache
inline
checking build system type... checking for unlink... x86_64-unknown-linux-gnu
checking host system type... yes
x86_64-unknown-linux-gnu
checking target system type... checking for sbrk... i686-w64-mingw32
checking for x86_64-unknown-linux-gcc... arm-linux-androideabi-gcc
yes
checking for C compiler default output file name... checking for setlocale... a.out
checking whether the C compiler works... yes
checking whether we are cross compiling... yes
checking for suffix of executables... yes
checking for LC_MESSAGES... 
checking for suffix of object files... yes
checking for working assert macro... o
checking whether we are using the GNU C compiler... yes
checking whether arm-linux-androideabi-gcc accepts -g... yes
checking whether declaration is required for errno... yes
checking for arm-linux-androideabi-gcc option to accept ISO C89... no
checking for a known getopt prototype in unistd.h... none needed
checking for library containing strerror... yes
checking whether declaration is required for environ... none required
checking for a BSD-compatible install... /usr/bin/install -c
checking whether build environment is sane... no
checking whether declaration is required for ffs... no
checking whether declaration is required for free... no
checking whether declaration is required for malloc... no
checking whether declaration is required for sbrk... no
checking whether declaration is required for strstr... no
checking whether free is declared... yes
checking whether getenv is declared... yes
checking whether malloc is declared... yes
checking whether mempcpy is declared... no
checking whether realloc is declared... yes
checking whether stpcpy is declared... yes
yes
checking whether strstr is declared... checking for x86_64-unknown-linux-strip... no
checking for strip... strip
configure: WARNING: using cross tools not prefixed with host triplet
checking for a thread-safe mkdir -p... /usr/sbin/mkdir -p
checking for gawk... gawk
checking whether make sets $(MAKE)... yes
checking for style of include used by make... GNU
checking dependency style of arm-linux-androideabi-gcc... yes
checking whether vsnprintf is declared... gcc3
checking for x86_64-unknown-linux-gcc... (cached) arm-linux-androideabi-gcc
yes
checking for library containing zlibVersion... checking whether we are using the GNU C compiler... (cached) yes
checking whether arm-linux-androideabi-gcc accepts -g... (cached) yes
checking for arm-linux-androideabi-gcc option to accept ISO C89... (cached) none needed
checking how to run the C preprocessor... arm-linux-androideabi-gcc -E
checking for grep that handles long lines and -e... /usr/sbin/grep
checking for egrep... -lz
checking zlib.h usability... /usr/sbin/grep -E
checking for ANSI C header files... yes
checking zlib.h presence... yes
checking for zlib.h... yes
checking for struct tm.tm_gmtoff in time.h... yes
checking for sys/types.h... yes
checking for struct stat.st_mtim.tv_sec in sys/stat.h... yes
checking for sys/stat.h... no
checking for struct stat.st_mtim.tv_nsec in sys/stat.h... yes
checking for stdlib.h... no
configure: updating cache ./config.cache
configure: creating ./config.status
yes
checking for string.h... yes
checking for memory.h... yes
checking for strings.h... yes
checking for inttypes.h... yes
checking for stdint.h... yes
checking for unistd.h... yes
checking minix/config.h usability... no
checking minix/config.h presence... no
checking for minix/config.h... no
checking whether it is safe to define __EXTENSIONS__... yes
checking how to print strings... printf
checking for a sed that does not truncate output... /usr/sbin/sed
checking for fgrep... /usr/sbin/grep -F
checking for ld used by arm-linux-androideabi-gcc... /tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld
checking if the linker (/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld) is GNU ld... yes
checking for BSD- or MS-compatible name lister (nm)... nm
checking the name lister (nm) interface... BSD nm
checking whether ln -s works... yes
checking the maximum length of command line arguments... 1572864
checking whether the shell understands some XSI constructs... yes
checking whether the shell understands "+="... yes
checking for /tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld option to reload object files... -r
checking for x86_64-unknown-linux-objdump... objdump
checking how to recognize dependent libraries... pass_all
checking for x86_64-unknown-linux-ar... ar
checking for x86_64-unknown-linux-strip... strip
checking for x86_64-unknown-linux-ranlib... ranlib
checking command to parse nm output from arm-linux-androideabi-gcc object... config.status: creating .gdbinit
ok
config.status: creating Makefile
checking for dlfcn.h... config.status: creating doc/Makefile
config.status: creating po/Makefile.in
yes
checking for objdir... config.status: creating config.h
.libs
config.status: executing depfiles commands
checking if arm-linux-androideabi-gcc supports -fno-rtti -fno-exceptions... no
checking for arm-linux-androideabi-gcc option to produce PIC... -fPIC -DPIC
checking if arm-linux-androideabi-gcc PIC flag -fPIC -DPIC works... yes
checking if arm-linux-androideabi-gcc static flag -static works... yes
checking if arm-linux-androideabi-gcc supports -c -o file.o... yes
checking if arm-linux-androideabi-gcc supports -c -o file.o... (cached) yes
checking whether the arm-linux-androideabi-gcc linker (/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld -m elf_i386) supports shared libraries... yes
checking whether -lc should be explicitly linked in... no
checking dynamic linker characteristics... GNU/Linux ld.so
checking how to hardcode library paths into programs... immediate
checking whether stripping libraries is possible... yes
checking if libtool supports shared libraries... yes
checking whether to build shared libraries... yes
checking whether to build static libraries... yes
checking for dlfcn.h... (cached) yes
checking for windows.h... config.status: executing libtool commands
config.status: executing default-1 commands
no
checking for library containing dlopen... config.status: creating po/POTFILES
config.status: creating po/Makefile
config.status: executing default commands
none required
checking for special C compiler options needed for large files... no
checking for _FILE_OFFSET_BITS value needed for large files... mkdir -p -- ./ld
Configuring in ./ld
unknown
checking for _LARGE_FILES value needed for large files... unknown
checking for setmode... no
checking whether NLS is requested... no
checking whether NLS is requested... no
checking for msgfmt... /usr/sbin/msgfmt
checking for gmsgfmt... /usr/sbin/msgfmt
checking for xgettext... /usr/sbin/xgettext
checking for msgmerge... /usr/sbin/msgmerge
checking whether to enable maintainer-specific portions of Makefiles... no
checking sys/gmon_out.h usability... configure: creating cache ./config.cache
checking build system type... x86_64-unknown-linux-gnu
checking host system type... x86_64-unknown-linux-gnu
checking target system type... i686-w64-mingw32
checking for x86_64-unknown-linux-gcc... arm-linux-androideabi-gcc
no
checking sys/gmon_out.h presence... checking for C compiler default output file name... no
checking for sys/gmon_out.h... no
checking for a known getopt prototype in unistd.h... a.out
checking whether the C compiler works... yes
checking whether we are cross compiling... yes
checking for suffix of executables... yes
checking for library containing fabs... 
checking for suffix of object files... o
checking whether we are using the GNU C compiler... yes
checking whether arm-linux-androideabi-gcc accepts -g... -lm
yes
checking for arm-linux-androideabi-gcc option to accept ISO C89... Setting warning flags = -W -Wall -Wstrict-prototypes -Wmissing-prototypes -Wshadow
none needed
checking for library containing strerror... configure: updating cache ./config.cache
configure: creating ./config.status
none required
checking for a BSD-compatible install... /usr/bin/install -c
checking whether build environment is sane... config.status: creating Makefile
config.status: creating po/Makefile.in
config.status: creating gconfig.h
config.status: executing depfiles commands
config.status: executing libtool commands
config.status: executing default-1 commands
config.status: creating po/POTFILES
config.status: creating po/Makefile
yes
checking for x86_64-unknown-linux-strip... no
checking for strip... strip
configure: WARNING: using cross tools not prefixed with host triplet
checking for a thread-safe mkdir -p... /usr/sbin/mkdir -p
checking for gawk... gawk
checking whether make sets $(MAKE)... yes
checking for style of include used by make... GNU
mkdir -p -- ./bfd
checking dependency style of arm-linux-androideabi-gcc... Configuring in ./bfd
gcc3
checking whether to enable maintainer-specific portions of Makefiles... no
checking for x86_64-unknown-linux-gcc... (cached) arm-linux-androideabi-gcc
checking whether we are using the GNU C compiler... (cached) yes
checking whether arm-linux-androideabi-gcc accepts -g... (cached) yes
checking for arm-linux-androideabi-gcc option to accept ISO C89... (cached) none needed
checking whether we are using the GNU C++ compiler... yes
checking whether arm-linux-androideabi-g++ accepts -g... configure: creating cache ./config.cache
yes
checking dependency style of arm-linux-androideabi-g++... checking build system type... x86_64-unknown-linux-gnu
checking host system type... x86_64-unknown-linux-gnu
checking target system type... gcc3
checking how to run the C preprocessor... i686-w64-mingw32
checking for x86_64-unknown-linux-gcc... arm-linux-androideabi-gcc
arm-linux-androideabi-gcc -E
checking for C compiler default output file name... checking for grep that handles long lines and -e... /usr/sbin/grep
checking for egrep... /usr/sbin/grep -E
checking for ANSI C header files... a.out
checking whether the C compiler works... yes
checking whether we are cross compiling... yes
checking for suffix of executables... 
checking for suffix of object files... yes
checking for sys/types.h... o
checking whether we are using the GNU C compiler... yes
checking whether arm-linux-androideabi-gcc accepts -g... yes
checking for sys/stat.h... yes
checking for arm-linux-androideabi-gcc option to accept ISO C89... yes
none needed
checking for stdlib.h... checking for library containing strerror... yes
none required
checking for a BSD-compatible install... /usr/bin/install -c
checking whether build environment is sane... checking for string.h... yes
checking for memory.h... yes
checking for x86_64-unknown-linux-strip... no
checking for strip... strip
configure: WARNING: using cross tools not prefixed with host triplet
checking for a thread-safe mkdir -p... /usr/sbin/mkdir -p
checking for gawk... gawk
checking whether make sets $(MAKE)... yes
checking for style of include used by make... GNU
checking dependency style of arm-linux-androideabi-gcc... yes
checking for strings.h... gcc3
checking for x86_64-unknown-linux-ar... ar
checking for x86_64-unknown-linux-ranlib... ranlib
checking for x86_64-unknown-linux-gcc... (cached) arm-linux-androideabi-gcc
yes
checking for inttypes.h... yes
checking whether we are using the GNU C compiler... (cached) yes
checking whether arm-linux-androideabi-gcc accepts -g... (cached) yes
checking for arm-linux-androideabi-gcc option to accept ISO C89... (cached) none needed
checking how to run the C preprocessor... checking for stdint.h... arm-linux-androideabi-gcc -E
yes
checking for unistd.h... yes
checking minix/config.h usability... checking for grep that handles long lines and -e... /usr/sbin/grep
checking for egrep... /usr/sbin/grep -E
checking for ANSI C header files... yes
checking for sys/types.h... no
checking minix/config.h presence... yes
checking for sys/stat.h... no
checking for minix/config.h... no
checking whether it is safe to define __EXTENSIONS__... yes
checking for stdlib.h... yes
checking how to print strings... printf
checking for a sed that does not truncate output... /usr/sbin/sed
checking for fgrep... /usr/sbin/grep -F
checking for ld used by arm-linux-androideabi-gcc... /tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld
checking if the linker (/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld) is GNU ld... yes
checking for BSD- or MS-compatible name lister (nm)... nm
checking the name lister (nm) interface... yes
checking for string.h... BSD nm
checking whether ln -s works... yes
checking the maximum length of command line arguments... 1572864
checking whether the shell understands some XSI constructs... yes
checking whether the shell understands "+="... yes
checking for /tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld option to reload object files... -r
checking for x86_64-unknown-linux-objdump... objdump
checking how to recognize dependent libraries... pass_all
checking for x86_64-unknown-linux-ar... ar
checking for x86_64-unknown-linux-strip... strip
checking for x86_64-unknown-linux-ranlib... ranlib
checking command to parse nm output from arm-linux-androideabi-gcc object... yes
checking for memory.h... yes
ok
checking for strings.h... checking for dlfcn.h... yes
checking for inttypes.h... yes
checking for objdir... .libs
yes
checking for stdint.h... yes
checking for unistd.h... checking if arm-linux-androideabi-gcc supports -fno-rtti -fno-exceptions... no
checking for arm-linux-androideabi-gcc option to produce PIC... -fPIC -DPIC
checking if arm-linux-androideabi-gcc PIC flag -fPIC -DPIC works... yes
checking minix/config.h usability... yes
checking if arm-linux-androideabi-gcc static flag -static works... no
checking minix/config.h presence... no
checking for minix/config.h... no
checking whether it is safe to define __EXTENSIONS__... yes
checking if arm-linux-androideabi-gcc supports -c -o file.o... yes
checking how to print strings... printf
checking for a sed that does not truncate output... /usr/sbin/sed
checking for fgrep... /usr/sbin/grep -F
checking for ld used by arm-linux-androideabi-gcc... yes
checking if arm-linux-androideabi-gcc supports -c -o file.o... (cached) yes
checking whether the arm-linux-androideabi-gcc linker (/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld -m elf_i386) supports shared libraries... yes
checking whether -lc should be explicitly linked in... /tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld
checking if the linker (/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld) is GNU ld... yes
checking for BSD- or MS-compatible name lister (nm)... nm
no
checking dynamic linker characteristics... checking the name lister (nm) interface... BSD nm
checking whether ln -s works... yes
checking the maximum length of command line arguments... 1572864
checking whether the shell understands some XSI constructs... yes
checking whether the shell understands "+="... yes
checking for /tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld option to reload object files... -r
checking for x86_64-unknown-linux-objdump... objdump
checking how to recognize dependent libraries... pass_all
checking for x86_64-unknown-linux-ar... (cached) ar
checking for x86_64-unknown-linux-strip... strip
checking for x86_64-unknown-linux-ranlib... (cached) ranlib
checking command to parse nm output from arm-linux-androideabi-gcc object... GNU/Linux ld.so
checking how to hardcode library paths into programs... immediate
checking whether stripping libraries is possible... yes
checking if libtool supports shared libraries... yes
checking whether to build shared libraries... yes
checking whether to build static libraries... yes
checking how to run the C++ preprocessor... arm-linux-androideabi-g++ -E
ok
checking for dlfcn.h... checking for ld used by arm-linux-androideabi-g++... yes
checking for objdir... .libs
/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld -m elf_i386
checking if the linker (/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld -m elf_i386) is GNU ld... yes
checking whether the arm-linux-androideabi-g++ linker (/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld -m elf_i386) supports shared libraries... yes
checking for arm-linux-androideabi-g++ option to produce PIC... -fPIC -DPIC
checking if arm-linux-androideabi-g++ PIC flag -fPIC -DPIC works... checking if arm-linux-androideabi-gcc supports -fno-rtti -fno-exceptions... yes
checking if arm-linux-androideabi-g++ static flag -static works... no
checking for arm-linux-androideabi-gcc option to produce PIC... -fPIC -DPIC
checking if arm-linux-androideabi-gcc PIC flag -fPIC -DPIC works... yes
checking if arm-linux-androideabi-gcc static flag -static works... yes
checking if arm-linux-androideabi-g++ supports -c -o file.o... yes
checking if arm-linux-androideabi-g++ supports -c -o file.o... (cached) yes
checking whether the arm-linux-androideabi-g++ linker (/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld -m elf_i386) supports shared libraries... yes
checking dynamic linker characteristics... (cached) GNU/Linux ld.so
checking how to hardcode library paths into programs... immediate
checking for dlfcn.h... (cached) yes
checking for windows.h... yes
checking if arm-linux-androideabi-gcc supports -c -o file.o... no
checking for library containing dlopen... yes
checking if arm-linux-androideabi-gcc supports -c -o file.o... (cached) yes
checking whether the arm-linux-androideabi-gcc linker (/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld -m elf_i386) supports shared libraries... yes
checking dynamic linker characteristics... none required
checking for special C compiler options needed for large files... no
checking for _FILE_OFFSET_BITS value needed for large files... GNU/Linux ld.so
checking how to hardcode library paths into programs... immediate
checking for shl_load... unknown
checking for _LARGE_FILES value needed for large files... no
checking for shl_load in -ldld... unknown
no
checking for dlopen... Setting warning flags = -W -Wall -Wstrict-prototypes -Wmissing-prototypes -Wshadow
checking for LC_MESSAGES... yes
checking whether a program can dlopen itself... cross
checking whether stripping libraries is possible... yes
checking if libtool supports shared libraries... yes
checking whether to build shared libraries... no
checking whether to build static libraries... yes
checking for dlfcn.h... (cached) yes
checking for windows.h... yes
checking whether NLS is requested... no
checking whether NLS is requested... no
checking for msgfmt... /usr/sbin/msgfmt
checking for gmsgfmt... /usr/sbin/msgfmt
checking for xgettext... /usr/sbin/xgettext
checking for msgmerge... no
checking for library containing dlopen... /usr/sbin/msgmerge
none required
checking for special C compiler options needed for large files... no
checking for _FILE_OFFSET_BITS value needed for large files... checking for bison... bison -y
checking for flex... flex
checking lex output file root... lex.yy
checking lex library... unknown
checking for _LARGE_FILES value needed for large files... unknown
Setting warning flags = -W -Wall -Wstrict-prototypes -Wmissing-prototypes -Wshadow
checking whether to enable maintainer-specific portions of Makefiles... no
checking whether to install libbfd... no
checking whether NLS is requested... no
checking whether NLS is requested... no
checking for msgfmt... /usr/sbin/msgfmt
checking for gmsgfmt... /usr/sbin/msgfmt
checking for xgettext... /usr/sbin/xgettext
checking for msgmerge... /usr/sbin/msgmerge
checking size of long long... none needed
checking whether yytext is a pointer... no
checking whether to enable maintainer-specific portions of Makefiles... no
checking how to compare bootstrapped objects... cmp --ignore-initial=16 $$f1 $$f2
checking for string.h... (cached) yes
checking for strings.h... (cached) yes
checking for stdlib.h... (cached) yes
checking for unistd.h... (cached) yes
checking elf-hints.h usability... no
checking elf-hints.h presence... no
checking for elf-hints.h... no
checking limits.h usability... yes
checking limits.h presence... yes
checking for limits.h... yes
8
checking locale.h usability... checking size of void *... yes
checking locale.h presence... yes
checking for locale.h... yes
checking sys/param.h usability... yes
checking sys/param.h presence... yes
checking for sys/param.h... yes
checking fcntl.h usability... yes
checking fcntl.h presence... yes
checking for fcntl.h... yes
checking sys/file.h usability... yes
checking sys/file.h presence... yes
checking for sys/file.h... yes
4
checking size of long... checking sys/time.h usability... yes
checking sys/time.h presence... yes
checking for sys/time.h... yes
checking for sys/stat.h... (cached) yes
checking whether string.h and strings.h may both be included... yes
checking for glob... no
checking for mkstemp... yes
checking for realpath... yes
checking for sbrk... yes
checking for setlocale... 4
checking for build system executable suffix... no
checking alloca.h usability... yes
checking for waitpid... yes
checking alloca.h presence... yes
checking for alloca.h... yes
yes
checking for open... checking stddef.h usability... yes
checking for lseek... yes
checking stddef.h presence... yes
checking for stddef.h... yes
checking for string.h... (cached) yes
yes
checking for strings.h... (cached) yes
checking for close... checking for stdlib.h... (cached) yes
checking time.h usability... yes
yes
checking time.h presence... checking for dirent.h that defines DIR... yes
checking for time.h... yes
checking for unistd.h... (cached) yes
yes
checking wchar.h usability... checking for library containing opendir... none required
checking for library containing dlopen... (cached) none required
checking for .preinit_array/.init_array/.fini_array support... no
checking for a known getopt prototype in unistd.h... yes
checking wchar.h presence... yes
checking for wchar.h... yes
yes
checking fcntl.h usability... checking whether strstr is declared... yes
checking fcntl.h presence... yes
checking whether free is declared... yes
checking for fcntl.h... yes
checking sys/file.h usability... yes
checking whether sbrk is declared... yes
checking sys/file.h presence... yes
checking for sys/file.h... yes
checking sys/time.h usability... yes
checking whether getenv is declared... yes
yes
checking sys/time.h presence... checking whether environ is declared... yes
checking for sys/time.h... yes
checking for sys/stat.h... (cached) yes
checking sys/resource.h usability... yes
checking for library containing zlibVersion... yes
checking sys/resource.h presence... yes
checking for sys/resource.h... yes
looking for a compliant stdint.h in stdint.h, checking for uintmax_t... -lz
checking zlib.h usability... yes
checking for uintptr_t... yes
checking zlib.h presence... yes
checking for zlib.h... yes
checking whether ANSI C string concatenation works... yes
checking size of void *... yes
checking for int_least32_t... yes
checking for int_fast32_t... yes
checking for uint64_t... yes
checking what to include in bfd_stdint.h... stdint.h (already complete)
checking whether time.h and sys/time.h may both be included... yes
checking for dirent.h that defines DIR... yes
checking for library containing opendir... none required
checking whether string.h and strings.h may both be included... 4
yes
checking for fcntl... configure: updating cache ./config.cache
configure: creating ./config.status
yes
checking for getpagesize... yes
checking for setitimer... yes
checking for sysconf... yes
checking for fdopen... yes
checking for getuid... yes
checking for getgid... yes
checking for fileno... yes
checking for strtoull... yes
checking for getrlimit... yes
checking whether basename is declared... no
checking whether ftello is declared... yes
checking whether ftello64 is declared... no
checking whether fseeko is declared... config.status: creating Makefile
yes
checking whether fseeko64 is declared... config.status: creating po/Makefile.in
no
config.status: creating config.h
checking whether ffs is declared... config.status: executing depfiles commands
yes
checking whether free is declared... yes
checking whether getenv is declared... yes
checking whether malloc is declared... yes
checking whether realloc is declared... yes
checking whether stpcpy is declared... yes
checking whether strstr is declared... yes
checking whether snprintf is declared... yes
checking whether vsnprintf is declared... yes
checking whether strnlen is declared... yes
checking for library containing zlibVersion... -lz
checking zlib.h usability... yes
checking zlib.h presence... yes
checking for zlib.h... yes
checking linker --as-needed support... yes
checking for cos in -lm... yes
checking for ftello... yes
checking for ftello64... no
checking for fseeko... yes
checking for fseeko64... no
checking for fopen64... no
checking size of off_t... config.status: executing libtool commands
config.status: executing default-1 commands
config.status: creating po/POTFILES
config.status: creating po/Makefile
make[2]: Entering directory '/tmp/mingw-w64-binutils/src/binutils-i686-w64-mingw32/libiberty'
if [ x"" != x ] && [ ! -d pic ]; then \
  mkdir pic; \
else true; fi
touch stamp-picdir
if [ x"" != x ] && [ ! -d noasan ]; then \
  mkdir noasan; \
else true; fi
touch stamp-noasandir
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/dwarfnames.c -o pic/dwarfnames.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/dwarfnames.c -o noasan/dwarfnames.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/dwarfnames.c -o dwarfnames.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/dyn-string.c -o pic/dyn-string.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/dyn-string.c -o noasan/dyn-string.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/dyn-string.c -o dyn-string.o
4
checking file_ptr type... long
checking for stdlib.h... (cached) yes
checking for unistd.h... (cached) yes
checking for getpagesize... (cached) yes
checking for working mmap... no
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/fdmatch.c -o pic/fdmatch.o; \
else true; fi
checking for madvise... if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/fdmatch.c -o noasan/fdmatch.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/fdmatch.c -o fdmatch.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/fibheap.c -o pic/fibheap.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/fibheap.c -o noasan/fibheap.o; \
else true; fi
yes
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/fibheap.c -o fibheap.o
checking for mprotect... if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/filename_cmp.c -o pic/filename_cmp.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/filename_cmp.c -o noasan/filename_cmp.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/filename_cmp.c -o filename_cmp.o
yes
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/floatformat.c -o pic/floatformat.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/floatformat.c -o noasan/floatformat.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/floatformat.c -o floatformat.o
configure: updating cache ./config.cache
configure: creating ./config.status
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/fnmatch.c -o pic/fnmatch.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/fnmatch.c -o noasan/fnmatch.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/fnmatch.c -o fnmatch.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/fopen_unlocked.c -o pic/fopen_unlocked.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/fopen_unlocked.c -o noasan/fopen_unlocked.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/fopen_unlocked.c -o fopen_unlocked.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/getopt.c -o pic/getopt.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/getopt.c -o noasan/getopt.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/getopt.c -o getopt.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/getopt1.c -o pic/getopt1.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/getopt1.c -o noasan/getopt1.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/getopt1.c -o getopt1.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/getpwd.c -o pic/getpwd.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/getpwd.c -o noasan/getpwd.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/getpwd.c -o getpwd.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/getruntime.c -o pic/getruntime.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/getruntime.c -o noasan/getruntime.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/getruntime.c -o getruntime.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/hashtab.c -o pic/hashtab.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/hashtab.c -o noasan/hashtab.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/hashtab.c -o hashtab.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/hex.c -o pic/hex.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/hex.c -o noasan/hex.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/hex.c -o hex.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/lbasename.c -o pic/lbasename.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/lbasename.c -o noasan/lbasename.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/lbasename.c -o lbasename.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/lrealpath.c -o pic/lrealpath.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/lrealpath.c -o noasan/lrealpath.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/lrealpath.c -o lrealpath.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/make-relative-prefix.c -o pic/make-relative-prefix.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/make-relative-prefix.c -o noasan/make-relative-prefix.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/make-relative-prefix.c -o make-relative-prefix.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/make-temp-file.c -o pic/make-temp-file.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/make-temp-file.c -o noasan/make-temp-file.o; \
else true; fi
config.status: creating Makefile
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/make-temp-file.c -o make-temp-file.o
config.status: creating doc/Makefile
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/objalloc.c -o pic/objalloc.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/objalloc.c -o noasan/objalloc.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/objalloc.c -o objalloc.o
config.status: creating bfd-in3.h
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/obstack.c -o pic/obstack.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/obstack.c -o noasan/obstack.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/obstack.c -o obstack.o
config.status: creating po/Makefile.in
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/partition.c -o pic/partition.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/partition.c -o noasan/partition.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/partition.c -o partition.o
config.status: creating config.h
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/pexecute.c -o pic/pexecute.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/pexecute.c -o noasan/pexecute.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/pexecute.c -o pexecute.o
config.status: executing depfiles commands
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/physmem.c -o pic/physmem.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/physmem.c -o noasan/physmem.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/physmem.c -o physmem.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/pex-common.c -o pic/pex-common.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/pex-common.c -o noasan/pex-common.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/pex-common.c -o pex-common.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/pex-one.c -o pic/pex-one.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/pex-one.c -o noasan/pex-one.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/pex-one.c -o pex-one.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/pex-unix.c -o pic/pex-unix.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/pex-unix.c -o noasan/pex-unix.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/pex-unix.c -o pex-unix.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/safe-ctype.c -o pic/safe-ctype.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/safe-ctype.c -o noasan/safe-ctype.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/safe-ctype.c -o safe-ctype.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/simple-object.c -o pic/simple-object.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/simple-object.c -o noasan/simple-object.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/simple-object.c -o simple-object.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/simple-object-coff.c -o pic/simple-object-coff.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/simple-object-coff.c -o noasan/simple-object-coff.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/simple-object-coff.c -o simple-object-coff.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/simple-object-elf.c -o pic/simple-object-elf.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/simple-object-elf.c -o noasan/simple-object-elf.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/simple-object-elf.c -o simple-object-elf.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/simple-object-mach-o.c -o pic/simple-object-mach-o.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/simple-object-mach-o.c -o noasan/simple-object-mach-o.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/simple-object-mach-o.c -o simple-object-mach-o.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/simple-object-xcoff.c -o pic/simple-object-xcoff.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/simple-object-xcoff.c -o noasan/simple-object-xcoff.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/simple-object-xcoff.c -o simple-object-xcoff.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/sort.c -o pic/sort.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/sort.c -o noasan/sort.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/sort.c -o sort.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/spaces.c -o pic/spaces.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/spaces.c -o noasan/spaces.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/spaces.c -o spaces.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/splay-tree.c -o pic/splay-tree.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/splay-tree.c -o noasan/splay-tree.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/splay-tree.c -o splay-tree.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/stack-limit.c -o pic/stack-limit.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/stack-limit.c -o noasan/stack-limit.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/stack-limit.c -o stack-limit.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/strerror.c -o pic/strerror.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/strerror.c -o noasan/strerror.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/strerror.c -o strerror.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/strsignal.c -o pic/strsignal.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/strsignal.c -o noasan/strsignal.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/strsignal.c -o strsignal.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/timeval-utils.c -o pic/timeval-utils.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/timeval-utils.c -o noasan/timeval-utils.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/timeval-utils.c -o timeval-utils.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/unlink-if-ordinary.c -o pic/unlink-if-ordinary.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/unlink-if-ordinary.c -o noasan/unlink-if-ordinary.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/unlink-if-ordinary.c -o unlink-if-ordinary.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/xatexit.c -o pic/xatexit.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/xatexit.c -o noasan/xatexit.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/xatexit.c -o xatexit.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/xexit.c -o pic/xexit.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/xexit.c -o noasan/xexit.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/xexit.c -o xexit.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/xmalloc.c -o pic/xmalloc.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/xmalloc.c -o noasan/xmalloc.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/xmalloc.c -o xmalloc.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/xmemdup.c -o pic/xmemdup.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/xmemdup.c -o noasan/xmemdup.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/xmemdup.c -o xmemdup.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/xstrdup.c -o pic/xstrdup.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/xstrdup.c -o noasan/xstrdup.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/xstrdup.c -o xstrdup.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/xstrerror.c -o pic/xstrerror.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/xstrerror.c -o noasan/xstrerror.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/xstrerror.c -o xstrerror.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/xstrndup.c -o pic/xstrndup.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/xstrndup.c -o noasan/xstrndup.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/xstrndup.c -o xstrndup.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/bcmp.c -o pic/bcmp.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/bcmp.c -o noasan/bcmp.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/bcmp.c -o bcmp.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/mempcpy.c -o pic/mempcpy.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/mempcpy.c -o noasan/mempcpy.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/mempcpy.c -o mempcpy.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/rindex.c -o pic/rindex.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/rindex.c -o noasan/rindex.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/rindex.c -o rindex.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/strverscmp.c -o pic/strverscmp.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/strverscmp.c -o noasan/strverscmp.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/strverscmp.c -o strverscmp.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/setproctitle.c -o pic/setproctitle.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/setproctitle.c -o noasan/setproctitle.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/setproctitle.c -o setproctitle.o
echo ./regex.o ./cplus-dem.o ./cp-demangle.o ./md5.o ./sha1.o ./alloca.o ./argv.o ./choose-temp.o ./concat.o ./cp-demint.o ./crc32.o ./d-demangle.o ./dwarfnames.o ./dyn-string.o ./fdmatch.o ./fibheap.o ./filename_cmp.o ./floatformat.o ./fnmatch.o ./fopen_unlocked.o ./getopt.o ./getopt1.o ./getpwd.o ./getruntime.o ./hashtab.o ./hex.o ./lbasename.o ./lrealpath.o ./make-relative-prefix.o ./make-temp-file.o ./objalloc.o ./obstack.o ./partition.o ./pexecute.o ./physmem.o ./pex-common.o ./pex-one.o ./pex-unix.o ./safe-ctype.o ./simple-object.o ./simple-object-coff.o ./simple-object-elf.o ./simple-object-mach-o.o ./simple-object-xcoff.o ./sort.o ./spaces.o ./splay-tree.o ./stack-limit.o ./strerror.o ./strsignal.o ./timeval-utils.o ./unlink-if-ordinary.o ./xatexit.o ./xexit.o ./xmalloc.o ./xmemdup.o ./xstrdup.o ./xstrerror.o ./xstrndup.o > required-list
config.status: executing libtool commands
make[3]: Entering directory '/tmp/mingw-w64-binutils/src/binutils-i686-w64-mingw32/libiberty/testsuite'
make[3]: Nothing to be done for 'all'.
make[3]: Leaving directory '/tmp/mingw-w64-binutils/src/binutils-i686-w64-mingw32/libiberty/testsuite'
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/regex.c -o pic/regex.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/regex.c -o noasan/regex.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/regex.c -o regex.o
config.status: executing default-1 commands
config.status: executing bfd_stdint.h commands
config.status: executing default commands
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/cplus-dem.c -o pic/cplus-dem.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/cplus-dem.c -o noasan/cplus-dem.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/cplus-dem.c -o cplus-dem.o
mkdir -p -- ./opcodes
Configuring in ./opcodes
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/cp-demangle.c -o pic/cp-demangle.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/cp-demangle.c -o noasan/cp-demangle.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/cp-demangle.c -o cp-demangle.o
configure: creating cache ./config.cache
checking build system type... x86_64-unknown-linux-gnu
checking host system type... x86_64-unknown-linux-gnu
checking target system type... i686-w64-mingw32
checking for x86_64-unknown-linux-gcc... arm-linux-androideabi-gcc
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/md5.c -o pic/md5.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/md5.c -o noasan/md5.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/md5.c -o md5.o
checking for C compiler default output file name... if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/sha1.c -o pic/sha1.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/sha1.c -o noasan/sha1.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/sha1.c -o sha1.o
a.out
checking whether the C compiler works... yes
checking whether we are cross compiling... yes
checking for suffix of executables... if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/alloca.c -o pic/alloca.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/alloca.c -o noasan/alloca.o; \
else true; fi

arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/alloca.c -o alloca.o
checking for suffix of object files... o
checking whether we are using the GNU C compiler... if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/argv.c -o pic/argv.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/argv.c -o noasan/argv.o; \
else true; fi
yes
checking whether arm-linux-androideabi-gcc accepts -g... arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/argv.c -o argv.o
yes
checking for arm-linux-androideabi-gcc option to accept ISO C89... if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/choose-temp.c -o pic/choose-temp.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/choose-temp.c -o noasan/choose-temp.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/choose-temp.c -o choose-temp.o
none needed
checking for library containing strerror... /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/choose-temp.c: In function 'choose_temp_base':
/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/choose-temp.c:72:14: warning: call to 'mktemp' declared with attribute warning: mktemp possibly used unsafely; consider using mkstemp [enabled by default]
   if (mktemp (temp_filename) == 0)
              ^
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/concat.c -o pic/concat.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/concat.c -o noasan/concat.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/concat.c -o concat.o
none required
checking for a BSD-compatible install... /usr/bin/install -c
checking whether build environment is sane... if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/cp-demint.c -o pic/cp-demint.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/cp-demint.c -o noasan/cp-demint.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/cp-demint.c -o cp-demint.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/crc32.c -o pic/crc32.o; \
else true; fi
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic    /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/crc32.c -o noasan/crc32.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/crc32.c -o crc32.o
if [ x"" != x ]; then \
  arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic   /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/d-demangle.c -o pic/d-demangle.o; \
else true; fi
arm-linux-androideabi-gcc -c -DHAVE_CONFIG_H   -I. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/../include  -W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic  /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/d-demangle.c -o d-demangle.o
rm -f ./libiberty.a pic/./libiberty.a noasan/./libiberty.a
ar rc ./libiberty.a \
  ./regex.o ./cplus-dem.o ./cp-demangle.o ./md5.o ./sha1.o ./alloca.o ./argv.o ./choose-temp.o ./concat.o ./cp-demint.o ./crc32.o ./d-demangle.o ./dwarfnames.o ./dyn-string.o ./fdmatch.o ./fibheap.o ./filename_cmp.o ./floatformat.o ./fnmatch.o ./fopen_unlocked.o ./getopt.o ./getopt1.o ./getpwd.o ./getruntime.o ./hashtab.o ./hex.o ./lbasename.o ./lrealpath.o ./make-relative-prefix.o ./make-temp-file.o ./objalloc.o ./obstack.o ./partition.o ./pexecute.o ./physmem.o ./pex-common.o ./pex-one.o ./pex-unix.o ./safe-ctype.o ./simple-object.o ./simple-object-coff.o ./simple-object-elf.o ./simple-object-mach-o.o ./simple-object-xcoff.o ./sort.o ./spaces.o ./splay-tree.o ./stack-limit.o ./strerror.o ./strsignal.o ./timeval-utils.o ./unlink-if-ordinary.o ./xatexit.o ./xexit.o ./xmalloc.o ./xmemdup.o ./xstrdup.o ./xstrerror.o ./xstrndup.o  ./bcmp.o ./mempcpy.o ./rindex.o ./strverscmp.o ./setproctitle.o
ranlib ./libiberty.a
if [ x"" != x ]; then \
  cd pic; \
  ar rc ./libiberty.a \
    ./regex.o ./cplus-dem.o ./cp-demangle.o ./md5.o ./sha1.o ./alloca.o ./argv.o ./choose-temp.o ./concat.o ./cp-demint.o ./crc32.o ./d-demangle.o ./dwarfnames.o ./dyn-string.o ./fdmatch.o ./fibheap.o ./filename_cmp.o ./floatformat.o ./fnmatch.o ./fopen_unlocked.o ./getopt.o ./getopt1.o ./getpwd.o ./getruntime.o ./hashtab.o ./hex.o ./lbasename.o ./lrealpath.o ./make-relative-prefix.o ./make-temp-file.o ./objalloc.o ./obstack.o ./partition.o ./pexecute.o ./physmem.o ./pex-common.o ./pex-one.o ./pex-unix.o ./safe-ctype.o ./simple-object.o ./simple-object-coff.o ./simple-object-elf.o ./simple-object-mach-o.o ./simple-object-xcoff.o ./sort.o ./spaces.o ./splay-tree.o ./stack-limit.o ./strerror.o ./strsignal.o ./timeval-utils.o ./unlink-if-ordinary.o ./xatexit.o ./xexit.o ./xmalloc.o ./xmemdup.o ./xstrdup.o ./xstrerror.o ./xstrndup.o  ./bcmp.o ./mempcpy.o ./rindex.o ./strverscmp.o ./setproctitle.o; \
  ranlib ./libiberty.a; \
  cd ..; \
else true; fi; \
if [ x"" != x ]; then \
  cd noasan; \
  ar rc ./libiberty.a \
    ./regex.o ./cplus-dem.o ./cp-demangle.o ./md5.o ./sha1.o ./alloca.o ./argv.o ./choose-temp.o ./concat.o ./cp-demint.o ./crc32.o ./d-demangle.o ./dwarfnames.o ./dyn-string.o ./fdmatch.o ./fibheap.o ./filename_cmp.o ./floatformat.o ./fnmatch.o ./fopen_unlocked.o ./getopt.o ./getopt1.o ./getpwd.o ./getruntime.o ./hashtab.o ./hex.o ./lbasename.o ./lrealpath.o ./make-relative-prefix.o ./make-temp-file.o ./objalloc.o ./obstack.o ./partition.o ./pexecute.o ./physmem.o ./pex-common.o ./pex-one.o ./pex-unix.o ./safe-ctype.o ./simple-object.o ./simple-object-coff.o ./simple-object-elf.o ./simple-object-mach-o.o ./simple-object-xcoff.o ./sort.o ./spaces.o ./splay-tree.o ./stack-limit.o ./strerror.o ./strsignal.o ./timeval-utils.o ./unlink-if-ordinary.o ./xatexit.o ./xexit.o ./xmalloc.o ./xmemdup.o ./xstrdup.o ./xstrerror.o ./xstrndup.o  ./bcmp.o ./mempcpy.o ./rindex.o ./strverscmp.o ./setproctitle.o; \
  ranlib ./libiberty.a; \
  cd ..; \
else true; fi
make[2]: Leaving directory '/tmp/mingw-w64-binutils/src/binutils-i686-w64-mingw32/libiberty'
make[2]: Entering directory '/tmp/mingw-w64-binutils/src/binutils-i686-w64-mingw32/bfd'
creating bfdver.h
rm -f elf32-target.h
sed -e s/NN/32/g < /tmp/mingw-w64-binutils/src/binutils-2.25.1/bfd/elfxx-target.h > elf32-target.new
mv -f elf32-target.new elf32-target.h
rm -f elf64-target.h
sed -e s/NN/64/g < /tmp/mingw-w64-binutils/src/binutils-2.25.1/bfd/elfxx-target.h > elf64-target.new
mv -f elf64-target.new elf64-target.h
rm -f targmatch.h
sed -f /tmp/mingw-w64-binutils/src/binutils-2.25.1/bfd/targmatch.sed < /tmp/mingw-w64-binutils/src/binutils-2.25.1/bfd/config.bfd > targmatch.new
mv -f targmatch.new targmatch.h
Making info in doc
make[3]: Entering directory '/tmp/mingw-w64-binutils/src/binutils-i686-w64-mingw32/bfd/doc'
arm-linux-androideabi-gcc -o chw$$  \
    -I.. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/bfd/doc/.. -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/bfd/doc/../../include -I/tmp/mingw-w64-binutils/src/binutils-2.25.1/bfd/doc/../../intl -I../../intl /tmp/mingw-w64-binutils/src/binutils-2.25.1/bfd/doc/chew.c; \
/bin/sh /tmp/mingw-w64-binutils/src/binutils-2.25.1/bfd/doc/../../move-if-change \
  chw$$ chew; \
touch chew.stamp
yes
./chew -f /tmp/mingw-w64-binutils/src/binutils-2.25.1/bfd/doc/doc.str < /tmp/mingw-w64-binutils/src/binutils-2.25.1/bfd/doc/../aoutx.h >aoutx.tmp
checking for x86_64-unknown-linux-strip... no
checking for strip... strip
configure: WARNING: using cross tools not prefixed with host triplet
checking for a thread-safe mkdir -p... /usr/sbin/mkdir -p
checking for gawk... gawk
checking whether make sets $(MAKE)... /bin/sh: ./chew: cannot execute binary file: Exec format error
Makefile:798: recipe for target 'aoutx.stamp' failed
make[3]: *** [aoutx.stamp] Error 126
make[3]: Leaving directory '/tmp/mingw-w64-binutils/src/binutils-i686-w64-mingw32/bfd/doc'
Makefile:1647: recipe for target 'info-recursive' failed
make[2]: *** [info-recursive] Error 1
make[2]: Leaving directory '/tmp/mingw-w64-binutils/src/binutils-i686-w64-mingw32/bfd'
Makefile:2599: recipe for target 'all-bfd' failed
make[1]: *** [all-bfd] Error 2
make[1]: *** Waiting for unfinished jobs....
yes
checking for style of include used by make... GNU
checking dependency style of arm-linux-androideabi-gcc... gcc3
checking for x86_64-unknown-linux-gcc... (cached) arm-linux-androideabi-gcc
checking whether we are using the GNU C compiler... (cached) yes
checking whether arm-linux-androideabi-gcc accepts -g... (cached) yes
checking for arm-linux-androideabi-gcc option to accept ISO C89... (cached) none needed
checking how to run the C preprocessor... arm-linux-androideabi-gcc -E
checking for grep that handles long lines and -e... /usr/sbin/grep
checking for egrep... /usr/sbin/grep -E
checking for ANSI C header files... yes
checking for sys/types.h... yes
checking for sys/stat.h... yes
checking for stdlib.h... yes
checking for string.h... yes
checking for memory.h... yes
checking for strings.h... yes
checking for inttypes.h... yes
checking for stdint.h... yes
checking for unistd.h... yes
checking minix/config.h usability... no
checking minix/config.h presence... no
checking for minix/config.h... no
checking whether it is safe to define __EXTENSIONS__... yes
checking for x86_64-unknown-linux-ar... ar
checking for x86_64-unknown-linux-ranlib... ranlib
checking how to print strings... printf
checking for a sed that does not truncate output... /usr/sbin/sed
checking for fgrep... /usr/sbin/grep -F
checking for ld used by arm-linux-androideabi-gcc... /tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld
checking if the linker (/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld) is GNU ld... yes
checking for BSD- or MS-compatible name lister (nm)... nm
checking the name lister (nm) interface... BSD nm
checking whether ln -s works... yes
checking the maximum length of command line arguments... 1572864
checking whether the shell understands some XSI constructs... yes
checking whether the shell understands "+="... yes
checking for /tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld option to reload object files... -r
checking for x86_64-unknown-linux-objdump... objdump
checking how to recognize dependent libraries... pass_all
checking for x86_64-unknown-linux-ar... (cached) ar
checking for x86_64-unknown-linux-strip... strip
checking for x86_64-unknown-linux-ranlib... (cached) ranlib
checking command to parse nm output from arm-linux-androideabi-gcc object... ok
checking for dlfcn.h... yes
checking for objdir... .libs
checking if arm-linux-androideabi-gcc supports -fno-rtti -fno-exceptions... no
checking for arm-linux-androideabi-gcc option to produce PIC... -fPIC -DPIC
checking if arm-linux-androideabi-gcc PIC flag -fPIC -DPIC works... yes
checking if arm-linux-androideabi-gcc static flag -static works... yes
checking if arm-linux-androideabi-gcc supports -c -o file.o... yes
checking if arm-linux-androideabi-gcc supports -c -o file.o... (cached) yes
checking whether the arm-linux-androideabi-gcc linker (/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld -m elf_i386) supports shared libraries... yes
checking dynamic linker characteristics... GNU/Linux ld.so
checking how to hardcode library paths into programs... immediate
checking whether stripping libraries is possible... yes
checking if libtool supports shared libraries... yes
checking whether to build shared libraries... no
checking whether to build static libraries... yes
Setting warning flags = -W -Wall -Wstrict-prototypes -Wmissing-prototypes -Wshadow
checking whether arm-linux-androideabi-gcc supports -Wmissing-field-initializers... yes
checking whether to enable maintainer-specific portions of Makefiles... no
checking whether to install libbfd... no
checking whether NLS is requested... no
checking whether NLS is requested... no
checking for msgfmt... /usr/sbin/msgfmt
checking for gmsgfmt... /usr/sbin/msgfmt
checking for xgettext... /usr/sbin/xgettext
checking for msgmerge... /usr/sbin/msgmerge
checking for build system executable suffix... no
checking for string.h... (cached) yes
checking for strings.h... (cached) yes
checking for stdlib.h... (cached) yes
checking limits.h usability... yes
checking limits.h presence... yes
checking for limits.h... yes
checking whether string.h and strings.h may both be included... yes
checking whether basename is declared... no
checking whether stpcpy is declared... yes
checking for sigsetjmp... 
checking linker --as-needed support... yes
checking for cos in -lm... yes
configure: updating cache ./config.cache
configure: creating ./config.status
config.status: creating Makefile
config.status: creating po/Makefile.in
config.status: creating config.h
config.status: executing depfiles commands
config.status: executing libtool commands
config.status: executing default-1 commands
config.status: creating po/POTFILES
config.status: creating po/Makefile
make[1]: Leaving directory '/tmp/mingw-w64-binutils/src/binutils-i686-w64-mingw32'
Makefile:831: recipe for target 'all' failed
make: *** [all] Error 2
==> ERROR: A failure occurred in build().
    Aborting...
===> Printing config.logs
found log at /tmp/mingw-w64-binutils/src/binutils-i686-w64-mingw32/config.log
found log at /tmp/mingw-w64-binutils/src/binutils-i686-w64-mingw32/bfd/config.log
found log at /tmp/mingw-w64-binutils/src/binutils-i686-w64-mingw32/intl/config.log
found log at /tmp/mingw-w64-binutils/src/binutils-i686-w64-mingw32/ld/config.log
found log at /tmp/mingw-w64-binutils/src/binutils-i686-w64-mingw32/opcodes/config.log
found log at /tmp/mingw-w64-binutils/src/binutils-i686-w64-mingw32/gas/config.log
found log at /tmp/mingw-w64-binutils/src/binutils-i686-w64-mingw32/libiberty/config.log
found log at /tmp/mingw-w64-binutils/src/binutils-i686-w64-mingw32/etc/config.log
found log at /tmp/mingw-w64-binutils/src/binutils-i686-w64-mingw32/gprof/config.log
found log at /tmp/mingw-w64-binutils/src/binutils-i686-w64-mingw32/binutils/config.log
____
File /tmp/mingw-w64-binutils/src/binutils-i686-w64-mingw32/config.log
This file contains any messages produced by compilers while
running configure, to aid debugging if configure makes a mistake.

It was created by configure, which was
generated by GNU Autoconf 2.64.  Invocation command line was

  $ /tmp/mingw-w64-binutils/src/binutils-2.25.1/configure --host x86_64-unknown-linux --prefix=/usr --target=i686-w64-mingw32 --infodir=/usr/share/info/i686-w64-mingw32 --enable-lto --enable-plugins --disable-multilib --disable-nls --disable-werror

## --------- ##
## Platform. ##
## --------- ##

hostname = d5f3793a98c0
uname -m = x86_64
uname -r = 3.13.0-66-generic
uname -s = Linux
uname -v = #108-Ubuntu SMP Wed Oct 7 15:20:27 UTC 2015

/usr/bin/uname -p = unknown
/bin/uname -X     = unknown

/bin/arch              = unknown
/usr/bin/arch -k       = unknown
/usr/convex/getsysinfo = unknown
/usr/bin/hostinfo      = unknown
/bin/machine           = unknown
/usr/bin/oslevel       = unknown
/bin/universe          = unknown

PATH: /tmp/toolchain/bin
PATH: /usr/local/sbin
PATH: /usr/local/bin
PATH: /usr/sbin
PATH: /usr/bin
PATH: /sbin
PATH: /bin


## ----------- ##
## Core tests. ##
## ----------- ##

configure:2322: checking build system type
configure:2336: result: x86_64-unknown-linux-gnu
configure:2383: checking host system type
configure:2396: result: x86_64-unknown-linux-gnu
configure:2416: checking target system type
configure:2429: result: i686-w64-mingw32
configure:2483: checking for a BSD-compatible install
configure:2551: result: /usr/bin/install -c
configure:2562: checking whether ln works
configure:2584: result: yes
configure:2588: checking whether ln -s works
configure:2592: result: yes
configure:2599: checking for a sed that does not truncate output
configure:2663: result: /usr/sbin/sed
configure:2672: checking for gawk
configure:2688: found /usr/sbin/gawk
configure:2699: result: gawk
configure:3941: checking for x86_64-unknown-linux-gcc
configure:3968: result: arm-linux-androideabi-gcc
configure:4237: checking for C compiler version
configure:4246: arm-linux-androideabi-gcc --version >&5
arm-linux-androideabi-gcc (GCC) 4.8
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

configure:4257: $? = 0
configure:4246: arm-linux-androideabi-gcc -v >&5
Using built-in specs.
COLLECT_GCC=arm-linux-androideabi-gcc
COLLECT_LTO_WRAPPER=/tmp/toolchain/bin/../libexec/gcc/arm-linux-androideabi/4.8/lto-wrapper
Target: arm-linux-androideabi
Configured with: /s/ndk-toolchain/src/build/../gcc/gcc-4.8/configure --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --target=arm-linux-androideabi --host=x86_64-linux-gnu --build=x86_64-linux-gnu --with-gnu-as --with-gnu-ld --enable-languages=c,c++ --with-gmp=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpfr=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpc=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-cloog=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-isl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-ppl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --disable-ppl-version-check --disable-cloog-version-check --disable-isl-version-check --enable-cloog-backend=isl --with-host-libstdcxx='-static-libgcc -Wl,-Bstatic,-lstdc++,-Bdynamic -lm' --disable-libssp --enable-threads --disable-nls --disable-libmudflap --disable-libgomp --disable-libstdc__-v3 --disable-sjlj-exceptions --disable-shared --disable-tls --disable-libitm --with-float=soft --with-fpu=vfp --with-arch=armv5te --enable-target-optspace --enable-initfini-array --disable-nls --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --with-sysroot=/tmp/ndk-andrewhsieh/build/toolchain/prefix/sysroot --with-binutils-version=2.25 --with-mpfr-version=3.1.1 --with-mpc-version=1.0.1 --with-gmp-version=5.0.5 --with-gcc-version=4.8 --with-gdb-version=7.7 --with-python=/usr/local/google/home/andrewhsieh/mydroid/ndk/prebuilt/linux-x86_64/bin/python-config.sh --with-gxx-include-dir=/tmp/ndk-andrewhsieh/build/toolchain/prefix/include/c++/4.8 --with-bugurl=http://source.android.com/source/report-bugs.html --enable-languages=c,c++ --disable-bootstrap --enable-plugins --enable-libgomp --enable-gnu-indirect-function --disable-libsanitizer --enable-gold --enable-threads --enable-graphite=yes --with-cloog-version=0.18.0 --with-isl-version=0.11.1 --enable-eh-frame-hdr-for-static --with-arch=armv5te --program-transform-name='s&^&arm-linux-androideabi-&' --enable-gold=default
Thread model: posix
gcc version 4.8 (GCC) 
configure:4257: $? = 0
configure:4246: arm-linux-androideabi-gcc -V >&5
arm-linux-androideabi-gcc: error: unrecognized command line option '-V'
arm-linux-androideabi-gcc: fatal error: no input files
compilation terminated.
configure:4257: $? = 1
configure:4246: arm-linux-androideabi-gcc -qversion >&5
arm-linux-androideabi-gcc: error: unrecognized command line option '-qversion'
arm-linux-androideabi-gcc: fatal error: no input files
compilation terminated.
configure:4257: $? = 1
configure:4277: checking for C compiler default output file name
configure:4299: arm-linux-androideabi-gcc    conftest.c  >&5
configure:4303: $? = 0
configure:4340: result: a.out
configure:4356: checking whether the C compiler works
configure:4365: ./a.out
/tmp/mingw-w64-binutils/src/binutils-2.25.1/configure: line 4367: ./a.out: cannot execute binary file: Exec format error
configure:4369: $? = 126
configure:4384: result: yes
configure:4391: checking whether we are cross compiling
configure:4393: result: yes
configure:4396: checking for suffix of executables
configure:4403: arm-linux-androideabi-gcc -o conftest    conftest.c  >&5
configure:4407: $? = 0
configure:4429: result: 
configure:4435: checking for suffix of object files
configure:4457: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4461: $? = 0
configure:4482: result: o
configure:4486: checking whether we are using the GNU C compiler
configure:4505: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4505: $? = 0
configure:4514: result: yes
configure:4523: checking whether arm-linux-androideabi-gcc accepts -g
configure:4543: arm-linux-androideabi-gcc -c -g  conftest.c >&5
configure:4543: $? = 0
configure:4584: result: yes
configure:4601: checking for arm-linux-androideabi-gcc option to accept ISO C89
configure:4665: arm-linux-androideabi-gcc  -c   conftest.c >&5
configure:4665: $? = 0
configure:4678: result: none needed
configure:4810: checking for C++ compiler version
configure:4819: arm-linux-androideabi-g++ --version >&5
arm-linux-androideabi-g++ (GCC) 4.8
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

configure:4830: $? = 0
configure:4819: arm-linux-androideabi-g++ -v >&5
Using built-in specs.
COLLECT_GCC=arm-linux-androideabi-g++
COLLECT_LTO_WRAPPER=/tmp/toolchain/bin/../libexec/gcc/arm-linux-androideabi/4.8/lto-wrapper
Target: arm-linux-androideabi
Configured with: /s/ndk-toolchain/src/build/../gcc/gcc-4.8/configure --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --target=arm-linux-androideabi --host=x86_64-linux-gnu --build=x86_64-linux-gnu --with-gnu-as --with-gnu-ld --enable-languages=c,c++ --with-gmp=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpfr=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpc=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-cloog=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-isl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-ppl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --disable-ppl-version-check --disable-cloog-version-check --disable-isl-version-check --enable-cloog-backend=isl --with-host-libstdcxx='-static-libgcc -Wl,-Bstatic,-lstdc++,-Bdynamic -lm' --disable-libssp --enable-threads --disable-nls --disable-libmudflap --disable-libgomp --disable-libstdc__-v3 --disable-sjlj-exceptions --disable-shared --disable-tls --disable-libitm --with-float=soft --with-fpu=vfp --with-arch=armv5te --enable-target-optspace --enable-initfini-array --disable-nls --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --with-sysroot=/tmp/ndk-andrewhsieh/build/toolchain/prefix/sysroot --with-binutils-version=2.25 --with-mpfr-version=3.1.1 --with-mpc-version=1.0.1 --with-gmp-version=5.0.5 --with-gcc-version=4.8 --with-gdb-version=7.7 --with-python=/usr/local/google/home/andrewhsieh/mydroid/ndk/prebuilt/linux-x86_64/bin/python-config.sh --with-gxx-include-dir=/tmp/ndk-andrewhsieh/build/toolchain/prefix/include/c++/4.8 --with-bugurl=http://source.android.com/source/report-bugs.html --enable-languages=c,c++ --disable-bootstrap --enable-plugins --enable-libgomp --enable-gnu-indirect-function --disable-libsanitizer --enable-gold --enable-threads --enable-graphite=yes --with-cloog-version=0.18.0 --with-isl-version=0.11.1 --enable-eh-frame-hdr-for-static --with-arch=armv5te --program-transform-name='s&^&arm-linux-androideabi-&' --enable-gold=default
Thread model: posix
gcc version 4.8 (GCC) 
configure:4830: $? = 0
configure:4819: arm-linux-androideabi-g++ -V >&5
arm-linux-androideabi-g++: error: unrecognized command line option '-V'
arm-linux-androideabi-g++: fatal error: no input files
compilation terminated.
configure:4830: $? = 1
configure:4819: arm-linux-androideabi-g++ -qversion >&5
arm-linux-androideabi-g++: error: unrecognized command line option '-qversion'
arm-linux-androideabi-g++: fatal error: no input files
compilation terminated.
configure:4830: $? = 1
configure:4834: checking whether we are using the GNU C++ compiler
configure:4853: arm-linux-androideabi-g++ -c   conftest.cpp >&5
configure:4853: $? = 0
configure:4862: result: yes
configure:4871: checking whether arm-linux-androideabi-g++ accepts -g
configure:4891: arm-linux-androideabi-g++ -c -g  conftest.cpp >&5
configure:4891: $? = 0
configure:4932: result: yes
configure:4981: checking whether g++ accepts -static-libstdc++ -static-libgcc
configure:4998: arm-linux-androideabi-g++ -o conftest    -static-libstdc++ -static-libgcc conftest.cpp  >&5
configure:4998: $? = 0
configure:4999: result: yes
configure:5023: checking for x86_64-unknown-linux-gnatbind
configure:5053: result: no
configure:5063: checking for gnatbind
configure:5093: result: no
configure:5115: checking for x86_64-unknown-linux-gnatmake
configure:5145: result: no
configure:5155: checking for gnatmake
configure:5185: result: no
configure:5204: checking whether compiler driver understands Ada
configure:5227: result: no
configure:5236: checking how to compare bootstrapped objects
configure:5261: result: cmp --ignore-initial=16 $$f1 $$f2
configure:5315: checking for objdir
configure:5330: result: .libs
configure:5902: checking for version 0.10 of ISL
configure:5930: result: yes
configure:6133: checking for version 0.17.0 of CLooG
configure:6150: arm-linux-androideabi-gcc -c  -DCLOOG_INT_GMP     conftest.c >&5
conftest.c:10:27: fatal error: cloog/version.h: No such file or directory
 #include "cloog/version.h"
                           ^
compilation terminated.
configure:6150: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define LT_OBJDIR ".libs/"
| /* end confdefs.h.  */
| #include "cloog/version.h"
| int
| main ()
| {
| #if CLOOG_VERSION_MAJOR != 0     || CLOOG_VERSION_MINOR != 17     || CLOOG_VERSION_REVISION < 0
|     choke me
|    #endif
|   ;
|   return 0;
| }
configure:6156: result: no
configure:6175: checking for version 0.18.0 of CLooG
configure:6192: arm-linux-androideabi-gcc -c  -DCLOOG_INT_GMP     conftest.c >&5
conftest.c:10:27: fatal error: cloog/version.h: No such file or directory
 #include "cloog/version.h"
                           ^
compilation terminated.
configure:6192: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define LT_OBJDIR ".libs/"
| /* end confdefs.h.  */
| #include "cloog/version.h"
| int
| main ()
| {
| #if CLOOG_VERSION_MAJOR != 0     || CLOOG_VERSION_MINOR != 18     || CLOOG_VERSION_REVISION < 0
|     choke me
|    #endif
|   ;
|   return 0;
| }
configure:6198: result: no
configure:7123: checking for default BUILD_CONFIG
configure:7155: result: 
configure:7160: checking for --enable-vtable-verify
configure:7173: result: no
configure:7762: checking for bison
configure:7778: found /usr/sbin/bison
configure:7789: result: bison -y
configure:7809: checking for bison
configure:7825: found /usr/sbin/bison
configure:7836: result: bison
configure:7856: checking for gm4
configure:7886: result: no
configure:7856: checking for gnum4
configure:7886: result: no
configure:7856: checking for m4
configure:7872: found /usr/sbin/m4
configure:7883: result: m4
configure:7903: checking for flex
configure:7919: found /usr/sbin/flex
configure:7930: result: flex
configure:7951: checking for flex
configure:7967: found /usr/sbin/flex
configure:7978: result: flex
configure:7998: checking for makeinfo
configure:8014: found /usr/sbin/makeinfo
configure:8025: result: makeinfo
configure:8059: checking for expect
configure:8089: result: no
configure:8108: checking for runtest
configure:8138: result: no
configure:8214: checking for x86_64-unknown-linux-ar
configure:8244: result: no
configure:8253: checking for ar
configure:8269: found /usr/sbin/ar
configure:8280: result: ar
configure:8355: checking for x86_64-unknown-linux-as
configure:8385: result: no
configure:8394: checking for as
configure:8410: found /usr/sbin/as
configure:8421: result: as
configure:8496: checking for x86_64-unknown-linux-dlltool
configure:8526: result: no
configure:8535: checking for dlltool
configure:8565: result: no
configure:8595: checking for ld
configure:8622: result: /tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld
configure:8637: checking for x86_64-unknown-linux-ld
configure:8664: result: /tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld
configure:8778: checking for x86_64-unknown-linux-lipo
configure:8808: result: no
configure:8817: checking for lipo
configure:8847: result: no
configure:8919: checking for x86_64-unknown-linux-nm
configure:8949: result: no
configure:8958: checking for nm
configure:8974: found /usr/sbin/nm
configure:8985: result: nm
configure:9060: checking for x86_64-unknown-linux-ranlib
configure:9090: result: no
configure:9099: checking for ranlib
configure:9115: found /usr/sbin/ranlib
configure:9126: result: ranlib
configure:9196: checking for x86_64-unknown-linux-strip
configure:9226: result: no
configure:9235: checking for strip
configure:9251: found /usr/sbin/strip
configure:9262: result: strip
configure:9332: checking for x86_64-unknown-linux-windres
configure:9362: result: no
configure:9371: checking for windres
configure:9401: result: no
configure:9473: checking for x86_64-unknown-linux-windmc
configure:9503: result: no
configure:9512: checking for windmc
configure:9542: result: no
configure:9614: checking for x86_64-unknown-linux-objcopy
configure:9644: result: no
configure:9653: checking for objcopy
configure:9669: found /usr/sbin/objcopy
configure:9680: result: objcopy
configure:9755: checking for x86_64-unknown-linux-objdump
configure:9785: result: no
configure:9794: checking for objdump
configure:9810: found /usr/sbin/objdump
configure:9821: result: objdump
configure:9896: checking for x86_64-unknown-linux-readelf
configure:9926: result: no
configure:9935: checking for readelf
configure:9951: found /usr/sbin/readelf
configure:9962: result: readelf
configure:10076: checking for i686-w64-mingw32-cc
configure:10106: result: no
configure:10076: checking for i686-w64-mingw32-gcc
configure:10106: result: no
configure:10237: checking for i686-w64-mingw32-c++
configure:10267: result: no
configure:10237: checking for i686-w64-mingw32-g++
configure:10267: result: no
configure:10237: checking for i686-w64-mingw32-cxx
configure:10267: result: no
configure:10237: checking for i686-w64-mingw32-gxx
configure:10267: result: no
configure:10398: checking for i686-w64-mingw32-gcc
configure:10428: result: no
configure:10554: checking for i686-w64-mingw32-gcj
configure:10584: result: no
configure:10715: checking for i686-w64-mingw32-gfortran
configure:10745: result: no
configure:10876: checking for i686-w64-mingw32-gccgo
configure:10906: result: no
configure:11117: checking for i686-w64-mingw32-ar
configure:11147: result: no
configure:11347: checking for i686-w64-mingw32-as
configure:11377: result: no
configure:11577: checking for i686-w64-mingw32-dlltool
configure:11607: result: no
configure:11807: checking for i686-w64-mingw32-ld
configure:11837: result: no
configure:12037: checking for i686-w64-mingw32-lipo
configure:12067: result: no
configure:12267: checking for i686-w64-mingw32-nm
configure:12297: result: no
configure:12497: checking for i686-w64-mingw32-objdump
configure:12527: result: no
configure:12727: checking for i686-w64-mingw32-ranlib
configure:12757: result: no
configure:12957: checking for i686-w64-mingw32-readelf
configure:12987: result: no
configure:13187: checking for i686-w64-mingw32-strip
configure:13217: result: no
configure:13417: checking for i686-w64-mingw32-windres
configure:13447: result: no
configure:13647: checking for i686-w64-mingw32-windmc
configure:13677: result: no
configure:13744: checking where to find the target ar
configure:13767: result: just compiled
configure:13786: checking where to find the target as
configure:13809: result: just compiled
configure:13828: checking where to find the target cc
configure:13865: result: pre-installed
configure:13870: checking where to find the target c++
configure:13910: result: pre-installed
configure:13915: checking where to find the target c++ for libstdc++
configure:13955: result: pre-installed
configure:13960: checking where to find the target dlltool
configure:13983: result: just compiled
configure:14002: checking where to find the target gcc
configure:14039: result: pre-installed
configure:14044: checking where to find the target gcj
configure:14084: result: pre-installed
configure:14089: checking where to find the target gfortran
configure:14129: result: pre-installed
configure:14134: checking where to find the target gccgo
configure:14174: result: pre-installed
configure:14179: checking where to find the target ld
configure:14202: result: just compiled
configure:14221: checking where to find the target lipo
configure:14247: result: pre-installed
configure:14252: checking where to find the target nm
configure:14275: result: just compiled
configure:14294: checking where to find the target objdump
configure:14317: result: just compiled
configure:14336: checking where to find the target ranlib
configure:14359: result: just compiled
configure:14378: checking where to find the target readelf
configure:14401: result: just compiled
configure:14420: checking where to find the target strip
configure:14443: result: just compiled
configure:14462: checking where to find the target windres
configure:14485: result: just compiled
configure:14504: checking where to find the target windmc
configure:14527: result: just compiled
configure:14574: checking whether to enable maintainer-specific portions of Makefiles
configure:14583: result: no
configure:14804: creating ./config.status

## ---------------------- ##
## Running config.status. ##
## ---------------------- ##

This file was extended by config.status, which was
generated by GNU Autoconf 2.64.  Invocation command line was

  CONFIG_FILES    = 
  CONFIG_HEADERS  = 
  CONFIG_LINKS    = 
  CONFIG_COMMANDS = 
  $ ./config.status 

on d5f3793a98c0

config.status:939: creating Makefile

## ---------------- ##
## Cache variables. ##
## ---------------- ##

ac_cv_build=x86_64-unknown-linux-gnu
ac_cv_c_compiler_gnu=yes
ac_cv_cxx_compiler_gnu=yes
ac_cv_env_AR_FOR_TARGET_set=
ac_cv_env_AR_FOR_TARGET_value=
ac_cv_env_AR_set=
ac_cv_env_AR_value=
ac_cv_env_AS_FOR_TARGET_set=
ac_cv_env_AS_FOR_TARGET_value=
ac_cv_env_AS_set=
ac_cv_env_AS_value=
ac_cv_env_CCC_set=
ac_cv_env_CCC_value=
ac_cv_env_CC_FOR_TARGET_set=
ac_cv_env_CC_FOR_TARGET_value=
ac_cv_env_CC_set=set
ac_cv_env_CC_value=arm-linux-androideabi-gcc
ac_cv_env_CFLAGS_set=set
ac_cv_env_CFLAGS_value=
ac_cv_env_CPPFLAGS_set=set
ac_cv_env_CPPFLAGS_value=
ac_cv_env_CXXFLAGS_set=set
ac_cv_env_CXXFLAGS_value=
ac_cv_env_CXX_FOR_TARGET_set=
ac_cv_env_CXX_FOR_TARGET_value=
ac_cv_env_CXX_set=set
ac_cv_env_CXX_value=arm-linux-androideabi-g++
ac_cv_env_DLLTOOL_FOR_TARGET_set=
ac_cv_env_DLLTOOL_FOR_TARGET_value=
ac_cv_env_DLLTOOL_set=
ac_cv_env_DLLTOOL_value=
ac_cv_env_GCC_FOR_TARGET_set=
ac_cv_env_GCC_FOR_TARGET_value=
ac_cv_env_GCJ_FOR_TARGET_set=
ac_cv_env_GCJ_FOR_TARGET_value=
ac_cv_env_GFORTRAN_FOR_TARGET_set=
ac_cv_env_GFORTRAN_FOR_TARGET_value=
ac_cv_env_GOC_FOR_TARGET_set=
ac_cv_env_GOC_FOR_TARGET_value=
ac_cv_env_LDFLAGS_set=set
ac_cv_env_LDFLAGS_value=
ac_cv_env_LD_FOR_TARGET_set=
ac_cv_env_LD_FOR_TARGET_value=
ac_cv_env_LD_set=
ac_cv_env_LD_value=
ac_cv_env_LIBS_set=
ac_cv_env_LIBS_value=
ac_cv_env_LIPO_FOR_TARGET_set=
ac_cv_env_LIPO_FOR_TARGET_value=
ac_cv_env_LIPO_set=
ac_cv_env_LIPO_value=
ac_cv_env_NM_FOR_TARGET_set=
ac_cv_env_NM_FOR_TARGET_value=
ac_cv_env_NM_set=
ac_cv_env_NM_value=
ac_cv_env_OBJCOPY_set=
ac_cv_env_OBJCOPY_value=
ac_cv_env_OBJDUMP_FOR_TARGET_set=
ac_cv_env_OBJDUMP_FOR_TARGET_value=
ac_cv_env_OBJDUMP_set=
ac_cv_env_OBJDUMP_value=
ac_cv_env_RANLIB_FOR_TARGET_set=
ac_cv_env_RANLIB_FOR_TARGET_value=
ac_cv_env_RANLIB_set=
ac_cv_env_RANLIB_value=
ac_cv_env_READELF_FOR_TARGET_set=
ac_cv_env_READELF_FOR_TARGET_value=
ac_cv_env_READELF_set=
ac_cv_env_READELF_value=
ac_cv_env_STRIP_FOR_TARGET_set=
ac_cv_env_STRIP_FOR_TARGET_value=
ac_cv_env_STRIP_set=
ac_cv_env_STRIP_value=
ac_cv_env_WINDMC_FOR_TARGET_set=
ac_cv_env_WINDMC_FOR_TARGET_value=
ac_cv_env_WINDMC_set=
ac_cv_env_WINDMC_value=
ac_cv_env_WINDRES_FOR_TARGET_set=
ac_cv_env_WINDRES_FOR_TARGET_value=
ac_cv_env_WINDRES_set=
ac_cv_env_WINDRES_value=
ac_cv_env_build_alias_set=
ac_cv_env_build_alias_value=
ac_cv_env_build_configargs_set=
ac_cv_env_build_configargs_value=
ac_cv_env_host_alias_set=set
ac_cv_env_host_alias_value=x86_64-unknown-linux
ac_cv_env_host_configargs_set=
ac_cv_env_host_configargs_value=
ac_cv_env_target_alias_set=set
ac_cv_env_target_alias_value=i686-w64-mingw32
ac_cv_env_target_configargs_set=
ac_cv_env_target_configargs_value=
ac_cv_host=x86_64-unknown-linux-gnu
ac_cv_objext=o
ac_cv_path_SED=/usr/sbin/sed
ac_cv_path_install='/usr/bin/install -c'
ac_cv_prog_AR=ar
ac_cv_prog_AS=as
ac_cv_prog_AWK=gawk
ac_cv_prog_BISON=bison
ac_cv_prog_CC=arm-linux-androideabi-gcc
ac_cv_prog_FLEX=flex
ac_cv_prog_LD=/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld
ac_cv_prog_LEX=flex
ac_cv_prog_M4=m4
ac_cv_prog_MAKEINFO=makeinfo
ac_cv_prog_NM=nm
ac_cv_prog_OBJCOPY=objcopy
ac_cv_prog_OBJDUMP=objdump
ac_cv_prog_RANLIB=ranlib
ac_cv_prog_READELF=readelf
ac_cv_prog_STRIP=strip
ac_cv_prog_YACC='bison -y'
ac_cv_prog_cc_c89=
ac_cv_prog_cc_g=yes
ac_cv_prog_cxx_g=yes
ac_cv_target=i686-w64-mingw32
acx_cv_cc_gcc_supports_ada=no
acx_cv_prog_LN=ln
gcc_cv_cloog=no
gcc_cv_isl=yes
gcc_cv_prog_cmp_skip='cmp --ignore-initial=16 $$f1 $$f2'
gcc_cv_tool_dirs=
gcc_cv_tool_prefix=/usr
lt_cv_objdir=.libs

## ----------------- ##
## Output variables. ##
## ----------------- ##

AR='ar'
AR_FOR_BUILD='$(AR)'
AR_FOR_TARGET='$$r/$(HOST_SUBDIR)/binutils/ar'
AS='as'
AS_FOR_BUILD='$(AS)'
AS_FOR_TARGET='$$r/$(HOST_SUBDIR)/gas/as-new'
AWK='gawk'
BISON='bison'
BUILD_CONFIG=''
CC='arm-linux-androideabi-gcc'
CC_FOR_BUILD='$(CC)'
CC_FOR_TARGET='i686-w64-mingw32-cc'
CFLAGS=''
CFLAGS_FOR_BUILD=''
CFLAGS_FOR_TARGET='-g -O2 '
COMPILER_AS_FOR_TARGET='$(AS_FOR_TARGET)'
COMPILER_LD_FOR_TARGET='$(LD_FOR_TARGET)'
COMPILER_NM_FOR_TARGET='$(NM_FOR_TARGET)'
CONFIGURE_GDB_TK=''
CPPFLAGS=''
CXX='arm-linux-androideabi-g++'
CXXFLAGS=''
CXXFLAGS_FOR_BUILD=''
CXXFLAGS_FOR_TARGET='-g -O2 '
CXX_FOR_BUILD='$(CXX)'
CXX_FOR_TARGET='i686-w64-mingw32-c++'
DEBUG_PREFIX_CFLAGS_FOR_TARGET=''
DEFS='-DPACKAGE_NAME=\"\" -DPACKAGE_TARNAME=\"\" -DPACKAGE_VERSION=\"\" -DPACKAGE_STRING=\"\" -DPACKAGE_BUGREPORT=\"\" -DPACKAGE_URL=\"\" -DLT_OBJDIR=\".libs/\"'
DLLTOOL='dlltool'
DLLTOOL_FOR_BUILD='$(DLLTOOL)'
DLLTOOL_FOR_TARGET='$$r/$(HOST_SUBDIR)/binutils/dlltool'
ECHO_C=''
ECHO_N='-n'
ECHO_T=''
EXEEXT=''
EXPECT='expect'
EXTRA_CONFIGARGS_LIBJAVA='--disable-static'
FLAGS_FOR_TARGET=' -L${prefix}/${target}/lib -L${prefix}/mingw/lib -isystem ${prefix}/${target}/include -isystem ${prefix}/mingw/include -L$$r/$(HOST_SUBDIR)/ld'
FLEX='flex'
GCC_FOR_TARGET='i686-w64-mingw32-gcc'
GCC_SHLIB_SUBDIR=''
GCJ_FOR_BUILD='$(GCJ)'
GCJ_FOR_TARGET='i686-w64-mingw32-gcj'
GDB_TK=''
GFORTRAN_FOR_BUILD='$(GFORTRAN)'
GFORTRAN_FOR_TARGET='i686-w64-mingw32-gfortran'
GNATBIND='no'
GNATMAKE='no'
GOC_FOR_BUILD='$(GOC)'
GOC_FOR_TARGET='i686-w64-mingw32-gccgo'
INSTALL_DATA='${INSTALL} -m 644'
INSTALL_GDB_TK=''
INSTALL_PROGRAM='${INSTALL}'
INSTALL_SCRIPT='${INSTALL}'
LD='/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld'
LDFLAGS=''
LDFLAGS_FOR_BUILD=''
LDFLAGS_FOR_TARGET=''
LD_FOR_BUILD='$(LD)'
LD_FOR_TARGET='$$r/$(HOST_SUBDIR)/ld/ld-new'
LEX='flex'
LIBOBJS=''
LIBS=''
LIPO='lipo'
LIPO_FOR_TARGET='i686-w64-mingw32-lipo'
LN='ln'
LN_S='ln -s'
LTLIBOBJS=''
M4='m4'
MAINT='#'
MAINTAINER_MODE_FALSE=''
MAINTAINER_MODE_TRUE='#'
MAKEINFO='makeinfo'
NM='nm'
NM_FOR_BUILD='$(NM)'
NM_FOR_TARGET='$$r/$(HOST_SUBDIR)/binutils/nm-new'
OBJCOPY='objcopy'
OBJDUMP='objdump'
OBJDUMP_FOR_TARGET='$$r/$(HOST_SUBDIR)/binutils/objdump'
OBJEXT='o'
PACKAGE_BUGREPORT=''
PACKAGE_NAME=''
PACKAGE_STRING=''
PACKAGE_TARNAME=''
PACKAGE_URL=''
PACKAGE_VERSION=''
PATH_SEPARATOR=':'
RANLIB='ranlib'
RANLIB_FOR_BUILD='$(RANLIB)'
RANLIB_FOR_TARGET='$$r/$(HOST_SUBDIR)/binutils/ranlib'
RAW_CXX_FOR_TARGET='i686-w64-mingw32-c++'
READELF='readelf'
READELF_FOR_TARGET='$$r/$(HOST_SUBDIR)/binutils/readelf'
RPATH_ENVVAR='LD_LIBRARY_PATH'
RUNTEST='runtest'
SED='/usr/sbin/sed'
SHELL='/bin/sh'
STRIP='strip'
STRIP_FOR_TARGET='$$r/$(HOST_SUBDIR)/binutils/strip-new'
SYSROOT_CFLAGS_FOR_TARGET=''
TOPLEVEL_CONFIGURE_ARGUMENTS='/tmp/mingw-w64-binutils/src/binutils-2.25.1/configure --host x86_64-unknown-linux --prefix=/usr --target=i686-w64-mingw32 --infodir=/usr/share/info/i686-w64-mingw32 --enable-lto --enable-plugins --disable-multilib --disable-nls --disable-werror'
WINDMC='windmc'
WINDMC_FOR_BUILD='$(WINDMC)'
WINDMC_FOR_TARGET='$$r/$(HOST_SUBDIR)/binutils/windmc'
WINDRES='windres'
WINDRES_FOR_BUILD='$(WINDRES)'
WINDRES_FOR_TARGET='$$r/$(HOST_SUBDIR)/binutils/windres'
YACC='bison -y'
ac_ct_CC=''
ac_ct_CXX=''
bindir='${exec_prefix}/bin'
build='x86_64-unknown-linux-gnu'
build_alias=''
build_configargs=' --cache-file=../config.cache '\''--prefix=/usr'\'' '\''--infodir=/usr/share/info/i686-w64-mingw32'\'' '\''--enable-lto'\'' '\''--enable-plugins'\'' '\''--disable-multilib'\'' '\''--disable-nls'\'' '\''--disable-werror'\'' --program-transform-name='\''s&^&i686-w64-mingw32-&'\'' --disable-option-checking'
build_configdirs=' libiberty'
build_cpu='x86_64'
build_libsubdir='build-x86_64-unknown-linux-gnu'
build_noncanonical='x86_64-unknown-linux-gnu'
build_os='linux-gnu'
build_subdir='build-x86_64-unknown-linux-gnu'
build_tooldir='${exec_prefix}/i686-w64-mingw32'
build_vendor='unknown'
clooginc=''
clooglibs=''
compare_exclusions='gcc/cc*-checksum$(objext) | gcc/ada/*tools/*'
configdirs=' intl libiberty opcodes bfd binutils gas ld gprof etc'
datadir='${datarootdir}'
datarootdir='${prefix}/share'
do_compare='cmp --ignore-initial=16 $$f1 $$f2'
docdir='${datarootdir}/doc/${PACKAGE}'
dvidir='${docdir}'
exec_prefix='${prefix}'
extra_host_libiberty_configure_flags=''
extra_isl_gmp_configure_flags=''
extra_mpc_gmp_configure_flags=''
extra_mpc_mpfr_configure_flags=''
extra_mpfr_configure_flags=''
gmpinc=''
gmplibs='-lmpc -lmpfr -lgmp'
host='x86_64-unknown-linux-gnu'
host_alias='x86_64-unknown-linux'
host_configargs=' --cache-file=./config.cache  --with-gnu-as --with-gnu-ld --with-system-zlib '\''--prefix=/usr'\'' '\''--infodir=/usr/share/info/i686-w64-mingw32'\'' '\''--enable-lto'\'' '\''--enable-plugins'\'' '\''--disable-multilib'\'' '\''--disable-nls'\'' '\''--disable-werror'\'' --program-transform-name='\''s&^&i686-w64-mingw32-&'\'' --disable-option-checking'
host_cpu='x86_64'
host_noncanonical='x86_64-unknown-linux'
host_os='linux-gnu'
host_shared='no'
host_subdir='.'
host_vendor='unknown'
htmldir='${docdir}'
includedir='${prefix}/include'
infodir='/usr/share/info/i686-w64-mingw32'
islinc=''
libdir='${exec_prefix}/lib'
libexecdir='${exec_prefix}/libexec'
localedir='${datarootdir}/locale'
localstatedir='${prefix}/var'
mandir='${datarootdir}/man'
oldincludedir='/usr/include'
pdfdir='${docdir}'
poststage1_ldflags='-static-libstdc++ -static-libgcc'
poststage1_libs=''
prefix='/usr'
program_transform_name='s&^&i686-w64-mingw32-&'
psdir='${docdir}'
sbindir='${exec_prefix}/sbin'
sharedstatedir='${prefix}/com'
stage1_cflags='-g'
stage1_checking='--enable-checking=yes,types'
stage1_languages=',c,'
stage1_ldflags='-static-libstdc++ -static-libgcc'
stage1_libs=''
stage2_werror_flag=''
sysconfdir='${prefix}/etc'
target='i686-w64-mingw32'
target_alias='i686-w64-mingw32'
target_configargs='--cache-file=./config.cache --with-cross-host=x86_64-unknown-linux   '\''--prefix=/usr'\'' '\''--infodir=/usr/share/info/i686-w64-mingw32'\'' '\''--enable-lto'\'' '\''--enable-plugins'\'' '\''--disable-multilib'\'' '\''--disable-nls'\'' '\''--disable-werror'\'' --program-transform-name='\''s&^&i686-w64-mingw32-&'\'' --disable-option-checking'
target_configdirs=''
target_cpu='i686'
target_noncanonical='i686-w64-mingw32'
target_os='mingw32'
target_subdir='i686-w64-mingw32'
target_vendor='w64'
tooldir='${exec_prefix}/i686-w64-mingw32'

## ------------------- ##
## File substitutions. ##
## ------------------- ##

alphaieee_frag='/dev/null'
host_makefile_frag='/dev/null'
ospace_frag='/dev/null'
serialization_dependencies='serdep.tmp'
target_makefile_frag='/dev/null'

## ----------- ##
## confdefs.h. ##
## ----------- ##

/* confdefs.h */
#define PACKAGE_NAME ""
#define PACKAGE_TARNAME ""
#define PACKAGE_VERSION ""
#define PACKAGE_STRING ""
#define PACKAGE_BUGREPORT ""
#define PACKAGE_URL ""
#define LT_OBJDIR ".libs/"

configure: exit 0

____
File /tmp/mingw-w64-binutils/src/binutils-i686-w64-mingw32/bfd/config.log
This file contains any messages produced by compilers while
running configure, to aid debugging if configure makes a mistake.

It was created by bfd configure 2.25.1, which was
generated by GNU Autoconf 2.64.  Invocation command line was

  $ /tmp/mingw-w64-binutils/src/binutils-2.25.1/bfd/configure --cache-file=./config.cache --with-gnu-as --with-gnu-ld --with-system-zlib --prefix=/usr --infodir=/usr/share/info/i686-w64-mingw32 --enable-lto --enable-plugins --disable-multilib --disable-nls --disable-werror --program-transform-name=s&^&i686-w64-mingw32-& --disable-option-checking --build=x86_64-unknown-linux-gnu --host=x86_64-unknown-linux --target=i686-w64-mingw32 --srcdir=/tmp/mingw-w64-binutils/src/binutils-2.25.1/bfd

## --------- ##
## Platform. ##
## --------- ##

hostname = d5f3793a98c0
uname -m = x86_64
uname -r = 3.13.0-66-generic
uname -s = Linux
uname -v = #108-Ubuntu SMP Wed Oct 7 15:20:27 UTC 2015

/usr/bin/uname -p = unknown
/bin/uname -X     = unknown

/bin/arch              = unknown
/usr/bin/arch -k       = unknown
/usr/convex/getsysinfo = unknown
/usr/bin/hostinfo      = unknown
/bin/machine           = unknown
/usr/bin/oslevel       = unknown
/bin/universe          = unknown

PATH: /tmp/toolchain/bin
PATH: /usr/local/sbin
PATH: /usr/local/bin
PATH: /usr/sbin
PATH: /usr/bin
PATH: /sbin
PATH: /bin


## ----------- ##
## Core tests. ##
## ----------- ##

configure:2460: creating cache ./config.cache
configure:2565: checking build system type
configure:2579: result: x86_64-unknown-linux-gnu
configure:2599: checking host system type
configure:2612: result: x86_64-unknown-linux-gnu
configure:2632: checking target system type
configure:2645: result: i686-w64-mingw32
configure:2679: checking for x86_64-unknown-linux-gcc
configure:2706: result: arm-linux-androideabi-gcc
configure:2975: checking for C compiler version
configure:2984: arm-linux-androideabi-gcc --version >&5
arm-linux-androideabi-gcc (GCC) 4.8
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

configure:2995: $? = 0
configure:2984: arm-linux-androideabi-gcc -v >&5
Using built-in specs.
COLLECT_GCC=arm-linux-androideabi-gcc
COLLECT_LTO_WRAPPER=/tmp/toolchain/bin/../libexec/gcc/arm-linux-androideabi/4.8/lto-wrapper
Target: arm-linux-androideabi
Configured with: /s/ndk-toolchain/src/build/../gcc/gcc-4.8/configure --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --target=arm-linux-androideabi --host=x86_64-linux-gnu --build=x86_64-linux-gnu --with-gnu-as --with-gnu-ld --enable-languages=c,c++ --with-gmp=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpfr=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpc=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-cloog=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-isl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-ppl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --disable-ppl-version-check --disable-cloog-version-check --disable-isl-version-check --enable-cloog-backend=isl --with-host-libstdcxx='-static-libgcc -Wl,-Bstatic,-lstdc++,-Bdynamic -lm' --disable-libssp --enable-threads --disable-nls --disable-libmudflap --disable-libgomp --disable-libstdc__-v3 --disable-sjlj-exceptions --disable-shared --disable-tls --disable-libitm --with-float=soft --with-fpu=vfp --with-arch=armv5te --enable-target-optspace --enable-initfini-array --disable-nls --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --with-sysroot=/tmp/ndk-andrewhsieh/build/toolchain/prefix/sysroot --with-binutils-version=2.25 --with-mpfr-version=3.1.1 --with-mpc-version=1.0.1 --with-gmp-version=5.0.5 --with-gcc-version=4.8 --with-gdb-version=7.7 --with-python=/usr/local/google/home/andrewhsieh/mydroid/ndk/prebuilt/linux-x86_64/bin/python-config.sh --with-gxx-include-dir=/tmp/ndk-andrewhsieh/build/toolchain/prefix/include/c++/4.8 --with-bugurl=http://source.android.com/source/report-bugs.html --enable-languages=c,c++ --disable-bootstrap --enable-plugins --enable-libgomp --enable-gnu-indirect-function --disable-libsanitizer --enable-gold --enable-threads --enable-graphite=yes --with-cloog-version=0.18.0 --with-isl-version=0.11.1 --enable-eh-frame-hdr-for-static --with-arch=armv5te --program-transform-name='s&^&arm-linux-androideabi-&' --enable-gold=default
Thread model: posix
gcc version 4.8 (GCC) 
configure:2995: $? = 0
configure:2984: arm-linux-androideabi-gcc -V >&5
arm-linux-androideabi-gcc: error: unrecognized command line option '-V'
arm-linux-androideabi-gcc: fatal error: no input files
compilation terminated.
configure:2995: $? = 1
configure:2984: arm-linux-androideabi-gcc -qversion >&5
arm-linux-androideabi-gcc: error: unrecognized command line option '-qversion'
arm-linux-androideabi-gcc: fatal error: no input files
compilation terminated.
configure:2995: $? = 1
configure:3015: checking for C compiler default output file name
configure:3037: arm-linux-androideabi-gcc   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:3041: $? = 0
configure:3078: result: a.out
configure:3094: checking whether the C compiler works
configure:3122: result: yes
configure:3129: checking whether we are cross compiling
configure:3131: result: yes
configure:3134: checking for suffix of executables
configure:3141: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:3145: $? = 0
configure:3167: result: 
configure:3173: checking for suffix of object files
configure:3195: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:3199: $? = 0
configure:3220: result: o
configure:3224: checking whether we are using the GNU C compiler
configure:3243: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:3243: $? = 0
configure:3252: result: yes
configure:3261: checking whether arm-linux-androideabi-gcc accepts -g
configure:3281: arm-linux-androideabi-gcc -c -g  conftest.c >&5
configure:3281: $? = 0
configure:3322: result: yes
configure:3339: checking for arm-linux-androideabi-gcc option to accept ISO C89
configure:3403: arm-linux-androideabi-gcc  -c   conftest.c >&5
configure:3403: $? = 0
configure:3416: result: none needed
configure:3437: checking for library containing strerror
configure:3468: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:3468: $? = 0
configure:3485: result: none required
configure:3510: checking for a BSD-compatible install
configure:3578: result: /usr/bin/install -c
configure:3589: checking whether build environment is sane
configure:3639: result: yes
configure:3688: checking for x86_64-unknown-linux-strip
configure:3718: result: no
configure:3728: checking for strip
configure:3744: found /usr/sbin/strip
configure:3755: result: strip
configure:3767: WARNING: using cross tools not prefixed with host triplet
configure:3780: checking for a thread-safe mkdir -p
configure:3819: result: /usr/sbin/mkdir -p
configure:3832: checking for gawk
configure:3859: result: gawk
configure:3870: checking whether make sets $(MAKE)
configure:3892: result: yes
configure:3922: checking for style of include used by make
configure:3950: result: GNU
configure:4035: checking dependency style of arm-linux-androideabi-gcc
configure:4145: result: gcc3
configure:4165: checking for x86_64-unknown-linux-ar
configure:4192: result: ar
configure:4257: checking for x86_64-unknown-linux-ranlib
configure:4284: result: ranlib
configure:4387: checking for x86_64-unknown-linux-gcc
configure:4414: result: arm-linux-androideabi-gcc
configure:4683: checking for C compiler version
configure:4692: arm-linux-androideabi-gcc --version >&5
arm-linux-androideabi-gcc (GCC) 4.8
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

configure:4703: $? = 0
configure:4692: arm-linux-androideabi-gcc -v >&5
Using built-in specs.
COLLECT_GCC=arm-linux-androideabi-gcc
COLLECT_LTO_WRAPPER=/tmp/toolchain/bin/../libexec/gcc/arm-linux-androideabi/4.8/lto-wrapper
Target: arm-linux-androideabi
Configured with: /s/ndk-toolchain/src/build/../gcc/gcc-4.8/configure --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --target=arm-linux-androideabi --host=x86_64-linux-gnu --build=x86_64-linux-gnu --with-gnu-as --with-gnu-ld --enable-languages=c,c++ --with-gmp=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpfr=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpc=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-cloog=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-isl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-ppl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --disable-ppl-version-check --disable-cloog-version-check --disable-isl-version-check --enable-cloog-backend=isl --with-host-libstdcxx='-static-libgcc -Wl,-Bstatic,-lstdc++,-Bdynamic -lm' --disable-libssp --enable-threads --disable-nls --disable-libmudflap --disable-libgomp --disable-libstdc__-v3 --disable-sjlj-exceptions --disable-shared --disable-tls --disable-libitm --with-float=soft --with-fpu=vfp --with-arch=armv5te --enable-target-optspace --enable-initfini-array --disable-nls --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --with-sysroot=/tmp/ndk-andrewhsieh/build/toolchain/prefix/sysroot --with-binutils-version=2.25 --with-mpfr-version=3.1.1 --with-mpc-version=1.0.1 --with-gmp-version=5.0.5 --with-gcc-version=4.8 --with-gdb-version=7.7 --with-python=/usr/local/google/home/andrewhsieh/mydroid/ndk/prebuilt/linux-x86_64/bin/python-config.sh --with-gxx-include-dir=/tmp/ndk-andrewhsieh/build/toolchain/prefix/include/c++/4.8 --with-bugurl=http://source.android.com/source/report-bugs.html --enable-languages=c,c++ --disable-bootstrap --enable-plugins --enable-libgomp --enable-gnu-indirect-function --disable-libsanitizer --enable-gold --enable-threads --enable-graphite=yes --with-cloog-version=0.18.0 --with-isl-version=0.11.1 --enable-eh-frame-hdr-for-static --with-arch=armv5te --program-transform-name='s&^&arm-linux-androideabi-&' --enable-gold=default
Thread model: posix
gcc version 4.8 (GCC) 
configure:4703: $? = 0
configure:4692: arm-linux-androideabi-gcc -V >&5
arm-linux-androideabi-gcc: error: unrecognized command line option '-V'
arm-linux-androideabi-gcc: fatal error: no input files
compilation terminated.
configure:4703: $? = 1
configure:4692: arm-linux-androideabi-gcc -qversion >&5
arm-linux-androideabi-gcc: error: unrecognized command line option '-qversion'
arm-linux-androideabi-gcc: fatal error: no input files
compilation terminated.
configure:4703: $? = 1
configure:4707: checking whether we are using the GNU C compiler
configure:4735: result: yes
configure:4744: checking whether arm-linux-androideabi-gcc accepts -g
configure:4805: result: yes
configure:4822: checking for arm-linux-androideabi-gcc option to accept ISO C89
configure:4899: result: none needed
configure:4924: checking how to run the C preprocessor
configure:4955: arm-linux-androideabi-gcc -E  conftest.c
configure:4955: $? = 0
configure:4969: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:11:28: fatal error: ac_nonexistent.h: No such file or directory
 #include <ac_nonexistent.h>
                            ^
compilation terminated.
configure:4969: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "bfd"
| #define PACKAGE_TARNAME "bfd"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "bfd 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "bfd"
| #define VERSION "2.25.1"
| /* end confdefs.h.  */
| #include <ac_nonexistent.h>
configure:4994: result: arm-linux-androideabi-gcc -E
configure:5014: arm-linux-androideabi-gcc -E  conftest.c
configure:5014: $? = 0
configure:5028: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:11:28: fatal error: ac_nonexistent.h: No such file or directory
 #include <ac_nonexistent.h>
                            ^
compilation terminated.
configure:5028: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "bfd"
| #define PACKAGE_TARNAME "bfd"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "bfd 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "bfd"
| #define VERSION "2.25.1"
| /* end confdefs.h.  */
| #include <ac_nonexistent.h>
configure:5057: checking for grep that handles long lines and -e
configure:5115: result: /usr/sbin/grep
configure:5120: checking for egrep
configure:5182: result: /usr/sbin/grep -E
configure:5187: checking for ANSI C header files
configure:5207: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5207: $? = 0
configure:5291: result: yes
configure:5304: checking for sys/types.h
configure:5304: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5304: $? = 0
configure:5304: result: yes
configure:5304: checking for sys/stat.h
configure:5304: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5304: $? = 0
configure:5304: result: yes
configure:5304: checking for stdlib.h
configure:5304: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5304: $? = 0
configure:5304: result: yes
configure:5304: checking for string.h
configure:5304: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5304: $? = 0
configure:5304: result: yes
configure:5304: checking for memory.h
configure:5304: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5304: $? = 0
configure:5304: result: yes
configure:5304: checking for strings.h
configure:5304: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5304: $? = 0
configure:5304: result: yes
configure:5304: checking for inttypes.h
configure:5304: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5304: $? = 0
configure:5304: result: yes
configure:5304: checking for stdint.h
configure:5304: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5304: $? = 0
configure:5304: result: yes
configure:5304: checking for unistd.h
configure:5304: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5304: $? = 0
configure:5304: result: yes
configure:5318: checking minix/config.h usability
configure:5318: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:54:26: fatal error: minix/config.h: No such file or directory
 #include <minix/config.h>
                          ^
compilation terminated.
configure:5318: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "bfd"
| #define PACKAGE_TARNAME "bfd"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "bfd 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "bfd"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <minix/config.h>
configure:5318: result: no
configure:5318: checking minix/config.h presence
configure:5318: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:21:26: fatal error: minix/config.h: No such file or directory
 #include <minix/config.h>
                          ^
compilation terminated.
configure:5318: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "bfd"
| #define PACKAGE_TARNAME "bfd"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "bfd 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "bfd"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| /* end confdefs.h.  */
| #include <minix/config.h>
configure:5318: result: no
configure:5318: checking for minix/config.h
configure:5318: result: no
configure:5339: checking whether it is safe to define __EXTENSIONS__
configure:5357: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5357: $? = 0
configure:5364: result: yes
configure:5427: checking how to print strings
configure:5454: result: printf
configure:5475: checking for a sed that does not truncate output
configure:5539: result: /usr/sbin/sed
configure:5557: checking for fgrep
configure:5619: result: /usr/sbin/grep -F
configure:5654: checking for ld used by arm-linux-androideabi-gcc
configure:5721: result: /tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld
configure:5728: checking if the linker (/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld) is GNU ld
configure:5743: result: yes
configure:5755: checking for BSD- or MS-compatible name lister (nm)
configure:5804: result: nm
configure:5934: checking the name lister (nm) interface
configure:5941: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5944: nm "conftest.o"
configure:5947: output
00000000 b $d
00000000 B some_variable
configure:5954: result: BSD nm
configure:5957: checking whether ln -s works
configure:5961: result: yes
configure:5969: checking the maximum length of command line arguments
configure:6094: result: 1572864
configure:6111: checking whether the shell understands some XSI constructs
configure:6121: result: yes
configure:6125: checking whether the shell understands "+="
configure:6131: result: yes
configure:6166: checking for /tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld option to reload object files
configure:6173: result: -r
configure:6202: checking for x86_64-unknown-linux-objdump
configure:6229: result: objdump
configure:6301: checking how to recognize dependent libraries
configure:6502: result: pass_all
configure:6522: checking for x86_64-unknown-linux-ar
configure:6549: result: ar
configure:6627: checking for x86_64-unknown-linux-strip
configure:6654: result: strip
configure:6726: checking for x86_64-unknown-linux-ranlib
configure:6753: result: ranlib
configure:6895: checking command to parse nm output from arm-linux-androideabi-gcc object
configure:7013: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:7016: $? = 0
configure:7020: nm conftest.o \| sed -n -e 's/^.*[ ]\([ABCDGIRSTW][ABCDGIRSTW]*\)[ ][ ]*\([_A-Za-z][_A-Za-z0-9]*\)$/\1 \2 \2/p' \> conftest.nm
configure:7023: $? = 0
configure:7077: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c conftstm.o >&5
configure:7080: $? = 0
configure:7118: result: ok
configure:7213: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:7216: $? = 0
configure:7966: checking for dlfcn.h
configure:7966: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:7966: $? = 0
configure:7966: result: yes
configure:8122: checking for objdir
configure:8137: result: .libs
configure:8408: checking if arm-linux-androideabi-gcc supports -fno-rtti -fno-exceptions
configure:8426: arm-linux-androideabi-gcc -c   -fno-rtti -fno-exceptions conftest.c >&5
cc1: warning: command line option '-fno-rtti' is valid for C++/ObjC++ but not for C [enabled by default]
configure:8430: $? = 0
configure:8443: result: no
configure:8463: checking for arm-linux-androideabi-gcc option to produce PIC
configure:8749: result: -fPIC -DPIC
configure:8761: checking if arm-linux-androideabi-gcc PIC flag -fPIC -DPIC works
configure:8779: arm-linux-androideabi-gcc -c   -fPIC -DPIC -DPIC conftest.c >&5
configure:8783: $? = 0
configure:8796: result: yes
configure:8820: checking if arm-linux-androideabi-gcc static flag -static works
configure:8848: result: yes
configure:8863: checking if arm-linux-androideabi-gcc supports -c -o file.o
configure:8884: arm-linux-androideabi-gcc -c   -o out/conftest2.o conftest.c >&5
configure:8888: $? = 0
configure:8910: result: yes
configure:8918: checking if arm-linux-androideabi-gcc supports -c -o file.o
configure:8965: result: yes
configure:8998: checking whether the arm-linux-androideabi-gcc linker (/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld -m elf_i386) supports shared libraries
configure:10069: result: yes
configure:10314: checking dynamic linker characteristics
configure:10765: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  -Wl,-rpath -Wl,/foo conftest.c  >&5
configure:10765: $? = 0
configure:10987: result: GNU/Linux ld.so
configure:11094: checking how to hardcode library paths into programs
configure:11119: result: immediate
configure:11213: checking for shl_load
configure:11213: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
/tmp/ccMDJbqu.o:conftest.c:function main: error: undefined reference to 'shl_load'
collect2: error: ld returned 1 exit status
configure:11213: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "bfd"
| #define PACKAGE_TARNAME "bfd"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "bfd 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "bfd"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| /* end confdefs.h.  */
| /* Define shl_load to an innocuous variant, in case <limits.h> declares shl_load.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define shl_load innocuous_shl_load
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char shl_load (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef shl_load
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char shl_load ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_shl_load || defined __stub___shl_load
| choke me
| #endif
| 
| int
| main ()
| {
| return shl_load ();
|   ;
|   return 0;
| }
configure:11213: result: no
configure:11217: checking for shl_load in -ldld
configure:11242: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c -ldld   >&5
/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld: error: cannot find -ldld
/tmp/cc6i1buI.o:conftest.c:function main: error: undefined reference to 'shl_load'
collect2: error: ld returned 1 exit status
configure:11242: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "bfd"
| #define PACKAGE_TARNAME "bfd"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "bfd 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "bfd"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| /* end confdefs.h.  */
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char shl_load ();
| int
| main ()
| {
| return shl_load ();
|   ;
|   return 0;
| }
configure:11251: result: no
configure:11256: checking for dlopen
configure:11256: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:11256: $? = 0
configure:11256: result: yes
configure:11413: checking whether a program can dlopen itself
configure:11514: result: cross
configure:11659: checking whether stripping libraries is possible
configure:11664: result: yes
configure:11699: checking if libtool supports shared libraries
configure:11701: result: yes
configure:11704: checking whether to build shared libraries
configure:11725: result: no
configure:11728: checking whether to build static libraries
configure:11732: result: yes
configure:11782: checking for dlfcn.h
configure:11782: result: yes
configure:11795: checking for windows.h
configure:11795: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:63:21: fatal error: windows.h: No such file or directory
 #include <windows.h>
                     ^
compilation terminated.
configure:11795: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "bfd"
| #define PACKAGE_TARNAME "bfd"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "bfd 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "bfd"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| 
| #include <windows.h>
configure:11795: result: no
configure:11822: checking for library containing dlopen
configure:11853: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:11853: $? = 0
configure:11870: result: none required
configure:11901: checking for special C compiler options needed for large files
configure:11946: result: no
configure:11952: checking for _FILE_OFFSET_BITS value needed for large files
configure:11977: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:35:3: warning: left shift count >= width of type [enabled by default]
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
   ^
conftest.c:35:3: warning: left shift count >= width of type [enabled by default]
conftest.c:36:10: warning: left shift count >= width of type [enabled by default]
          && LARGE_OFF_T % 2147483647 == 1)
          ^
conftest.c:36:10: warning: left shift count >= width of type [enabled by default]
conftest.c:35:7: error: variably modified 'off_t_is_large' at file scope
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
       ^
configure:11977: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "bfd"
| #define PACKAGE_TARNAME "bfd"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "bfd 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "bfd"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| /* end confdefs.h.  */
| #include <sys/types.h>
|  /* Check that off_t can represent 2**63 - 1 correctly.
|     We can't simply define LARGE_OFF_T to be 9223372036854775807,
|     since some C++ compilers masquerading as C compilers
|     incorrectly reject 9223372036854775807.  */
| #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
|   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
| 		       && LARGE_OFF_T % 2147483647 == 1)
| 		      ? 1 : -1];
| int
| main ()
| {
| 
|   ;
|   return 0;
| }
configure:12001: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:36:3: warning: left shift count >= width of type [enabled by default]
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
   ^
conftest.c:36:3: warning: left shift count >= width of type [enabled by default]
conftest.c:37:10: warning: left shift count >= width of type [enabled by default]
          && LARGE_OFF_T % 2147483647 == 1)
          ^
conftest.c:37:10: warning: left shift count >= width of type [enabled by default]
conftest.c:36:7: error: variably modified 'off_t_is_large' at file scope
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
       ^
configure:12001: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "bfd"
| #define PACKAGE_TARNAME "bfd"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "bfd 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "bfd"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| /* end confdefs.h.  */
| #define _FILE_OFFSET_BITS 64
| #include <sys/types.h>
|  /* Check that off_t can represent 2**63 - 1 correctly.
|     We can't simply define LARGE_OFF_T to be 9223372036854775807,
|     since some C++ compilers masquerading as C compilers
|     incorrectly reject 9223372036854775807.  */
| #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
|   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
| 		       && LARGE_OFF_T % 2147483647 == 1)
| 		      ? 1 : -1];
| int
| main ()
| {
| 
|   ;
|   return 0;
| }
configure:12009: result: unknown
configure:12021: checking for _LARGE_FILES value needed for large files
configure:12046: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:35:3: warning: left shift count >= width of type [enabled by default]
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
   ^
conftest.c:35:3: warning: left shift count >= width of type [enabled by default]
conftest.c:36:10: warning: left shift count >= width of type [enabled by default]
          && LARGE_OFF_T % 2147483647 == 1)
          ^
conftest.c:36:10: warning: left shift count >= width of type [enabled by default]
conftest.c:35:7: error: variably modified 'off_t_is_large' at file scope
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
       ^
configure:12046: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "bfd"
| #define PACKAGE_TARNAME "bfd"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "bfd 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "bfd"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| /* end confdefs.h.  */
| #include <sys/types.h>
|  /* Check that off_t can represent 2**63 - 1 correctly.
|     We can't simply define LARGE_OFF_T to be 9223372036854775807,
|     since some C++ compilers masquerading as C compilers
|     incorrectly reject 9223372036854775807.  */
| #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
|   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
| 		       && LARGE_OFF_T % 2147483647 == 1)
| 		      ? 1 : -1];
| int
| main ()
| {
| 
|   ;
|   return 0;
| }
configure:12070: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:36:3: warning: left shift count >= width of type [enabled by default]
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
   ^
conftest.c:36:3: warning: left shift count >= width of type [enabled by default]
conftest.c:37:10: warning: left shift count >= width of type [enabled by default]
          && LARGE_OFF_T % 2147483647 == 1)
          ^
conftest.c:37:10: warning: left shift count >= width of type [enabled by default]
conftest.c:36:7: error: variably modified 'off_t_is_large' at file scope
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
       ^
configure:12070: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "bfd"
| #define PACKAGE_TARNAME "bfd"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "bfd 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "bfd"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| /* end confdefs.h.  */
| #define _LARGE_FILES 1
| #include <sys/types.h>
|  /* Check that off_t can represent 2**63 - 1 correctly.
|     We can't simply define LARGE_OFF_T to be 9223372036854775807,
|     since some C++ compilers masquerading as C compilers
|     incorrectly reject 9223372036854775807.  */
| #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
|   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
| 		       && LARGE_OFF_T % 2147483647 == 1)
| 		      ? 1 : -1];
| int
| main ()
| {
| 
|   ;
|   return 0;
| }
configure:12078: result: unknown
configure:12333: checking whether to enable maintainer-specific portions of Makefiles
configure:12342: result: no
configure:12378: checking whether to install libbfd
configure:12391: result: no
configure:12441: checking whether NLS is requested
configure:12444: result: no
configure:12512: checking whether NLS is requested
configure:12521: result: no
configure:12559: checking for msgfmt
configure:12590: result: /usr/sbin/msgfmt
configure:12599: checking for gmsgfmt
configure:12630: result: /usr/sbin/msgfmt
configure:12670: checking for xgettext
configure:12701: result: /usr/sbin/xgettext
configure:12741: checking for msgmerge
configure:12771: result: /usr/sbin/msgmerge
configure:12824: checking size of long long
configure:12829: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12829: $? = 0
configure:12829: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:66:12: error: size of array 'test_array' is negative
 static int test_array [1 - 2 * !(((long int) (sizeof (long long))) <= 0)];
            ^
configure:12829: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "bfd"
| #define PACKAGE_TARNAME "bfd"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "bfd 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "bfd"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define USE_SECUREPLT 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static int test_array [1 - 2 * !(((long int) (sizeof (long long))) <= 0)];
| test_array [0] = 0
| 
|   ;
|   return 0;
| }
configure:12829: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:66:12: error: size of array 'test_array' is negative
 static int test_array [1 - 2 * !(((long int) (sizeof (long long))) <= 1)];
            ^
configure:12829: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "bfd"
| #define PACKAGE_TARNAME "bfd"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "bfd 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "bfd"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define USE_SECUREPLT 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static int test_array [1 - 2 * !(((long int) (sizeof (long long))) <= 1)];
| test_array [0] = 0
| 
|   ;
|   return 0;
| }
configure:12829: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:66:12: error: size of array 'test_array' is negative
 static int test_array [1 - 2 * !(((long int) (sizeof (long long))) <= 3)];
            ^
configure:12829: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "bfd"
| #define PACKAGE_TARNAME "bfd"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "bfd 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "bfd"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define USE_SECUREPLT 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static int test_array [1 - 2 * !(((long int) (sizeof (long long))) <= 3)];
| test_array [0] = 0
| 
|   ;
|   return 0;
| }
configure:12829: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:66:12: error: size of array 'test_array' is negative
 static int test_array [1 - 2 * !(((long int) (sizeof (long long))) <= 7)];
            ^
configure:12829: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "bfd"
| #define PACKAGE_TARNAME "bfd"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "bfd 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "bfd"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define USE_SECUREPLT 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static int test_array [1 - 2 * !(((long int) (sizeof (long long))) <= 7)];
| test_array [0] = 0
| 
|   ;
|   return 0;
| }
configure:12829: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12829: $? = 0
configure:12829: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12829: $? = 0
configure:12829: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12829: $? = 0
configure:12829: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12829: $? = 0
configure:12844: result: 8
configure:12858: checking size of void *
configure:12863: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12863: $? = 0
configure:12863: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:67:12: error: size of array 'test_array' is negative
 static int test_array [1 - 2 * !(((long int) (sizeof (void *))) <= 0)];
            ^
configure:12863: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "bfd"
| #define PACKAGE_TARNAME "bfd"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "bfd 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "bfd"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define USE_SECUREPLT 1
| #define SIZEOF_LONG_LONG 8
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static int test_array [1 - 2 * !(((long int) (sizeof (void *))) <= 0)];
| test_array [0] = 0
| 
|   ;
|   return 0;
| }
configure:12863: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:67:12: error: size of array 'test_array' is negative
 static int test_array [1 - 2 * !(((long int) (sizeof (void *))) <= 1)];
            ^
configure:12863: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "bfd"
| #define PACKAGE_TARNAME "bfd"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "bfd 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "bfd"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define USE_SECUREPLT 1
| #define SIZEOF_LONG_LONG 8
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static int test_array [1 - 2 * !(((long int) (sizeof (void *))) <= 1)];
| test_array [0] = 0
| 
|   ;
|   return 0;
| }
configure:12863: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:67:12: error: size of array 'test_array' is negative
 static int test_array [1 - 2 * !(((long int) (sizeof (void *))) <= 3)];
            ^
configure:12863: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "bfd"
| #define PACKAGE_TARNAME "bfd"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "bfd 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "bfd"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define USE_SECUREPLT 1
| #define SIZEOF_LONG_LONG 8
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static int test_array [1 - 2 * !(((long int) (sizeof (void *))) <= 3)];
| test_array [0] = 0
| 
|   ;
|   return 0;
| }
configure:12863: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12863: $? = 0
configure:12863: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12863: $? = 0
configure:12863: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12863: $? = 0
configure:12878: result: 4
configure:12892: checking size of long
configure:12897: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12897: $? = 0
configure:12897: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:68:12: error: size of array 'test_array' is negative
 static int test_array [1 - 2 * !(((long int) (sizeof (long))) <= 0)];
            ^
configure:12897: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "bfd"
| #define PACKAGE_TARNAME "bfd"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "bfd 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "bfd"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define USE_SECUREPLT 1
| #define SIZEOF_LONG_LONG 8
| #define SIZEOF_VOID_P 4
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static int test_array [1 - 2 * !(((long int) (sizeof (long))) <= 0)];
| test_array [0] = 0
| 
|   ;
|   return 0;
| }
configure:12897: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:68:12: error: size of array 'test_array' is negative
 static int test_array [1 - 2 * !(((long int) (sizeof (long))) <= 1)];
            ^
configure:12897: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "bfd"
| #define PACKAGE_TARNAME "bfd"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "bfd 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "bfd"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define USE_SECUREPLT 1
| #define SIZEOF_LONG_LONG 8
| #define SIZEOF_VOID_P 4
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static int test_array [1 - 2 * !(((long int) (sizeof (long))) <= 1)];
| test_array [0] = 0
| 
|   ;
|   return 0;
| }
configure:12897: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:68:12: error: size of array 'test_array' is negative
 static int test_array [1 - 2 * !(((long int) (sizeof (long))) <= 3)];
            ^
configure:12897: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "bfd"
| #define PACKAGE_TARNAME "bfd"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "bfd 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "bfd"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define USE_SECUREPLT 1
| #define SIZEOF_LONG_LONG 8
| #define SIZEOF_VOID_P 4
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static int test_array [1 - 2 * !(((long int) (sizeof (long))) <= 3)];
| test_array [0] = 0
| 
|   ;
|   return 0;
| }
configure:12897: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12897: $? = 0
configure:12897: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12897: $? = 0
configure:12897: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12897: $? = 0
configure:12912: result: 4
configure:12966: checking for build system executable suffix
configure:12984: result: no
configure:12994: checking alloca.h usability
configure:12994: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12994: $? = 0
configure:12994: result: yes
configure:12994: checking alloca.h presence
configure:12994: arm-linux-androideabi-gcc -E  conftest.c
configure:12994: $? = 0
configure:12994: result: yes
configure:12994: checking for alloca.h
configure:12994: result: yes
configure:12994: checking stddef.h usability
configure:12994: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12994: $? = 0
configure:12994: result: yes
configure:12994: checking stddef.h presence
configure:12994: arm-linux-androideabi-gcc -E  conftest.c
configure:12994: $? = 0
configure:12994: result: yes
configure:12994: checking for stddef.h
configure:12994: result: yes
configure:12994: checking for string.h
configure:12994: result: yes
configure:12994: checking for strings.h
configure:12994: result: yes
configure:12994: checking for stdlib.h
configure:12994: result: yes
configure:12994: checking time.h usability
configure:12994: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12994: $? = 0
configure:12994: result: yes
configure:12994: checking time.h presence
configure:12994: arm-linux-androideabi-gcc -E  conftest.c
configure:12994: $? = 0
configure:12994: result: yes
configure:12994: checking for time.h
configure:12994: result: yes
configure:12994: checking for unistd.h
configure:12994: result: yes
configure:12994: checking wchar.h usability
configure:12994: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12994: $? = 0
configure:12994: result: yes
configure:12994: checking wchar.h presence
configure:12994: arm-linux-androideabi-gcc -E  conftest.c
configure:12994: $? = 0
configure:12994: result: yes
configure:12994: checking for wchar.h
configure:12994: result: yes
configure:13008: checking fcntl.h usability
configure:13008: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13008: $? = 0
configure:13008: result: yes
configure:13008: checking fcntl.h presence
configure:13008: arm-linux-androideabi-gcc -E  conftest.c
configure:13008: $? = 0
configure:13008: result: yes
configure:13008: checking for fcntl.h
configure:13008: result: yes
configure:13008: checking sys/file.h usability
configure:13008: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13008: $? = 0
configure:13008: result: yes
configure:13008: checking sys/file.h presence
configure:13008: arm-linux-androideabi-gcc -E  conftest.c
configure:13008: $? = 0
configure:13008: result: yes
configure:13008: checking for sys/file.h
configure:13008: result: yes
configure:13008: checking sys/time.h usability
configure:13008: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13008: $? = 0
configure:13008: result: yes
configure:13008: checking sys/time.h presence
configure:13008: arm-linux-androideabi-gcc -E  conftest.c
configure:13008: $? = 0
configure:13008: result: yes
configure:13008: checking for sys/time.h
configure:13008: result: yes
configure:13008: checking for sys/stat.h
configure:13008: result: yes
configure:13008: checking sys/resource.h usability
configure:13008: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13008: $? = 0
configure:13008: result: yes
configure:13008: checking sys/resource.h presence
configure:13008: arm-linux-androideabi-gcc -E  conftest.c
configure:13008: $? = 0
configure:13008: result: yes
configure:13008: checking for sys/resource.h
configure:13008: result: yes
configure:13032: checking for uintmax_t
configure:13032: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13032: $? = 0
configure:13032: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:52:24: error: expected expression before ')' token
 if (sizeof ((uintmax_t)))
                        ^
configure:13032: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "bfd"
| #define PACKAGE_TARNAME "bfd"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "bfd 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "bfd"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define USE_SECUREPLT 1
| #define SIZEOF_LONG_LONG 8
| #define SIZEOF_VOID_P 4
| #define SIZEOF_LONG 4
| #define HAVE_ALLOCA_H 1
| #define HAVE_STDDEF_H 1
| #define HAVE_STRING_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_RESOURCE_H 1
| /* end confdefs.h.  */
| #include <sys/types.h>
| #include <stdint.h>
| 
| int
| main ()
| {
| if (sizeof ((uintmax_t)))
| 	    return 0;
|   ;
|   return 0;
| }
configure:13032: result: yes
configure:13041: checking for uintptr_t
configure:13041: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13041: $? = 0
configure:13041: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:52:24: error: expected expression before ')' token
 if (sizeof ((uintptr_t)))
                        ^
configure:13041: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "bfd"
| #define PACKAGE_TARNAME "bfd"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "bfd 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "bfd"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define USE_SECUREPLT 1
| #define SIZEOF_LONG_LONG 8
| #define SIZEOF_VOID_P 4
| #define SIZEOF_LONG 4
| #define HAVE_ALLOCA_H 1
| #define HAVE_STDDEF_H 1
| #define HAVE_STRING_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_RESOURCE_H 1
| /* end confdefs.h.  */
| #include <sys/types.h>
| #include <stdint.h>
| 
| int
| main ()
| {
| if (sizeof ((uintptr_t)))
| 	    return 0;
|   ;
|   return 0;
| }
configure:13041: result: yes
configure:13050: checking for int_least32_t
configure:13050: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13050: $? = 0
configure:13050: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:52:28: error: expected expression before ')' token
 if (sizeof ((int_least32_t)))
                            ^
configure:13050: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "bfd"
| #define PACKAGE_TARNAME "bfd"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "bfd 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "bfd"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define USE_SECUREPLT 1
| #define SIZEOF_LONG_LONG 8
| #define SIZEOF_VOID_P 4
| #define SIZEOF_LONG 4
| #define HAVE_ALLOCA_H 1
| #define HAVE_STDDEF_H 1
| #define HAVE_STRING_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_RESOURCE_H 1
| /* end confdefs.h.  */
| #include <sys/types.h>
| #include <stdint.h>
| 
| int
| main ()
| {
| if (sizeof ((int_least32_t)))
| 	    return 0;
|   ;
|   return 0;
| }
configure:13050: result: yes
configure:13059: checking for int_fast32_t
configure:13059: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13059: $? = 0
configure:13059: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:52:27: error: expected expression before ')' token
 if (sizeof ((int_fast32_t)))
                           ^
configure:13059: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "bfd"
| #define PACKAGE_TARNAME "bfd"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "bfd 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "bfd"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define USE_SECUREPLT 1
| #define SIZEOF_LONG_LONG 8
| #define SIZEOF_VOID_P 4
| #define SIZEOF_LONG 4
| #define HAVE_ALLOCA_H 1
| #define HAVE_STDDEF_H 1
| #define HAVE_STRING_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_RESOURCE_H 1
| /* end confdefs.h.  */
| #include <sys/types.h>
| #include <stdint.h>
| 
| int
| main ()
| {
| if (sizeof ((int_fast32_t)))
| 	    return 0;
|   ;
|   return 0;
| }
configure:13059: result: yes
configure:13068: checking for uint64_t
configure:13068: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13068: $? = 0
configure:13068: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:52:23: error: expected expression before ')' token
 if (sizeof ((uint64_t)))
                       ^
configure:13068: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "bfd"
| #define PACKAGE_TARNAME "bfd"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "bfd 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "bfd"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define USE_SECUREPLT 1
| #define SIZEOF_LONG_LONG 8
| #define SIZEOF_VOID_P 4
| #define SIZEOF_LONG 4
| #define HAVE_ALLOCA_H 1
| #define HAVE_STDDEF_H 1
| #define HAVE_STRING_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_RESOURCE_H 1
| /* end confdefs.h.  */
| #include <sys/types.h>
| #include <stdint.h>
| 
| int
| main ()
| {
| if (sizeof ((uint64_t)))
| 	    return 0;
|   ;
|   return 0;
| }
configure:13068: result: yes
configure:13149: checking what to include in bfd_stdint.h
configure:13177: result: stdint.h (already complete)
configure:13425: checking whether time.h and sys/time.h may both be included
configure:13445: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13445: $? = 0
configure:13452: result: yes
configure:13463: checking for dirent.h that defines DIR
configure:13482: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13482: $? = 0
configure:13490: result: yes
configure:13504: checking for library containing opendir
configure:13535: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:13535: $? = 0
configure:13552: result: none required
configure:13620: checking whether string.h and strings.h may both be included
configure:13637: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13637: $? = 0
configure:13644: result: yes
configure:13655: checking for fcntl
configure:13655: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:13655: $? = 0
configure:13655: result: yes
configure:13655: checking for getpagesize
configure:13655: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:13655: $? = 0
configure:13655: result: yes
configure:13655: checking for setitimer
configure:13655: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:13655: $? = 0
configure:13655: result: yes
configure:13655: checking for sysconf
configure:13655: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:13655: $? = 0
configure:13655: result: yes
configure:13655: checking for fdopen
configure:13655: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:13655: $? = 0
configure:13655: result: yes
configure:13655: checking for getuid
configure:13655: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:13655: $? = 0
configure:13655: result: yes
configure:13655: checking for getgid
configure:13655: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:13655: $? = 0
configure:13655: result: yes
configure:13655: checking for fileno
configure:13655: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:13655: $? = 0
configure:13655: result: yes
configure:13668: checking for strtoull
configure:13668: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:13668: $? = 0
configure:13668: result: yes
configure:13668: checking for getrlimit
configure:13668: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:13668: $? = 0
configure:13668: result: yes
configure:13679: checking whether basename is declared
configure:13679: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:99:10: error: 'basename' undeclared (first use in this function)
   (void) basename;
          ^
conftest.c:99:10: note: each undeclared identifier is reported only once for each function it appears in
configure:13679: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "bfd"
| #define PACKAGE_TARNAME "bfd"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "bfd 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "bfd"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define USE_SECUREPLT 1
| #define SIZEOF_LONG_LONG 8
| #define SIZEOF_VOID_P 4
| #define SIZEOF_LONG 4
| #define HAVE_ALLOCA_H 1
| #define HAVE_STDDEF_H 1
| #define HAVE_STRING_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_DIRENT_H 1
| #define STRING_WITH_STRINGS 1
| #define HAVE_FCNTL 1
| #define HAVE_GETPAGESIZE 1
| #define HAVE_SETITIMER 1
| #define HAVE_SYSCONF 1
| #define HAVE_FDOPEN 1
| #define HAVE_GETUID 1
| #define HAVE_GETGID 1
| #define HAVE_FILENO 1
| #define HAVE_STRTOULL 1
| #define HAVE_GETRLIMIT 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| #ifndef basename
| #ifdef __cplusplus
|   (void) basename;
| #else
|   (void) basename;
| #endif
| #endif
| 
|   ;
|   return 0;
| }
configure:13679: result: no
configure:13690: checking whether ftello is declared
configure:13690: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13690: $? = 0
configure:13690: result: yes
configure:13701: checking whether ftello64 is declared
configure:13701: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:101:10: error: 'ftello64' undeclared (first use in this function)
   (void) ftello64;
          ^
conftest.c:101:10: note: each undeclared identifier is reported only once for each function it appears in
configure:13701: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "bfd"
| #define PACKAGE_TARNAME "bfd"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "bfd 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "bfd"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define USE_SECUREPLT 1
| #define SIZEOF_LONG_LONG 8
| #define SIZEOF_VOID_P 4
| #define SIZEOF_LONG 4
| #define HAVE_ALLOCA_H 1
| #define HAVE_STDDEF_H 1
| #define HAVE_STRING_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_DIRENT_H 1
| #define STRING_WITH_STRINGS 1
| #define HAVE_FCNTL 1
| #define HAVE_GETPAGESIZE 1
| #define HAVE_SETITIMER 1
| #define HAVE_SYSCONF 1
| #define HAVE_FDOPEN 1
| #define HAVE_GETUID 1
| #define HAVE_GETGID 1
| #define HAVE_FILENO 1
| #define HAVE_STRTOULL 1
| #define HAVE_GETRLIMIT 1
| #define HAVE_DECL_BASENAME 0
| #define HAVE_DECL_FTELLO 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| #ifndef ftello64
| #ifdef __cplusplus
|   (void) ftello64;
| #else
|   (void) ftello64;
| #endif
| #endif
| 
|   ;
|   return 0;
| }
configure:13701: result: no
configure:13712: checking whether fseeko is declared
configure:13712: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13712: $? = 0
configure:13712: result: yes
configure:13723: checking whether fseeko64 is declared
configure:13723: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:103:10: error: 'fseeko64' undeclared (first use in this function)
   (void) fseeko64;
          ^
conftest.c:103:10: note: each undeclared identifier is reported only once for each function it appears in
configure:13723: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "bfd"
| #define PACKAGE_TARNAME "bfd"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "bfd 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "bfd"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define USE_SECUREPLT 1
| #define SIZEOF_LONG_LONG 8
| #define SIZEOF_VOID_P 4
| #define SIZEOF_LONG 4
| #define HAVE_ALLOCA_H 1
| #define HAVE_STDDEF_H 1
| #define HAVE_STRING_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_DIRENT_H 1
| #define STRING_WITH_STRINGS 1
| #define HAVE_FCNTL 1
| #define HAVE_GETPAGESIZE 1
| #define HAVE_SETITIMER 1
| #define HAVE_SYSCONF 1
| #define HAVE_FDOPEN 1
| #define HAVE_GETUID 1
| #define HAVE_GETGID 1
| #define HAVE_FILENO 1
| #define HAVE_STRTOULL 1
| #define HAVE_GETRLIMIT 1
| #define HAVE_DECL_BASENAME 0
| #define HAVE_DECL_FTELLO 1
| #define HAVE_DECL_FTELLO64 0
| #define HAVE_DECL_FSEEKO 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| #ifndef fseeko64
| #ifdef __cplusplus
|   (void) fseeko64;
| #else
|   (void) fseeko64;
| #endif
| #endif
| 
|   ;
|   return 0;
| }
configure:13723: result: no
configure:13743: checking whether ffs is declared
configure:13743: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13743: $? = 0
configure:13743: result: yes
configure:13754: checking whether free is declared
configure:13754: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13754: $? = 0
configure:13754: result: yes
configure:13765: checking whether getenv is declared
configure:13765: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13765: $? = 0
configure:13765: result: yes
configure:13776: checking whether malloc is declared
configure:13776: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13776: $? = 0
configure:13776: result: yes
configure:13787: checking whether realloc is declared
configure:13787: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13787: $? = 0
configure:13787: result: yes
configure:13798: checking whether stpcpy is declared
configure:13798: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13798: $? = 0
configure:13798: result: yes
configure:13809: checking whether strstr is declared
configure:13809: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13809: $? = 0
configure:13809: result: yes
configure:13820: checking whether snprintf is declared
configure:13820: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13820: $? = 0
configure:13820: result: yes
configure:13831: checking whether vsnprintf is declared
configure:13831: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13831: $? = 0
configure:13831: result: yes
configure:13842: checking whether strnlen is declared
configure:13842: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13842: $? = 0
configure:13842: result: yes
configure:13868: checking for library containing zlibVersion
configure:13899: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
/tmp/cc2lbggp.o:conftest.c:function main: error: undefined reference to 'zlibVersion'
collect2: error: ld returned 1 exit status
configure:13899: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "bfd"
| #define PACKAGE_TARNAME "bfd"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "bfd 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "bfd"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define USE_SECUREPLT 1
| #define SIZEOF_LONG_LONG 8
| #define SIZEOF_VOID_P 4
| #define SIZEOF_LONG 4
| #define HAVE_ALLOCA_H 1
| #define HAVE_STDDEF_H 1
| #define HAVE_STRING_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_DIRENT_H 1
| #define STRING_WITH_STRINGS 1
| #define HAVE_FCNTL 1
| #define HAVE_GETPAGESIZE 1
| #define HAVE_SETITIMER 1
| #define HAVE_SYSCONF 1
| #define HAVE_FDOPEN 1
| #define HAVE_GETUID 1
| #define HAVE_GETGID 1
| #define HAVE_FILENO 1
| #define HAVE_STRTOULL 1
| #define HAVE_GETRLIMIT 1
| #define HAVE_DECL_BASENAME 0
| #define HAVE_DECL_FTELLO 1
| #define HAVE_DECL_FTELLO64 0
| #define HAVE_DECL_FSEEKO 1
| #define HAVE_DECL_FSEEKO64 0
| #define HAVE_DECL_FFS 1
| #define HAVE_DECL_FREE 1
| #define HAVE_DECL_GETENV 1
| #define HAVE_DECL_MALLOC 1
| #define HAVE_DECL_REALLOC 1
| #define HAVE_DECL_STPCPY 1
| #define HAVE_DECL_STRSTR 1
| #define HAVE_DECL_SNPRINTF 1
| #define HAVE_DECL_VSNPRINTF 1
| #define HAVE_DECL_STRNLEN 1
| /* end confdefs.h.  */
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char zlibVersion ();
| int
| main ()
| {
| return zlibVersion ();
|   ;
|   return 0;
| }
configure:13899: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c -lz   >&5
configure:13899: $? = 0
configure:13916: result: -lz
configure:13923: checking zlib.h usability
configure:13923: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13923: $? = 0
configure:13923: result: yes
configure:13923: checking zlib.h presence
configure:13923: arm-linux-androideabi-gcc -E  conftest.c
configure:13923: $? = 0
configure:13923: result: yes
configure:13923: checking for zlib.h
configure:13923: result: yes
configure:15009: checking linker --as-needed support
configure:15020: result: yes
configure:15111: checking for cos in -lm
configure:15136: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c -lm  -lz  >&5
conftest.c:82:6: warning: conflicting types for built-in function 'cos' [enabled by default]
 char cos ();
      ^
configure:15136: $? = 0
configure:15145: result: yes
configure:15752: checking for ftello
configure:15752: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c -lz  >&5
configure:15752: $? = 0
configure:15752: result: yes
configure:15752: checking for ftello64
configure:15752: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c -lz  >&5
/tmp/cci5EhEE.o:conftest.c:function main: error: undefined reference to 'ftello64'
collect2: error: ld returned 1 exit status
configure:15752: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "bfd"
| #define PACKAGE_TARNAME "bfd"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "bfd 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "bfd"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define USE_SECUREPLT 1
| #define SIZEOF_LONG_LONG 8
| #define SIZEOF_VOID_P 4
| #define SIZEOF_LONG 4
| #define HAVE_ALLOCA_H 1
| #define HAVE_STDDEF_H 1
| #define HAVE_STRING_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_DIRENT_H 1
| #define STRING_WITH_STRINGS 1
| #define HAVE_FCNTL 1
| #define HAVE_GETPAGESIZE 1
| #define HAVE_SETITIMER 1
| #define HAVE_SYSCONF 1
| #define HAVE_FDOPEN 1
| #define HAVE_GETUID 1
| #define HAVE_GETGID 1
| #define HAVE_FILENO 1
| #define HAVE_STRTOULL 1
| #define HAVE_GETRLIMIT 1
| #define HAVE_DECL_BASENAME 0
| #define HAVE_DECL_FTELLO 1
| #define HAVE_DECL_FTELLO64 0
| #define HAVE_DECL_FSEEKO 1
| #define HAVE_DECL_FSEEKO64 0
| #define HAVE_DECL_FFS 1
| #define HAVE_DECL_FREE 1
| #define HAVE_DECL_GETENV 1
| #define HAVE_DECL_MALLOC 1
| #define HAVE_DECL_REALLOC 1
| #define HAVE_DECL_STPCPY 1
| #define HAVE_DECL_STRSTR 1
| #define HAVE_DECL_SNPRINTF 1
| #define HAVE_DECL_VSNPRINTF 1
| #define HAVE_DECL_STRNLEN 1
| #define HAVE_ZLIB_H 1
| #define HAVE_FTELLO 1
| /* end confdefs.h.  */
| /* Define ftello64 to an innocuous variant, in case <limits.h> declares ftello64.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define ftello64 innocuous_ftello64
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char ftello64 (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef ftello64
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char ftello64 ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_ftello64 || defined __stub___ftello64
| choke me
| #endif
| 
| int
| main ()
| {
| return ftello64 ();
|   ;
|   return 0;
| }
configure:15752: result: no
configure:15752: checking for fseeko
configure:15752: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c -lz  >&5
configure:15752: $? = 0
configure:15752: result: yes
configure:15752: checking for fseeko64
configure:15752: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c -lz  >&5
/tmp/cc8ncSeg.o:conftest.c:function main: error: undefined reference to 'fseeko64'
collect2: error: ld returned 1 exit status
configure:15752: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "bfd"
| #define PACKAGE_TARNAME "bfd"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "bfd 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "bfd"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define USE_SECUREPLT 1
| #define SIZEOF_LONG_LONG 8
| #define SIZEOF_VOID_P 4
| #define SIZEOF_LONG 4
| #define HAVE_ALLOCA_H 1
| #define HAVE_STDDEF_H 1
| #define HAVE_STRING_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_DIRENT_H 1
| #define STRING_WITH_STRINGS 1
| #define HAVE_FCNTL 1
| #define HAVE_GETPAGESIZE 1
| #define HAVE_SETITIMER 1
| #define HAVE_SYSCONF 1
| #define HAVE_FDOPEN 1
| #define HAVE_GETUID 1
| #define HAVE_GETGID 1
| #define HAVE_FILENO 1
| #define HAVE_STRTOULL 1
| #define HAVE_GETRLIMIT 1
| #define HAVE_DECL_BASENAME 0
| #define HAVE_DECL_FTELLO 1
| #define HAVE_DECL_FTELLO64 0
| #define HAVE_DECL_FSEEKO 1
| #define HAVE_DECL_FSEEKO64 0
| #define HAVE_DECL_FFS 1
| #define HAVE_DECL_FREE 1
| #define HAVE_DECL_GETENV 1
| #define HAVE_DECL_MALLOC 1
| #define HAVE_DECL_REALLOC 1
| #define HAVE_DECL_STPCPY 1
| #define HAVE_DECL_STRSTR 1
| #define HAVE_DECL_SNPRINTF 1
| #define HAVE_DECL_VSNPRINTF 1
| #define HAVE_DECL_STRNLEN 1
| #define HAVE_ZLIB_H 1
| #define HAVE_FTELLO 1
| #define HAVE_FSEEKO 1
| /* end confdefs.h.  */
| /* Define fseeko64 to an innocuous variant, in case <limits.h> declares fseeko64.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define fseeko64 innocuous_fseeko64
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char fseeko64 (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef fseeko64
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char fseeko64 ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_fseeko64 || defined __stub___fseeko64
| choke me
| #endif
| 
| int
| main ()
| {
| return fseeko64 ();
|   ;
|   return 0;
| }
configure:15752: result: no
configure:15752: checking for fopen64
configure:15752: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c -lz  >&5
/tmp/ccEcN9zv.o:conftest.c:function main: error: undefined reference to 'fopen64'
collect2: error: ld returned 1 exit status
configure:15752: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "bfd"
| #define PACKAGE_TARNAME "bfd"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "bfd 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "bfd"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define USE_SECUREPLT 1
| #define SIZEOF_LONG_LONG 8
| #define SIZEOF_VOID_P 4
| #define SIZEOF_LONG 4
| #define HAVE_ALLOCA_H 1
| #define HAVE_STDDEF_H 1
| #define HAVE_STRING_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_DIRENT_H 1
| #define STRING_WITH_STRINGS 1
| #define HAVE_FCNTL 1
| #define HAVE_GETPAGESIZE 1
| #define HAVE_SETITIMER 1
| #define HAVE_SYSCONF 1
| #define HAVE_FDOPEN 1
| #define HAVE_GETUID 1
| #define HAVE_GETGID 1
| #define HAVE_FILENO 1
| #define HAVE_STRTOULL 1
| #define HAVE_GETRLIMIT 1
| #define HAVE_DECL_BASENAME 0
| #define HAVE_DECL_FTELLO 1
| #define HAVE_DECL_FTELLO64 0
| #define HAVE_DECL_FSEEKO 1
| #define HAVE_DECL_FSEEKO64 0
| #define HAVE_DECL_FFS 1
| #define HAVE_DECL_FREE 1
| #define HAVE_DECL_GETENV 1
| #define HAVE_DECL_MALLOC 1
| #define HAVE_DECL_REALLOC 1
| #define HAVE_DECL_STPCPY 1
| #define HAVE_DECL_STRSTR 1
| #define HAVE_DECL_SNPRINTF 1
| #define HAVE_DECL_VSNPRINTF 1
| #define HAVE_DECL_STRNLEN 1
| #define HAVE_ZLIB_H 1
| #define HAVE_FTELLO 1
| #define HAVE_FSEEKO 1
| /* end confdefs.h.  */
| /* Define fopen64 to an innocuous variant, in case <limits.h> declares fopen64.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define fopen64 innocuous_fopen64
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char fopen64 (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef fopen64
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char fopen64 ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_fopen64 || defined __stub___fopen64
| choke me
| #endif
| 
| int
| main ()
| {
| return fopen64 ();
|   ;
|   return 0;
| }
configure:15752: result: no
configure:15767: checking size of off_t
configure:15772: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:15772: $? = 0
configure:15772: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:113:12: error: size of array 'test_array' is negative
 static int test_array [1 - 2 * !(((long int) (sizeof (off_t))) <= 0)];
            ^
configure:15772: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "bfd"
| #define PACKAGE_TARNAME "bfd"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "bfd 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "bfd"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define USE_SECUREPLT 1
| #define SIZEOF_LONG_LONG 8
| #define SIZEOF_VOID_P 4
| #define SIZEOF_LONG 4
| #define HAVE_ALLOCA_H 1
| #define HAVE_STDDEF_H 1
| #define HAVE_STRING_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_DIRENT_H 1
| #define STRING_WITH_STRINGS 1
| #define HAVE_FCNTL 1
| #define HAVE_GETPAGESIZE 1
| #define HAVE_SETITIMER 1
| #define HAVE_SYSCONF 1
| #define HAVE_FDOPEN 1
| #define HAVE_GETUID 1
| #define HAVE_GETGID 1
| #define HAVE_FILENO 1
| #define HAVE_STRTOULL 1
| #define HAVE_GETRLIMIT 1
| #define HAVE_DECL_BASENAME 0
| #define HAVE_DECL_FTELLO 1
| #define HAVE_DECL_FTELLO64 0
| #define HAVE_DECL_FSEEKO 1
| #define HAVE_DECL_FSEEKO64 0
| #define HAVE_DECL_FFS 1
| #define HAVE_DECL_FREE 1
| #define HAVE_DECL_GETENV 1
| #define HAVE_DECL_MALLOC 1
| #define HAVE_DECL_REALLOC 1
| #define HAVE_DECL_STPCPY 1
| #define HAVE_DECL_STRSTR 1
| #define HAVE_DECL_SNPRINTF 1
| #define HAVE_DECL_VSNPRINTF 1
| #define HAVE_DECL_STRNLEN 1
| #define HAVE_ZLIB_H 1
| #define HAVE_FTELLO 1
| #define HAVE_FSEEKO 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static int test_array [1 - 2 * !(((long int) (sizeof (off_t))) <= 0)];
| test_array [0] = 0
| 
|   ;
|   return 0;
| }
configure:15772: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:113:12: error: size of array 'test_array' is negative
 static int test_array [1 - 2 * !(((long int) (sizeof (off_t))) <= 1)];
            ^
configure:15772: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "bfd"
| #define PACKAGE_TARNAME "bfd"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "bfd 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "bfd"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define USE_SECUREPLT 1
| #define SIZEOF_LONG_LONG 8
| #define SIZEOF_VOID_P 4
| #define SIZEOF_LONG 4
| #define HAVE_ALLOCA_H 1
| #define HAVE_STDDEF_H 1
| #define HAVE_STRING_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_DIRENT_H 1
| #define STRING_WITH_STRINGS 1
| #define HAVE_FCNTL 1
| #define HAVE_GETPAGESIZE 1
| #define HAVE_SETITIMER 1
| #define HAVE_SYSCONF 1
| #define HAVE_FDOPEN 1
| #define HAVE_GETUID 1
| #define HAVE_GETGID 1
| #define HAVE_FILENO 1
| #define HAVE_STRTOULL 1
| #define HAVE_GETRLIMIT 1
| #define HAVE_DECL_BASENAME 0
| #define HAVE_DECL_FTELLO 1
| #define HAVE_DECL_FTELLO64 0
| #define HAVE_DECL_FSEEKO 1
| #define HAVE_DECL_FSEEKO64 0
| #define HAVE_DECL_FFS 1
| #define HAVE_DECL_FREE 1
| #define HAVE_DECL_GETENV 1
| #define HAVE_DECL_MALLOC 1
| #define HAVE_DECL_REALLOC 1
| #define HAVE_DECL_STPCPY 1
| #define HAVE_DECL_STRSTR 1
| #define HAVE_DECL_SNPRINTF 1
| #define HAVE_DECL_VSNPRINTF 1
| #define HAVE_DECL_STRNLEN 1
| #define HAVE_ZLIB_H 1
| #define HAVE_FTELLO 1
| #define HAVE_FSEEKO 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static int test_array [1 - 2 * !(((long int) (sizeof (off_t))) <= 1)];
| test_array [0] = 0
| 
|   ;
|   return 0;
| }
configure:15772: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:113:12: error: size of array 'test_array' is negative
 static int test_array [1 - 2 * !(((long int) (sizeof (off_t))) <= 3)];
            ^
configure:15772: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "bfd"
| #define PACKAGE_TARNAME "bfd"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "bfd 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "bfd"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define USE_SECUREPLT 1
| #define SIZEOF_LONG_LONG 8
| #define SIZEOF_VOID_P 4
| #define SIZEOF_LONG 4
| #define HAVE_ALLOCA_H 1
| #define HAVE_STDDEF_H 1
| #define HAVE_STRING_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_DIRENT_H 1
| #define STRING_WITH_STRINGS 1
| #define HAVE_FCNTL 1
| #define HAVE_GETPAGESIZE 1
| #define HAVE_SETITIMER 1
| #define HAVE_SYSCONF 1
| #define HAVE_FDOPEN 1
| #define HAVE_GETUID 1
| #define HAVE_GETGID 1
| #define HAVE_FILENO 1
| #define HAVE_STRTOULL 1
| #define HAVE_GETRLIMIT 1
| #define HAVE_DECL_BASENAME 0
| #define HAVE_DECL_FTELLO 1
| #define HAVE_DECL_FTELLO64 0
| #define HAVE_DECL_FSEEKO 1
| #define HAVE_DECL_FSEEKO64 0
| #define HAVE_DECL_FFS 1
| #define HAVE_DECL_FREE 1
| #define HAVE_DECL_GETENV 1
| #define HAVE_DECL_MALLOC 1
| #define HAVE_DECL_REALLOC 1
| #define HAVE_DECL_STPCPY 1
| #define HAVE_DECL_STRSTR 1
| #define HAVE_DECL_SNPRINTF 1
| #define HAVE_DECL_VSNPRINTF 1
| #define HAVE_DECL_STRNLEN 1
| #define HAVE_ZLIB_H 1
| #define HAVE_FTELLO 1
| #define HAVE_FSEEKO 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static int test_array [1 - 2 * !(((long int) (sizeof (off_t))) <= 3)];
| test_array [0] = 0
| 
|   ;
|   return 0;
| }
configure:15772: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:15772: $? = 0
configure:15772: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:15772: $? = 0
configure:15772: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:15772: $? = 0
configure:15787: result: 4
configure:15798: checking file_ptr type
configure:15807: result: long
configure:15824: checking for stdlib.h
configure:15824: result: yes
configure:15824: checking for unistd.h
configure:15824: result: yes
configure:15837: checking for getpagesize
configure:15837: result: yes
configure:15846: checking for working mmap
configure:15993: result: no
configure:16005: checking for madvise
configure:16005: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c -lz  >&5
configure:16005: $? = 0
configure:16005: result: yes
configure:16005: checking for mprotect
configure:16005: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c -lz  >&5
configure:16005: $? = 0
configure:16005: result: yes
configure:16098: updating cache ./config.cache
configure:16167: creating ./config.status

## ---------------------- ##
## Running config.status. ##
## ---------------------- ##

This file was extended by bfd config.status 2.25.1, which was
generated by GNU Autoconf 2.64.  Invocation command line was

  CONFIG_FILES    = 
  CONFIG_HEADERS  = 
  CONFIG_LINKS    = 
  CONFIG_COMMANDS = 
  $ ./config.status 

on d5f3793a98c0

config.status:1220: creating Makefile
config.status:1220: creating doc/Makefile
config.status:1220: creating bfd-in3.h
config.status:1220: creating po/Makefile.in
config.status:1220: creating config.h
config.status:1433: executing depfiles commands
config.status:1433: executing libtool commands
config.status:1433: executing default-1 commands
config.status:1433: executing bfd_stdint.h commands
config.status:1433: executing default commands

## ---------------- ##
## Cache variables. ##
## ---------------- ##

ac_cv_build=x86_64-unknown-linux-gnu
ac_cv_c_compiler_gnu=yes
ac_cv_env_CC_set=set
ac_cv_env_CC_value=arm-linux-androideabi-gcc
ac_cv_env_CFLAGS_set=set
ac_cv_env_CFLAGS_value=
ac_cv_env_CPPFLAGS_set=set
ac_cv_env_CPPFLAGS_value=
ac_cv_env_CPP_set=
ac_cv_env_CPP_value=
ac_cv_env_LDFLAGS_set=set
ac_cv_env_LDFLAGS_value='-static-libstdc++ -static-libgcc '
ac_cv_env_LIBS_set=
ac_cv_env_LIBS_value=
ac_cv_env_build_alias_set=set
ac_cv_env_build_alias_value=x86_64-unknown-linux-gnu
ac_cv_env_host_alias_set=set
ac_cv_env_host_alias_value=x86_64-unknown-linux
ac_cv_env_target_alias_set=set
ac_cv_env_target_alias_value=i686-w64-mingw32
ac_cv_func_dlopen=yes
ac_cv_func_fcntl=yes
ac_cv_func_fdopen=yes
ac_cv_func_fileno=yes
ac_cv_func_fopen64=no
ac_cv_func_fseeko64=no
ac_cv_func_fseeko=yes
ac_cv_func_ftello64=no
ac_cv_func_ftello=yes
ac_cv_func_getgid=yes
ac_cv_func_getpagesize=yes
ac_cv_func_getrlimit=yes
ac_cv_func_getuid=yes
ac_cv_func_madvise=yes
ac_cv_func_mmap_fixed_mapped=no
ac_cv_func_mprotect=yes
ac_cv_func_setitimer=yes
ac_cv_func_shl_load=no
ac_cv_func_strtoull=yes
ac_cv_func_sysconf=yes
ac_cv_have_decl_basename=no
ac_cv_have_decl_ffs=yes
ac_cv_have_decl_free=yes
ac_cv_have_decl_fseeko64=no
ac_cv_have_decl_fseeko=yes
ac_cv_have_decl_ftello64=no
ac_cv_have_decl_ftello=yes
ac_cv_have_decl_getenv=yes
ac_cv_have_decl_malloc=yes
ac_cv_have_decl_realloc=yes
ac_cv_have_decl_snprintf=yes
ac_cv_have_decl_stpcpy=yes
ac_cv_have_decl_strnlen=yes
ac_cv_have_decl_strstr=yes
ac_cv_have_decl_vsnprintf=yes
ac_cv_header_alloca_h=yes
ac_cv_header_dirent_dirent_h=yes
ac_cv_header_dlfcn_h=yes
ac_cv_header_fcntl_h=yes
ac_cv_header_inttypes_h=yes
ac_cv_header_memory_h=yes
ac_cv_header_minix_config_h=no
ac_cv_header_stdc=yes
ac_cv_header_stddef_h=yes
ac_cv_header_stdint_h=yes
ac_cv_header_stdlib_h=yes
ac_cv_header_string_h=yes
ac_cv_header_strings_h=yes
ac_cv_header_sys_file_h=yes
ac_cv_header_sys_resource_h=yes
ac_cv_header_sys_stat_h=yes
ac_cv_header_sys_time_h=yes
ac_cv_header_sys_types_h=yes
ac_cv_header_time=yes
ac_cv_header_time_h=yes
ac_cv_header_unistd_h=yes
ac_cv_header_wchar_h=yes
ac_cv_header_windows_h=no
ac_cv_header_zlib_h=yes
ac_cv_host=x86_64-unknown-linux-gnu
ac_cv_lib_dld_shl_load=no
ac_cv_lib_m_cos=yes
ac_cv_objext=o
ac_cv_path_EGREP='/usr/sbin/grep -E'
ac_cv_path_FGREP='/usr/sbin/grep -F'
ac_cv_path_GMSGFMT=/usr/sbin/msgfmt
ac_cv_path_GREP=/usr/sbin/grep
ac_cv_path_MSGFMT=/usr/sbin/msgfmt
ac_cv_path_MSGMERGE=/usr/sbin/msgmerge
ac_cv_path_SED=/usr/sbin/sed
ac_cv_path_XGETTEXT=/usr/sbin/xgettext
ac_cv_path_mkdir=/usr/sbin/mkdir
ac_cv_prog_AR=ar
ac_cv_prog_AWK=gawk
ac_cv_prog_CC=arm-linux-androideabi-gcc
ac_cv_prog_CPP='arm-linux-androideabi-gcc -E'
ac_cv_prog_OBJDUMP=objdump
ac_cv_prog_RANLIB=ranlib
ac_cv_prog_STRIP=strip
ac_cv_prog_ac_ct_STRIP=strip
ac_cv_prog_cc_c89=
ac_cv_prog_cc_g=yes
ac_cv_prog_make_make_set=yes
ac_cv_safe_to_define___extensions__=yes
ac_cv_search_dlopen='none required'
ac_cv_search_opendir='none required'
ac_cv_search_strerror='none required'
ac_cv_search_zlibVersion=-lz
ac_cv_sizeof_long=4
ac_cv_sizeof_long_long=8
ac_cv_sizeof_off_t=4
ac_cv_sizeof_void_p=4
ac_cv_sys_file_offset_bits=unknown
ac_cv_sys_large_files=unknown
ac_cv_sys_largefile_CC=no
ac_cv_target=i686-w64-mingw32
ac_cv_type_int_fast32_t=yes
ac_cv_type_int_least32_t=yes
ac_cv_type_u_int64_t=no
ac_cv_type_uint64_t=yes
ac_cv_type_uintmax_t=yes
ac_cv_type_uintptr_t=yes
acx_cv_header_stdint=stdint.h
acx_cv_header_stdint_kind='(already complete)'
am_cv_CC_dependencies_compiler_type=gcc3
bfd_cv_build_exeext=no
bfd_cv_ld_as_needed=yes
gcc_cv_header_string=yes
lt_cv_deplibs_check_method=pass_all
lt_cv_dlopen=dlopen
lt_cv_dlopen_libs=
lt_cv_dlopen_self=cross
lt_cv_file_magic_cmd='$MAGIC_CMD'
lt_cv_file_magic_test_file=
lt_cv_ld_reload_flag=-r
lt_cv_nm_interface='BSD nm'
lt_cv_objdir=.libs
lt_cv_path_LD=/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld
lt_cv_path_NM=nm
lt_cv_prog_compiler_c_o=yes
lt_cv_prog_compiler_pic_works=yes
lt_cv_prog_compiler_rtti_exceptions=no
lt_cv_prog_compiler_static_works=yes
lt_cv_prog_gnu_ld=yes
lt_cv_shlibpath_overrides_runpath=yes
lt_cv_sys_global_symbol_pipe='sed -n -e '\''s/^.*[	 ]\([ABCDGIRSTW][ABCDGIRSTW]*\)[	 ][	 ]*\([_A-Za-z][_A-Za-z0-9]*\)$/\1 \2 \2/p'\'''
lt_cv_sys_global_symbol_to_c_name_address='sed -n -e '\''s/^: \([^ ]*\) $/  {\"\1\", (void *) 0},/p'\'' -e '\''s/^[ABCDGIRSTW]* \([^ ]*\) \([^ ]*\)$/  {"\2", (void *) \&\2},/p'\'''
lt_cv_sys_global_symbol_to_c_name_address_lib_prefix='sed -n -e '\''s/^: \([^ ]*\) $/  {\"\1\", (void *) 0},/p'\'' -e '\''s/^[ABCDGIRSTW]* \([^ ]*\) \(lib[^ ]*\)$/  {"\2", (void *) \&\2},/p'\'' -e '\''s/^[ABCDGIRSTW]* \([^ ]*\) \([^ ]*\)$/  {"lib\2", (void *) \&\2},/p'\'''
lt_cv_sys_global_symbol_to_cdecl='sed -n -e '\''s/^T .* \(.*\)$/extern int \1();/p'\'' -e '\''s/^[ABCDGIRSTW]* .* \(.*\)$/extern char \1;/p'\'''
lt_cv_sys_max_cmd_len=1572864

## ----------------- ##
## Output variables. ##
## ----------------- ##

ACLOCAL='${SHELL} /tmp/mingw-w64-binutils/src/binutils-2.25.1/missing --run aclocal-1.11'
AMDEPBACKSLASH='\'
AMDEP_FALSE='#'
AMDEP_TRUE=''
AMTAR='${SHELL} /tmp/mingw-w64-binutils/src/binutils-2.25.1/missing --run tar'
AR='ar'
AUTOCONF='${SHELL} /tmp/mingw-w64-binutils/src/binutils-2.25.1/missing --run autoconf'
AUTOHEADER='${SHELL} /tmp/mingw-w64-binutils/src/binutils-2.25.1/missing --run autoheader'
AUTOMAKE='${SHELL} /tmp/mingw-w64-binutils/src/binutils-2.25.1/missing --run automake-1.11'
AWK='gawk'
BFD_HOSTPTR_T='unsigned long'
BFD_HOST_64BIT_LONG='0'
BFD_HOST_64BIT_LONG_LONG='1'
BFD_HOST_64_BIT='long long'
BFD_HOST_64_BIT_DEFINED='1'
BFD_HOST_U_64_BIT='unsigned long long'
CATALOGS=''
CATOBJEXT=''
CC='arm-linux-androideabi-gcc'
CCDEPMODE='depmode=gcc3'
CC_FOR_BUILD='arm-linux-androideabi-gcc'
CFLAGS=''
COREFILE=''
COREFLAG=''
CPP='arm-linux-androideabi-gcc -E'
CPPFLAGS=''
CYGPATH_W='echo'
DATADIRNAME=''
DEBUGDIR='${exec_prefix}/lib/debug'
DEFS='-DHAVE_CONFIG_H'
DEPDIR='.deps'
DSYMUTIL=''
DUMPBIN=''
ECHO_C=''
ECHO_N='-n'
ECHO_T=''
EGREP='/usr/sbin/grep -E'
EXEEXT=''
EXEEXT_FOR_BUILD=''
FGREP='/usr/sbin/grep -F'
GENCAT=''
GENINSRC_NEVER_FALSE=''
GENINSRC_NEVER_TRUE='#'
GMSGFMT='/usr/sbin/msgfmt'
GREP='/usr/sbin/grep'
HDEFINES=''
INCINTL=''
INSTALL_DATA='/usr/bin/install -c -m 644'
INSTALL_LIBBFD_FALSE=''
INSTALL_LIBBFD_TRUE='#'
INSTALL_PROGRAM='/usr/bin/install -c'
INSTALL_SCRIPT='/usr/bin/install -c'
INSTALL_STRIP_PROGRAM='$(install_sh) -c -s'
INSTOBJEXT=''
LD='/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld -m elf_i386'
LDFLAGS='-static-libstdc++ -static-libgcc '
LIBINTL=''
LIBINTL_DEP=''
LIBM='-lm'
LIBOBJS=''
LIBS='-lz '
LIBTOOL='$(SHELL) $(top_builddir)/libtool'
LIPO=''
LN_S='ln -s'
LTLIBOBJS=''
MAINT='#'
MAINTAINER_MODE_FALSE=''
MAINTAINER_MODE_TRUE='#'
MAKEINFO='makeinfo --split-size=5000000'
MKDIR_P='/usr/sbin/mkdir -p'
MKINSTALLDIRS='/tmp/mingw-w64-binutils/src/binutils-2.25.1/bfd/../mkinstalldirs'
MSGFMT='/usr/sbin/msgfmt'
MSGMERGE='/usr/sbin/msgmerge'
NM='nm'
NMEDIT=''
NO_WERROR=''
OBJDUMP='objdump'
OBJEXT='o'
OTOOL64=''
OTOOL=''
PACKAGE='bfd'
PACKAGE_BUGREPORT=''
PACKAGE_NAME='bfd'
PACKAGE_STRING='bfd 2.25.1'
PACKAGE_TARNAME='bfd'
PACKAGE_URL=''
PACKAGE_VERSION='2.25.1'
PATH_SEPARATOR=':'
PKGVERSION='(GNU Binutils) '
PLUGINS_FALSE='#'
PLUGINS_TRUE=''
POSUB=''
RANLIB='ranlib'
REPORT_BUGS_TEXI='@uref{http://www.sourceware.org/bugzilla/}'
REPORT_BUGS_TO='<http://www.sourceware.org/bugzilla/>'
SED='/usr/sbin/sed'
SET_MAKE=''
SHARED_LDFLAGS=''
SHARED_LIBADD=''
SHELL='/bin/sh'
STRIP='strip'
TDEFINES='  '
USE_NLS='no'
VERSION='2.25.1'
WARN_CFLAGS='-W -Wall -Wstrict-prototypes -Wmissing-prototypes -Wshadow'
XGETTEXT='/usr/sbin/xgettext'
ac_ct_CC=''
ac_ct_DUMPBIN=''
all_backends='$(BFD32_BACKENDS)'
am__EXEEXT_FALSE=''
am__EXEEXT_TRUE='#'
am__fastdepCC_FALSE='#'
am__fastdepCC_TRUE=''
am__include='include'
am__isrc=' -I$(srcdir)'
am__leading_dot='.'
am__quote=''
am__tar='${AMTAR} chof - "$$tardir"'
am__untar='${AMTAR} xf -'
bfd64_libs=''
bfd_backends=' pe-i386.lo peigen.lo cofflink.lo pei-i386.lo elf32-i386.lo elf-ifunc.lo elf-nacl.lo elf-vxworks.lo elf32.lo elf.lo elflink.lo elf-attrs.lo elf-strtab.lo elf-eh-frame.lo dwarf1.lo elf32-gen.lo plugin.lo'
bfd_default_target_size='32'
bfd_file_ptr='long'
bfd_machines=' cpu-i386.lo cpu-plugin.lo'
bfd_ufile_ptr='unsigned long'
bfdincludedir='$(exec_prefix)/$(host_noncanonical)/$(target_noncanonical)/include'
bfdlibdir='$(exec_prefix)/$(host_noncanonical)/$(target_noncanonical)/lib'
bindir='${exec_prefix}/bin'
build='x86_64-unknown-linux-gnu'
build_alias='x86_64-unknown-linux-gnu'
build_cpu='x86_64'
build_os='linux-gnu'
build_vendor='unknown'
datadir='${datarootdir}'
datarootdir='${prefix}/share'
docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
dvidir='${docdir}'
exec_prefix='${prefix}'
havevecs='-DHAVE_i386_pe_vec -DHAVE_i386_pei_vec -DHAVE_i386_elf32_vec -DHAVE_elf32_le_vec -DHAVE_elf32_be_vec -DHAVE_plugin_vec'
host='x86_64-unknown-linux-gnu'
host_alias='x86_64-unknown-linux'
host_cpu='x86_64'
host_noncanonical='x86_64-unknown-linux'
host_os='linux-gnu'
host_vendor='unknown'
htmldir='${docdir}'
includedir='${prefix}/include'
infodir='/usr/share/info/i686-w64-mingw32'
install_sh='${SHELL} /tmp/mingw-w64-binutils/src/binutils-2.25.1/install-sh'
libdir='${exec_prefix}/lib'
libexecdir='${exec_prefix}/libexec'
localedir='${datarootdir}/locale'
localstatedir='${prefix}/var'
lt_cv_dlopen_libs=''
mandir='${datarootdir}/man'
mkdir_p='/usr/sbin/mkdir -p'
oldincludedir='/usr/include'
pdfdir='${docdir}'
prefix='/usr'
program_transform_name='s&^&i686-w64-mingw32-&'
psdir='${docdir}'
sbindir='${exec_prefix}/sbin'
sharedstatedir='${prefix}/com'
supports_plugins='1'
sysconfdir='${prefix}/etc'
target='i686-w64-mingw32'
target_alias='i686-w64-mingw32'
target_cpu='i686'
target_noncanonical='i686-w64-mingw32'
target_os='mingw32'
target_vendor='w64'
tdefaults=' -DDEFAULT_VECTOR=i386_pe_vec -DSELECT_VECS='\''&i386_pe_vec,&i386_pei_vec,&i386_elf32_vec,&elf32_le_vec,&elf32_be_vec,&plugin_vec'\'' -DSELECT_ARCHITECTURES='\''&bfd_i386_arch,&bfd_plugin_arch'\'''
wordsize='32'

## ----------- ##
## confdefs.h. ##
## ----------- ##

/* confdefs.h */
#define PACKAGE_NAME "bfd"
#define PACKAGE_TARNAME "bfd"
#define PACKAGE_VERSION "2.25.1"
#define PACKAGE_STRING "bfd 2.25.1"
#define PACKAGE_BUGREPORT ""
#define PACKAGE_URL ""
#define PACKAGE "bfd"
#define VERSION "2.25.1"
#define STDC_HEADERS 1
#define HAVE_SYS_TYPES_H 1
#define HAVE_SYS_STAT_H 1
#define HAVE_STDLIB_H 1
#define HAVE_STRING_H 1
#define HAVE_MEMORY_H 1
#define HAVE_STRINGS_H 1
#define HAVE_INTTYPES_H 1
#define HAVE_STDINT_H 1
#define HAVE_UNISTD_H 1
#define __EXTENSIONS__ 1
#define _ALL_SOURCE 1
#define _GNU_SOURCE 1
#define _POSIX_PTHREAD_SEMANTICS 1
#define _TANDEM_SOURCE 1
#define HAVE_DLFCN_H 1
#define LT_OBJDIR ".libs/"
#define HAVE_DLFCN_H 1
#define USE_SECUREPLT 1
#define SIZEOF_LONG_LONG 8
#define SIZEOF_VOID_P 4
#define SIZEOF_LONG 4
#define HAVE_ALLOCA_H 1
#define HAVE_STDDEF_H 1
#define HAVE_STRING_H 1
#define HAVE_STRINGS_H 1
#define HAVE_STDLIB_H 1
#define HAVE_TIME_H 1
#define HAVE_UNISTD_H 1
#define HAVE_WCHAR_H 1
#define HAVE_FCNTL_H 1
#define HAVE_SYS_FILE_H 1
#define HAVE_SYS_TIME_H 1
#define HAVE_SYS_STAT_H 1
#define HAVE_SYS_RESOURCE_H 1
#define TIME_WITH_SYS_TIME 1
#define HAVE_DIRENT_H 1
#define STRING_WITH_STRINGS 1
#define HAVE_FCNTL 1
#define HAVE_GETPAGESIZE 1
#define HAVE_SETITIMER 1
#define HAVE_SYSCONF 1
#define HAVE_FDOPEN 1
#define HAVE_GETUID 1
#define HAVE_GETGID 1
#define HAVE_FILENO 1
#define HAVE_STRTOULL 1
#define HAVE_GETRLIMIT 1
#define HAVE_DECL_BASENAME 0
#define HAVE_DECL_FTELLO 1
#define HAVE_DECL_FTELLO64 0
#define HAVE_DECL_FSEEKO 1
#define HAVE_DECL_FSEEKO64 0
#define HAVE_DECL_FFS 1
#define HAVE_DECL_FREE 1
#define HAVE_DECL_GETENV 1
#define HAVE_DECL_MALLOC 1
#define HAVE_DECL_REALLOC 1
#define HAVE_DECL_STPCPY 1
#define HAVE_DECL_STRSTR 1
#define HAVE_DECL_SNPRINTF 1
#define HAVE_DECL_VSNPRINTF 1
#define HAVE_DECL_STRNLEN 1
#define HAVE_ZLIB_H 1
#define HAVE_FTELLO 1
#define HAVE_FSEEKO 1
#define SIZEOF_OFF_T 4
#define HAVE_STDLIB_H 1
#define HAVE_UNISTD_H 1
#define HAVE_GETPAGESIZE 1
#define HAVE_MADVISE 1
#define HAVE_MPROTECT 1

configure: exit 0

____
File /tmp/mingw-w64-binutils/src/binutils-i686-w64-mingw32/intl/config.log
This file contains any messages produced by compilers while
running configure, to aid debugging if configure makes a mistake.

It was created by configure, which was
generated by GNU Autoconf 2.64.  Invocation command line was

  $ /tmp/mingw-w64-binutils/src/binutils-2.25.1/intl/configure --cache-file=./config.cache --with-gnu-as --with-gnu-ld --with-system-zlib --prefix=/usr --infodir=/usr/share/info/i686-w64-mingw32 --enable-lto --enable-plugins --disable-multilib --disable-nls --disable-werror --program-transform-name=s&^&i686-w64-mingw32-& --disable-option-checking --build=x86_64-unknown-linux-gnu --host=x86_64-unknown-linux --target=i686-w64-mingw32 --srcdir=/tmp/mingw-w64-binutils/src/binutils-2.25.1/intl

## --------- ##
## Platform. ##
## --------- ##

hostname = d5f3793a98c0
uname -m = x86_64
uname -r = 3.13.0-66-generic
uname -s = Linux
uname -v = #108-Ubuntu SMP Wed Oct 7 15:20:27 UTC 2015

/usr/bin/uname -p = unknown
/bin/uname -X     = unknown

/bin/arch              = unknown
/usr/bin/arch -k       = unknown
/usr/convex/getsysinfo = unknown
/usr/bin/hostinfo      = unknown
/bin/machine           = unknown
/usr/bin/oslevel       = unknown
/bin/universe          = unknown

PATH: /tmp/toolchain/bin
PATH: /usr/local/sbin
PATH: /usr/local/bin
PATH: /usr/sbin
PATH: /usr/bin
PATH: /sbin
PATH: /bin


## ----------- ##
## Core tests. ##
## ----------- ##

configure:2098: creating cache ./config.cache
configure:2179: checking whether make sets $(MAKE)
configure:2201: result: yes
configure:2247: checking for a BSD-compatible install
configure:2315: result: /usr/bin/install -c
configure:2340: checking whether NLS is requested
configure:2349: result: no
configure:2387: checking for msgfmt
configure:2418: result: /usr/sbin/msgfmt
configure:2427: checking for gmsgfmt
configure:2458: result: /usr/sbin/msgfmt
configure:2498: checking for xgettext
configure:2529: result: /usr/sbin/xgettext
configure:2569: checking for msgmerge
configure:2599: result: /usr/sbin/msgmerge
configure:2642: checking for x86_64-unknown-linux-gcc
configure:2669: result: arm-linux-androideabi-gcc
configure:2938: checking for C compiler version
configure:2947: arm-linux-androideabi-gcc --version >&5
arm-linux-androideabi-gcc (GCC) 4.8
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

configure:2958: $? = 0
configure:2947: arm-linux-androideabi-gcc -v >&5
Using built-in specs.
COLLECT_GCC=arm-linux-androideabi-gcc
COLLECT_LTO_WRAPPER=/tmp/toolchain/bin/../libexec/gcc/arm-linux-androideabi/4.8/lto-wrapper
Target: arm-linux-androideabi
Configured with: /s/ndk-toolchain/src/build/../gcc/gcc-4.8/configure --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --target=arm-linux-androideabi --host=x86_64-linux-gnu --build=x86_64-linux-gnu --with-gnu-as --with-gnu-ld --enable-languages=c,c++ --with-gmp=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpfr=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpc=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-cloog=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-isl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-ppl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --disable-ppl-version-check --disable-cloog-version-check --disable-isl-version-check --enable-cloog-backend=isl --with-host-libstdcxx='-static-libgcc -Wl,-Bstatic,-lstdc++,-Bdynamic -lm' --disable-libssp --enable-threads --disable-nls --disable-libmudflap --disable-libgomp --disable-libstdc__-v3 --disable-sjlj-exceptions --disable-shared --disable-tls --disable-libitm --with-float=soft --with-fpu=vfp --with-arch=armv5te --enable-target-optspace --enable-initfini-array --disable-nls --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --with-sysroot=/tmp/ndk-andrewhsieh/build/toolchain/prefix/sysroot --with-binutils-version=2.25 --with-mpfr-version=3.1.1 --with-mpc-version=1.0.1 --with-gmp-version=5.0.5 --with-gcc-version=4.8 --with-gdb-version=7.7 --with-python=/usr/local/google/home/andrewhsieh/mydroid/ndk/prebuilt/linux-x86_64/bin/python-config.sh --with-gxx-include-dir=/tmp/ndk-andrewhsieh/build/toolchain/prefix/include/c++/4.8 --with-bugurl=http://source.android.com/source/report-bugs.html --enable-languages=c,c++ --disable-bootstrap --enable-plugins --enable-libgomp --enable-gnu-indirect-function --disable-libsanitizer --enable-gold --enable-threads --enable-graphite=yes --with-cloog-version=0.18.0 --with-isl-version=0.11.1 --enable-eh-frame-hdr-for-static --with-arch=armv5te --program-transform-name='s&^&arm-linux-androideabi-&' --enable-gold=default
Thread model: posix
gcc version 4.8 (GCC) 
configure:2958: $? = 0
configure:2947: arm-linux-androideabi-gcc -V >&5
arm-linux-androideabi-gcc: error: unrecognized command line option '-V'
arm-linux-androideabi-gcc: fatal error: no input files
compilation terminated.
configure:2958: $? = 1
configure:2947: arm-linux-androideabi-gcc -qversion >&5
arm-linux-androideabi-gcc: error: unrecognized command line option '-qversion'
arm-linux-androideabi-gcc: fatal error: no input files
compilation terminated.
configure:2958: $? = 1
configure:2978: checking for C compiler default output file name
configure:3000: arm-linux-androideabi-gcc   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:3004: $? = 0
configure:3041: result: a.out
configure:3057: checking whether the C compiler works
configure:3085: result: yes
configure:3092: checking whether we are cross compiling
configure:3094: result: yes
configure:3097: checking for suffix of executables
configure:3104: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:3108: $? = 0
configure:3130: result: 
configure:3136: checking for suffix of object files
configure:3158: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:3162: $? = 0
configure:3183: result: o
configure:3187: checking whether we are using the GNU C compiler
configure:3206: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:3206: $? = 0
configure:3215: result: yes
configure:3224: checking whether arm-linux-androideabi-gcc accepts -g
configure:3244: arm-linux-androideabi-gcc -c -g  conftest.c >&5
configure:3244: $? = 0
configure:3285: result: yes
configure:3302: checking for arm-linux-androideabi-gcc option to accept ISO C89
configure:3366: arm-linux-androideabi-gcc  -c   conftest.c >&5
configure:3366: $? = 0
configure:3379: result: none needed
configure:3403: checking build system type
configure:3417: result: x86_64-unknown-linux-gnu
configure:3437: checking host system type
configure:3450: result: x86_64-unknown-linux-gnu
configure:3473: checking for x86_64-unknown-linux-ranlib
configure:3500: result: ranlib
configure:3563: checking for library containing strerror
configure:3594: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:3594: $? = 0
configure:3611: result: none required
configure:3624: checking how to run the C preprocessor
configure:3655: arm-linux-androideabi-gcc -E  conftest.c
configure:3655: $? = 0
configure:3669: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:9:28: fatal error: ac_nonexistent.h: No such file or directory
 #include <ac_nonexistent.h>
                            ^
compilation terminated.
configure:3669: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| /* end confdefs.h.  */
| #include <ac_nonexistent.h>
configure:3694: result: arm-linux-androideabi-gcc -E
configure:3714: arm-linux-androideabi-gcc -E  conftest.c
configure:3714: $? = 0
configure:3728: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:9:28: fatal error: ac_nonexistent.h: No such file or directory
 #include <ac_nonexistent.h>
                            ^
compilation terminated.
configure:3728: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| /* end confdefs.h.  */
| #include <ac_nonexistent.h>
configure:3757: checking for grep that handles long lines and -e
configure:3815: result: /usr/sbin/grep
configure:3820: checking for egrep
configure:3882: result: /usr/sbin/grep -E
configure:3887: checking for ANSI C header files
configure:3907: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:3907: $? = 0
configure:3991: result: yes
configure:3999: checking for an ANSI C-conforming const
configure:4064: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4064: $? = 0
configure:4071: result: yes
configure:4079: checking for inline
configure:4095: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4095: $? = 0
configure:4103: result: inline
configure:4126: checking for sys/types.h
configure:4126: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4126: $? = 0
configure:4126: result: yes
configure:4126: checking for sys/stat.h
configure:4126: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4126: $? = 0
configure:4126: result: yes
configure:4126: checking for stdlib.h
configure:4126: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4126: $? = 0
configure:4126: result: yes
configure:4126: checking for string.h
configure:4126: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4126: $? = 0
configure:4126: result: yes
configure:4126: checking for memory.h
configure:4126: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4126: $? = 0
configure:4126: result: yes
configure:4126: checking for strings.h
configure:4126: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4126: $? = 0
configure:4126: result: yes
configure:4126: checking for inttypes.h
configure:4126: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4126: $? = 0
configure:4126: result: yes
configure:4126: checking for stdint.h
configure:4126: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4126: $? = 0
configure:4126: result: yes
configure:4126: checking for unistd.h
configure:4126: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4126: $? = 0
configure:4126: result: yes
configure:4139: checking for off_t
configure:4139: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4139: $? = 0
configure:4139: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:55:20: error: expected expression before ')' token
 if (sizeof ((off_t)))
                    ^
configure:4139: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| if (sizeof ((off_t)))
| 	    return 0;
|   ;
|   return 0;
| }
configure:4139: result: yes
configure:4150: checking for size_t
configure:4150: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4150: $? = 0
configure:4150: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:55:21: error: expected expression before ')' token
 if (sizeof ((size_t)))
                     ^
configure:4150: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| if (sizeof ((size_t)))
| 	    return 0;
|   ;
|   return 0;
| }
configure:4150: result: yes
configure:4163: checking for working alloca.h
configure:4180: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:4180: $? = 0
configure:4188: result: yes
configure:4196: checking for alloca
configure:4233: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:4233: $? = 0
configure:4241: result: yes
configure:4354: checking for stdlib.h
configure:4354: result: yes
configure:4354: checking for unistd.h
configure:4354: result: yes
configure:4367: checking for getpagesize
configure:4367: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:4367: $? = 0
configure:4367: result: yes
configure:4376: checking for working mmap
configure:4523: result: no
configure:4533: checking whether we are using the GNU C Library 2.1 or newer
configure:4560: result: no
configure:4568: checking whether integer division by zero raises SIGFPE
configure:4636: result: guessing no
configure:4649: checking for inttypes.h
configure:4666: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4666: $? = 0
configure:4673: result: yes
configure:4684: checking for stdint.h
configure:4701: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4701: $? = 0
configure:4708: result: yes
configure:4719: checking for unsigned long long
configure:4736: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:4736: $? = 0
configure:4744: result: yes
configure:4772: checking for inttypes.h
configure:4790: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4790: $? = 0
configure:4798: result: yes
configure:4811: checking whether the inttypes.h PRIxNN macros are broken
configure:4832: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4832: $? = 0
configure:4840: result: no
configure:4891: checking for ld used by GCC
configure:4954: result: /tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld
configure:4961: checking if the linker (/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld) is GNU ld
GNU gold (GNU Binutils 2.24.90) 1.11
configure:4973: result: yes
configure:4979: checking for shared library run path origin
configure:4992: result: done
configure:5398: checking argz.h usability
configure:5398: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:63:18: fatal error: argz.h: No such file or directory
 #include <argz.h>
                  ^
compilation terminated.
configure:5398: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_ALLOCA 1
| #define HAVE_STDLIB_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_GETPAGESIZE 1
| #define INTDIV0_RAISES_SIGFPE 0
| #define HAVE_INTTYPES_H_WITH_UINTMAX 1
| #define HAVE_STDINT_H_WITH_UINTMAX 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_INTTYPES_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <argz.h>
configure:5398: result: no
configure:5398: checking argz.h presence
configure:5398: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:30:18: fatal error: argz.h: No such file or directory
 #include <argz.h>
                  ^
compilation terminated.
configure:5398: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_ALLOCA 1
| #define HAVE_STDLIB_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_GETPAGESIZE 1
| #define INTDIV0_RAISES_SIGFPE 0
| #define HAVE_INTTYPES_H_WITH_UINTMAX 1
| #define HAVE_STDINT_H_WITH_UINTMAX 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_INTTYPES_H 1
| /* end confdefs.h.  */
| #include <argz.h>
configure:5398: result: no
configure:5398: checking for argz.h
configure:5398: result: no
configure:5398: checking limits.h usability
configure:5398: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5398: $? = 0
configure:5398: result: yes
configure:5398: checking limits.h presence
configure:5398: arm-linux-androideabi-gcc -E  conftest.c
configure:5398: $? = 0
configure:5398: result: yes
configure:5398: checking for limits.h
configure:5398: result: yes
configure:5398: checking locale.h usability
configure:5398: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5398: $? = 0
configure:5398: result: yes
configure:5398: checking locale.h presence
configure:5398: arm-linux-androideabi-gcc -E  conftest.c
configure:5398: $? = 0
configure:5398: result: yes
configure:5398: checking for locale.h
configure:5398: result: yes
configure:5398: checking nl_types.h usability
configure:5398: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:65:22: fatal error: nl_types.h: No such file or directory
 #include <nl_types.h>
                      ^
compilation terminated.
configure:5398: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_ALLOCA 1
| #define HAVE_STDLIB_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_GETPAGESIZE 1
| #define INTDIV0_RAISES_SIGFPE 0
| #define HAVE_INTTYPES_H_WITH_UINTMAX 1
| #define HAVE_STDINT_H_WITH_UINTMAX 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LOCALE_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <nl_types.h>
configure:5398: result: no
configure:5398: checking nl_types.h presence
configure:5398: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:32:22: fatal error: nl_types.h: No such file or directory
 #include <nl_types.h>
                      ^
compilation terminated.
configure:5398: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_ALLOCA 1
| #define HAVE_STDLIB_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_GETPAGESIZE 1
| #define INTDIV0_RAISES_SIGFPE 0
| #define HAVE_INTTYPES_H_WITH_UINTMAX 1
| #define HAVE_STDINT_H_WITH_UINTMAX 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LOCALE_H 1
| /* end confdefs.h.  */
| #include <nl_types.h>
configure:5398: result: no
configure:5398: checking for nl_types.h
configure:5398: result: no
configure:5398: checking malloc.h usability
configure:5398: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5398: $? = 0
configure:5398: result: yes
configure:5398: checking malloc.h presence
configure:5398: arm-linux-androideabi-gcc -E  conftest.c
configure:5398: $? = 0
configure:5398: result: yes
configure:5398: checking for malloc.h
configure:5398: result: yes
configure:5398: checking stddef.h usability
configure:5398: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5398: $? = 0
configure:5398: result: yes
configure:5398: checking stddef.h presence
configure:5398: arm-linux-androideabi-gcc -E  conftest.c
configure:5398: $? = 0
configure:5398: result: yes
configure:5398: checking for stddef.h
configure:5398: result: yes
configure:5398: checking for stdlib.h
configure:5398: result: yes
configure:5398: checking for string.h
configure:5398: result: yes
configure:5398: checking for unistd.h
configure:5398: result: yes
configure:5398: checking sys/param.h usability
configure:5398: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5398: $? = 0
configure:5398: result: yes
configure:5398: checking sys/param.h presence
configure:5398: arm-linux-androideabi-gcc -E  conftest.c
configure:5398: $? = 0
configure:5398: result: yes
configure:5398: checking for sys/param.h
configure:5398: result: yes
configure:5415: checking for feof_unlocked
configure:5415: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
/tmp/cccivK9f.o:conftest.c:function main: error: undefined reference to 'feof_unlocked'
collect2: error: ld returned 1 exit status
configure:5415: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_ALLOCA 1
| #define HAVE_STDLIB_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_GETPAGESIZE 1
| #define INTDIV0_RAISES_SIGFPE 0
| #define HAVE_INTTYPES_H_WITH_UINTMAX 1
| #define HAVE_STDINT_H_WITH_UINTMAX 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STDDEF_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_PARAM_H 1
| /* end confdefs.h.  */
| /* Define feof_unlocked to an innocuous variant, in case <limits.h> declares feof_unlocked.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define feof_unlocked innocuous_feof_unlocked
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char feof_unlocked (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef feof_unlocked
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char feof_unlocked ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_feof_unlocked || defined __stub___feof_unlocked
| choke me
| #endif
| 
| int
| main ()
| {
| return feof_unlocked ();
|   ;
|   return 0;
| }
configure:5415: result: no
configure:5415: checking for fgets_unlocked
configure:5415: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
/tmp/ccDeqE3r.o:conftest.c:function main: error: undefined reference to 'fgets_unlocked'
collect2: error: ld returned 1 exit status
configure:5415: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_ALLOCA 1
| #define HAVE_STDLIB_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_GETPAGESIZE 1
| #define INTDIV0_RAISES_SIGFPE 0
| #define HAVE_INTTYPES_H_WITH_UINTMAX 1
| #define HAVE_STDINT_H_WITH_UINTMAX 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STDDEF_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_PARAM_H 1
| /* end confdefs.h.  */
| /* Define fgets_unlocked to an innocuous variant, in case <limits.h> declares fgets_unlocked.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define fgets_unlocked innocuous_fgets_unlocked
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char fgets_unlocked (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef fgets_unlocked
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char fgets_unlocked ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_fgets_unlocked || defined __stub___fgets_unlocked
| choke me
| #endif
| 
| int
| main ()
| {
| return fgets_unlocked ();
|   ;
|   return 0;
| }
configure:5415: result: no
configure:5415: checking for getc_unlocked
configure:5415: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:5415: $? = 0
configure:5415: result: yes
configure:5415: checking for getcwd
configure:5415: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:5415: $? = 0
configure:5415: result: yes
configure:5415: checking for getegid
configure:5415: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:5415: $? = 0
configure:5415: result: yes
configure:5415: checking for geteuid
configure:5415: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:5415: $? = 0
configure:5415: result: yes
configure:5415: checking for getgid
configure:5415: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:5415: $? = 0
configure:5415: result: yes
configure:5415: checking for getuid
configure:5415: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:5415: $? = 0
configure:5415: result: yes
configure:5415: checking for mempcpy
configure:5415: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
conftest.c:67:6: warning: conflicting types for built-in function 'mempcpy' [enabled by default]
 char mempcpy ();
      ^
/tmp/ccePa6C0.o:conftest.c:function main: error: undefined reference to 'mempcpy'
collect2: error: ld returned 1 exit status
configure:5415: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_ALLOCA 1
| #define HAVE_STDLIB_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_GETPAGESIZE 1
| #define INTDIV0_RAISES_SIGFPE 0
| #define HAVE_INTTYPES_H_WITH_UINTMAX 1
| #define HAVE_STDINT_H_WITH_UINTMAX 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STDDEF_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_GETC_UNLOCKED 1
| #define HAVE_GETCWD 1
| #define HAVE_GETEGID 1
| #define HAVE_GETEUID 1
| #define HAVE_GETGID 1
| #define HAVE_GETUID 1
| /* end confdefs.h.  */
| /* Define mempcpy to an innocuous variant, in case <limits.h> declares mempcpy.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define mempcpy innocuous_mempcpy
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char mempcpy (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef mempcpy
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char mempcpy ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_mempcpy || defined __stub___mempcpy
| choke me
| #endif
| 
| int
| main ()
| {
| return mempcpy ();
|   ;
|   return 0;
| }
configure:5415: result: no
configure:5415: checking for munmap
configure:5415: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:5415: $? = 0
configure:5415: result: yes
configure:5415: checking for putenv
configure:5415: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:5415: $? = 0
configure:5415: result: yes
configure:5415: checking for setenv
configure:5415: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:5415: $? = 0
configure:5415: result: yes
configure:5415: checking for setlocale
configure:5415: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:5415: $? = 0
configure:5415: result: yes
configure:5415: checking for stpcpy
configure:5415: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
conftest.c:71:6: warning: conflicting types for built-in function 'stpcpy' [enabled by default]
 char stpcpy ();
      ^
configure:5415: $? = 0
configure:5415: result: yes
configure:5415: checking for strcasecmp
configure:5415: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
conftest.c:72:6: warning: conflicting types for built-in function 'strcasecmp' [enabled by default]
 char strcasecmp ();
      ^
configure:5415: $? = 0
configure:5415: result: yes
configure:5415: checking for strdup
configure:5415: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
conftest.c:73:6: warning: conflicting types for built-in function 'strdup' [enabled by default]
 char strdup ();
      ^
configure:5415: $? = 0
configure:5415: result: yes
configure:5415: checking for strtoul
configure:5415: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:5415: $? = 0
configure:5415: result: yes
configure:5415: checking for tsearch
configure:5415: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:5415: $? = 0
configure:5415: result: yes
configure:5415: checking for __argz_count
configure:5415: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
/tmp/ccevdQFl.o:conftest.c:function main: error: undefined reference to '__argz_count'
collect2: error: ld returned 1 exit status
configure:5415: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_ALLOCA 1
| #define HAVE_STDLIB_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_GETPAGESIZE 1
| #define INTDIV0_RAISES_SIGFPE 0
| #define HAVE_INTTYPES_H_WITH_UINTMAX 1
| #define HAVE_STDINT_H_WITH_UINTMAX 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STDDEF_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_GETC_UNLOCKED 1
| #define HAVE_GETCWD 1
| #define HAVE_GETEGID 1
| #define HAVE_GETEUID 1
| #define HAVE_GETGID 1
| #define HAVE_GETUID 1
| #define HAVE_MUNMAP 1
| #define HAVE_PUTENV 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_STPCPY 1
| #define HAVE_STRCASECMP 1
| #define HAVE_STRDUP 1
| #define HAVE_STRTOUL 1
| #define HAVE_TSEARCH 1
| /* end confdefs.h.  */
| /* Define __argz_count to an innocuous variant, in case <limits.h> declares __argz_count.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define __argz_count innocuous___argz_count
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char __argz_count (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef __argz_count
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char __argz_count ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub___argz_count || defined __stub_____argz_count
| choke me
| #endif
| 
| int
| main ()
| {
| return __argz_count ();
|   ;
|   return 0;
| }
configure:5415: result: no
configure:5415: checking for __argz_stringify
configure:5415: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
/tmp/cccfH7Xg.o:conftest.c:function main: error: undefined reference to '__argz_stringify'
collect2: error: ld returned 1 exit status
configure:5415: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_ALLOCA 1
| #define HAVE_STDLIB_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_GETPAGESIZE 1
| #define INTDIV0_RAISES_SIGFPE 0
| #define HAVE_INTTYPES_H_WITH_UINTMAX 1
| #define HAVE_STDINT_H_WITH_UINTMAX 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STDDEF_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_GETC_UNLOCKED 1
| #define HAVE_GETCWD 1
| #define HAVE_GETEGID 1
| #define HAVE_GETEUID 1
| #define HAVE_GETGID 1
| #define HAVE_GETUID 1
| #define HAVE_MUNMAP 1
| #define HAVE_PUTENV 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_STPCPY 1
| #define HAVE_STRCASECMP 1
| #define HAVE_STRDUP 1
| #define HAVE_STRTOUL 1
| #define HAVE_TSEARCH 1
| /* end confdefs.h.  */
| /* Define __argz_stringify to an innocuous variant, in case <limits.h> declares __argz_stringify.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define __argz_stringify innocuous___argz_stringify
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char __argz_stringify (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef __argz_stringify
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char __argz_stringify ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub___argz_stringify || defined __stub_____argz_stringify
| choke me
| #endif
| 
| int
| main ()
| {
| return __argz_stringify ();
|   ;
|   return 0;
| }
configure:5415: result: no
configure:5415: checking for __argz_next
configure:5415: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
/tmp/ccu5UGqr.o:conftest.c:function main: error: undefined reference to '__argz_next'
collect2: error: ld returned 1 exit status
configure:5415: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_ALLOCA 1
| #define HAVE_STDLIB_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_GETPAGESIZE 1
| #define INTDIV0_RAISES_SIGFPE 0
| #define HAVE_INTTYPES_H_WITH_UINTMAX 1
| #define HAVE_STDINT_H_WITH_UINTMAX 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STDDEF_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_GETC_UNLOCKED 1
| #define HAVE_GETCWD 1
| #define HAVE_GETEGID 1
| #define HAVE_GETEUID 1
| #define HAVE_GETGID 1
| #define HAVE_GETUID 1
| #define HAVE_MUNMAP 1
| #define HAVE_PUTENV 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_STPCPY 1
| #define HAVE_STRCASECMP 1
| #define HAVE_STRDUP 1
| #define HAVE_STRTOUL 1
| #define HAVE_TSEARCH 1
| /* end confdefs.h.  */
| /* Define __argz_next to an innocuous variant, in case <limits.h> declares __argz_next.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define __argz_next innocuous___argz_next
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char __argz_next (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef __argz_next
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char __argz_next ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub___argz_next || defined __stub_____argz_next
| choke me
| #endif
| 
| int
| main ()
| {
| return __argz_next ();
|   ;
|   return 0;
| }
configure:5415: result: no
configure:5415: checking for __fsetlocking
configure:5415: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
/tmp/cceOMWnN.o:conftest.c:function main: error: undefined reference to '__fsetlocking'
collect2: error: ld returned 1 exit status
configure:5415: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_ALLOCA 1
| #define HAVE_STDLIB_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_GETPAGESIZE 1
| #define INTDIV0_RAISES_SIGFPE 0
| #define HAVE_INTTYPES_H_WITH_UINTMAX 1
| #define HAVE_STDINT_H_WITH_UINTMAX 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STDDEF_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_GETC_UNLOCKED 1
| #define HAVE_GETCWD 1
| #define HAVE_GETEGID 1
| #define HAVE_GETEUID 1
| #define HAVE_GETGID 1
| #define HAVE_GETUID 1
| #define HAVE_MUNMAP 1
| #define HAVE_PUTENV 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_STPCPY 1
| #define HAVE_STRCASECMP 1
| #define HAVE_STRDUP 1
| #define HAVE_STRTOUL 1
| #define HAVE_TSEARCH 1
| /* end confdefs.h.  */
| /* Define __fsetlocking to an innocuous variant, in case <limits.h> declares __fsetlocking.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define __fsetlocking innocuous___fsetlocking
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char __fsetlocking (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef __fsetlocking
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char __fsetlocking ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub___fsetlocking || defined __stub_____fsetlocking
| choke me
| #endif
| 
| int
| main ()
| {
| return __fsetlocking ();
|   ;
|   return 0;
| }
configure:5415: result: no
configure:5456: checking for iconv
configure:5478: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
conftest.c:54:19: fatal error: iconv.h: No such file or directory
 #include <iconv.h>
                   ^
compilation terminated.
configure:5478: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_ALLOCA 1
| #define HAVE_STDLIB_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_GETPAGESIZE 1
| #define INTDIV0_RAISES_SIGFPE 0
| #define HAVE_INTTYPES_H_WITH_UINTMAX 1
| #define HAVE_STDINT_H_WITH_UINTMAX 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STDDEF_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_GETC_UNLOCKED 1
| #define HAVE_GETCWD 1
| #define HAVE_GETEGID 1
| #define HAVE_GETEUID 1
| #define HAVE_GETGID 1
| #define HAVE_GETUID 1
| #define HAVE_MUNMAP 1
| #define HAVE_PUTENV 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_STPCPY 1
| #define HAVE_STRCASECMP 1
| #define HAVE_STRDUP 1
| #define HAVE_STRTOUL 1
| #define HAVE_TSEARCH 1
| /* end confdefs.h.  */
| #include <stdlib.h>
| #include <iconv.h>
| int
| main ()
| {
| iconv_t cd = iconv_open("","");
|        iconv(cd,NULL,NULL,NULL,NULL);
|        iconv_close(cd);
|   ;
|   return 0;
| }
configure:5500: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  -liconv >&5
conftest.c:54:19: fatal error: iconv.h: No such file or directory
 #include <iconv.h>
                   ^
compilation terminated.
configure:5500: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_ALLOCA 1
| #define HAVE_STDLIB_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_GETPAGESIZE 1
| #define INTDIV0_RAISES_SIGFPE 0
| #define HAVE_INTTYPES_H_WITH_UINTMAX 1
| #define HAVE_STDINT_H_WITH_UINTMAX 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STDDEF_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_GETC_UNLOCKED 1
| #define HAVE_GETCWD 1
| #define HAVE_GETEGID 1
| #define HAVE_GETEUID 1
| #define HAVE_GETGID 1
| #define HAVE_GETUID 1
| #define HAVE_MUNMAP 1
| #define HAVE_PUTENV 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_STPCPY 1
| #define HAVE_STRCASECMP 1
| #define HAVE_STRDUP 1
| #define HAVE_STRTOUL 1
| #define HAVE_TSEARCH 1
| /* end confdefs.h.  */
| #include <stdlib.h>
| #include <iconv.h>
| int
| main ()
| {
| iconv_t cd = iconv_open("","");
|          iconv(cd,NULL,NULL,NULL,NULL);
|          iconv_close(cd);
|   ;
|   return 0;
| }
configure:5510: result: no, consider installing GNU libiconv
configure:5582: checking for nl_langinfo and CODESET
configure:5598: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
conftest.c:53:22: fatal error: langinfo.h: No such file or directory
 #include <langinfo.h>
                      ^
compilation terminated.
configure:5598: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_ALLOCA 1
| #define HAVE_STDLIB_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_GETPAGESIZE 1
| #define INTDIV0_RAISES_SIGFPE 0
| #define HAVE_INTTYPES_H_WITH_UINTMAX 1
| #define HAVE_STDINT_H_WITH_UINTMAX 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STDDEF_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_GETC_UNLOCKED 1
| #define HAVE_GETCWD 1
| #define HAVE_GETEGID 1
| #define HAVE_GETEUID 1
| #define HAVE_GETGID 1
| #define HAVE_GETUID 1
| #define HAVE_MUNMAP 1
| #define HAVE_PUTENV 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_STPCPY 1
| #define HAVE_STRCASECMP 1
| #define HAVE_STRDUP 1
| #define HAVE_STRTOUL 1
| #define HAVE_TSEARCH 1
| /* end confdefs.h.  */
| #include <langinfo.h>
| int
| main ()
| {
| char* cs = nl_langinfo(CODESET);
|   ;
|   return 0;
| }
configure:5607: result: no
configure:5617: checking for LC_MESSAGES
configure:5633: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:5633: $? = 0
configure:5641: result: yes
configure:5655: checking for bison
configure:5671: found /usr/sbin/bison
configure:5682: result: bison
configure:5696: checking version of bison
configure:5705: result: 3.0.4, ok
configure:5727: checking whether NLS is requested
configure:5736: result: no
configure:6294: checking whether to use NLS
configure:6296: result: no
configure:6424: checking for aclocal
configure:6440: found /usr/sbin/aclocal
configure:6451: result: aclocal
configure:6467: checking for autoconf
configure:6483: found /usr/sbin/autoconf
configure:6494: result: autoconf
configure:6510: checking for autoheader
configure:6526: found /usr/sbin/autoheader
configure:6537: result: autoheader
configure:6646: updating cache ./config.cache
configure:6683: creating ./config.status

## ---------------------- ##
## Running config.status. ##
## ---------------------- ##

This file was extended by config.status, which was
generated by GNU Autoconf 2.64.  Invocation command line was

  CONFIG_FILES    = 
  CONFIG_HEADERS  = 
  CONFIG_LINKS    = 
  CONFIG_COMMANDS = 
  $ ./config.status 

on d5f3793a98c0

config.status:899: creating Makefile
config.status:899: creating config.intl
config.status:899: creating config.h
config.status:1072: executing default-1 commands

## ---------------- ##
## Cache variables. ##
## ---------------- ##

ac_cv_build=x86_64-unknown-linux-gnu
ac_cv_c_compiler_gnu=yes
ac_cv_c_const=yes
ac_cv_c_inline=inline
ac_cv_env_CC_set=set
ac_cv_env_CC_value=arm-linux-androideabi-gcc
ac_cv_env_CFLAGS_set=set
ac_cv_env_CFLAGS_value=
ac_cv_env_CPPFLAGS_set=set
ac_cv_env_CPPFLAGS_value=
ac_cv_env_CPP_set=
ac_cv_env_CPP_value=
ac_cv_env_LDFLAGS_set=set
ac_cv_env_LDFLAGS_value='-static-libstdc++ -static-libgcc '
ac_cv_env_LIBS_set=
ac_cv_env_LIBS_value=
ac_cv_env_build_alias_set=set
ac_cv_env_build_alias_value=x86_64-unknown-linux-gnu
ac_cv_env_host_alias_set=set
ac_cv_env_host_alias_value=x86_64-unknown-linux
ac_cv_env_target_alias_set=set
ac_cv_env_target_alias_value=i686-w64-mingw32
ac_cv_func___argz_count=no
ac_cv_func___argz_next=no
ac_cv_func___argz_stringify=no
ac_cv_func___fsetlocking=no
ac_cv_func_alloca_works=yes
ac_cv_func_feof_unlocked=no
ac_cv_func_fgets_unlocked=no
ac_cv_func_getc_unlocked=yes
ac_cv_func_getcwd=yes
ac_cv_func_getegid=yes
ac_cv_func_geteuid=yes
ac_cv_func_getgid=yes
ac_cv_func_getpagesize=yes
ac_cv_func_getuid=yes
ac_cv_func_mempcpy=no
ac_cv_func_mmap_fixed_mapped=no
ac_cv_func_munmap=yes
ac_cv_func_putenv=yes
ac_cv_func_setenv=yes
ac_cv_func_setlocale=yes
ac_cv_func_stpcpy=yes
ac_cv_func_strcasecmp=yes
ac_cv_func_strdup=yes
ac_cv_func_strtoul=yes
ac_cv_func_tsearch=yes
ac_cv_gnu_library_2_1=no
ac_cv_header_argz_h=no
ac_cv_header_inttypes_h=yes
ac_cv_header_limits_h=yes
ac_cv_header_locale_h=yes
ac_cv_header_malloc_h=yes
ac_cv_header_memory_h=yes
ac_cv_header_nl_types_h=no
ac_cv_header_stdc=yes
ac_cv_header_stddef_h=yes
ac_cv_header_stdint_h=yes
ac_cv_header_stdlib_h=yes
ac_cv_header_string_h=yes
ac_cv_header_strings_h=yes
ac_cv_header_sys_param_h=yes
ac_cv_header_sys_stat_h=yes
ac_cv_header_sys_types_h=yes
ac_cv_header_unistd_h=yes
ac_cv_host=x86_64-unknown-linux-gnu
ac_cv_objext=o
ac_cv_path_EGREP='/usr/sbin/grep -E'
ac_cv_path_GMSGFMT=/usr/sbin/msgfmt
ac_cv_path_GREP=/usr/sbin/grep
ac_cv_path_MSGFMT=/usr/sbin/msgfmt
ac_cv_path_MSGMERGE=/usr/sbin/msgmerge
ac_cv_path_XGETTEXT=/usr/sbin/xgettext
ac_cv_prog_ACLOCAL=aclocal
ac_cv_prog_AUTOCONF=autoconf
ac_cv_prog_AUTOHEADER=autoheader
ac_cv_prog_CC=arm-linux-androideabi-gcc
ac_cv_prog_CPP='arm-linux-androideabi-gcc -E'
ac_cv_prog_INTLBISON=bison
ac_cv_prog_RANLIB=ranlib
ac_cv_prog_cc_c89=
ac_cv_prog_cc_g=yes
ac_cv_prog_make_make_set=yes
ac_cv_search_strerror='none required'
ac_cv_type_off_t=yes
ac_cv_type_size_t=yes
ac_cv_type_unsigned_long_long=yes
ac_cv_working_alloca_h=yes
acl_cv_hardcode_direct=no
acl_cv_hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
acl_cv_hardcode_libdir_separator=
acl_cv_hardcode_minus_L=no
acl_cv_libext=a
acl_cv_path_LD=/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld
acl_cv_prog_gnu_ld=yes
acl_cv_rpath=done
acl_cv_shlibext=so
acl_cv_wl=-Wl,
am_cv_func_iconv='no, consider installing GNU libiconv'
am_cv_langinfo_codeset=no
am_cv_lib_iconv=no
am_cv_val_LC_MESSAGES=yes
gt_cv_header_inttypes_h=yes
gt_cv_int_divbyzero_sigfpe='guessing no'
gt_cv_inttypes_pri_broken=no
jm_ac_cv_header_inttypes_h=yes
jm_ac_cv_header_stdint_h=yes
nls_cv_header_intl=
nls_cv_header_libgt=

## ----------------- ##
## Output variables. ##
## ----------------- ##

ACLOCAL='aclocal'
ALLOCA=''
AUTOCONF='autoconf'
AUTOHEADER='autoheader'
BUILD_INCLUDED_LIBINTL='no'
CATOBJEXT=''
CC='arm-linux-androideabi-gcc'
CFLAGS=''
CPP='arm-linux-androideabi-gcc -E'
CPPFLAGS=''
DATADIRNAME='share'
DEFS='-DHAVE_CONFIG_H'
ECHO_C=''
ECHO_N='-n'
ECHO_T=''
EGREP='/usr/sbin/grep -E'
EXEEXT=''
GENCAT='gencat'
GLIBC21='no'
GMSGFMT='/usr/sbin/msgfmt'
GREP='/usr/sbin/grep'
INCINTL=''
INSTALL_DATA='/usr/bin/install -c -m 644'
INSTALL_PROGRAM='/usr/bin/install -c'
INSTALL_SCRIPT='/usr/bin/install -c'
INSTOBJEXT='.mo'
INTLBISON='bison'
INTLLIBS=''
INTLOBJS=''
INTL_LIBTOOL_SUFFIX_PREFIX=''
LDFLAGS='-static-libstdc++ -static-libgcc '
LIBICONV=''
LIBINTL=''
LIBINTL_DEP=''
LIBOBJS=''
LIBS=''
LTLIBICONV=''
LTLIBINTL=''
LTLIBOBJS=''
MAINT='#'
MKINSTALLDIRS='/tmp/mingw-w64-binutils/src/binutils-2.25.1/intl/../mkinstalldirs'
MSGFMT='/usr/sbin/msgfmt'
MSGMERGE='/usr/sbin/msgmerge'
OBJEXT='o'
PACKAGE_BUGREPORT=''
PACKAGE_NAME=''
PACKAGE_STRING=''
PACKAGE_TARNAME=''
PACKAGE_URL=''
PACKAGE_VERSION=''
PATH_SEPARATOR=':'
POSUB=''
RANLIB='ranlib'
SET_MAKE=''
SHELL='/bin/sh'
USE_INCLUDED_LIBINTL='no'
USE_NLS='no'
XGETTEXT='/usr/sbin/xgettext'
ac_ct_CC=''
bindir='${exec_prefix}/bin'
build='x86_64-unknown-linux-gnu'
build_alias='x86_64-unknown-linux-gnu'
build_cpu='x86_64'
build_os='linux-gnu'
build_vendor='unknown'
datadir='${datarootdir}'
datarootdir='${prefix}/share'
docdir='${datarootdir}/doc/${PACKAGE}'
dvidir='${docdir}'
exec_prefix='${prefix}'
host='x86_64-unknown-linux-gnu'
host_alias='x86_64-unknown-linux'
host_cpu='x86_64'
host_os='linux-gnu'
host_vendor='unknown'
htmldir='${docdir}'
includedir='${prefix}/include'
infodir='/usr/share/info/i686-w64-mingw32'
libdir='${exec_prefix}/lib'
libexecdir='${exec_prefix}/libexec'
localedir='${datarootdir}/locale'
localstatedir='${prefix}/var'
mandir='${datarootdir}/man'
oldincludedir='/usr/include'
pdfdir='${docdir}'
prefix='/usr'
program_transform_name='s&^&i686-w64-mingw32-&'
psdir='${docdir}'
sbindir='${exec_prefix}/sbin'
sharedstatedir='${prefix}/com'
sysconfdir='${prefix}/etc'
target_alias='i686-w64-mingw32'

## ----------- ##
## confdefs.h. ##
## ----------- ##

/* confdefs.h */
#define PACKAGE_NAME ""
#define PACKAGE_TARNAME ""
#define PACKAGE_VERSION ""
#define PACKAGE_STRING ""
#define PACKAGE_BUGREPORT ""
#define PACKAGE_URL ""
#define STDC_HEADERS 1
#define HAVE_SYS_TYPES_H 1
#define HAVE_SYS_STAT_H 1
#define HAVE_STDLIB_H 1
#define HAVE_STRING_H 1
#define HAVE_MEMORY_H 1
#define HAVE_STRINGS_H 1
#define HAVE_INTTYPES_H 1
#define HAVE_STDINT_H 1
#define HAVE_UNISTD_H 1
#define HAVE_ALLOCA_H 1
#define HAVE_ALLOCA 1
#define HAVE_STDLIB_H 1
#define HAVE_UNISTD_H 1
#define HAVE_GETPAGESIZE 1
#define INTDIV0_RAISES_SIGFPE 0
#define HAVE_INTTYPES_H_WITH_UINTMAX 1
#define HAVE_STDINT_H_WITH_UINTMAX 1
#define HAVE_UNSIGNED_LONG_LONG 1
#define HAVE_UINTMAX_T 1
#define HAVE_INTTYPES_H 1
#define HAVE_LIMITS_H 1
#define HAVE_LOCALE_H 1
#define HAVE_MALLOC_H 1
#define HAVE_STDDEF_H 1
#define HAVE_STDLIB_H 1
#define HAVE_STRING_H 1
#define HAVE_UNISTD_H 1
#define HAVE_SYS_PARAM_H 1
#define HAVE_GETC_UNLOCKED 1
#define HAVE_GETCWD 1
#define HAVE_GETEGID 1
#define HAVE_GETEUID 1
#define HAVE_GETGID 1
#define HAVE_GETUID 1
#define HAVE_MUNMAP 1
#define HAVE_PUTENV 1
#define HAVE_SETENV 1
#define HAVE_SETLOCALE 1
#define HAVE_STPCPY 1
#define HAVE_STRCASECMP 1
#define HAVE_STRDUP 1
#define HAVE_STRTOUL 1
#define HAVE_TSEARCH 1
#define HAVE_LC_MESSAGES 1
#define IN_LIBINTL 1
#define IN_LIBRARY 1
#define DEPENDS_ON_LIBICONV 1
#define ENABLE_RELOCATABLE 1
#define NO_XMALLOC 1
#define set_relocation_prefix libintl_set_relocation_prefix
#define relocate libintl_relocate

configure: exit 0

____
File /tmp/mingw-w64-binutils/src/binutils-i686-w64-mingw32/ld/config.log
This file contains any messages produced by compilers while
running configure, to aid debugging if configure makes a mistake.

It was created by ld configure 2.25.1, which was
generated by GNU Autoconf 2.64.  Invocation command line was

  $ /tmp/mingw-w64-binutils/src/binutils-2.25.1/ld/configure --cache-file=./config.cache --with-gnu-as --with-gnu-ld --with-system-zlib --prefix=/usr --infodir=/usr/share/info/i686-w64-mingw32 --enable-lto --enable-plugins --disable-multilib --disable-nls --disable-werror --program-transform-name=s&^&i686-w64-mingw32-& --disable-option-checking --build=x86_64-unknown-linux-gnu --host=x86_64-unknown-linux --target=i686-w64-mingw32 --srcdir=/tmp/mingw-w64-binutils/src/binutils-2.25.1/ld

## --------- ##
## Platform. ##
## --------- ##

hostname = d5f3793a98c0
uname -m = x86_64
uname -r = 3.13.0-66-generic
uname -s = Linux
uname -v = #108-Ubuntu SMP Wed Oct 7 15:20:27 UTC 2015

/usr/bin/uname -p = unknown
/bin/uname -X     = unknown

/bin/arch              = unknown
/usr/bin/arch -k       = unknown
/usr/convex/getsysinfo = unknown
/usr/bin/hostinfo      = unknown
/bin/machine           = unknown
/usr/bin/oslevel       = unknown
/bin/universe          = unknown

PATH: /tmp/toolchain/bin
PATH: /usr/local/sbin
PATH: /usr/local/bin
PATH: /usr/sbin
PATH: /usr/bin
PATH: /sbin
PATH: /bin


## ----------- ##
## Core tests. ##
## ----------- ##

configure:2527: creating cache ./config.cache
configure:2632: checking build system type
configure:2646: result: x86_64-unknown-linux-gnu
configure:2666: checking host system type
configure:2679: result: x86_64-unknown-linux-gnu
configure:2699: checking target system type
configure:2712: result: i686-w64-mingw32
configure:2747: checking for x86_64-unknown-linux-gcc
configure:2774: result: arm-linux-androideabi-gcc
configure:3043: checking for C compiler version
configure:3052: arm-linux-androideabi-gcc --version >&5
arm-linux-androideabi-gcc (GCC) 4.8
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

configure:3063: $? = 0
configure:3052: arm-linux-androideabi-gcc -v >&5
Using built-in specs.
COLLECT_GCC=arm-linux-androideabi-gcc
COLLECT_LTO_WRAPPER=/tmp/toolchain/bin/../libexec/gcc/arm-linux-androideabi/4.8/lto-wrapper
Target: arm-linux-androideabi
Configured with: /s/ndk-toolchain/src/build/../gcc/gcc-4.8/configure --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --target=arm-linux-androideabi --host=x86_64-linux-gnu --build=x86_64-linux-gnu --with-gnu-as --with-gnu-ld --enable-languages=c,c++ --with-gmp=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpfr=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpc=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-cloog=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-isl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-ppl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --disable-ppl-version-check --disable-cloog-version-check --disable-isl-version-check --enable-cloog-backend=isl --with-host-libstdcxx='-static-libgcc -Wl,-Bstatic,-lstdc++,-Bdynamic -lm' --disable-libssp --enable-threads --disable-nls --disable-libmudflap --disable-libgomp --disable-libstdc__-v3 --disable-sjlj-exceptions --disable-shared --disable-tls --disable-libitm --with-float=soft --with-fpu=vfp --with-arch=armv5te --enable-target-optspace --enable-initfini-array --disable-nls --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --with-sysroot=/tmp/ndk-andrewhsieh/build/toolchain/prefix/sysroot --with-binutils-version=2.25 --with-mpfr-version=3.1.1 --with-mpc-version=1.0.1 --with-gmp-version=5.0.5 --with-gcc-version=4.8 --with-gdb-version=7.7 --with-python=/usr/local/google/home/andrewhsieh/mydroid/ndk/prebuilt/linux-x86_64/bin/python-config.sh --with-gxx-include-dir=/tmp/ndk-andrewhsieh/build/toolchain/prefix/include/c++/4.8 --with-bugurl=http://source.android.com/source/report-bugs.html --enable-languages=c,c++ --disable-bootstrap --enable-plugins --enable-libgomp --enable-gnu-indirect-function --disable-libsanitizer --enable-gold --enable-threads --enable-graphite=yes --with-cloog-version=0.18.0 --with-isl-version=0.11.1 --enable-eh-frame-hdr-for-static --with-arch=armv5te --program-transform-name='s&^&arm-linux-androideabi-&' --enable-gold=default
Thread model: posix
gcc version 4.8 (GCC) 
configure:3063: $? = 0
configure:3052: arm-linux-androideabi-gcc -V >&5
arm-linux-androideabi-gcc: error: unrecognized command line option '-V'
arm-linux-androideabi-gcc: fatal error: no input files
compilation terminated.
configure:3063: $? = 1
configure:3052: arm-linux-androideabi-gcc -qversion >&5
arm-linux-androideabi-gcc: error: unrecognized command line option '-qversion'
arm-linux-androideabi-gcc: fatal error: no input files
compilation terminated.
configure:3063: $? = 1
configure:3083: checking for C compiler default output file name
configure:3105: arm-linux-androideabi-gcc   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:3109: $? = 0
configure:3146: result: a.out
configure:3162: checking whether the C compiler works
configure:3190: result: yes
configure:3197: checking whether we are cross compiling
configure:3199: result: yes
configure:3202: checking for suffix of executables
configure:3209: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:3213: $? = 0
configure:3235: result: 
configure:3241: checking for suffix of object files
configure:3263: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:3267: $? = 0
configure:3288: result: o
configure:3292: checking whether we are using the GNU C compiler
configure:3311: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:3311: $? = 0
configure:3320: result: yes
configure:3329: checking whether arm-linux-androideabi-gcc accepts -g
configure:3349: arm-linux-androideabi-gcc -c -g  conftest.c >&5
configure:3349: $? = 0
configure:3390: result: yes
configure:3407: checking for arm-linux-androideabi-gcc option to accept ISO C89
configure:3471: arm-linux-androideabi-gcc  -c   conftest.c >&5
configure:3471: $? = 0
configure:3484: result: none needed
configure:3505: checking for library containing strerror
configure:3536: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:3536: $? = 0
configure:3553: result: none required
configure:3578: checking for a BSD-compatible install
configure:3646: result: /usr/bin/install -c
configure:3657: checking whether build environment is sane
configure:3707: result: yes
configure:3756: checking for x86_64-unknown-linux-strip
configure:3786: result: no
configure:3796: checking for strip
configure:3812: found /usr/sbin/strip
configure:3823: result: strip
configure:3835: WARNING: using cross tools not prefixed with host triplet
configure:3848: checking for a thread-safe mkdir -p
configure:3887: result: /usr/sbin/mkdir -p
configure:3900: checking for gawk
configure:3927: result: gawk
configure:3938: checking whether make sets $(MAKE)
configure:3960: result: yes
configure:3990: checking for style of include used by make
configure:4018: result: GNU
configure:4103: checking dependency style of arm-linux-androideabi-gcc
configure:4213: result: gcc3
configure:4230: checking whether to enable maintainer-specific portions of Makefiles
configure:4239: result: no
configure:4261: checking for x86_64-unknown-linux-gcc
configure:4288: result: arm-linux-androideabi-gcc
configure:4557: checking for C compiler version
configure:4566: arm-linux-androideabi-gcc --version >&5
arm-linux-androideabi-gcc (GCC) 4.8
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

configure:4577: $? = 0
configure:4566: arm-linux-androideabi-gcc -v >&5
Using built-in specs.
COLLECT_GCC=arm-linux-androideabi-gcc
COLLECT_LTO_WRAPPER=/tmp/toolchain/bin/../libexec/gcc/arm-linux-androideabi/4.8/lto-wrapper
Target: arm-linux-androideabi
Configured with: /s/ndk-toolchain/src/build/../gcc/gcc-4.8/configure --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --target=arm-linux-androideabi --host=x86_64-linux-gnu --build=x86_64-linux-gnu --with-gnu-as --with-gnu-ld --enable-languages=c,c++ --with-gmp=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpfr=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpc=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-cloog=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-isl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-ppl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --disable-ppl-version-check --disable-cloog-version-check --disable-isl-version-check --enable-cloog-backend=isl --with-host-libstdcxx='-static-libgcc -Wl,-Bstatic,-lstdc++,-Bdynamic -lm' --disable-libssp --enable-threads --disable-nls --disable-libmudflap --disable-libgomp --disable-libstdc__-v3 --disable-sjlj-exceptions --disable-shared --disable-tls --disable-libitm --with-float=soft --with-fpu=vfp --with-arch=armv5te --enable-target-optspace --enable-initfini-array --disable-nls --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --with-sysroot=/tmp/ndk-andrewhsieh/build/toolchain/prefix/sysroot --with-binutils-version=2.25 --with-mpfr-version=3.1.1 --with-mpc-version=1.0.1 --with-gmp-version=5.0.5 --with-gcc-version=4.8 --with-gdb-version=7.7 --with-python=/usr/local/google/home/andrewhsieh/mydroid/ndk/prebuilt/linux-x86_64/bin/python-config.sh --with-gxx-include-dir=/tmp/ndk-andrewhsieh/build/toolchain/prefix/include/c++/4.8 --with-bugurl=http://source.android.com/source/report-bugs.html --enable-languages=c,c++ --disable-bootstrap --enable-plugins --enable-libgomp --enable-gnu-indirect-function --disable-libsanitizer --enable-gold --enable-threads --enable-graphite=yes --with-cloog-version=0.18.0 --with-isl-version=0.11.1 --enable-eh-frame-hdr-for-static --with-arch=armv5te --program-transform-name='s&^&arm-linux-androideabi-&' --enable-gold=default
Thread model: posix
gcc version 4.8 (GCC) 
configure:4577: $? = 0
configure:4566: arm-linux-androideabi-gcc -V >&5
arm-linux-androideabi-gcc: error: unrecognized command line option '-V'
arm-linux-androideabi-gcc: fatal error: no input files
compilation terminated.
configure:4577: $? = 1
configure:4566: arm-linux-androideabi-gcc -qversion >&5
arm-linux-androideabi-gcc: error: unrecognized command line option '-qversion'
arm-linux-androideabi-gcc: fatal error: no input files
compilation terminated.
configure:4577: $? = 1
configure:4581: checking whether we are using the GNU C compiler
configure:4609: result: yes
configure:4618: checking whether arm-linux-androideabi-gcc accepts -g
configure:4679: result: yes
configure:4696: checking for arm-linux-androideabi-gcc option to accept ISO C89
configure:4773: result: none needed
configure:4905: checking for C++ compiler version
configure:4914: arm-linux-androideabi-g++ --version >&5
arm-linux-androideabi-g++ (GCC) 4.8
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

configure:4925: $? = 0
configure:4914: arm-linux-androideabi-g++ -v >&5
Using built-in specs.
COLLECT_GCC=arm-linux-androideabi-g++
COLLECT_LTO_WRAPPER=/tmp/toolchain/bin/../libexec/gcc/arm-linux-androideabi/4.8/lto-wrapper
Target: arm-linux-androideabi
Configured with: /s/ndk-toolchain/src/build/../gcc/gcc-4.8/configure --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --target=arm-linux-androideabi --host=x86_64-linux-gnu --build=x86_64-linux-gnu --with-gnu-as --with-gnu-ld --enable-languages=c,c++ --with-gmp=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpfr=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpc=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-cloog=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-isl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-ppl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --disable-ppl-version-check --disable-cloog-version-check --disable-isl-version-check --enable-cloog-backend=isl --with-host-libstdcxx='-static-libgcc -Wl,-Bstatic,-lstdc++,-Bdynamic -lm' --disable-libssp --enable-threads --disable-nls --disable-libmudflap --disable-libgomp --disable-libstdc__-v3 --disable-sjlj-exceptions --disable-shared --disable-tls --disable-libitm --with-float=soft --with-fpu=vfp --with-arch=armv5te --enable-target-optspace --enable-initfini-array --disable-nls --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --with-sysroot=/tmp/ndk-andrewhsieh/build/toolchain/prefix/sysroot --with-binutils-version=2.25 --with-mpfr-version=3.1.1 --with-mpc-version=1.0.1 --with-gmp-version=5.0.5 --with-gcc-version=4.8 --with-gdb-version=7.7 --with-python=/usr/local/google/home/andrewhsieh/mydroid/ndk/prebuilt/linux-x86_64/bin/python-config.sh --with-gxx-include-dir=/tmp/ndk-andrewhsieh/build/toolchain/prefix/include/c++/4.8 --with-bugurl=http://source.android.com/source/report-bugs.html --enable-languages=c,c++ --disable-bootstrap --enable-plugins --enable-libgomp --enable-gnu-indirect-function --disable-libsanitizer --enable-gold --enable-threads --enable-graphite=yes --with-cloog-version=0.18.0 --with-isl-version=0.11.1 --enable-eh-frame-hdr-for-static --with-arch=armv5te --program-transform-name='s&^&arm-linux-androideabi-&' --enable-gold=default
Thread model: posix
gcc version 4.8 (GCC) 
configure:4925: $? = 0
configure:4914: arm-linux-androideabi-g++ -V >&5
arm-linux-androideabi-g++: error: unrecognized command line option '-V'
arm-linux-androideabi-g++: fatal error: no input files
compilation terminated.
configure:4925: $? = 1
configure:4914: arm-linux-androideabi-g++ -qversion >&5
arm-linux-androideabi-g++: error: unrecognized command line option '-qversion'
arm-linux-androideabi-g++: fatal error: no input files
compilation terminated.
configure:4925: $? = 1
configure:4929: checking whether we are using the GNU C++ compiler
configure:4948: arm-linux-androideabi-g++ -c   conftest.cpp >&5
configure:4948: $? = 0
configure:4957: result: yes
configure:4966: checking whether arm-linux-androideabi-g++ accepts -g
configure:4986: arm-linux-androideabi-g++ -c -g  conftest.cpp >&5
configure:4986: $? = 0
configure:5027: result: yes
configure:5052: checking dependency style of arm-linux-androideabi-g++
configure:5162: result: gcc3
configure:5182: checking how to run the C preprocessor
configure:5213: arm-linux-androideabi-gcc -E  conftest.c
configure:5213: $? = 0
configure:5227: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:11:28: fatal error: ac_nonexistent.h: No such file or directory
 #include <ac_nonexistent.h>
                            ^
compilation terminated.
configure:5227: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "ld"
| #define PACKAGE_TARNAME "ld"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "ld 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "ld"
| #define VERSION "2.25.1"
| /* end confdefs.h.  */
| #include <ac_nonexistent.h>
configure:5252: result: arm-linux-androideabi-gcc -E
configure:5272: arm-linux-androideabi-gcc -E  conftest.c
configure:5272: $? = 0
configure:5286: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:11:28: fatal error: ac_nonexistent.h: No such file or directory
 #include <ac_nonexistent.h>
                            ^
compilation terminated.
configure:5286: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "ld"
| #define PACKAGE_TARNAME "ld"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "ld 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "ld"
| #define VERSION "2.25.1"
| /* end confdefs.h.  */
| #include <ac_nonexistent.h>
configure:5315: checking for grep that handles long lines and -e
configure:5373: result: /usr/sbin/grep
configure:5378: checking for egrep
configure:5440: result: /usr/sbin/grep -E
configure:5445: checking for ANSI C header files
configure:5465: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5465: $? = 0
configure:5549: result: yes
configure:5562: checking for sys/types.h
configure:5562: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5562: $? = 0
configure:5562: result: yes
configure:5562: checking for sys/stat.h
configure:5562: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5562: $? = 0
configure:5562: result: yes
configure:5562: checking for stdlib.h
configure:5562: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5562: $? = 0
configure:5562: result: yes
configure:5562: checking for string.h
configure:5562: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5562: $? = 0
configure:5562: result: yes
configure:5562: checking for memory.h
configure:5562: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5562: $? = 0
configure:5562: result: yes
configure:5562: checking for strings.h
configure:5562: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5562: $? = 0
configure:5562: result: yes
configure:5562: checking for inttypes.h
configure:5562: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5562: $? = 0
configure:5562: result: yes
configure:5562: checking for stdint.h
configure:5562: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5562: $? = 0
configure:5562: result: yes
configure:5562: checking for unistd.h
configure:5562: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5562: $? = 0
configure:5562: result: yes
configure:5576: checking minix/config.h usability
configure:5576: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:54:26: fatal error: minix/config.h: No such file or directory
 #include <minix/config.h>
                          ^
compilation terminated.
configure:5576: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "ld"
| #define PACKAGE_TARNAME "ld"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "ld 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "ld"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <minix/config.h>
configure:5576: result: no
configure:5576: checking minix/config.h presence
configure:5576: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:21:26: fatal error: minix/config.h: No such file or directory
 #include <minix/config.h>
                          ^
compilation terminated.
configure:5576: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "ld"
| #define PACKAGE_TARNAME "ld"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "ld 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "ld"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| /* end confdefs.h.  */
| #include <minix/config.h>
configure:5576: result: no
configure:5576: checking for minix/config.h
configure:5576: result: no
configure:5597: checking whether it is safe to define __EXTENSIONS__
configure:5615: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5615: $? = 0
configure:5622: result: yes
configure:5686: checking how to print strings
configure:5713: result: printf
configure:5734: checking for a sed that does not truncate output
configure:5798: result: /usr/sbin/sed
configure:5816: checking for fgrep
configure:5878: result: /usr/sbin/grep -F
configure:5913: checking for ld used by arm-linux-androideabi-gcc
configure:5980: result: /tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld
configure:5987: checking if the linker (/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld) is GNU ld
configure:6002: result: yes
configure:6014: checking for BSD- or MS-compatible name lister (nm)
configure:6063: result: nm
configure:6193: checking the name lister (nm) interface
configure:6200: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:6203: nm "conftest.o"
configure:6206: output
00000000 b $d
00000000 B some_variable
configure:6213: result: BSD nm
configure:6216: checking whether ln -s works
configure:6220: result: yes
configure:6228: checking the maximum length of command line arguments
configure:6353: result: 1572864
configure:6370: checking whether the shell understands some XSI constructs
configure:6380: result: yes
configure:6384: checking whether the shell understands "+="
configure:6390: result: yes
configure:6425: checking for /tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld option to reload object files
configure:6432: result: -r
configure:6461: checking for x86_64-unknown-linux-objdump
configure:6488: result: objdump
configure:6560: checking how to recognize dependent libraries
configure:6761: result: pass_all
configure:6781: checking for x86_64-unknown-linux-ar
configure:6808: result: ar
configure:6886: checking for x86_64-unknown-linux-strip
configure:6913: result: strip
configure:6985: checking for x86_64-unknown-linux-ranlib
configure:7012: result: ranlib
configure:7154: checking command to parse nm output from arm-linux-androideabi-gcc object
configure:7272: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:7275: $? = 0
configure:7279: nm conftest.o \| sed -n -e 's/^.*[ ]\([ABCDGIRSTW][ABCDGIRSTW]*\)[ ][ ]*\([_A-Za-z][_A-Za-z0-9]*\)$/\1 \2 \2/p' \> conftest.nm
configure:7282: $? = 0
configure:7336: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c conftstm.o >&5
configure:7339: $? = 0
configure:7377: result: ok
configure:7472: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:7475: $? = 0
configure:8225: checking for dlfcn.h
configure:8225: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:8225: $? = 0
configure:8225: result: yes
configure:8413: checking for objdir
configure:8428: result: .libs
configure:8699: checking if arm-linux-androideabi-gcc supports -fno-rtti -fno-exceptions
configure:8717: arm-linux-androideabi-gcc -c   -fno-rtti -fno-exceptions conftest.c >&5
cc1: warning: command line option '-fno-rtti' is valid for C++/ObjC++ but not for C [enabled by default]
configure:8721: $? = 0
configure:8734: result: no
configure:8754: checking for arm-linux-androideabi-gcc option to produce PIC
configure:9040: result: -fPIC -DPIC
configure:9052: checking if arm-linux-androideabi-gcc PIC flag -fPIC -DPIC works
configure:9070: arm-linux-androideabi-gcc -c   -fPIC -DPIC -DPIC conftest.c >&5
configure:9074: $? = 0
configure:9087: result: yes
configure:9111: checking if arm-linux-androideabi-gcc static flag -static works
configure:9139: result: yes
configure:9154: checking if arm-linux-androideabi-gcc supports -c -o file.o
configure:9175: arm-linux-androideabi-gcc -c   -o out/conftest2.o conftest.c >&5
configure:9179: $? = 0
configure:9201: result: yes
configure:9209: checking if arm-linux-androideabi-gcc supports -c -o file.o
configure:9256: result: yes
configure:9289: checking whether the arm-linux-androideabi-gcc linker (/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld -m elf_i386) supports shared libraries
configure:10360: result: yes
configure:10397: checking whether -lc should be explicitly linked in
configure:10405: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:10408: $? = 0
configure:10423: arm-linux-androideabi-gcc -shared conftest.o  -v -Wl,-soname -Wl,conftest -o conftest 2\>\&1 \| /usr/sbin/grep  -lc  \>/dev/null 2\>\&1
configure:10426: $? = 0
configure:10440: result: no
configure:10605: checking dynamic linker characteristics
configure:11056: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  -Wl,-rpath -Wl,/foo conftest.c  >&5
configure:11056: $? = 0
configure:11278: result: GNU/Linux ld.so
configure:11385: checking how to hardcode library paths into programs
configure:11410: result: immediate
configure:11950: checking whether stripping libraries is possible
configure:11955: result: yes
configure:11990: checking if libtool supports shared libraries
configure:11992: result: yes
configure:11995: checking whether to build shared libraries
configure:12016: result: yes
configure:12019: checking whether to build static libraries
configure:12023: result: yes
configure:12046: checking how to run the C++ preprocessor
configure:12073: arm-linux-androideabi-g++ -E  conftest.cpp
configure:12073: $? = 0
configure:12087: arm-linux-androideabi-g++ -E  conftest.cpp
conftest.cpp:28:28: fatal error: ac_nonexistent.h: No such file or directory
 #include <ac_nonexistent.h>
                            ^
compilation terminated.
configure:12087: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "ld"
| #define PACKAGE_TARNAME "ld"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "ld 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "ld"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| /* end confdefs.h.  */
| #include <ac_nonexistent.h>
configure:12112: result: arm-linux-androideabi-g++ -E
configure:12132: arm-linux-androideabi-g++ -E  conftest.cpp
configure:12132: $? = 0
configure:12146: arm-linux-androideabi-g++ -E  conftest.cpp
conftest.cpp:28:28: fatal error: ac_nonexistent.h: No such file or directory
 #include <ac_nonexistent.h>
                            ^
compilation terminated.
configure:12146: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "ld"
| #define PACKAGE_TARNAME "ld"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "ld 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "ld"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| /* end confdefs.h.  */
| #include <ac_nonexistent.h>
configure:12314: checking for ld used by arm-linux-androideabi-g++
configure:12381: result: /tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld -m elf_i386
configure:12388: checking if the linker (/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld -m elf_i386) is GNU ld
configure:12403: result: yes
configure:12458: checking whether the arm-linux-androideabi-g++ linker (/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld -m elf_i386) supports shared libraries
configure:13390: result: yes
configure:13418: arm-linux-androideabi-g++ -c   conftest.cpp >&5
configure:13421: $? = 0
configure:13603: checking for arm-linux-androideabi-g++ option to produce PIC
configure:13926: result: -fPIC -DPIC
configure:13935: checking if arm-linux-androideabi-g++ PIC flag -fPIC -DPIC works
configure:13953: arm-linux-androideabi-g++ -c   -fPIC -DPIC -DPIC conftest.cpp >&5
configure:13957: $? = 0
configure:13970: result: yes
configure:13991: checking if arm-linux-androideabi-g++ static flag -static works
configure:14019: result: yes
configure:14031: checking if arm-linux-androideabi-g++ supports -c -o file.o
configure:14052: arm-linux-androideabi-g++ -c   -o out/conftest2.o conftest.cpp >&5
configure:14056: $? = 0
configure:14078: result: yes
configure:14083: checking if arm-linux-androideabi-g++ supports -c -o file.o
configure:14130: result: yes
configure:14160: checking whether the arm-linux-androideabi-g++ linker (/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld -m elf_i386) supports shared libraries
configure:14188: result: yes
configure:14331: checking dynamic linker characteristics
configure:14938: result: GNU/Linux ld.so
configure:14991: checking how to hardcode library paths into programs
configure:15016: result: immediate
configure:15087: checking for dlfcn.h
configure:15087: result: yes
configure:15100: checking for windows.h
configure:15100: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:63:21: fatal error: windows.h: No such file or directory
 #include <windows.h>
                     ^
compilation terminated.
configure:15100: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "ld"
| #define PACKAGE_TARNAME "ld"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "ld 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "ld"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| 
| #include <windows.h>
configure:15100: result: no
configure:15127: checking for library containing dlopen
configure:15158: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:15158: $? = 0
configure:15175: result: none required
configure:15206: checking for special C compiler options needed for large files
configure:15251: result: no
configure:15257: checking for _FILE_OFFSET_BITS value needed for large files
configure:15282: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:35:3: warning: left shift count >= width of type [enabled by default]
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
   ^
conftest.c:35:3: warning: left shift count >= width of type [enabled by default]
conftest.c:36:10: warning: left shift count >= width of type [enabled by default]
          && LARGE_OFF_T % 2147483647 == 1)
          ^
conftest.c:36:10: warning: left shift count >= width of type [enabled by default]
conftest.c:35:7: error: variably modified 'off_t_is_large' at file scope
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
       ^
configure:15282: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "ld"
| #define PACKAGE_TARNAME "ld"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "ld 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "ld"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| /* end confdefs.h.  */
| #include <sys/types.h>
|  /* Check that off_t can represent 2**63 - 1 correctly.
|     We can't simply define LARGE_OFF_T to be 9223372036854775807,
|     since some C++ compilers masquerading as C compilers
|     incorrectly reject 9223372036854775807.  */
| #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
|   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
| 		       && LARGE_OFF_T % 2147483647 == 1)
| 		      ? 1 : -1];
| int
| main ()
| {
| 
|   ;
|   return 0;
| }
configure:15306: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:36:3: warning: left shift count >= width of type [enabled by default]
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
   ^
conftest.c:36:3: warning: left shift count >= width of type [enabled by default]
conftest.c:37:10: warning: left shift count >= width of type [enabled by default]
          && LARGE_OFF_T % 2147483647 == 1)
          ^
conftest.c:37:10: warning: left shift count >= width of type [enabled by default]
conftest.c:36:7: error: variably modified 'off_t_is_large' at file scope
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
       ^
configure:15306: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "ld"
| #define PACKAGE_TARNAME "ld"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "ld 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "ld"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| /* end confdefs.h.  */
| #define _FILE_OFFSET_BITS 64
| #include <sys/types.h>
|  /* Check that off_t can represent 2**63 - 1 correctly.
|     We can't simply define LARGE_OFF_T to be 9223372036854775807,
|     since some C++ compilers masquerading as C compilers
|     incorrectly reject 9223372036854775807.  */
| #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
|   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
| 		       && LARGE_OFF_T % 2147483647 == 1)
| 		      ? 1 : -1];
| int
| main ()
| {
| 
|   ;
|   return 0;
| }
configure:15314: result: unknown
configure:15326: checking for _LARGE_FILES value needed for large files
configure:15351: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:35:3: warning: left shift count >= width of type [enabled by default]
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
   ^
conftest.c:35:3: warning: left shift count >= width of type [enabled by default]
conftest.c:36:10: warning: left shift count >= width of type [enabled by default]
          && LARGE_OFF_T % 2147483647 == 1)
          ^
conftest.c:36:10: warning: left shift count >= width of type [enabled by default]
conftest.c:35:7: error: variably modified 'off_t_is_large' at file scope
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
       ^
configure:15351: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "ld"
| #define PACKAGE_TARNAME "ld"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "ld 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "ld"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| /* end confdefs.h.  */
| #include <sys/types.h>
|  /* Check that off_t can represent 2**63 - 1 correctly.
|     We can't simply define LARGE_OFF_T to be 9223372036854775807,
|     since some C++ compilers masquerading as C compilers
|     incorrectly reject 9223372036854775807.  */
| #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
|   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
| 		       && LARGE_OFF_T % 2147483647 == 1)
| 		      ? 1 : -1];
| int
| main ()
| {
| 
|   ;
|   return 0;
| }
configure:15375: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:36:3: warning: left shift count >= width of type [enabled by default]
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
   ^
conftest.c:36:3: warning: left shift count >= width of type [enabled by default]
conftest.c:37:10: warning: left shift count >= width of type [enabled by default]
          && LARGE_OFF_T % 2147483647 == 1)
          ^
conftest.c:37:10: warning: left shift count >= width of type [enabled by default]
conftest.c:36:7: error: variably modified 'off_t_is_large' at file scope
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
       ^
configure:15375: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "ld"
| #define PACKAGE_TARNAME "ld"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "ld 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "ld"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| /* end confdefs.h.  */
| #define _LARGE_FILES 1
| #include <sys/types.h>
|  /* Check that off_t can represent 2**63 - 1 correctly.
|     We can't simply define LARGE_OFF_T to be 9223372036854775807,
|     since some C++ compilers masquerading as C compilers
|     incorrectly reject 9223372036854775807.  */
| #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
|   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
| 		       && LARGE_OFF_T % 2147483647 == 1)
| 		      ? 1 : -1];
| int
| main ()
| {
| 
|   ;
|   return 0;
| }
configure:15383: result: unknown
configure:15601: checking for LC_MESSAGES
configure:15617: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:15617: $? = 0
configure:15625: result: yes
configure:15663: checking whether NLS is requested
configure:15666: result: no
configure:15734: checking whether NLS is requested
configure:15743: result: no
configure:15781: checking for msgfmt
configure:15812: result: /usr/sbin/msgfmt
configure:15821: checking for gmsgfmt
configure:15852: result: /usr/sbin/msgfmt
configure:15892: checking for xgettext
configure:15923: result: /usr/sbin/xgettext
configure:15963: checking for msgmerge
configure:15993: result: /usr/sbin/msgmerge
configure:16035: checking for bison
configure:16062: result: bison -y
configure:16078: checking for flex
configure:16105: result: flex
configure:16142: flex conftest.l
configure:16146: $? = 0
configure:16148: checking lex output file root
configure:16162: result: lex.yy
configure:16167: checking lex library
configure:16181: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c   >&5
/tmp/ccOoLBSH.o:conftest.c:function yylex: error: undefined reference to 'yywrap'
/tmp/ccOoLBSH.o:conftest.c:function input: error: undefined reference to 'yywrap'
/tmp/ccOoLBSH.o:conftest.c:function main: error: undefined reference to 'yywrap'
collect2: error: ld returned 1 exit status
configure:16181: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "ld"
| #define PACKAGE_TARNAME "ld"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "ld 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "ld"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define GOT_HANDLING_DEFAULT GOT_HANDLING_TARGET_DEFAULT
| #define HAVE_LC_MESSAGES 1
| /* end confdefs.h.  */
| 
| #line 3 "lex.yy.c"
| 
| #define  YY_INT_ALIGNED short int
| 
| /* A lexical scanner generated by flex */
| 
| #define FLEX_SCANNER
| #define YY_FLEX_MAJOR_VERSION 2
| #define YY_FLEX_MINOR_VERSION 5
| #define YY_FLEX_SUBMINOR_VERSION 39
| #if YY_FLEX_SUBMINOR_VERSION > 0
| #define FLEX_BETA
| #endif
| 
| /* First, we deal with  platform-specific or compiler-specific issues. */
| 
| /* begin standard C headers. */
| #include <stdio.h>
| #include <string.h>
| #include <errno.h>
| #include <stdlib.h>
| 
| /* end standard C headers. */
| 
| /* flex integer type definitions */
| 
| #ifndef FLEXINT_H
| #define FLEXINT_H
| 
| /* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
| 
| #if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
| 
| /* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
|  * if you want the limit (max/min) macros for int types. 
|  */
| #ifndef __STDC_LIMIT_MACROS
| #define __STDC_LIMIT_MACROS 1
| #endif
| 
| #include <inttypes.h>
| typedef int8_t flex_int8_t;
| typedef uint8_t flex_uint8_t;
| typedef int16_t flex_int16_t;
| typedef uint16_t flex_uint16_t;
| typedef int32_t flex_int32_t;
| typedef uint32_t flex_uint32_t;
| #else
| typedef signed char flex_int8_t;
| typedef short int flex_int16_t;
| typedef int flex_int32_t;
| typedef unsigned char flex_uint8_t; 
| typedef unsigned short int flex_uint16_t;
| typedef unsigned int flex_uint32_t;
| 
| /* Limits of integral types. */
| #ifndef INT8_MIN
| #define INT8_MIN               (-128)
| #endif
| #ifndef INT16_MIN
| #define INT16_MIN              (-32767-1)
| #endif
| #ifndef INT32_MIN
| #define INT32_MIN              (-2147483647-1)
| #endif
| #ifndef INT8_MAX
| #define INT8_MAX               (127)
| #endif
| #ifndef INT16_MAX
| #define INT16_MAX              (32767)
| #endif
| #ifndef INT32_MAX
| #define INT32_MAX              (2147483647)
| #endif
| #ifndef UINT8_MAX
| #define UINT8_MAX              (255U)
| #endif
| #ifndef UINT16_MAX
| #define UINT16_MAX             (65535U)
| #endif
| #ifndef UINT32_MAX
| #define UINT32_MAX             (4294967295U)
| #endif
| 
| #endif /* ! C99 */
| 
| #endif /* ! FLEXINT_H */
| 
| #ifdef __cplusplus
| 
| /* The "const" storage-class-modifier is valid. */
| #define YY_USE_CONST
| 
| #else	/* ! __cplusplus */
| 
| /* C99 requires __STDC__ to be defined as 1. */
| #if defined (__STDC__)
| 
| #define YY_USE_CONST
| 
| #endif	/* defined (__STDC__) */
| #endif	/* ! __cplusplus */
| 
| #ifdef YY_USE_CONST
| #define yyconst const
| #else
| #define yyconst
| #endif
| 
| /* Returned upon end-of-file. */
| #define YY_NULL 0
| 
| /* Promotes a possibly negative, possibly signed char to an unsigned
|  * integer for use as an array index.  If the signed char is negative,
|  * we want to instead treat it as an 8-bit unsigned char, hence the
|  * double cast.
|  */
| #define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
| 
| /* Enter a start condition.  This macro really ought to take a parameter,
|  * but we do it the disgusting crufty way forced on us by the ()-less
|  * definition of BEGIN.
|  */
| #define BEGIN (yy_start) = 1 + 2 *
| 
| /* Translate the current start state into a value that can be later handed
|  * to BEGIN to return to the state.  The YYSTATE alias is for lex
|  * compatibility.
|  */
| #define YY_START (((yy_start) - 1) / 2)
| #define YYSTATE YY_START
| 
| /* Action number for EOF rule of a given start state. */
| #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
| 
| /* Special action meaning "start processing a new file". */
| #define YY_NEW_FILE yyrestart(yyin  )
| 
| #define YY_END_OF_BUFFER_CHAR 0
| 
| /* Size of default input buffer. */
| #ifndef YY_BUF_SIZE
| #define YY_BUF_SIZE 16384
| #endif
| 
| /* The state buf must be large enough to hold one state per character in the main buffer.
|  */
| #define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
| 
| #ifndef YY_TYPEDEF_YY_BUFFER_STATE
| #define YY_TYPEDEF_YY_BUFFER_STATE
| typedef struct yy_buffer_state *YY_BUFFER_STATE;
| #endif
| 
| #ifndef YY_TYPEDEF_YY_SIZE_T
| #define YY_TYPEDEF_YY_SIZE_T
| typedef size_t yy_size_t;
| #endif
| 
| extern yy_size_t yyleng;
| 
| extern FILE *yyin, *yyout;
| 
| #define EOB_ACT_CONTINUE_SCAN 0
| #define EOB_ACT_END_OF_FILE 1
| #define EOB_ACT_LAST_MATCH 2
| 
|     #define YY_LESS_LINENO(n)
|     #define YY_LINENO_REWIND_TO(ptr)
|     
| /* Return all but the first "n" matched characters back to the input stream. */
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
|         int yyless_macro_arg = (n); \
|         YY_LESS_LINENO(yyless_macro_arg);\
| 		*yy_cp = (yy_hold_char); \
| 		YY_RESTORE_YY_MORE_OFFSET \
| 		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
| 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
| 		} \
| 	while ( 0 )
| 
| #define unput(c) yyunput( c, (yytext_ptr)  )
| 
| #ifndef YY_STRUCT_YY_BUFFER_STATE
| #define YY_STRUCT_YY_BUFFER_STATE
| struct yy_buffer_state
| 	{
| 	FILE *yy_input_file;
| 
| 	char *yy_ch_buf;		/* input buffer */
| 	char *yy_buf_pos;		/* current position in input buffer */
| 
| 	/* Size of input buffer in bytes, not including room for EOB
| 	 * characters.
| 	 */
| 	yy_size_t yy_buf_size;
| 
| 	/* Number of characters read into yy_ch_buf, not including EOB
| 	 * characters.
| 	 */
| 	yy_size_t yy_n_chars;
| 
| 	/* Whether we "own" the buffer - i.e., we know we created it,
| 	 * and can realloc() it to grow it, and should free() it to
| 	 * delete it.
| 	 */
| 	int yy_is_our_buffer;
| 
| 	/* Whether this is an "interactive" input source; if so, and
| 	 * if we're using stdio for input, then we want to use getc()
| 	 * instead of fread(), to make sure we stop fetching input after
| 	 * each newline.
| 	 */
| 	int yy_is_interactive;
| 
| 	/* Whether we're considered to be at the beginning of a line.
| 	 * If so, '^' rules will be active on the next match, otherwise
| 	 * not.
| 	 */
| 	int yy_at_bol;
| 
|     int yy_bs_lineno; /**< The line count. */
|     int yy_bs_column; /**< The column count. */
|     
| 	/* Whether to try to fill the input buffer when we reach the
| 	 * end of it.
| 	 */
| 	int yy_fill_buffer;
| 
| 	int yy_buffer_status;
| 
| #define YY_BUFFER_NEW 0
| #define YY_BUFFER_NORMAL 1
| 	/* When an EOF's been seen but there's still some text to process
| 	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
| 	 * shouldn't try reading from the input source any more.  We might
| 	 * still have a bunch of tokens to match, though, because of
| 	 * possible backing-up.
| 	 *
| 	 * When we actually see the EOF, we change the status to "new"
| 	 * (via yyrestart()), so that the user can continue scanning by
| 	 * just pointing yyin at a new input file.
| 	 */
| #define YY_BUFFER_EOF_PENDING 2
| 
| 	};
| #endif /* !YY_STRUCT_YY_BUFFER_STATE */
| 
| /* Stack of input buffers. */
| static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
| static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
| static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
| 
| /* We provide macros for accessing buffer states in case in the
|  * future we want to put the buffer states in a more general
|  * "scanner state".
|  *
|  * Returns the top of the stack, or NULL.
|  */
| #define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
|                           ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
|                           : NULL)
| 
| /* Same as previous macro, but useful when we know that the buffer stack is not
|  * NULL or when we need an lvalue. For internal use only.
|  */
| #define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
| 
| /* yy_hold_char holds the character lost when yytext is formed. */
| static char yy_hold_char;
| static yy_size_t yy_n_chars;		/* number of characters read into yy_ch_buf */
| yy_size_t yyleng;
| 
| /* Points to current character in buffer. */
| static char *yy_c_buf_p = (char *) 0;
| static int yy_init = 0;		/* whether we need to initialize */
| static int yy_start = 0;	/* start state number */
| 
| /* Flag which is used to allow yywrap()'s to do buffer switches
|  * instead of setting up a fresh yyin.  A bit of a hack ...
|  */
| static int yy_did_buffer_switch_on_eof;
| 
| void yyrestart (FILE *input_file  );
| void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
| YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
| void yy_delete_buffer (YY_BUFFER_STATE b  );
| void yy_flush_buffer (YY_BUFFER_STATE b  );
| void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
| void yypop_buffer_state (void );
| 
| static void yyensure_buffer_stack (void );
| static void yy_load_buffer_state (void );
| static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
| 
| #define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
| 
| YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
| YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
| YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,yy_size_t len  );
| 
| void *yyalloc (yy_size_t  );
| void *yyrealloc (void *,yy_size_t  );
| void yyfree (void *  );
| 
| #define yy_new_buffer yy_create_buffer
| 
| #define yy_set_interactive(is_interactive) \
| 	{ \
| 	if ( ! YY_CURRENT_BUFFER ){ \
|         yyensure_buffer_stack (); \
| 		YY_CURRENT_BUFFER_LVALUE =    \
|             yy_create_buffer(yyin,YY_BUF_SIZE ); \
| 	} \
| 	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
| 	}
| 
| #define yy_set_bol(at_bol) \
| 	{ \
| 	if ( ! YY_CURRENT_BUFFER ){\
|         yyensure_buffer_stack (); \
| 		YY_CURRENT_BUFFER_LVALUE =    \
|             yy_create_buffer(yyin,YY_BUF_SIZE ); \
| 	} \
| 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
| 	}
| 
| #define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
| 
| /* Begin user sect3 */
| 
| typedef unsigned char YY_CHAR;
| 
| FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
| 
| typedef int yy_state_type;
| 
| extern int yylineno;
| 
| int yylineno = 1;
| 
| extern char *yytext;
| #define yytext_ptr yytext
| 
| static yy_state_type yy_get_previous_state (void );
| static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
| static int yy_get_next_buffer (void );
| static void yy_fatal_error (yyconst char msg[]  );
| 
| /* Done after the current pattern has been matched and before the
|  * corresponding action - sets up yytext.
|  */
| #define YY_DO_BEFORE_ACTION \
| 	(yytext_ptr) = yy_bp; \
| 	(yytext_ptr) -= (yy_more_len); \
| 	yyleng = (size_t) (yy_cp - (yytext_ptr)); \
| 	(yy_hold_char) = *yy_cp; \
| 	*yy_cp = '\0'; \
| 	(yy_c_buf_p) = yy_cp;
| 
| #define YY_NUM_RULES 8
| #define YY_END_OF_BUFFER 9
| /* This struct is not used in this scanner,
|    but its presence is necessary. */
| struct yy_trans_info
| 	{
| 	flex_int32_t yy_verify;
| 	flex_int32_t yy_nxt;
| 	};
| static yyconst flex_int16_t yy_acclist[23] =
|     {   0,
|         9,    7,    8,    8,    1,    7,    8,    2,    7,    8,
|         3,    7,    8,    4,    7,    8,    5,    7,    8,    6,
|         7,    8
|     } ;
| 
| static yyconst flex_int16_t yy_accept[14] =
|     {   0,
|         1,    1,    1,    2,    4,    5,    8,   11,   14,   17,
|        20,   23,   23
|     } ;
| 
| static yyconst flex_int32_t yy_ec[256] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    3,    4,    5,    6,
| 
|         7,    8,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| 
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1
|     } ;
| 
| static yyconst flex_int32_t yy_meta[9] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1
|     } ;
| 
| static yyconst flex_int16_t yy_base[13] =
|     {   0,
|         0,    0,    9,   10,   10,   10,   10,   10,   10,   10,
|        10,   10
|     } ;
| 
| static yyconst flex_int16_t yy_def[13] =
|     {   0,
|        12,    1,   12,   12,   12,   12,   12,   12,   12,   12,
|        12,    0
|     } ;
| 
| static yyconst flex_int16_t yy_nxt[19] =
|     {   0,
|         4,    5,    6,    7,    8,    9,   10,   11,   12,    3,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| static yyconst flex_int16_t yy_chk[19] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    3,   12,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| extern int yy_flex_debug;
| int yy_flex_debug = 0;
| 
| static yy_state_type *yy_state_buf=0, *yy_state_ptr=0;
| static char *yy_full_match;
| static int yy_lp;
| #define REJECT \
| { \
| *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */ \
| yy_cp = (yy_full_match); /* restore poss. backed-over text */ \
| ++(yy_lp); \
| goto find_rule; \
| }
| 
| static int yy_more_flag = 0;
| static int yy_more_len = 0;
| #define yymore() ((yy_more_flag) = 1)
| #define YY_MORE_ADJ (yy_more_len)
| #define YY_RESTORE_YY_MORE_OFFSET
| char *yytext;
| #line 1 "conftest.l"
| #line 470 "lex.yy.c"
| 
| #define INITIAL 0
| 
| #ifndef YY_NO_UNISTD_H
| /* Special case for "unistd.h", since it is non-ANSI. We include it way
|  * down here because we want the user's section 1 to have been scanned first.
|  * The user has a chance to override it with an option.
|  */
| #include <unistd.h>
| #endif
| 
| #ifndef YY_EXTRA_TYPE
| #define YY_EXTRA_TYPE void *
| #endif
| 
| static int yy_init_globals (void );
| 
| /* Accessor methods to globals.
|    These are made visible to non-reentrant scanners for convenience. */
| 
| int yylex_destroy (void );
| 
| int yyget_debug (void );
| 
| void yyset_debug (int debug_flag  );
| 
| YY_EXTRA_TYPE yyget_extra (void );
| 
| void yyset_extra (YY_EXTRA_TYPE user_defined  );
| 
| FILE *yyget_in (void );
| 
| void yyset_in  (FILE * in_str  );
| 
| FILE *yyget_out (void );
| 
| void yyset_out  (FILE * out_str  );
| 
| yy_size_t yyget_leng (void );
| 
| char *yyget_text (void );
| 
| int yyget_lineno (void );
| 
| void yyset_lineno (int line_number  );
| 
| /* Macros after this point can all be overridden by user definitions in
|  * section 1.
|  */
| 
| #ifndef YY_SKIP_YYWRAP
| #ifdef __cplusplus
| extern "C" int yywrap (void );
| #else
| extern int yywrap (void );
| #endif
| #endif
| 
|     static void yyunput (int c,char *buf_ptr  );
|     
| #ifndef yytext_ptr
| static void yy_flex_strncpy (char *,yyconst char *,int );
| #endif
| 
| #ifdef YY_NEED_STRLEN
| static int yy_flex_strlen (yyconst char * );
| #endif
| 
| #ifndef YY_NO_INPUT
| 
| #ifdef __cplusplus
| static int yyinput (void );
| #else
| static int input (void );
| #endif
| 
| #endif
| 
| /* Amount of stuff to slurp up with each read. */
| #ifndef YY_READ_BUF_SIZE
| #define YY_READ_BUF_SIZE 8192
| #endif
| 
| /* Copy whatever the last rule matched to the standard output. */
| #ifndef ECHO
| /* This used to be an fputs(), but since the string might contain NUL's,
|  * we now use fwrite().
|  */
| #define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
| #endif
| 
| /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
|  * is returned in "result".
|  */
| #ifndef YY_INPUT
| #define YY_INPUT(buf,result,max_size) \
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
| 		{ \
| 		int c = '*'; \
| 		size_t n; \
| 		for ( n = 0; n < max_size && \
| 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
| 			buf[n] = (char) c; \
| 		if ( c == '\n' ) \
| 			buf[n++] = (char) c; \
| 		if ( c == EOF && ferror( yyin ) ) \
| 			YY_FATAL_ERROR( "input in flex scanner failed" ); \
| 		result = n; \
| 		} \
| 	else \
| 		{ \
| 		errno=0; \
| 		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
| 			{ \
| 			if( errno != EINTR) \
| 				{ \
| 				YY_FATAL_ERROR( "input in flex scanner failed" ); \
| 				break; \
| 				} \
| 			errno=0; \
| 			clearerr(yyin); \
| 			} \
| 		}\
| \
| 
| #endif
| 
| /* No semi-colon after return; correct usage is to write "yyterminate();" -
|  * we don't want an extra ';' after the "return" because that will cause
|  * some compilers to complain about unreachable statements.
|  */
| #ifndef yyterminate
| #define yyterminate() return YY_NULL
| #endif
| 
| /* Number of entries by which start-condition stack grows. */
| #ifndef YY_START_STACK_INCR
| #define YY_START_STACK_INCR 25
| #endif
| 
| /* Report a fatal error. */
| #ifndef YY_FATAL_ERROR
| #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
| #endif
| 
| /* end tables serialization structures and prototypes */
| 
| /* Default declaration of generated scanner - a define so the user can
|  * easily add parameters.
|  */
| #ifndef YY_DECL
| #define YY_DECL_IS_OURS 1
| 
| extern int yylex (void);
| 
| #define YY_DECL int yylex (void)
| #endif /* !YY_DECL */
| 
| /* Code executed at the beginning of each rule, after yytext and yyleng
|  * have been set up.
|  */
| #ifndef YY_USER_ACTION
| #define YY_USER_ACTION
| #endif
| 
| /* Code executed at the end of each rule. */
| #ifndef YY_BREAK
| #define YY_BREAK break;
| #endif
| 
| #define YY_RULE_SETUP \
| 	YY_USER_ACTION
| 
| /** The main scanner function which does all the work.
|  */
| YY_DECL
| {
| 	register yy_state_type yy_current_state;
| 	register char *yy_cp, *yy_bp;
| 	register int yy_act;
|     
| 	if ( !(yy_init) )
| 		{
| 		(yy_init) = 1;
| 
| #ifdef YY_USER_INIT
| 		YY_USER_INIT;
| #endif
| 
|         /* Create the reject buffer large enough to save one state per allowed character. */
|         if ( ! (yy_state_buf) )
|             (yy_state_buf) = (yy_state_type *)yyalloc(YY_STATE_BUF_SIZE  );
|             if ( ! (yy_state_buf) )
|                 YY_FATAL_ERROR( "out of dynamic memory in yylex()" );
| 
| 		if ( ! (yy_start) )
| 			(yy_start) = 1;	/* first start state */
| 
| 		if ( ! yyin )
| 			yyin = stdin;
| 
| 		if ( ! yyout )
| 			yyout = stdout;
| 
| 		if ( ! YY_CURRENT_BUFFER ) {
| 			yyensure_buffer_stack ();
| 			YY_CURRENT_BUFFER_LVALUE =
| 				yy_create_buffer(yyin,YY_BUF_SIZE );
| 		}
| 
| 		yy_load_buffer_state( );
| 		}
| 
| 	{
| #line 1 "conftest.l"
| 
| #line 687 "lex.yy.c"
| 
| 	while ( 1 )		/* loops until end-of-file is reached */
| 		{
| 		(yy_more_len) = 0;
| 		if ( (yy_more_flag) )
| 			{
| 			(yy_more_len) = (yy_c_buf_p) - (yytext_ptr);
| 			(yy_more_flag) = 0;
| 			}
| 		yy_cp = (yy_c_buf_p);
| 
| 		/* Support of yytext. */
| 		*yy_cp = (yy_hold_char);
| 
| 		/* yy_bp points to the position in yy_ch_buf of the start of
| 		 * the current run.
| 		 */
| 		yy_bp = yy_cp;
| 
| 		yy_current_state = (yy_start);
| 
| 		(yy_state_ptr) = (yy_state_buf);
| 		*(yy_state_ptr)++ = yy_current_state;
| 
| yy_match:
| 		do
| 			{
| 			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
| 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 				{
| 				yy_current_state = (int) yy_def[yy_current_state];
| 				if ( yy_current_state >= 13 )
| 					yy_c = yy_meta[(unsigned int) yy_c];
| 				}
| 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 			*(yy_state_ptr)++ = yy_current_state;
| 			++yy_cp;
| 			}
| 		while ( yy_base[yy_current_state] != 10 );
| 
| yy_find_action:
| 		yy_current_state = *--(yy_state_ptr);
| 		(yy_lp) = yy_accept[yy_current_state];
| find_rule: /* we branch to this label when backing up */
| 		for ( ; ; ) /* until we find what rule we matched */
| 			{
| 			if ( (yy_lp) && (yy_lp) < yy_accept[yy_current_state + 1] )
| 				{
| 				yy_act = yy_acclist[(yy_lp)];
| 					{
| 					(yy_full_match) = yy_cp;
| 					break;
| 					}
| 				}
| 			--yy_cp;
| 			yy_current_state = *--(yy_state_ptr);
| 			(yy_lp) = yy_accept[yy_current_state];
| 			}
| 
| 		YY_DO_BEFORE_ACTION;
| 
| do_action:	/* This label is used only to access EOF actions. */
| 
| 		switch ( yy_act )
| 	{ /* beginning of action switch */
| case 1:
| YY_RULE_SETUP
| #line 2 "conftest.l"
| { ECHO; }
| 	YY_BREAK
| case 2:
| YY_RULE_SETUP
| #line 3 "conftest.l"
| { REJECT; }
| 	YY_BREAK
| case 3:
| YY_RULE_SETUP
| #line 4 "conftest.l"
| { yymore (); }
| 	YY_BREAK
| case 4:
| YY_RULE_SETUP
| #line 5 "conftest.l"
| { yyless (1); }
| 	YY_BREAK
| case 5:
| YY_RULE_SETUP
| #line 6 "conftest.l"
| { yyless (input () != 0); }
| 	YY_BREAK
| case 6:
| YY_RULE_SETUP
| #line 7 "conftest.l"
| { unput (yytext[0]); }
| 	YY_BREAK
| case 7:
| YY_RULE_SETUP
| #line 8 "conftest.l"
| { BEGIN INITIAL; }
| 	YY_BREAK
| case 8:
| YY_RULE_SETUP
| #line 9 "conftest.l"
| ECHO;
| 	YY_BREAK
| #line 793 "lex.yy.c"
| 			case YY_STATE_EOF(INITIAL):
| 				yyterminate();
| 
| 	case YY_END_OF_BUFFER:
| 		{
| 		/* Amount of text matched not including the EOB char. */
| 		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
| 
| 		/* Undo the effects of YY_DO_BEFORE_ACTION. */
| 		*yy_cp = (yy_hold_char);
| 		YY_RESTORE_YY_MORE_OFFSET
| 
| 		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
| 			{
| 			/* We're scanning a new file or input source.  It's
| 			 * possible that this happened because the user
| 			 * just pointed yyin at a new source and called
| 			 * yylex().  If so, then we have to assure
| 			 * consistency between YY_CURRENT_BUFFER and our
| 			 * globals.  Here is the right place to do so, because
| 			 * this is the first action (other than possibly a
| 			 * back-up) that will match for the new input source.
| 			 */
| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
| 			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
| 			}
| 
| 		/* Note that here we test for yy_c_buf_p "<=" to the position
| 		 * of the first EOB in the buffer, since yy_c_buf_p will
| 		 * already have been incremented past the NUL character
| 		 * (since all states make transitions on EOB to the
| 		 * end-of-buffer state).  Contrast this with the test
| 		 * in input().
| 		 */
| 		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
| 			{ /* This was really a NUL. */
| 			yy_state_type yy_next_state;
| 
| 			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
| 
| 			yy_current_state = yy_get_previous_state(  );
| 
| 			/* Okay, we're now positioned to make the NUL
| 			 * transition.  We couldn't have
| 			 * yy_get_previous_state() go ahead and do it
| 			 * for us because it doesn't know how to deal
| 			 * with the possibility of jamming (and we don't
| 			 * want to build jamming into it because then it
| 			 * will run more slowly).
| 			 */
| 
| 			yy_next_state = yy_try_NUL_trans( yy_current_state );
| 
| 			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 
| 			if ( yy_next_state )
| 				{
| 				/* Consume the NUL. */
| 				yy_cp = ++(yy_c_buf_p);
| 				yy_current_state = yy_next_state;
| 				goto yy_match;
| 				}
| 
| 			else
| 				{
| 				yy_cp = (yy_c_buf_p);
| 				goto yy_find_action;
| 				}
| 			}
| 
| 		else switch ( yy_get_next_buffer(  ) )
| 			{
| 			case EOB_ACT_END_OF_FILE:
| 				{
| 				(yy_did_buffer_switch_on_eof) = 0;
| 
| 				if ( yywrap( ) )
| 					{
| 					/* Note: because we've taken care in
| 					 * yy_get_next_buffer() to have set up
| 					 * yytext, we can now set up
| 					 * yy_c_buf_p so that if some total
| 					 * hoser (like flex itself) wants to
| 					 * call the scanner after we return the
| 					 * YY_NULL, it'll still work - another
| 					 * YY_NULL will get returned.
| 					 */
| 					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
| 
| 					yy_act = YY_STATE_EOF(YY_START);
| 					goto do_action;
| 					}
| 
| 				else
| 					{
| 					if ( ! (yy_did_buffer_switch_on_eof) )
| 						YY_NEW_FILE;
| 					}
| 				break;
| 				}
| 
| 			case EOB_ACT_CONTINUE_SCAN:
| 				(yy_c_buf_p) =
| 					(yytext_ptr) + yy_amount_of_matched_text;
| 
| 				yy_current_state = yy_get_previous_state(  );
| 
| 				yy_cp = (yy_c_buf_p);
| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 				goto yy_match;
| 
| 			case EOB_ACT_LAST_MATCH:
| 				(yy_c_buf_p) =
| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
| 
| 				yy_current_state = yy_get_previous_state(  );
| 
| 				yy_cp = (yy_c_buf_p);
| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 				goto yy_find_action;
| 			}
| 		break;
| 		}
| 
| 	default:
| 		YY_FATAL_ERROR(
| 			"fatal flex scanner internal error--no action found" );
| 	} /* end of action switch */
| 		} /* end of scanning one token */
| 	} /* end of user's declarations */
| } /* end of yylex */
| 
| /* yy_get_next_buffer - try to read in a new buffer
|  *
|  * Returns a code representing an action:
|  *	EOB_ACT_LAST_MATCH -
|  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
|  *	EOB_ACT_END_OF_FILE - end of file
|  */
| static int yy_get_next_buffer (void)
| {
|     	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
| 	register char *source = (yytext_ptr);
| 	register int number_to_move, i;
| 	int ret_val;
| 
| 	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
| 		YY_FATAL_ERROR(
| 		"fatal flex scanner internal error--end of buffer missed" );
| 
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
| 		{ /* Don't try to fill the buffer, so this is an EOF. */
| 		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
| 			{
| 			/* We matched a single character, the EOB, so
| 			 * treat this as a final EOF.
| 			 */
| 			return EOB_ACT_END_OF_FILE;
| 			}
| 
| 		else
| 			{
| 			/* We matched some text prior to the EOB, first
| 			 * process it.
| 			 */
| 			return EOB_ACT_LAST_MATCH;
| 			}
| 		}
| 
| 	/* Try to read more data. */
| 
| 	/* First move last chars to start of buffer. */
| 	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
| 
| 	for ( i = 0; i < number_to_move; ++i )
| 		*(dest++) = *(source++);
| 
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
| 		/* don't do the read, it's not guaranteed to return an EOF,
| 		 * just force an EOF
| 		 */
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
| 
| 	else
| 		{
| 			yy_size_t num_to_read =
| 			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
| 
| 		while ( num_to_read <= 0 )
| 			{ /* Not enough room in the buffer - grow it. */
| 
| 			YY_FATAL_ERROR(
| "input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
| 
| 			}
| 
| 		if ( num_to_read > YY_READ_BUF_SIZE )
| 			num_to_read = YY_READ_BUF_SIZE;
| 
| 		/* Read in more data. */
| 		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
| 			(yy_n_chars), num_to_read );
| 
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	if ( (yy_n_chars) == 0 )
| 		{
| 		if ( number_to_move == YY_MORE_ADJ )
| 			{
| 			ret_val = EOB_ACT_END_OF_FILE;
| 			yyrestart(yyin  );
| 			}
| 
| 		else
| 			{
| 			ret_val = EOB_ACT_LAST_MATCH;
| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
| 				YY_BUFFER_EOF_PENDING;
| 			}
| 		}
| 
| 	else
| 		ret_val = EOB_ACT_CONTINUE_SCAN;
| 
| 	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
| 		/* Extend the array by 50%, plus the number we really need. */
| 		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
| 		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
| 		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
| 			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
| 	}
| 
| 	(yy_n_chars) += number_to_move;
| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
| 
| 	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
| 
| 	return ret_val;
| }
| 
| /* yy_get_previous_state - get the state just before the EOB char was reached */
| 
|     static yy_state_type yy_get_previous_state (void)
| {
| 	register yy_state_type yy_current_state;
| 	register char *yy_cp;
|     
| 	yy_current_state = (yy_start);
| 
| 	(yy_state_ptr) = (yy_state_buf);
| 	*(yy_state_ptr)++ = yy_current_state;
| 
| 	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
| 		{
| 		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
| 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 			{
| 			yy_current_state = (int) yy_def[yy_current_state];
| 			if ( yy_current_state >= 13 )
| 				yy_c = yy_meta[(unsigned int) yy_c];
| 			}
| 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 		*(yy_state_ptr)++ = yy_current_state;
| 		}
| 
| 	return yy_current_state;
| }
| 
| /* yy_try_NUL_trans - try to make a transition on the NUL character
|  *
|  * synopsis
|  *	next_state = yy_try_NUL_trans( current_state );
|  */
|     static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
| {
| 	register int yy_is_jam;
|     
| 	register YY_CHAR yy_c = 1;
| 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 		{
| 		yy_current_state = (int) yy_def[yy_current_state];
| 		if ( yy_current_state >= 13 )
| 			yy_c = yy_meta[(unsigned int) yy_c];
| 		}
| 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 	yy_is_jam = (yy_current_state == 12);
| 	if ( ! yy_is_jam )
| 		*(yy_state_ptr)++ = yy_current_state;
| 
| 		return yy_is_jam ? 0 : yy_current_state;
| }
| 
|     static void yyunput (int c, register char * yy_bp )
| {
| 	register char *yy_cp;
|     
|     yy_cp = (yy_c_buf_p);
| 
| 	/* undo effects of setting up yytext */
| 	*yy_cp = (yy_hold_char);
| 
| 	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
| 		{ /* need to shift things up to make room */
| 		/* +2 for EOB chars. */
| 		register yy_size_t number_to_move = (yy_n_chars) + 2;
| 		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
| 					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
| 		register char *source =
| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
| 
| 		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
| 			*--dest = *--source;
| 
| 		yy_cp += (int) (dest - source);
| 		yy_bp += (int) (dest - source);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
| 
| 		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
| 			YY_FATAL_ERROR( "flex scanner push-back overflow" );
| 		}
| 
| 	*--yy_cp = (char) c;
| 
| 	(yytext_ptr) = yy_bp;
| 	(yy_hold_char) = *yy_cp;
| 	(yy_c_buf_p) = yy_cp;
| }
| 
| #ifndef YY_NO_INPUT
| #ifdef __cplusplus
|     static int yyinput (void)
| #else
|     static int input  (void)
| #endif
| 
| {
| 	int c;
|     
| 	*(yy_c_buf_p) = (yy_hold_char);
| 
| 	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
| 		{
| 		/* yy_c_buf_p now points to the character we want to return.
| 		 * If this occurs *before* the EOB characters, then it's a
| 		 * valid NUL; if not, then we've hit the end of the buffer.
| 		 */
| 		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
| 			/* This was really a NUL. */
| 			*(yy_c_buf_p) = '\0';
| 
| 		else
| 			{ /* need more input */
| 			yy_size_t offset = (yy_c_buf_p) - (yytext_ptr);
| 			++(yy_c_buf_p);
| 
| 			switch ( yy_get_next_buffer(  ) )
| 				{
| 				case EOB_ACT_LAST_MATCH:
| 					/* This happens because yy_g_n_b()
| 					 * sees that we've accumulated a
| 					 * token and flags that we need to
| 					 * try matching the token before
| 					 * proceeding.  But for input(),
| 					 * there's no matching to consider.
| 					 * So convert the EOB_ACT_LAST_MATCH
| 					 * to EOB_ACT_END_OF_FILE.
| 					 */
| 
| 					/* Reset buffer status. */
| 					yyrestart(yyin );
| 
| 					/*FALLTHROUGH*/
| 
| 				case EOB_ACT_END_OF_FILE:
| 					{
| 					if ( yywrap( ) )
| 						return EOF;
| 
| 					if ( ! (yy_did_buffer_switch_on_eof) )
| 						YY_NEW_FILE;
| #ifdef __cplusplus
| 					return yyinput();
| #else
| 					return input();
| #endif
| 					}
| 
| 				case EOB_ACT_CONTINUE_SCAN:
| 					(yy_c_buf_p) = (yytext_ptr) + offset;
| 					break;
| 				}
| 			}
| 		}
| 
| 	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
| 	*(yy_c_buf_p) = '\0';	/* preserve yytext */
| 	(yy_hold_char) = *++(yy_c_buf_p);
| 
| 	return c;
| }
| #endif	/* ifndef YY_NO_INPUT */
| 
| /** Immediately switch to a different input stream.
|  * @param input_file A readable stream.
|  * 
|  * @note This function does not reset the start condition to @c INITIAL .
|  */
|     void yyrestart  (FILE * input_file )
| {
|     
| 	if ( ! YY_CURRENT_BUFFER ){
|         yyensure_buffer_stack ();
| 		YY_CURRENT_BUFFER_LVALUE =
|             yy_create_buffer(yyin,YY_BUF_SIZE );
| 	}
| 
| 	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
| 	yy_load_buffer_state( );
| }
| 
| /** Switch to a different input buffer.
|  * @param new_buffer The new input buffer.
|  * 
|  */
|     void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
| {
|     
| 	/* TODO. We should be able to replace this entire function body
| 	 * with
| 	 *		yypop_buffer_state();
| 	 *		yypush_buffer_state(new_buffer);
|      */
| 	yyensure_buffer_stack ();
| 	if ( YY_CURRENT_BUFFER == new_buffer )
| 		return;
| 
| 	if ( YY_CURRENT_BUFFER )
| 		{
| 		/* Flush out information for old buffer. */
| 		*(yy_c_buf_p) = (yy_hold_char);
| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
| 	yy_load_buffer_state( );
| 
| 	/* We don't actually know whether we did this switch during
| 	 * EOF (yywrap()) processing, but the only time this flag
| 	 * is looked at is after yywrap() is called, so it's safe
| 	 * to go ahead and always set it.
| 	 */
| 	(yy_did_buffer_switch_on_eof) = 1;
| }
| 
| static void yy_load_buffer_state  (void)
| {
|     	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
| 	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
| 	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
| 	(yy_hold_char) = *(yy_c_buf_p);
| }
| 
| /** Allocate and initialize an input buffer state.
|  * @param file A readable stream.
|  * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
|  * 
|  * @return the allocated buffer state.
|  */
|     YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
| {
| 	YY_BUFFER_STATE b;
|     
| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_buf_size = size;
| 
| 	/* yy_ch_buf has to be 2 characters longer than the size given because
| 	 * we need to put in 2 end-of-buffer characters.
| 	 */
| 	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
| 	if ( ! b->yy_ch_buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_is_our_buffer = 1;
| 
| 	yy_init_buffer(b,file );
| 
| 	return b;
| }
| 
| /** Destroy the buffer.
|  * @param b a buffer created with yy_create_buffer()
|  * 
|  */
|     void yy_delete_buffer (YY_BUFFER_STATE  b )
| {
|     
| 	if ( ! b )
| 		return;
| 
| 	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
| 		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
| 
| 	if ( b->yy_is_our_buffer )
| 		yyfree((void *) b->yy_ch_buf  );
| 
| 	yyfree((void *) b  );
| }
| 
| /* Initializes or reinitializes a buffer.
|  * This function is sometimes called more than once on the same buffer,
|  * such as during a yyrestart() or at EOF.
|  */
|     static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
| 
| {
| 	int oerrno = errno;
|     
| 	yy_flush_buffer(b );
| 
| 	b->yy_input_file = file;
| 	b->yy_fill_buffer = 1;
| 
|     /* If b is the current buffer, then yy_init_buffer was _probably_
|      * called from yyrestart() or through yy_get_next_buffer.
|      * In that case, we don't want to reset the lineno or column.
|      */
|     if (b != YY_CURRENT_BUFFER){
|         b->yy_bs_lineno = 1;
|         b->yy_bs_column = 0;
|     }
| 
|         b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
|     
| 	errno = oerrno;
| }
| 
| /** Discard all buffered characters. On the next scan, YY_INPUT will be called.
|  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
|  * 
|  */
|     void yy_flush_buffer (YY_BUFFER_STATE  b )
| {
|     	if ( ! b )
| 		return;
| 
| 	b->yy_n_chars = 0;
| 
| 	/* We always need two end-of-buffer characters.  The first causes
| 	 * a transition to the end-of-buffer state.  The second causes
| 	 * a jam in that state.
| 	 */
| 	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
| 	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b->yy_buf_pos = &b->yy_ch_buf[0];
| 
| 	b->yy_at_bol = 1;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	if ( b == YY_CURRENT_BUFFER )
| 		yy_load_buffer_state( );
| }
| 
| /** Pushes the new state onto the stack. The new state becomes
|  *  the current state. This function will allocate the stack
|  *  if necessary.
|  *  @param new_buffer The new state.
|  *  
|  */
| void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
| {
|     	if (new_buffer == NULL)
| 		return;
| 
| 	yyensure_buffer_stack();
| 
| 	/* This block is copied from yy_switch_to_buffer. */
| 	if ( YY_CURRENT_BUFFER )
| 		{
| 		/* Flush out information for old buffer. */
| 		*(yy_c_buf_p) = (yy_hold_char);
| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	/* Only push if top exists. Otherwise, replace top. */
| 	if (YY_CURRENT_BUFFER)
| 		(yy_buffer_stack_top)++;
| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
| 
| 	/* copied from yy_switch_to_buffer. */
| 	yy_load_buffer_state( );
| 	(yy_did_buffer_switch_on_eof) = 1;
| }
| 
| /** Removes and deletes the top of the stack, if present.
|  *  The next element becomes the new top.
|  *  
|  */
| void yypop_buffer_state (void)
| {
|     	if (!YY_CURRENT_BUFFER)
| 		return;
| 
| 	yy_delete_buffer(YY_CURRENT_BUFFER );
| 	YY_CURRENT_BUFFER_LVALUE = NULL;
| 	if ((yy_buffer_stack_top) > 0)
| 		--(yy_buffer_stack_top);
| 
| 	if (YY_CURRENT_BUFFER) {
| 		yy_load_buffer_state( );
| 		(yy_did_buffer_switch_on_eof) = 1;
| 	}
| }
| 
| /* Allocates the stack if it does not exist.
|  *  Guarantees space for at least one push.
|  */
| static void yyensure_buffer_stack (void)
| {
| 	yy_size_t num_to_alloc;
|     
| 	if (!(yy_buffer_stack)) {
| 
| 		/* First allocation is just for 2 elements, since we don't know if this
| 		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
| 		 * immediate realloc on the next call.
|          */
| 		num_to_alloc = 1;
| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
| 								(num_to_alloc * sizeof(struct yy_buffer_state*)
| 								);
| 		if ( ! (yy_buffer_stack) )
| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
| 								  
| 		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
| 				
| 		(yy_buffer_stack_max) = num_to_alloc;
| 		(yy_buffer_stack_top) = 0;
| 		return;
| 	}
| 
| 	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
| 
| 		/* Increase the buffer to prepare for a possible push. */
| 		int grow_size = 8 /* arbitrary grow size */;
| 
| 		num_to_alloc = (yy_buffer_stack_max) + grow_size;
| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
| 								((yy_buffer_stack),
| 								num_to_alloc * sizeof(struct yy_buffer_state*)
| 								);
| 		if ( ! (yy_buffer_stack) )
| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
| 
| 		/* zero only the new slots.*/
| 		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
| 		(yy_buffer_stack_max) = num_to_alloc;
| 	}
| }
| 
| /** Setup the input buffer state to scan directly from a user-specified character buffer.
|  * @param base the character buffer
|  * @param size the size in bytes of the character buffer
|  * 
|  * @return the newly allocated buffer state object. 
|  */
| YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
| {
| 	YY_BUFFER_STATE b;
|     
| 	if ( size < 2 ||
| 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
| 	     base[size-1] != YY_END_OF_BUFFER_CHAR )
| 		/* They forgot to leave room for the EOB's. */
| 		return 0;
| 
| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
| 
| 	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
| 	b->yy_buf_pos = b->yy_ch_buf = base;
| 	b->yy_is_our_buffer = 0;
| 	b->yy_input_file = 0;
| 	b->yy_n_chars = b->yy_buf_size;
| 	b->yy_is_interactive = 0;
| 	b->yy_at_bol = 1;
| 	b->yy_fill_buffer = 0;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	yy_switch_to_buffer(b  );
| 
| 	return b;
| }
| 
| /** Setup the input buffer state to scan a string. The next call to yylex() will
|  * scan from a @e copy of @a str.
|  * @param yystr a NUL-terminated string to scan
|  * 
|  * @return the newly allocated buffer state object.
|  * @note If you want to scan bytes that may contain NUL values, then use
|  *       yy_scan_bytes() instead.
|  */
| YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
| {
|     
| 	return yy_scan_bytes(yystr,strlen(yystr) );
| }
| 
| /** Setup the input buffer state to scan the given bytes. The next call to yylex() will
|  * scan from a @e copy of @a bytes.
|  * @param yybytes the byte buffer to scan
|  * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
|  * 
|  * @return the newly allocated buffer state object.
|  */
| YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len )
| {
| 	YY_BUFFER_STATE b;
| 	char *buf;
| 	yy_size_t n;
| 	yy_size_t i;
|     
| 	/* Get memory for full buffer, including space for trailing EOB's. */
| 	n = _yybytes_len + 2;
| 	buf = (char *) yyalloc(n  );
| 	if ( ! buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
| 
| 	for ( i = 0; i < _yybytes_len; ++i )
| 		buf[i] = yybytes[i];
| 
| 	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b = yy_scan_buffer(buf,n );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
| 
| 	/* It's okay to grow etc. this buffer, and we should throw it
| 	 * away when we're done.
| 	 */
| 	b->yy_is_our_buffer = 1;
| 
| 	return b;
| }
| 
| #ifndef YY_EXIT_FAILURE
| #define YY_EXIT_FAILURE 2
| #endif
| 
| static void yy_fatal_error (yyconst char* msg )
| {
|     	(void) fprintf( stderr, "%s\n", msg );
| 	exit( YY_EXIT_FAILURE );
| }
| 
| /* Redefine yyless() so it works in section 3 code. */
| 
| #undef yyless
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
|         int yyless_macro_arg = (n); \
|         YY_LESS_LINENO(yyless_macro_arg);\
| 		yytext[yyleng] = (yy_hold_char); \
| 		(yy_c_buf_p) = yytext + yyless_macro_arg; \
| 		(yy_hold_char) = *(yy_c_buf_p); \
| 		*(yy_c_buf_p) = '\0'; \
| 		yyleng = yyless_macro_arg; \
| 		} \
| 	while ( 0 )
| 
| /* Accessor  methods (get/set functions) to struct members. */
| 
| /** Get the current line number.
|  * 
|  */
| int yyget_lineno  (void)
| {
|         
|     return yylineno;
| }
| 
| /** Get the input stream.
|  * 
|  */
| FILE *yyget_in  (void)
| {
|         return yyin;
| }
| 
| /** Get the output stream.
|  * 
|  */
| FILE *yyget_out  (void)
| {
|         return yyout;
| }
| 
| /** Get the length of the current token.
|  * 
|  */
| yy_size_t yyget_leng  (void)
| {
|         return yyleng;
| }
| 
| /** Get the current token.
|  * 
|  */
| 
| char *yyget_text  (void)
| {
|         return yytext;
| }
| 
| /** Set the current line number.
|  * @param line_number
|  * 
|  */
| void yyset_lineno (int  line_number )
| {
|     
|     yylineno = line_number;
| }
| 
| /** Set the input stream. This does not discard the current
|  * input buffer.
|  * @param in_str A readable stream.
|  * 
|  * @see yy_switch_to_buffer
|  */
| void yyset_in (FILE *  in_str )
| {
|         yyin = in_str ;
| }
| 
| void yyset_out (FILE *  out_str )
| {
|         yyout = out_str ;
| }
| 
| int yyget_debug  (void)
| {
|         return yy_flex_debug;
| }
| 
| void yyset_debug (int  bdebug )
| {
|         yy_flex_debug = bdebug ;
| }
| 
| static int yy_init_globals (void)
| {
|         /* Initialization is the same as for the non-reentrant scanner.
|      * This function is called from yylex_destroy(), so don't allocate here.
|      */
| 
|     (yy_buffer_stack) = 0;
|     (yy_buffer_stack_top) = 0;
|     (yy_buffer_stack_max) = 0;
|     (yy_c_buf_p) = (char *) 0;
|     (yy_init) = 0;
|     (yy_start) = 0;
| 
|     (yy_state_buf) = 0;
|     (yy_state_ptr) = 0;
|     (yy_full_match) = 0;
|     (yy_lp) = 0;
| 
| /* Defined in main.c */
| #ifdef YY_STDINIT
|     yyin = stdin;
|     yyout = stdout;
| #else
|     yyin = (FILE *) 0;
|     yyout = (FILE *) 0;
| #endif
| 
|     /* For future reference: Set errno on error, since we are called by
|      * yylex_init()
|      */
|     return 0;
| }
| 
| /* yylex_destroy is for both reentrant and non-reentrant scanners. */
| int yylex_destroy  (void)
| {
|     
|     /* Pop the buffer stack, destroying each element. */
| 	while(YY_CURRENT_BUFFER){
| 		yy_delete_buffer(YY_CURRENT_BUFFER  );
| 		YY_CURRENT_BUFFER_LVALUE = NULL;
| 		yypop_buffer_state();
| 	}
| 
| 	/* Destroy the stack itself. */
| 	yyfree((yy_buffer_stack) );
| 	(yy_buffer_stack) = NULL;
| 
|     yyfree ( (yy_state_buf) );
|     (yy_state_buf)  = NULL;
| 
|     /* Reset the globals. This is important in a non-reentrant scanner so the next time
|      * yylex() is called, initialization will occur. */
|     yy_init_globals( );
| 
|     return 0;
| }
| 
| /*
|  * Internal utility routines.
|  */
| 
| #ifndef yytext_ptr
| static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
| {
| 	register int i;
| 	for ( i = 0; i < n; ++i )
| 		s1[i] = s2[i];
| }
| #endif
| 
| #ifdef YY_NEED_STRLEN
| static int yy_flex_strlen (yyconst char * s )
| {
| 	register int n;
| 	for ( n = 0; s[n]; ++n )
| 		;
| 
| 	return n;
| }
| #endif
| 
| void *yyalloc (yy_size_t  size )
| {
| 	return (void *) malloc( size );
| }
| 
| void *yyrealloc  (void * ptr, yy_size_t  size )
| {
| 	/* The cast to (char *) in the following accommodates both
| 	 * implementations that use char* generic pointers, and those
| 	 * that use void* generic pointers.  It works with the latter
| 	 * because both ANSI C and C++ allow castless assignment from
| 	 * any pointer type to void*, and deal with argument conversions
| 	 * as though doing an assignment.
| 	 */
| 	return (void *) realloc( (char *) ptr, size );
| }
| 
| void yyfree (void * ptr )
| {
| 	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
| }
| 
| #define YYTABLES_NAME "yytables"
| 
| #line 9 "conftest.l"
| 
| 
| #ifdef YYTEXT_POINTER
| extern char *yytext;
| #endif
| int
| main (void)
| {
|   return ! yylex () + ! yywrap ();
| }
configure:16181: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c -lfl  >&5
/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld: error: cannot find -lfl
/tmp/cc6J5z9l.o:conftest.c:function yylex: error: undefined reference to 'yywrap'
/tmp/cc6J5z9l.o:conftest.c:function input: error: undefined reference to 'yywrap'
/tmp/cc6J5z9l.o:conftest.c:function main: error: undefined reference to 'yywrap'
collect2: error: ld returned 1 exit status
configure:16181: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "ld"
| #define PACKAGE_TARNAME "ld"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "ld 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "ld"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define GOT_HANDLING_DEFAULT GOT_HANDLING_TARGET_DEFAULT
| #define HAVE_LC_MESSAGES 1
| /* end confdefs.h.  */
| 
| #line 3 "lex.yy.c"
| 
| #define  YY_INT_ALIGNED short int
| 
| /* A lexical scanner generated by flex */
| 
| #define FLEX_SCANNER
| #define YY_FLEX_MAJOR_VERSION 2
| #define YY_FLEX_MINOR_VERSION 5
| #define YY_FLEX_SUBMINOR_VERSION 39
| #if YY_FLEX_SUBMINOR_VERSION > 0
| #define FLEX_BETA
| #endif
| 
| /* First, we deal with  platform-specific or compiler-specific issues. */
| 
| /* begin standard C headers. */
| #include <stdio.h>
| #include <string.h>
| #include <errno.h>
| #include <stdlib.h>
| 
| /* end standard C headers. */
| 
| /* flex integer type definitions */
| 
| #ifndef FLEXINT_H
| #define FLEXINT_H
| 
| /* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
| 
| #if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
| 
| /* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
|  * if you want the limit (max/min) macros for int types. 
|  */
| #ifndef __STDC_LIMIT_MACROS
| #define __STDC_LIMIT_MACROS 1
| #endif
| 
| #include <inttypes.h>
| typedef int8_t flex_int8_t;
| typedef uint8_t flex_uint8_t;
| typedef int16_t flex_int16_t;
| typedef uint16_t flex_uint16_t;
| typedef int32_t flex_int32_t;
| typedef uint32_t flex_uint32_t;
| #else
| typedef signed char flex_int8_t;
| typedef short int flex_int16_t;
| typedef int flex_int32_t;
| typedef unsigned char flex_uint8_t; 
| typedef unsigned short int flex_uint16_t;
| typedef unsigned int flex_uint32_t;
| 
| /* Limits of integral types. */
| #ifndef INT8_MIN
| #define INT8_MIN               (-128)
| #endif
| #ifndef INT16_MIN
| #define INT16_MIN              (-32767-1)
| #endif
| #ifndef INT32_MIN
| #define INT32_MIN              (-2147483647-1)
| #endif
| #ifndef INT8_MAX
| #define INT8_MAX               (127)
| #endif
| #ifndef INT16_MAX
| #define INT16_MAX              (32767)
| #endif
| #ifndef INT32_MAX
| #define INT32_MAX              (2147483647)
| #endif
| #ifndef UINT8_MAX
| #define UINT8_MAX              (255U)
| #endif
| #ifndef UINT16_MAX
| #define UINT16_MAX             (65535U)
| #endif
| #ifndef UINT32_MAX
| #define UINT32_MAX             (4294967295U)
| #endif
| 
| #endif /* ! C99 */
| 
| #endif /* ! FLEXINT_H */
| 
| #ifdef __cplusplus
| 
| /* The "const" storage-class-modifier is valid. */
| #define YY_USE_CONST
| 
| #else	/* ! __cplusplus */
| 
| /* C99 requires __STDC__ to be defined as 1. */
| #if defined (__STDC__)
| 
| #define YY_USE_CONST
| 
| #endif	/* defined (__STDC__) */
| #endif	/* ! __cplusplus */
| 
| #ifdef YY_USE_CONST
| #define yyconst const
| #else
| #define yyconst
| #endif
| 
| /* Returned upon end-of-file. */
| #define YY_NULL 0
| 
| /* Promotes a possibly negative, possibly signed char to an unsigned
|  * integer for use as an array index.  If the signed char is negative,
|  * we want to instead treat it as an 8-bit unsigned char, hence the
|  * double cast.
|  */
| #define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
| 
| /* Enter a start condition.  This macro really ought to take a parameter,
|  * but we do it the disgusting crufty way forced on us by the ()-less
|  * definition of BEGIN.
|  */
| #define BEGIN (yy_start) = 1 + 2 *
| 
| /* Translate the current start state into a value that can be later handed
|  * to BEGIN to return to the state.  The YYSTATE alias is for lex
|  * compatibility.
|  */
| #define YY_START (((yy_start) - 1) / 2)
| #define YYSTATE YY_START
| 
| /* Action number for EOF rule of a given start state. */
| #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
| 
| /* Special action meaning "start processing a new file". */
| #define YY_NEW_FILE yyrestart(yyin  )
| 
| #define YY_END_OF_BUFFER_CHAR 0
| 
| /* Size of default input buffer. */
| #ifndef YY_BUF_SIZE
| #define YY_BUF_SIZE 16384
| #endif
| 
| /* The state buf must be large enough to hold one state per character in the main buffer.
|  */
| #define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
| 
| #ifndef YY_TYPEDEF_YY_BUFFER_STATE
| #define YY_TYPEDEF_YY_BUFFER_STATE
| typedef struct yy_buffer_state *YY_BUFFER_STATE;
| #endif
| 
| #ifndef YY_TYPEDEF_YY_SIZE_T
| #define YY_TYPEDEF_YY_SIZE_T
| typedef size_t yy_size_t;
| #endif
| 
| extern yy_size_t yyleng;
| 
| extern FILE *yyin, *yyout;
| 
| #define EOB_ACT_CONTINUE_SCAN 0
| #define EOB_ACT_END_OF_FILE 1
| #define EOB_ACT_LAST_MATCH 2
| 
|     #define YY_LESS_LINENO(n)
|     #define YY_LINENO_REWIND_TO(ptr)
|     
| /* Return all but the first "n" matched characters back to the input stream. */
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
|         int yyless_macro_arg = (n); \
|         YY_LESS_LINENO(yyless_macro_arg);\
| 		*yy_cp = (yy_hold_char); \
| 		YY_RESTORE_YY_MORE_OFFSET \
| 		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
| 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
| 		} \
| 	while ( 0 )
| 
| #define unput(c) yyunput( c, (yytext_ptr)  )
| 
| #ifndef YY_STRUCT_YY_BUFFER_STATE
| #define YY_STRUCT_YY_BUFFER_STATE
| struct yy_buffer_state
| 	{
| 	FILE *yy_input_file;
| 
| 	char *yy_ch_buf;		/* input buffer */
| 	char *yy_buf_pos;		/* current position in input buffer */
| 
| 	/* Size of input buffer in bytes, not including room for EOB
| 	 * characters.
| 	 */
| 	yy_size_t yy_buf_size;
| 
| 	/* Number of characters read into yy_ch_buf, not including EOB
| 	 * characters.
| 	 */
| 	yy_size_t yy_n_chars;
| 
| 	/* Whether we "own" the buffer - i.e., we know we created it,
| 	 * and can realloc() it to grow it, and should free() it to
| 	 * delete it.
| 	 */
| 	int yy_is_our_buffer;
| 
| 	/* Whether this is an "interactive" input source; if so, and
| 	 * if we're using stdio for input, then we want to use getc()
| 	 * instead of fread(), to make sure we stop fetching input after
| 	 * each newline.
| 	 */
| 	int yy_is_interactive;
| 
| 	/* Whether we're considered to be at the beginning of a line.
| 	 * If so, '^' rules will be active on the next match, otherwise
| 	 * not.
| 	 */
| 	int yy_at_bol;
| 
|     int yy_bs_lineno; /**< The line count. */
|     int yy_bs_column; /**< The column count. */
|     
| 	/* Whether to try to fill the input buffer when we reach the
| 	 * end of it.
| 	 */
| 	int yy_fill_buffer;
| 
| 	int yy_buffer_status;
| 
| #define YY_BUFFER_NEW 0
| #define YY_BUFFER_NORMAL 1
| 	/* When an EOF's been seen but there's still some text to process
| 	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
| 	 * shouldn't try reading from the input source any more.  We might
| 	 * still have a bunch of tokens to match, though, because of
| 	 * possible backing-up.
| 	 *
| 	 * When we actually see the EOF, we change the status to "new"
| 	 * (via yyrestart()), so that the user can continue scanning by
| 	 * just pointing yyin at a new input file.
| 	 */
| #define YY_BUFFER_EOF_PENDING 2
| 
| 	};
| #endif /* !YY_STRUCT_YY_BUFFER_STATE */
| 
| /* Stack of input buffers. */
| static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
| static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
| static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
| 
| /* We provide macros for accessing buffer states in case in the
|  * future we want to put the buffer states in a more general
|  * "scanner state".
|  *
|  * Returns the top of the stack, or NULL.
|  */
| #define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
|                           ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
|                           : NULL)
| 
| /* Same as previous macro, but useful when we know that the buffer stack is not
|  * NULL or when we need an lvalue. For internal use only.
|  */
| #define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
| 
| /* yy_hold_char holds the character lost when yytext is formed. */
| static char yy_hold_char;
| static yy_size_t yy_n_chars;		/* number of characters read into yy_ch_buf */
| yy_size_t yyleng;
| 
| /* Points to current character in buffer. */
| static char *yy_c_buf_p = (char *) 0;
| static int yy_init = 0;		/* whether we need to initialize */
| static int yy_start = 0;	/* start state number */
| 
| /* Flag which is used to allow yywrap()'s to do buffer switches
|  * instead of setting up a fresh yyin.  A bit of a hack ...
|  */
| static int yy_did_buffer_switch_on_eof;
| 
| void yyrestart (FILE *input_file  );
| void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
| YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
| void yy_delete_buffer (YY_BUFFER_STATE b  );
| void yy_flush_buffer (YY_BUFFER_STATE b  );
| void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
| void yypop_buffer_state (void );
| 
| static void yyensure_buffer_stack (void );
| static void yy_load_buffer_state (void );
| static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
| 
| #define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
| 
| YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
| YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
| YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,yy_size_t len  );
| 
| void *yyalloc (yy_size_t  );
| void *yyrealloc (void *,yy_size_t  );
| void yyfree (void *  );
| 
| #define yy_new_buffer yy_create_buffer
| 
| #define yy_set_interactive(is_interactive) \
| 	{ \
| 	if ( ! YY_CURRENT_BUFFER ){ \
|         yyensure_buffer_stack (); \
| 		YY_CURRENT_BUFFER_LVALUE =    \
|             yy_create_buffer(yyin,YY_BUF_SIZE ); \
| 	} \
| 	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
| 	}
| 
| #define yy_set_bol(at_bol) \
| 	{ \
| 	if ( ! YY_CURRENT_BUFFER ){\
|         yyensure_buffer_stack (); \
| 		YY_CURRENT_BUFFER_LVALUE =    \
|             yy_create_buffer(yyin,YY_BUF_SIZE ); \
| 	} \
| 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
| 	}
| 
| #define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
| 
| /* Begin user sect3 */
| 
| typedef unsigned char YY_CHAR;
| 
| FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
| 
| typedef int yy_state_type;
| 
| extern int yylineno;
| 
| int yylineno = 1;
| 
| extern char *yytext;
| #define yytext_ptr yytext
| 
| static yy_state_type yy_get_previous_state (void );
| static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
| static int yy_get_next_buffer (void );
| static void yy_fatal_error (yyconst char msg[]  );
| 
| /* Done after the current pattern has been matched and before the
|  * corresponding action - sets up yytext.
|  */
| #define YY_DO_BEFORE_ACTION \
| 	(yytext_ptr) = yy_bp; \
| 	(yytext_ptr) -= (yy_more_len); \
| 	yyleng = (size_t) (yy_cp - (yytext_ptr)); \
| 	(yy_hold_char) = *yy_cp; \
| 	*yy_cp = '\0'; \
| 	(yy_c_buf_p) = yy_cp;
| 
| #define YY_NUM_RULES 8
| #define YY_END_OF_BUFFER 9
| /* This struct is not used in this scanner,
|    but its presence is necessary. */
| struct yy_trans_info
| 	{
| 	flex_int32_t yy_verify;
| 	flex_int32_t yy_nxt;
| 	};
| static yyconst flex_int16_t yy_acclist[23] =
|     {   0,
|         9,    7,    8,    8,    1,    7,    8,    2,    7,    8,
|         3,    7,    8,    4,    7,    8,    5,    7,    8,    6,
|         7,    8
|     } ;
| 
| static yyconst flex_int16_t yy_accept[14] =
|     {   0,
|         1,    1,    1,    2,    4,    5,    8,   11,   14,   17,
|        20,   23,   23
|     } ;
| 
| static yyconst flex_int32_t yy_ec[256] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    3,    4,    5,    6,
| 
|         7,    8,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| 
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1
|     } ;
| 
| static yyconst flex_int32_t yy_meta[9] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1
|     } ;
| 
| static yyconst flex_int16_t yy_base[13] =
|     {   0,
|         0,    0,    9,   10,   10,   10,   10,   10,   10,   10,
|        10,   10
|     } ;
| 
| static yyconst flex_int16_t yy_def[13] =
|     {   0,
|        12,    1,   12,   12,   12,   12,   12,   12,   12,   12,
|        12,    0
|     } ;
| 
| static yyconst flex_int16_t yy_nxt[19] =
|     {   0,
|         4,    5,    6,    7,    8,    9,   10,   11,   12,    3,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| static yyconst flex_int16_t yy_chk[19] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    3,   12,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| extern int yy_flex_debug;
| int yy_flex_debug = 0;
| 
| static yy_state_type *yy_state_buf=0, *yy_state_ptr=0;
| static char *yy_full_match;
| static int yy_lp;
| #define REJECT \
| { \
| *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */ \
| yy_cp = (yy_full_match); /* restore poss. backed-over text */ \
| ++(yy_lp); \
| goto find_rule; \
| }
| 
| static int yy_more_flag = 0;
| static int yy_more_len = 0;
| #define yymore() ((yy_more_flag) = 1)
| #define YY_MORE_ADJ (yy_more_len)
| #define YY_RESTORE_YY_MORE_OFFSET
| char *yytext;
| #line 1 "conftest.l"
| #line 470 "lex.yy.c"
| 
| #define INITIAL 0
| 
| #ifndef YY_NO_UNISTD_H
| /* Special case for "unistd.h", since it is non-ANSI. We include it way
|  * down here because we want the user's section 1 to have been scanned first.
|  * The user has a chance to override it with an option.
|  */
| #include <unistd.h>
| #endif
| 
| #ifndef YY_EXTRA_TYPE
| #define YY_EXTRA_TYPE void *
| #endif
| 
| static int yy_init_globals (void );
| 
| /* Accessor methods to globals.
|    These are made visible to non-reentrant scanners for convenience. */
| 
| int yylex_destroy (void );
| 
| int yyget_debug (void );
| 
| void yyset_debug (int debug_flag  );
| 
| YY_EXTRA_TYPE yyget_extra (void );
| 
| void yyset_extra (YY_EXTRA_TYPE user_defined  );
| 
| FILE *yyget_in (void );
| 
| void yyset_in  (FILE * in_str  );
| 
| FILE *yyget_out (void );
| 
| void yyset_out  (FILE * out_str  );
| 
| yy_size_t yyget_leng (void );
| 
| char *yyget_text (void );
| 
| int yyget_lineno (void );
| 
| void yyset_lineno (int line_number  );
| 
| /* Macros after this point can all be overridden by user definitions in
|  * section 1.
|  */
| 
| #ifndef YY_SKIP_YYWRAP
| #ifdef __cplusplus
| extern "C" int yywrap (void );
| #else
| extern int yywrap (void );
| #endif
| #endif
| 
|     static void yyunput (int c,char *buf_ptr  );
|     
| #ifndef yytext_ptr
| static void yy_flex_strncpy (char *,yyconst char *,int );
| #endif
| 
| #ifdef YY_NEED_STRLEN
| static int yy_flex_strlen (yyconst char * );
| #endif
| 
| #ifndef YY_NO_INPUT
| 
| #ifdef __cplusplus
| static int yyinput (void );
| #else
| static int input (void );
| #endif
| 
| #endif
| 
| /* Amount of stuff to slurp up with each read. */
| #ifndef YY_READ_BUF_SIZE
| #define YY_READ_BUF_SIZE 8192
| #endif
| 
| /* Copy whatever the last rule matched to the standard output. */
| #ifndef ECHO
| /* This used to be an fputs(), but since the string might contain NUL's,
|  * we now use fwrite().
|  */
| #define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
| #endif
| 
| /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
|  * is returned in "result".
|  */
| #ifndef YY_INPUT
| #define YY_INPUT(buf,result,max_size) \
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
| 		{ \
| 		int c = '*'; \
| 		size_t n; \
| 		for ( n = 0; n < max_size && \
| 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
| 			buf[n] = (char) c; \
| 		if ( c == '\n' ) \
| 			buf[n++] = (char) c; \
| 		if ( c == EOF && ferror( yyin ) ) \
| 			YY_FATAL_ERROR( "input in flex scanner failed" ); \
| 		result = n; \
| 		} \
| 	else \
| 		{ \
| 		errno=0; \
| 		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
| 			{ \
| 			if( errno != EINTR) \
| 				{ \
| 				YY_FATAL_ERROR( "input in flex scanner failed" ); \
| 				break; \
| 				} \
| 			errno=0; \
| 			clearerr(yyin); \
| 			} \
| 		}\
| \
| 
| #endif
| 
| /* No semi-colon after return; correct usage is to write "yyterminate();" -
|  * we don't want an extra ';' after the "return" because that will cause
|  * some compilers to complain about unreachable statements.
|  */
| #ifndef yyterminate
| #define yyterminate() return YY_NULL
| #endif
| 
| /* Number of entries by which start-condition stack grows. */
| #ifndef YY_START_STACK_INCR
| #define YY_START_STACK_INCR 25
| #endif
| 
| /* Report a fatal error. */
| #ifndef YY_FATAL_ERROR
| #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
| #endif
| 
| /* end tables serialization structures and prototypes */
| 
| /* Default declaration of generated scanner - a define so the user can
|  * easily add parameters.
|  */
| #ifndef YY_DECL
| #define YY_DECL_IS_OURS 1
| 
| extern int yylex (void);
| 
| #define YY_DECL int yylex (void)
| #endif /* !YY_DECL */
| 
| /* Code executed at the beginning of each rule, after yytext and yyleng
|  * have been set up.
|  */
| #ifndef YY_USER_ACTION
| #define YY_USER_ACTION
| #endif
| 
| /* Code executed at the end of each rule. */
| #ifndef YY_BREAK
| #define YY_BREAK break;
| #endif
| 
| #define YY_RULE_SETUP \
| 	YY_USER_ACTION
| 
| /** The main scanner function which does all the work.
|  */
| YY_DECL
| {
| 	register yy_state_type yy_current_state;
| 	register char *yy_cp, *yy_bp;
| 	register int yy_act;
|     
| 	if ( !(yy_init) )
| 		{
| 		(yy_init) = 1;
| 
| #ifdef YY_USER_INIT
| 		YY_USER_INIT;
| #endif
| 
|         /* Create the reject buffer large enough to save one state per allowed character. */
|         if ( ! (yy_state_buf) )
|             (yy_state_buf) = (yy_state_type *)yyalloc(YY_STATE_BUF_SIZE  );
|             if ( ! (yy_state_buf) )
|                 YY_FATAL_ERROR( "out of dynamic memory in yylex()" );
| 
| 		if ( ! (yy_start) )
| 			(yy_start) = 1;	/* first start state */
| 
| 		if ( ! yyin )
| 			yyin = stdin;
| 
| 		if ( ! yyout )
| 			yyout = stdout;
| 
| 		if ( ! YY_CURRENT_BUFFER ) {
| 			yyensure_buffer_stack ();
| 			YY_CURRENT_BUFFER_LVALUE =
| 				yy_create_buffer(yyin,YY_BUF_SIZE );
| 		}
| 
| 		yy_load_buffer_state( );
| 		}
| 
| 	{
| #line 1 "conftest.l"
| 
| #line 687 "lex.yy.c"
| 
| 	while ( 1 )		/* loops until end-of-file is reached */
| 		{
| 		(yy_more_len) = 0;
| 		if ( (yy_more_flag) )
| 			{
| 			(yy_more_len) = (yy_c_buf_p) - (yytext_ptr);
| 			(yy_more_flag) = 0;
| 			}
| 		yy_cp = (yy_c_buf_p);
| 
| 		/* Support of yytext. */
| 		*yy_cp = (yy_hold_char);
| 
| 		/* yy_bp points to the position in yy_ch_buf of the start of
| 		 * the current run.
| 		 */
| 		yy_bp = yy_cp;
| 
| 		yy_current_state = (yy_start);
| 
| 		(yy_state_ptr) = (yy_state_buf);
| 		*(yy_state_ptr)++ = yy_current_state;
| 
| yy_match:
| 		do
| 			{
| 			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
| 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 				{
| 				yy_current_state = (int) yy_def[yy_current_state];
| 				if ( yy_current_state >= 13 )
| 					yy_c = yy_meta[(unsigned int) yy_c];
| 				}
| 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 			*(yy_state_ptr)++ = yy_current_state;
| 			++yy_cp;
| 			}
| 		while ( yy_base[yy_current_state] != 10 );
| 
| yy_find_action:
| 		yy_current_state = *--(yy_state_ptr);
| 		(yy_lp) = yy_accept[yy_current_state];
| find_rule: /* we branch to this label when backing up */
| 		for ( ; ; ) /* until we find what rule we matched */
| 			{
| 			if ( (yy_lp) && (yy_lp) < yy_accept[yy_current_state + 1] )
| 				{
| 				yy_act = yy_acclist[(yy_lp)];
| 					{
| 					(yy_full_match) = yy_cp;
| 					break;
| 					}
| 				}
| 			--yy_cp;
| 			yy_current_state = *--(yy_state_ptr);
| 			(yy_lp) = yy_accept[yy_current_state];
| 			}
| 
| 		YY_DO_BEFORE_ACTION;
| 
| do_action:	/* This label is used only to access EOF actions. */
| 
| 		switch ( yy_act )
| 	{ /* beginning of action switch */
| case 1:
| YY_RULE_SETUP
| #line 2 "conftest.l"
| { ECHO; }
| 	YY_BREAK
| case 2:
| YY_RULE_SETUP
| #line 3 "conftest.l"
| { REJECT; }
| 	YY_BREAK
| case 3:
| YY_RULE_SETUP
| #line 4 "conftest.l"
| { yymore (); }
| 	YY_BREAK
| case 4:
| YY_RULE_SETUP
| #line 5 "conftest.l"
| { yyless (1); }
| 	YY_BREAK
| case 5:
| YY_RULE_SETUP
| #line 6 "conftest.l"
| { yyless (input () != 0); }
| 	YY_BREAK
| case 6:
| YY_RULE_SETUP
| #line 7 "conftest.l"
| { unput (yytext[0]); }
| 	YY_BREAK
| case 7:
| YY_RULE_SETUP
| #line 8 "conftest.l"
| { BEGIN INITIAL; }
| 	YY_BREAK
| case 8:
| YY_RULE_SETUP
| #line 9 "conftest.l"
| ECHO;
| 	YY_BREAK
| #line 793 "lex.yy.c"
| 			case YY_STATE_EOF(INITIAL):
| 				yyterminate();
| 
| 	case YY_END_OF_BUFFER:
| 		{
| 		/* Amount of text matched not including the EOB char. */
| 		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
| 
| 		/* Undo the effects of YY_DO_BEFORE_ACTION. */
| 		*yy_cp = (yy_hold_char);
| 		YY_RESTORE_YY_MORE_OFFSET
| 
| 		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
| 			{
| 			/* We're scanning a new file or input source.  It's
| 			 * possible that this happened because the user
| 			 * just pointed yyin at a new source and called
| 			 * yylex().  If so, then we have to assure
| 			 * consistency between YY_CURRENT_BUFFER and our
| 			 * globals.  Here is the right place to do so, because
| 			 * this is the first action (other than possibly a
| 			 * back-up) that will match for the new input source.
| 			 */
| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
| 			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
| 			}
| 
| 		/* Note that here we test for yy_c_buf_p "<=" to the position
| 		 * of the first EOB in the buffer, since yy_c_buf_p will
| 		 * already have been incremented past the NUL character
| 		 * (since all states make transitions on EOB to the
| 		 * end-of-buffer state).  Contrast this with the test
| 		 * in input().
| 		 */
| 		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
| 			{ /* This was really a NUL. */
| 			yy_state_type yy_next_state;
| 
| 			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
| 
| 			yy_current_state = yy_get_previous_state(  );
| 
| 			/* Okay, we're now positioned to make the NUL
| 			 * transition.  We couldn't have
| 			 * yy_get_previous_state() go ahead and do it
| 			 * for us because it doesn't know how to deal
| 			 * with the possibility of jamming (and we don't
| 			 * want to build jamming into it because then it
| 			 * will run more slowly).
| 			 */
| 
| 			yy_next_state = yy_try_NUL_trans( yy_current_state );
| 
| 			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 
| 			if ( yy_next_state )
| 				{
| 				/* Consume the NUL. */
| 				yy_cp = ++(yy_c_buf_p);
| 				yy_current_state = yy_next_state;
| 				goto yy_match;
| 				}
| 
| 			else
| 				{
| 				yy_cp = (yy_c_buf_p);
| 				goto yy_find_action;
| 				}
| 			}
| 
| 		else switch ( yy_get_next_buffer(  ) )
| 			{
| 			case EOB_ACT_END_OF_FILE:
| 				{
| 				(yy_did_buffer_switch_on_eof) = 0;
| 
| 				if ( yywrap( ) )
| 					{
| 					/* Note: because we've taken care in
| 					 * yy_get_next_buffer() to have set up
| 					 * yytext, we can now set up
| 					 * yy_c_buf_p so that if some total
| 					 * hoser (like flex itself) wants to
| 					 * call the scanner after we return the
| 					 * YY_NULL, it'll still work - another
| 					 * YY_NULL will get returned.
| 					 */
| 					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
| 
| 					yy_act = YY_STATE_EOF(YY_START);
| 					goto do_action;
| 					}
| 
| 				else
| 					{
| 					if ( ! (yy_did_buffer_switch_on_eof) )
| 						YY_NEW_FILE;
| 					}
| 				break;
| 				}
| 
| 			case EOB_ACT_CONTINUE_SCAN:
| 				(yy_c_buf_p) =
| 					(yytext_ptr) + yy_amount_of_matched_text;
| 
| 				yy_current_state = yy_get_previous_state(  );
| 
| 				yy_cp = (yy_c_buf_p);
| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 				goto yy_match;
| 
| 			case EOB_ACT_LAST_MATCH:
| 				(yy_c_buf_p) =
| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
| 
| 				yy_current_state = yy_get_previous_state(  );
| 
| 				yy_cp = (yy_c_buf_p);
| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 				goto yy_find_action;
| 			}
| 		break;
| 		}
| 
| 	default:
| 		YY_FATAL_ERROR(
| 			"fatal flex scanner internal error--no action found" );
| 	} /* end of action switch */
| 		} /* end of scanning one token */
| 	} /* end of user's declarations */
| } /* end of yylex */
| 
| /* yy_get_next_buffer - try to read in a new buffer
|  *
|  * Returns a code representing an action:
|  *	EOB_ACT_LAST_MATCH -
|  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
|  *	EOB_ACT_END_OF_FILE - end of file
|  */
| static int yy_get_next_buffer (void)
| {
|     	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
| 	register char *source = (yytext_ptr);
| 	register int number_to_move, i;
| 	int ret_val;
| 
| 	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
| 		YY_FATAL_ERROR(
| 		"fatal flex scanner internal error--end of buffer missed" );
| 
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
| 		{ /* Don't try to fill the buffer, so this is an EOF. */
| 		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
| 			{
| 			/* We matched a single character, the EOB, so
| 			 * treat this as a final EOF.
| 			 */
| 			return EOB_ACT_END_OF_FILE;
| 			}
| 
| 		else
| 			{
| 			/* We matched some text prior to the EOB, first
| 			 * process it.
| 			 */
| 			return EOB_ACT_LAST_MATCH;
| 			}
| 		}
| 
| 	/* Try to read more data. */
| 
| 	/* First move last chars to start of buffer. */
| 	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
| 
| 	for ( i = 0; i < number_to_move; ++i )
| 		*(dest++) = *(source++);
| 
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
| 		/* don't do the read, it's not guaranteed to return an EOF,
| 		 * just force an EOF
| 		 */
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
| 
| 	else
| 		{
| 			yy_size_t num_to_read =
| 			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
| 
| 		while ( num_to_read <= 0 )
| 			{ /* Not enough room in the buffer - grow it. */
| 
| 			YY_FATAL_ERROR(
| "input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
| 
| 			}
| 
| 		if ( num_to_read > YY_READ_BUF_SIZE )
| 			num_to_read = YY_READ_BUF_SIZE;
| 
| 		/* Read in more data. */
| 		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
| 			(yy_n_chars), num_to_read );
| 
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	if ( (yy_n_chars) == 0 )
| 		{
| 		if ( number_to_move == YY_MORE_ADJ )
| 			{
| 			ret_val = EOB_ACT_END_OF_FILE;
| 			yyrestart(yyin  );
| 			}
| 
| 		else
| 			{
| 			ret_val = EOB_ACT_LAST_MATCH;
| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
| 				YY_BUFFER_EOF_PENDING;
| 			}
| 		}
| 
| 	else
| 		ret_val = EOB_ACT_CONTINUE_SCAN;
| 
| 	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
| 		/* Extend the array by 50%, plus the number we really need. */
| 		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
| 		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
| 		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
| 			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
| 	}
| 
| 	(yy_n_chars) += number_to_move;
| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
| 
| 	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
| 
| 	return ret_val;
| }
| 
| /* yy_get_previous_state - get the state just before the EOB char was reached */
| 
|     static yy_state_type yy_get_previous_state (void)
| {
| 	register yy_state_type yy_current_state;
| 	register char *yy_cp;
|     
| 	yy_current_state = (yy_start);
| 
| 	(yy_state_ptr) = (yy_state_buf);
| 	*(yy_state_ptr)++ = yy_current_state;
| 
| 	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
| 		{
| 		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
| 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 			{
| 			yy_current_state = (int) yy_def[yy_current_state];
| 			if ( yy_current_state >= 13 )
| 				yy_c = yy_meta[(unsigned int) yy_c];
| 			}
| 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 		*(yy_state_ptr)++ = yy_current_state;
| 		}
| 
| 	return yy_current_state;
| }
| 
| /* yy_try_NUL_trans - try to make a transition on the NUL character
|  *
|  * synopsis
|  *	next_state = yy_try_NUL_trans( current_state );
|  */
|     static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
| {
| 	register int yy_is_jam;
|     
| 	register YY_CHAR yy_c = 1;
| 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 		{
| 		yy_current_state = (int) yy_def[yy_current_state];
| 		if ( yy_current_state >= 13 )
| 			yy_c = yy_meta[(unsigned int) yy_c];
| 		}
| 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 	yy_is_jam = (yy_current_state == 12);
| 	if ( ! yy_is_jam )
| 		*(yy_state_ptr)++ = yy_current_state;
| 
| 		return yy_is_jam ? 0 : yy_current_state;
| }
| 
|     static void yyunput (int c, register char * yy_bp )
| {
| 	register char *yy_cp;
|     
|     yy_cp = (yy_c_buf_p);
| 
| 	/* undo effects of setting up yytext */
| 	*yy_cp = (yy_hold_char);
| 
| 	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
| 		{ /* need to shift things up to make room */
| 		/* +2 for EOB chars. */
| 		register yy_size_t number_to_move = (yy_n_chars) + 2;
| 		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
| 					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
| 		register char *source =
| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
| 
| 		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
| 			*--dest = *--source;
| 
| 		yy_cp += (int) (dest - source);
| 		yy_bp += (int) (dest - source);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
| 
| 		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
| 			YY_FATAL_ERROR( "flex scanner push-back overflow" );
| 		}
| 
| 	*--yy_cp = (char) c;
| 
| 	(yytext_ptr) = yy_bp;
| 	(yy_hold_char) = *yy_cp;
| 	(yy_c_buf_p) = yy_cp;
| }
| 
| #ifndef YY_NO_INPUT
| #ifdef __cplusplus
|     static int yyinput (void)
| #else
|     static int input  (void)
| #endif
| 
| {
| 	int c;
|     
| 	*(yy_c_buf_p) = (yy_hold_char);
| 
| 	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
| 		{
| 		/* yy_c_buf_p now points to the character we want to return.
| 		 * If this occurs *before* the EOB characters, then it's a
| 		 * valid NUL; if not, then we've hit the end of the buffer.
| 		 */
| 		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
| 			/* This was really a NUL. */
| 			*(yy_c_buf_p) = '\0';
| 
| 		else
| 			{ /* need more input */
| 			yy_size_t offset = (yy_c_buf_p) - (yytext_ptr);
| 			++(yy_c_buf_p);
| 
| 			switch ( yy_get_next_buffer(  ) )
| 				{
| 				case EOB_ACT_LAST_MATCH:
| 					/* This happens because yy_g_n_b()
| 					 * sees that we've accumulated a
| 					 * token and flags that we need to
| 					 * try matching the token before
| 					 * proceeding.  But for input(),
| 					 * there's no matching to consider.
| 					 * So convert the EOB_ACT_LAST_MATCH
| 					 * to EOB_ACT_END_OF_FILE.
| 					 */
| 
| 					/* Reset buffer status. */
| 					yyrestart(yyin );
| 
| 					/*FALLTHROUGH*/
| 
| 				case EOB_ACT_END_OF_FILE:
| 					{
| 					if ( yywrap( ) )
| 						return EOF;
| 
| 					if ( ! (yy_did_buffer_switch_on_eof) )
| 						YY_NEW_FILE;
| #ifdef __cplusplus
| 					return yyinput();
| #else
| 					return input();
| #endif
| 					}
| 
| 				case EOB_ACT_CONTINUE_SCAN:
| 					(yy_c_buf_p) = (yytext_ptr) + offset;
| 					break;
| 				}
| 			}
| 		}
| 
| 	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
| 	*(yy_c_buf_p) = '\0';	/* preserve yytext */
| 	(yy_hold_char) = *++(yy_c_buf_p);
| 
| 	return c;
| }
| #endif	/* ifndef YY_NO_INPUT */
| 
| /** Immediately switch to a different input stream.
|  * @param input_file A readable stream.
|  * 
|  * @note This function does not reset the start condition to @c INITIAL .
|  */
|     void yyrestart  (FILE * input_file )
| {
|     
| 	if ( ! YY_CURRENT_BUFFER ){
|         yyensure_buffer_stack ();
| 		YY_CURRENT_BUFFER_LVALUE =
|             yy_create_buffer(yyin,YY_BUF_SIZE );
| 	}
| 
| 	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
| 	yy_load_buffer_state( );
| }
| 
| /** Switch to a different input buffer.
|  * @param new_buffer The new input buffer.
|  * 
|  */
|     void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
| {
|     
| 	/* TODO. We should be able to replace this entire function body
| 	 * with
| 	 *		yypop_buffer_state();
| 	 *		yypush_buffer_state(new_buffer);
|      */
| 	yyensure_buffer_stack ();
| 	if ( YY_CURRENT_BUFFER == new_buffer )
| 		return;
| 
| 	if ( YY_CURRENT_BUFFER )
| 		{
| 		/* Flush out information for old buffer. */
| 		*(yy_c_buf_p) = (yy_hold_char);
| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
| 	yy_load_buffer_state( );
| 
| 	/* We don't actually know whether we did this switch during
| 	 * EOF (yywrap()) processing, but the only time this flag
| 	 * is looked at is after yywrap() is called, so it's safe
| 	 * to go ahead and always set it.
| 	 */
| 	(yy_did_buffer_switch_on_eof) = 1;
| }
| 
| static void yy_load_buffer_state  (void)
| {
|     	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
| 	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
| 	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
| 	(yy_hold_char) = *(yy_c_buf_p);
| }
| 
| /** Allocate and initialize an input buffer state.
|  * @param file A readable stream.
|  * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
|  * 
|  * @return the allocated buffer state.
|  */
|     YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
| {
| 	YY_BUFFER_STATE b;
|     
| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_buf_size = size;
| 
| 	/* yy_ch_buf has to be 2 characters longer than the size given because
| 	 * we need to put in 2 end-of-buffer characters.
| 	 */
| 	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
| 	if ( ! b->yy_ch_buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_is_our_buffer = 1;
| 
| 	yy_init_buffer(b,file );
| 
| 	return b;
| }
| 
| /** Destroy the buffer.
|  * @param b a buffer created with yy_create_buffer()
|  * 
|  */
|     void yy_delete_buffer (YY_BUFFER_STATE  b )
| {
|     
| 	if ( ! b )
| 		return;
| 
| 	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
| 		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
| 
| 	if ( b->yy_is_our_buffer )
| 		yyfree((void *) b->yy_ch_buf  );
| 
| 	yyfree((void *) b  );
| }
| 
| /* Initializes or reinitializes a buffer.
|  * This function is sometimes called more than once on the same buffer,
|  * such as during a yyrestart() or at EOF.
|  */
|     static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
| 
| {
| 	int oerrno = errno;
|     
| 	yy_flush_buffer(b );
| 
| 	b->yy_input_file = file;
| 	b->yy_fill_buffer = 1;
| 
|     /* If b is the current buffer, then yy_init_buffer was _probably_
|      * called from yyrestart() or through yy_get_next_buffer.
|      * In that case, we don't want to reset the lineno or column.
|      */
|     if (b != YY_CURRENT_BUFFER){
|         b->yy_bs_lineno = 1;
|         b->yy_bs_column = 0;
|     }
| 
|         b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
|     
| 	errno = oerrno;
| }
| 
| /** Discard all buffered characters. On the next scan, YY_INPUT will be called.
|  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
|  * 
|  */
|     void yy_flush_buffer (YY_BUFFER_STATE  b )
| {
|     	if ( ! b )
| 		return;
| 
| 	b->yy_n_chars = 0;
| 
| 	/* We always need two end-of-buffer characters.  The first causes
| 	 * a transition to the end-of-buffer state.  The second causes
| 	 * a jam in that state.
| 	 */
| 	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
| 	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b->yy_buf_pos = &b->yy_ch_buf[0];
| 
| 	b->yy_at_bol = 1;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	if ( b == YY_CURRENT_BUFFER )
| 		yy_load_buffer_state( );
| }
| 
| /** Pushes the new state onto the stack. The new state becomes
|  *  the current state. This function will allocate the stack
|  *  if necessary.
|  *  @param new_buffer The new state.
|  *  
|  */
| void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
| {
|     	if (new_buffer == NULL)
| 		return;
| 
| 	yyensure_buffer_stack();
| 
| 	/* This block is copied from yy_switch_to_buffer. */
| 	if ( YY_CURRENT_BUFFER )
| 		{
| 		/* Flush out information for old buffer. */
| 		*(yy_c_buf_p) = (yy_hold_char);
| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	/* Only push if top exists. Otherwise, replace top. */
| 	if (YY_CURRENT_BUFFER)
| 		(yy_buffer_stack_top)++;
| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
| 
| 	/* copied from yy_switch_to_buffer. */
| 	yy_load_buffer_state( );
| 	(yy_did_buffer_switch_on_eof) = 1;
| }
| 
| /** Removes and deletes the top of the stack, if present.
|  *  The next element becomes the new top.
|  *  
|  */
| void yypop_buffer_state (void)
| {
|     	if (!YY_CURRENT_BUFFER)
| 		return;
| 
| 	yy_delete_buffer(YY_CURRENT_BUFFER );
| 	YY_CURRENT_BUFFER_LVALUE = NULL;
| 	if ((yy_buffer_stack_top) > 0)
| 		--(yy_buffer_stack_top);
| 
| 	if (YY_CURRENT_BUFFER) {
| 		yy_load_buffer_state( );
| 		(yy_did_buffer_switch_on_eof) = 1;
| 	}
| }
| 
| /* Allocates the stack if it does not exist.
|  *  Guarantees space for at least one push.
|  */
| static void yyensure_buffer_stack (void)
| {
| 	yy_size_t num_to_alloc;
|     
| 	if (!(yy_buffer_stack)) {
| 
| 		/* First allocation is just for 2 elements, since we don't know if this
| 		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
| 		 * immediate realloc on the next call.
|          */
| 		num_to_alloc = 1;
| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
| 								(num_to_alloc * sizeof(struct yy_buffer_state*)
| 								);
| 		if ( ! (yy_buffer_stack) )
| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
| 								  
| 		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
| 				
| 		(yy_buffer_stack_max) = num_to_alloc;
| 		(yy_buffer_stack_top) = 0;
| 		return;
| 	}
| 
| 	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
| 
| 		/* Increase the buffer to prepare for a possible push. */
| 		int grow_size = 8 /* arbitrary grow size */;
| 
| 		num_to_alloc = (yy_buffer_stack_max) + grow_size;
| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
| 								((yy_buffer_stack),
| 								num_to_alloc * sizeof(struct yy_buffer_state*)
| 								);
| 		if ( ! (yy_buffer_stack) )
| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
| 
| 		/* zero only the new slots.*/
| 		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
| 		(yy_buffer_stack_max) = num_to_alloc;
| 	}
| }
| 
| /** Setup the input buffer state to scan directly from a user-specified character buffer.
|  * @param base the character buffer
|  * @param size the size in bytes of the character buffer
|  * 
|  * @return the newly allocated buffer state object. 
|  */
| YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
| {
| 	YY_BUFFER_STATE b;
|     
| 	if ( size < 2 ||
| 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
| 	     base[size-1] != YY_END_OF_BUFFER_CHAR )
| 		/* They forgot to leave room for the EOB's. */
| 		return 0;
| 
| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
| 
| 	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
| 	b->yy_buf_pos = b->yy_ch_buf = base;
| 	b->yy_is_our_buffer = 0;
| 	b->yy_input_file = 0;
| 	b->yy_n_chars = b->yy_buf_size;
| 	b->yy_is_interactive = 0;
| 	b->yy_at_bol = 1;
| 	b->yy_fill_buffer = 0;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	yy_switch_to_buffer(b  );
| 
| 	return b;
| }
| 
| /** Setup the input buffer state to scan a string. The next call to yylex() will
|  * scan from a @e copy of @a str.
|  * @param yystr a NUL-terminated string to scan
|  * 
|  * @return the newly allocated buffer state object.
|  * @note If you want to scan bytes that may contain NUL values, then use
|  *       yy_scan_bytes() instead.
|  */
| YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
| {
|     
| 	return yy_scan_bytes(yystr,strlen(yystr) );
| }
| 
| /** Setup the input buffer state to scan the given bytes. The next call to yylex() will
|  * scan from a @e copy of @a bytes.
|  * @param yybytes the byte buffer to scan
|  * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
|  * 
|  * @return the newly allocated buffer state object.
|  */
| YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len )
| {
| 	YY_BUFFER_STATE b;
| 	char *buf;
| 	yy_size_t n;
| 	yy_size_t i;
|     
| 	/* Get memory for full buffer, including space for trailing EOB's. */
| 	n = _yybytes_len + 2;
| 	buf = (char *) yyalloc(n  );
| 	if ( ! buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
| 
| 	for ( i = 0; i < _yybytes_len; ++i )
| 		buf[i] = yybytes[i];
| 
| 	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b = yy_scan_buffer(buf,n );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
| 
| 	/* It's okay to grow etc. this buffer, and we should throw it
| 	 * away when we're done.
| 	 */
| 	b->yy_is_our_buffer = 1;
| 
| 	return b;
| }
| 
| #ifndef YY_EXIT_FAILURE
| #define YY_EXIT_FAILURE 2
| #endif
| 
| static void yy_fatal_error (yyconst char* msg )
| {
|     	(void) fprintf( stderr, "%s\n", msg );
| 	exit( YY_EXIT_FAILURE );
| }
| 
| /* Redefine yyless() so it works in section 3 code. */
| 
| #undef yyless
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
|         int yyless_macro_arg = (n); \
|         YY_LESS_LINENO(yyless_macro_arg);\
| 		yytext[yyleng] = (yy_hold_char); \
| 		(yy_c_buf_p) = yytext + yyless_macro_arg; \
| 		(yy_hold_char) = *(yy_c_buf_p); \
| 		*(yy_c_buf_p) = '\0'; \
| 		yyleng = yyless_macro_arg; \
| 		} \
| 	while ( 0 )
| 
| /* Accessor  methods (get/set functions) to struct members. */
| 
| /** Get the current line number.
|  * 
|  */
| int yyget_lineno  (void)
| {
|         
|     return yylineno;
| }
| 
| /** Get the input stream.
|  * 
|  */
| FILE *yyget_in  (void)
| {
|         return yyin;
| }
| 
| /** Get the output stream.
|  * 
|  */
| FILE *yyget_out  (void)
| {
|         return yyout;
| }
| 
| /** Get the length of the current token.
|  * 
|  */
| yy_size_t yyget_leng  (void)
| {
|         return yyleng;
| }
| 
| /** Get the current token.
|  * 
|  */
| 
| char *yyget_text  (void)
| {
|         return yytext;
| }
| 
| /** Set the current line number.
|  * @param line_number
|  * 
|  */
| void yyset_lineno (int  line_number )
| {
|     
|     yylineno = line_number;
| }
| 
| /** Set the input stream. This does not discard the current
|  * input buffer.
|  * @param in_str A readable stream.
|  * 
|  * @see yy_switch_to_buffer
|  */
| void yyset_in (FILE *  in_str )
| {
|         yyin = in_str ;
| }
| 
| void yyset_out (FILE *  out_str )
| {
|         yyout = out_str ;
| }
| 
| int yyget_debug  (void)
| {
|         return yy_flex_debug;
| }
| 
| void yyset_debug (int  bdebug )
| {
|         yy_flex_debug = bdebug ;
| }
| 
| static int yy_init_globals (void)
| {
|         /* Initialization is the same as for the non-reentrant scanner.
|      * This function is called from yylex_destroy(), so don't allocate here.
|      */
| 
|     (yy_buffer_stack) = 0;
|     (yy_buffer_stack_top) = 0;
|     (yy_buffer_stack_max) = 0;
|     (yy_c_buf_p) = (char *) 0;
|     (yy_init) = 0;
|     (yy_start) = 0;
| 
|     (yy_state_buf) = 0;
|     (yy_state_ptr) = 0;
|     (yy_full_match) = 0;
|     (yy_lp) = 0;
| 
| /* Defined in main.c */
| #ifdef YY_STDINIT
|     yyin = stdin;
|     yyout = stdout;
| #else
|     yyin = (FILE *) 0;
|     yyout = (FILE *) 0;
| #endif
| 
|     /* For future reference: Set errno on error, since we are called by
|      * yylex_init()
|      */
|     return 0;
| }
| 
| /* yylex_destroy is for both reentrant and non-reentrant scanners. */
| int yylex_destroy  (void)
| {
|     
|     /* Pop the buffer stack, destroying each element. */
| 	while(YY_CURRENT_BUFFER){
| 		yy_delete_buffer(YY_CURRENT_BUFFER  );
| 		YY_CURRENT_BUFFER_LVALUE = NULL;
| 		yypop_buffer_state();
| 	}
| 
| 	/* Destroy the stack itself. */
| 	yyfree((yy_buffer_stack) );
| 	(yy_buffer_stack) = NULL;
| 
|     yyfree ( (yy_state_buf) );
|     (yy_state_buf)  = NULL;
| 
|     /* Reset the globals. This is important in a non-reentrant scanner so the next time
|      * yylex() is called, initialization will occur. */
|     yy_init_globals( );
| 
|     return 0;
| }
| 
| /*
|  * Internal utility routines.
|  */
| 
| #ifndef yytext_ptr
| static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
| {
| 	register int i;
| 	for ( i = 0; i < n; ++i )
| 		s1[i] = s2[i];
| }
| #endif
| 
| #ifdef YY_NEED_STRLEN
| static int yy_flex_strlen (yyconst char * s )
| {
| 	register int n;
| 	for ( n = 0; s[n]; ++n )
| 		;
| 
| 	return n;
| }
| #endif
| 
| void *yyalloc (yy_size_t  size )
| {
| 	return (void *) malloc( size );
| }
| 
| void *yyrealloc  (void * ptr, yy_size_t  size )
| {
| 	/* The cast to (char *) in the following accommodates both
| 	 * implementations that use char* generic pointers, and those
| 	 * that use void* generic pointers.  It works with the latter
| 	 * because both ANSI C and C++ allow castless assignment from
| 	 * any pointer type to void*, and deal with argument conversions
| 	 * as though doing an assignment.
| 	 */
| 	return (void *) realloc( (char *) ptr, size );
| }
| 
| void yyfree (void * ptr )
| {
| 	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
| }
| 
| #define YYTABLES_NAME "yytables"
| 
| #line 9 "conftest.l"
| 
| 
| #ifdef YYTEXT_POINTER
| extern char *yytext;
| #endif
| int
| main (void)
| {
|   return ! yylex () + ! yywrap ();
| }
configure:16181: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c -ll  >&5
/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld: error: cannot find -ll
/tmp/ccKCGwKZ.o:conftest.c:function yylex: error: undefined reference to 'yywrap'
/tmp/ccKCGwKZ.o:conftest.c:function input: error: undefined reference to 'yywrap'
/tmp/ccKCGwKZ.o:conftest.c:function main: error: undefined reference to 'yywrap'
collect2: error: ld returned 1 exit status
configure:16181: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "ld"
| #define PACKAGE_TARNAME "ld"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "ld 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "ld"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define GOT_HANDLING_DEFAULT GOT_HANDLING_TARGET_DEFAULT
| #define HAVE_LC_MESSAGES 1
| /* end confdefs.h.  */
| 
| #line 3 "lex.yy.c"
| 
| #define  YY_INT_ALIGNED short int
| 
| /* A lexical scanner generated by flex */
| 
| #define FLEX_SCANNER
| #define YY_FLEX_MAJOR_VERSION 2
| #define YY_FLEX_MINOR_VERSION 5
| #define YY_FLEX_SUBMINOR_VERSION 39
| #if YY_FLEX_SUBMINOR_VERSION > 0
| #define FLEX_BETA
| #endif
| 
| /* First, we deal with  platform-specific or compiler-specific issues. */
| 
| /* begin standard C headers. */
| #include <stdio.h>
| #include <string.h>
| #include <errno.h>
| #include <stdlib.h>
| 
| /* end standard C headers. */
| 
| /* flex integer type definitions */
| 
| #ifndef FLEXINT_H
| #define FLEXINT_H
| 
| /* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
| 
| #if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
| 
| /* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
|  * if you want the limit (max/min) macros for int types. 
|  */
| #ifndef __STDC_LIMIT_MACROS
| #define __STDC_LIMIT_MACROS 1
| #endif
| 
| #include <inttypes.h>
| typedef int8_t flex_int8_t;
| typedef uint8_t flex_uint8_t;
| typedef int16_t flex_int16_t;
| typedef uint16_t flex_uint16_t;
| typedef int32_t flex_int32_t;
| typedef uint32_t flex_uint32_t;
| #else
| typedef signed char flex_int8_t;
| typedef short int flex_int16_t;
| typedef int flex_int32_t;
| typedef unsigned char flex_uint8_t; 
| typedef unsigned short int flex_uint16_t;
| typedef unsigned int flex_uint32_t;
| 
| /* Limits of integral types. */
| #ifndef INT8_MIN
| #define INT8_MIN               (-128)
| #endif
| #ifndef INT16_MIN
| #define INT16_MIN              (-32767-1)
| #endif
| #ifndef INT32_MIN
| #define INT32_MIN              (-2147483647-1)
| #endif
| #ifndef INT8_MAX
| #define INT8_MAX               (127)
| #endif
| #ifndef INT16_MAX
| #define INT16_MAX              (32767)
| #endif
| #ifndef INT32_MAX
| #define INT32_MAX              (2147483647)
| #endif
| #ifndef UINT8_MAX
| #define UINT8_MAX              (255U)
| #endif
| #ifndef UINT16_MAX
| #define UINT16_MAX             (65535U)
| #endif
| #ifndef UINT32_MAX
| #define UINT32_MAX             (4294967295U)
| #endif
| 
| #endif /* ! C99 */
| 
| #endif /* ! FLEXINT_H */
| 
| #ifdef __cplusplus
| 
| /* The "const" storage-class-modifier is valid. */
| #define YY_USE_CONST
| 
| #else	/* ! __cplusplus */
| 
| /* C99 requires __STDC__ to be defined as 1. */
| #if defined (__STDC__)
| 
| #define YY_USE_CONST
| 
| #endif	/* defined (__STDC__) */
| #endif	/* ! __cplusplus */
| 
| #ifdef YY_USE_CONST
| #define yyconst const
| #else
| #define yyconst
| #endif
| 
| /* Returned upon end-of-file. */
| #define YY_NULL 0
| 
| /* Promotes a possibly negative, possibly signed char to an unsigned
|  * integer for use as an array index.  If the signed char is negative,
|  * we want to instead treat it as an 8-bit unsigned char, hence the
|  * double cast.
|  */
| #define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
| 
| /* Enter a start condition.  This macro really ought to take a parameter,
|  * but we do it the disgusting crufty way forced on us by the ()-less
|  * definition of BEGIN.
|  */
| #define BEGIN (yy_start) = 1 + 2 *
| 
| /* Translate the current start state into a value that can be later handed
|  * to BEGIN to return to the state.  The YYSTATE alias is for lex
|  * compatibility.
|  */
| #define YY_START (((yy_start) - 1) / 2)
| #define YYSTATE YY_START
| 
| /* Action number for EOF rule of a given start state. */
| #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
| 
| /* Special action meaning "start processing a new file". */
| #define YY_NEW_FILE yyrestart(yyin  )
| 
| #define YY_END_OF_BUFFER_CHAR 0
| 
| /* Size of default input buffer. */
| #ifndef YY_BUF_SIZE
| #define YY_BUF_SIZE 16384
| #endif
| 
| /* The state buf must be large enough to hold one state per character in the main buffer.
|  */
| #define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
| 
| #ifndef YY_TYPEDEF_YY_BUFFER_STATE
| #define YY_TYPEDEF_YY_BUFFER_STATE
| typedef struct yy_buffer_state *YY_BUFFER_STATE;
| #endif
| 
| #ifndef YY_TYPEDEF_YY_SIZE_T
| #define YY_TYPEDEF_YY_SIZE_T
| typedef size_t yy_size_t;
| #endif
| 
| extern yy_size_t yyleng;
| 
| extern FILE *yyin, *yyout;
| 
| #define EOB_ACT_CONTINUE_SCAN 0
| #define EOB_ACT_END_OF_FILE 1
| #define EOB_ACT_LAST_MATCH 2
| 
|     #define YY_LESS_LINENO(n)
|     #define YY_LINENO_REWIND_TO(ptr)
|     
| /* Return all but the first "n" matched characters back to the input stream. */
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
|         int yyless_macro_arg = (n); \
|         YY_LESS_LINENO(yyless_macro_arg);\
| 		*yy_cp = (yy_hold_char); \
| 		YY_RESTORE_YY_MORE_OFFSET \
| 		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
| 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
| 		} \
| 	while ( 0 )
| 
| #define unput(c) yyunput( c, (yytext_ptr)  )
| 
| #ifndef YY_STRUCT_YY_BUFFER_STATE
| #define YY_STRUCT_YY_BUFFER_STATE
| struct yy_buffer_state
| 	{
| 	FILE *yy_input_file;
| 
| 	char *yy_ch_buf;		/* input buffer */
| 	char *yy_buf_pos;		/* current position in input buffer */
| 
| 	/* Size of input buffer in bytes, not including room for EOB
| 	 * characters.
| 	 */
| 	yy_size_t yy_buf_size;
| 
| 	/* Number of characters read into yy_ch_buf, not including EOB
| 	 * characters.
| 	 */
| 	yy_size_t yy_n_chars;
| 
| 	/* Whether we "own" the buffer - i.e., we know we created it,
| 	 * and can realloc() it to grow it, and should free() it to
| 	 * delete it.
| 	 */
| 	int yy_is_our_buffer;
| 
| 	/* Whether this is an "interactive" input source; if so, and
| 	 * if we're using stdio for input, then we want to use getc()
| 	 * instead of fread(), to make sure we stop fetching input after
| 	 * each newline.
| 	 */
| 	int yy_is_interactive;
| 
| 	/* Whether we're considered to be at the beginning of a line.
| 	 * If so, '^' rules will be active on the next match, otherwise
| 	 * not.
| 	 */
| 	int yy_at_bol;
| 
|     int yy_bs_lineno; /**< The line count. */
|     int yy_bs_column; /**< The column count. */
|     
| 	/* Whether to try to fill the input buffer when we reach the
| 	 * end of it.
| 	 */
| 	int yy_fill_buffer;
| 
| 	int yy_buffer_status;
| 
| #define YY_BUFFER_NEW 0
| #define YY_BUFFER_NORMAL 1
| 	/* When an EOF's been seen but there's still some text to process
| 	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
| 	 * shouldn't try reading from the input source any more.  We might
| 	 * still have a bunch of tokens to match, though, because of
| 	 * possible backing-up.
| 	 *
| 	 * When we actually see the EOF, we change the status to "new"
| 	 * (via yyrestart()), so that the user can continue scanning by
| 	 * just pointing yyin at a new input file.
| 	 */
| #define YY_BUFFER_EOF_PENDING 2
| 
| 	};
| #endif /* !YY_STRUCT_YY_BUFFER_STATE */
| 
| /* Stack of input buffers. */
| static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
| static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
| static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
| 
| /* We provide macros for accessing buffer states in case in the
|  * future we want to put the buffer states in a more general
|  * "scanner state".
|  *
|  * Returns the top of the stack, or NULL.
|  */
| #define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
|                           ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
|                           : NULL)
| 
| /* Same as previous macro, but useful when we know that the buffer stack is not
|  * NULL or when we need an lvalue. For internal use only.
|  */
| #define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
| 
| /* yy_hold_char holds the character lost when yytext is formed. */
| static char yy_hold_char;
| static yy_size_t yy_n_chars;		/* number of characters read into yy_ch_buf */
| yy_size_t yyleng;
| 
| /* Points to current character in buffer. */
| static char *yy_c_buf_p = (char *) 0;
| static int yy_init = 0;		/* whether we need to initialize */
| static int yy_start = 0;	/* start state number */
| 
| /* Flag which is used to allow yywrap()'s to do buffer switches
|  * instead of setting up a fresh yyin.  A bit of a hack ...
|  */
| static int yy_did_buffer_switch_on_eof;
| 
| void yyrestart (FILE *input_file  );
| void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
| YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
| void yy_delete_buffer (YY_BUFFER_STATE b  );
| void yy_flush_buffer (YY_BUFFER_STATE b  );
| void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
| void yypop_buffer_state (void );
| 
| static void yyensure_buffer_stack (void );
| static void yy_load_buffer_state (void );
| static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
| 
| #define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
| 
| YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
| YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
| YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,yy_size_t len  );
| 
| void *yyalloc (yy_size_t  );
| void *yyrealloc (void *,yy_size_t  );
| void yyfree (void *  );
| 
| #define yy_new_buffer yy_create_buffer
| 
| #define yy_set_interactive(is_interactive) \
| 	{ \
| 	if ( ! YY_CURRENT_BUFFER ){ \
|         yyensure_buffer_stack (); \
| 		YY_CURRENT_BUFFER_LVALUE =    \
|             yy_create_buffer(yyin,YY_BUF_SIZE ); \
| 	} \
| 	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
| 	}
| 
| #define yy_set_bol(at_bol) \
| 	{ \
| 	if ( ! YY_CURRENT_BUFFER ){\
|         yyensure_buffer_stack (); \
| 		YY_CURRENT_BUFFER_LVALUE =    \
|             yy_create_buffer(yyin,YY_BUF_SIZE ); \
| 	} \
| 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
| 	}
| 
| #define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
| 
| /* Begin user sect3 */
| 
| typedef unsigned char YY_CHAR;
| 
| FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
| 
| typedef int yy_state_type;
| 
| extern int yylineno;
| 
| int yylineno = 1;
| 
| extern char *yytext;
| #define yytext_ptr yytext
| 
| static yy_state_type yy_get_previous_state (void );
| static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
| static int yy_get_next_buffer (void );
| static void yy_fatal_error (yyconst char msg[]  );
| 
| /* Done after the current pattern has been matched and before the
|  * corresponding action - sets up yytext.
|  */
| #define YY_DO_BEFORE_ACTION \
| 	(yytext_ptr) = yy_bp; \
| 	(yytext_ptr) -= (yy_more_len); \
| 	yyleng = (size_t) (yy_cp - (yytext_ptr)); \
| 	(yy_hold_char) = *yy_cp; \
| 	*yy_cp = '\0'; \
| 	(yy_c_buf_p) = yy_cp;
| 
| #define YY_NUM_RULES 8
| #define YY_END_OF_BUFFER 9
| /* This struct is not used in this scanner,
|    but its presence is necessary. */
| struct yy_trans_info
| 	{
| 	flex_int32_t yy_verify;
| 	flex_int32_t yy_nxt;
| 	};
| static yyconst flex_int16_t yy_acclist[23] =
|     {   0,
|         9,    7,    8,    8,    1,    7,    8,    2,    7,    8,
|         3,    7,    8,    4,    7,    8,    5,    7,    8,    6,
|         7,    8
|     } ;
| 
| static yyconst flex_int16_t yy_accept[14] =
|     {   0,
|         1,    1,    1,    2,    4,    5,    8,   11,   14,   17,
|        20,   23,   23
|     } ;
| 
| static yyconst flex_int32_t yy_ec[256] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    3,    4,    5,    6,
| 
|         7,    8,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| 
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1
|     } ;
| 
| static yyconst flex_int32_t yy_meta[9] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1
|     } ;
| 
| static yyconst flex_int16_t yy_base[13] =
|     {   0,
|         0,    0,    9,   10,   10,   10,   10,   10,   10,   10,
|        10,   10
|     } ;
| 
| static yyconst flex_int16_t yy_def[13] =
|     {   0,
|        12,    1,   12,   12,   12,   12,   12,   12,   12,   12,
|        12,    0
|     } ;
| 
| static yyconst flex_int16_t yy_nxt[19] =
|     {   0,
|         4,    5,    6,    7,    8,    9,   10,   11,   12,    3,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| static yyconst flex_int16_t yy_chk[19] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    3,   12,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| extern int yy_flex_debug;
| int yy_flex_debug = 0;
| 
| static yy_state_type *yy_state_buf=0, *yy_state_ptr=0;
| static char *yy_full_match;
| static int yy_lp;
| #define REJECT \
| { \
| *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */ \
| yy_cp = (yy_full_match); /* restore poss. backed-over text */ \
| ++(yy_lp); \
| goto find_rule; \
| }
| 
| static int yy_more_flag = 0;
| static int yy_more_len = 0;
| #define yymore() ((yy_more_flag) = 1)
| #define YY_MORE_ADJ (yy_more_len)
| #define YY_RESTORE_YY_MORE_OFFSET
| char *yytext;
| #line 1 "conftest.l"
| #line 470 "lex.yy.c"
| 
| #define INITIAL 0
| 
| #ifndef YY_NO_UNISTD_H
| /* Special case for "unistd.h", since it is non-ANSI. We include it way
|  * down here because we want the user's section 1 to have been scanned first.
|  * The user has a chance to override it with an option.
|  */
| #include <unistd.h>
| #endif
| 
| #ifndef YY_EXTRA_TYPE
| #define YY_EXTRA_TYPE void *
| #endif
| 
| static int yy_init_globals (void );
| 
| /* Accessor methods to globals.
|    These are made visible to non-reentrant scanners for convenience. */
| 
| int yylex_destroy (void );
| 
| int yyget_debug (void );
| 
| void yyset_debug (int debug_flag  );
| 
| YY_EXTRA_TYPE yyget_extra (void );
| 
| void yyset_extra (YY_EXTRA_TYPE user_defined  );
| 
| FILE *yyget_in (void );
| 
| void yyset_in  (FILE * in_str  );
| 
| FILE *yyget_out (void );
| 
| void yyset_out  (FILE * out_str  );
| 
| yy_size_t yyget_leng (void );
| 
| char *yyget_text (void );
| 
| int yyget_lineno (void );
| 
| void yyset_lineno (int line_number  );
| 
| /* Macros after this point can all be overridden by user definitions in
|  * section 1.
|  */
| 
| #ifndef YY_SKIP_YYWRAP
| #ifdef __cplusplus
| extern "C" int yywrap (void );
| #else
| extern int yywrap (void );
| #endif
| #endif
| 
|     static void yyunput (int c,char *buf_ptr  );
|     
| #ifndef yytext_ptr
| static void yy_flex_strncpy (char *,yyconst char *,int );
| #endif
| 
| #ifdef YY_NEED_STRLEN
| static int yy_flex_strlen (yyconst char * );
| #endif
| 
| #ifndef YY_NO_INPUT
| 
| #ifdef __cplusplus
| static int yyinput (void );
| #else
| static int input (void );
| #endif
| 
| #endif
| 
| /* Amount of stuff to slurp up with each read. */
| #ifndef YY_READ_BUF_SIZE
| #define YY_READ_BUF_SIZE 8192
| #endif
| 
| /* Copy whatever the last rule matched to the standard output. */
| #ifndef ECHO
| /* This used to be an fputs(), but since the string might contain NUL's,
|  * we now use fwrite().
|  */
| #define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
| #endif
| 
| /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
|  * is returned in "result".
|  */
| #ifndef YY_INPUT
| #define YY_INPUT(buf,result,max_size) \
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
| 		{ \
| 		int c = '*'; \
| 		size_t n; \
| 		for ( n = 0; n < max_size && \
| 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
| 			buf[n] = (char) c; \
| 		if ( c == '\n' ) \
| 			buf[n++] = (char) c; \
| 		if ( c == EOF && ferror( yyin ) ) \
| 			YY_FATAL_ERROR( "input in flex scanner failed" ); \
| 		result = n; \
| 		} \
| 	else \
| 		{ \
| 		errno=0; \
| 		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
| 			{ \
| 			if( errno != EINTR) \
| 				{ \
| 				YY_FATAL_ERROR( "input in flex scanner failed" ); \
| 				break; \
| 				} \
| 			errno=0; \
| 			clearerr(yyin); \
| 			} \
| 		}\
| \
| 
| #endif
| 
| /* No semi-colon after return; correct usage is to write "yyterminate();" -
|  * we don't want an extra ';' after the "return" because that will cause
|  * some compilers to complain about unreachable statements.
|  */
| #ifndef yyterminate
| #define yyterminate() return YY_NULL
| #endif
| 
| /* Number of entries by which start-condition stack grows. */
| #ifndef YY_START_STACK_INCR
| #define YY_START_STACK_INCR 25
| #endif
| 
| /* Report a fatal error. */
| #ifndef YY_FATAL_ERROR
| #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
| #endif
| 
| /* end tables serialization structures and prototypes */
| 
| /* Default declaration of generated scanner - a define so the user can
|  * easily add parameters.
|  */
| #ifndef YY_DECL
| #define YY_DECL_IS_OURS 1
| 
| extern int yylex (void);
| 
| #define YY_DECL int yylex (void)
| #endif /* !YY_DECL */
| 
| /* Code executed at the beginning of each rule, after yytext and yyleng
|  * have been set up.
|  */
| #ifndef YY_USER_ACTION
| #define YY_USER_ACTION
| #endif
| 
| /* Code executed at the end of each rule. */
| #ifndef YY_BREAK
| #define YY_BREAK break;
| #endif
| 
| #define YY_RULE_SETUP \
| 	YY_USER_ACTION
| 
| /** The main scanner function which does all the work.
|  */
| YY_DECL
| {
| 	register yy_state_type yy_current_state;
| 	register char *yy_cp, *yy_bp;
| 	register int yy_act;
|     
| 	if ( !(yy_init) )
| 		{
| 		(yy_init) = 1;
| 
| #ifdef YY_USER_INIT
| 		YY_USER_INIT;
| #endif
| 
|         /* Create the reject buffer large enough to save one state per allowed character. */
|         if ( ! (yy_state_buf) )
|             (yy_state_buf) = (yy_state_type *)yyalloc(YY_STATE_BUF_SIZE  );
|             if ( ! (yy_state_buf) )
|                 YY_FATAL_ERROR( "out of dynamic memory in yylex()" );
| 
| 		if ( ! (yy_start) )
| 			(yy_start) = 1;	/* first start state */
| 
| 		if ( ! yyin )
| 			yyin = stdin;
| 
| 		if ( ! yyout )
| 			yyout = stdout;
| 
| 		if ( ! YY_CURRENT_BUFFER ) {
| 			yyensure_buffer_stack ();
| 			YY_CURRENT_BUFFER_LVALUE =
| 				yy_create_buffer(yyin,YY_BUF_SIZE );
| 		}
| 
| 		yy_load_buffer_state( );
| 		}
| 
| 	{
| #line 1 "conftest.l"
| 
| #line 687 "lex.yy.c"
| 
| 	while ( 1 )		/* loops until end-of-file is reached */
| 		{
| 		(yy_more_len) = 0;
| 		if ( (yy_more_flag) )
| 			{
| 			(yy_more_len) = (yy_c_buf_p) - (yytext_ptr);
| 			(yy_more_flag) = 0;
| 			}
| 		yy_cp = (yy_c_buf_p);
| 
| 		/* Support of yytext. */
| 		*yy_cp = (yy_hold_char);
| 
| 		/* yy_bp points to the position in yy_ch_buf of the start of
| 		 * the current run.
| 		 */
| 		yy_bp = yy_cp;
| 
| 		yy_current_state = (yy_start);
| 
| 		(yy_state_ptr) = (yy_state_buf);
| 		*(yy_state_ptr)++ = yy_current_state;
| 
| yy_match:
| 		do
| 			{
| 			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
| 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 				{
| 				yy_current_state = (int) yy_def[yy_current_state];
| 				if ( yy_current_state >= 13 )
| 					yy_c = yy_meta[(unsigned int) yy_c];
| 				}
| 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 			*(yy_state_ptr)++ = yy_current_state;
| 			++yy_cp;
| 			}
| 		while ( yy_base[yy_current_state] != 10 );
| 
| yy_find_action:
| 		yy_current_state = *--(yy_state_ptr);
| 		(yy_lp) = yy_accept[yy_current_state];
| find_rule: /* we branch to this label when backing up */
| 		for ( ; ; ) /* until we find what rule we matched */
| 			{
| 			if ( (yy_lp) && (yy_lp) < yy_accept[yy_current_state + 1] )
| 				{
| 				yy_act = yy_acclist[(yy_lp)];
| 					{
| 					(yy_full_match) = yy_cp;
| 					break;
| 					}
| 				}
| 			--yy_cp;
| 			yy_current_state = *--(yy_state_ptr);
| 			(yy_lp) = yy_accept[yy_current_state];
| 			}
| 
| 		YY_DO_BEFORE_ACTION;
| 
| do_action:	/* This label is used only to access EOF actions. */
| 
| 		switch ( yy_act )
| 	{ /* beginning of action switch */
| case 1:
| YY_RULE_SETUP
| #line 2 "conftest.l"
| { ECHO; }
| 	YY_BREAK
| case 2:
| YY_RULE_SETUP
| #line 3 "conftest.l"
| { REJECT; }
| 	YY_BREAK
| case 3:
| YY_RULE_SETUP
| #line 4 "conftest.l"
| { yymore (); }
| 	YY_BREAK
| case 4:
| YY_RULE_SETUP
| #line 5 "conftest.l"
| { yyless (1); }
| 	YY_BREAK
| case 5:
| YY_RULE_SETUP
| #line 6 "conftest.l"
| { yyless (input () != 0); }
| 	YY_BREAK
| case 6:
| YY_RULE_SETUP
| #line 7 "conftest.l"
| { unput (yytext[0]); }
| 	YY_BREAK
| case 7:
| YY_RULE_SETUP
| #line 8 "conftest.l"
| { BEGIN INITIAL; }
| 	YY_BREAK
| case 8:
| YY_RULE_SETUP
| #line 9 "conftest.l"
| ECHO;
| 	YY_BREAK
| #line 793 "lex.yy.c"
| 			case YY_STATE_EOF(INITIAL):
| 				yyterminate();
| 
| 	case YY_END_OF_BUFFER:
| 		{
| 		/* Amount of text matched not including the EOB char. */
| 		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
| 
| 		/* Undo the effects of YY_DO_BEFORE_ACTION. */
| 		*yy_cp = (yy_hold_char);
| 		YY_RESTORE_YY_MORE_OFFSET
| 
| 		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
| 			{
| 			/* We're scanning a new file or input source.  It's
| 			 * possible that this happened because the user
| 			 * just pointed yyin at a new source and called
| 			 * yylex().  If so, then we have to assure
| 			 * consistency between YY_CURRENT_BUFFER and our
| 			 * globals.  Here is the right place to do so, because
| 			 * this is the first action (other than possibly a
| 			 * back-up) that will match for the new input source.
| 			 */
| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
| 			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
| 			}
| 
| 		/* Note that here we test for yy_c_buf_p "<=" to the position
| 		 * of the first EOB in the buffer, since yy_c_buf_p will
| 		 * already have been incremented past the NUL character
| 		 * (since all states make transitions on EOB to the
| 		 * end-of-buffer state).  Contrast this with the test
| 		 * in input().
| 		 */
| 		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
| 			{ /* This was really a NUL. */
| 			yy_state_type yy_next_state;
| 
| 			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
| 
| 			yy_current_state = yy_get_previous_state(  );
| 
| 			/* Okay, we're now positioned to make the NUL
| 			 * transition.  We couldn't have
| 			 * yy_get_previous_state() go ahead and do it
| 			 * for us because it doesn't know how to deal
| 			 * with the possibility of jamming (and we don't
| 			 * want to build jamming into it because then it
| 			 * will run more slowly).
| 			 */
| 
| 			yy_next_state = yy_try_NUL_trans( yy_current_state );
| 
| 			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 
| 			if ( yy_next_state )
| 				{
| 				/* Consume the NUL. */
| 				yy_cp = ++(yy_c_buf_p);
| 				yy_current_state = yy_next_state;
| 				goto yy_match;
| 				}
| 
| 			else
| 				{
| 				yy_cp = (yy_c_buf_p);
| 				goto yy_find_action;
| 				}
| 			}
| 
| 		else switch ( yy_get_next_buffer(  ) )
| 			{
| 			case EOB_ACT_END_OF_FILE:
| 				{
| 				(yy_did_buffer_switch_on_eof) = 0;
| 
| 				if ( yywrap( ) )
| 					{
| 					/* Note: because we've taken care in
| 					 * yy_get_next_buffer() to have set up
| 					 * yytext, we can now set up
| 					 * yy_c_buf_p so that if some total
| 					 * hoser (like flex itself) wants to
| 					 * call the scanner after we return the
| 					 * YY_NULL, it'll still work - another
| 					 * YY_NULL will get returned.
| 					 */
| 					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
| 
| 					yy_act = YY_STATE_EOF(YY_START);
| 					goto do_action;
| 					}
| 
| 				else
| 					{
| 					if ( ! (yy_did_buffer_switch_on_eof) )
| 						YY_NEW_FILE;
| 					}
| 				break;
| 				}
| 
| 			case EOB_ACT_CONTINUE_SCAN:
| 				(yy_c_buf_p) =
| 					(yytext_ptr) + yy_amount_of_matched_text;
| 
| 				yy_current_state = yy_get_previous_state(  );
| 
| 				yy_cp = (yy_c_buf_p);
| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 				goto yy_match;
| 
| 			case EOB_ACT_LAST_MATCH:
| 				(yy_c_buf_p) =
| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
| 
| 				yy_current_state = yy_get_previous_state(  );
| 
| 				yy_cp = (yy_c_buf_p);
| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 				goto yy_find_action;
| 			}
| 		break;
| 		}
| 
| 	default:
| 		YY_FATAL_ERROR(
| 			"fatal flex scanner internal error--no action found" );
| 	} /* end of action switch */
| 		} /* end of scanning one token */
| 	} /* end of user's declarations */
| } /* end of yylex */
| 
| /* yy_get_next_buffer - try to read in a new buffer
|  *
|  * Returns a code representing an action:
|  *	EOB_ACT_LAST_MATCH -
|  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
|  *	EOB_ACT_END_OF_FILE - end of file
|  */
| static int yy_get_next_buffer (void)
| {
|     	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
| 	register char *source = (yytext_ptr);
| 	register int number_to_move, i;
| 	int ret_val;
| 
| 	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
| 		YY_FATAL_ERROR(
| 		"fatal flex scanner internal error--end of buffer missed" );
| 
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
| 		{ /* Don't try to fill the buffer, so this is an EOF. */
| 		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
| 			{
| 			/* We matched a single character, the EOB, so
| 			 * treat this as a final EOF.
| 			 */
| 			return EOB_ACT_END_OF_FILE;
| 			}
| 
| 		else
| 			{
| 			/* We matched some text prior to the EOB, first
| 			 * process it.
| 			 */
| 			return EOB_ACT_LAST_MATCH;
| 			}
| 		}
| 
| 	/* Try to read more data. */
| 
| 	/* First move last chars to start of buffer. */
| 	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
| 
| 	for ( i = 0; i < number_to_move; ++i )
| 		*(dest++) = *(source++);
| 
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
| 		/* don't do the read, it's not guaranteed to return an EOF,
| 		 * just force an EOF
| 		 */
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
| 
| 	else
| 		{
| 			yy_size_t num_to_read =
| 			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
| 
| 		while ( num_to_read <= 0 )
| 			{ /* Not enough room in the buffer - grow it. */
| 
| 			YY_FATAL_ERROR(
| "input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
| 
| 			}
| 
| 		if ( num_to_read > YY_READ_BUF_SIZE )
| 			num_to_read = YY_READ_BUF_SIZE;
| 
| 		/* Read in more data. */
| 		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
| 			(yy_n_chars), num_to_read );
| 
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	if ( (yy_n_chars) == 0 )
| 		{
| 		if ( number_to_move == YY_MORE_ADJ )
| 			{
| 			ret_val = EOB_ACT_END_OF_FILE;
| 			yyrestart(yyin  );
| 			}
| 
| 		else
| 			{
| 			ret_val = EOB_ACT_LAST_MATCH;
| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
| 				YY_BUFFER_EOF_PENDING;
| 			}
| 		}
| 
| 	else
| 		ret_val = EOB_ACT_CONTINUE_SCAN;
| 
| 	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
| 		/* Extend the array by 50%, plus the number we really need. */
| 		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
| 		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
| 		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
| 			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
| 	}
| 
| 	(yy_n_chars) += number_to_move;
| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
| 
| 	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
| 
| 	return ret_val;
| }
| 
| /* yy_get_previous_state - get the state just before the EOB char was reached */
| 
|     static yy_state_type yy_get_previous_state (void)
| {
| 	register yy_state_type yy_current_state;
| 	register char *yy_cp;
|     
| 	yy_current_state = (yy_start);
| 
| 	(yy_state_ptr) = (yy_state_buf);
| 	*(yy_state_ptr)++ = yy_current_state;
| 
| 	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
| 		{
| 		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
| 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 			{
| 			yy_current_state = (int) yy_def[yy_current_state];
| 			if ( yy_current_state >= 13 )
| 				yy_c = yy_meta[(unsigned int) yy_c];
| 			}
| 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 		*(yy_state_ptr)++ = yy_current_state;
| 		}
| 
| 	return yy_current_state;
| }
| 
| /* yy_try_NUL_trans - try to make a transition on the NUL character
|  *
|  * synopsis
|  *	next_state = yy_try_NUL_trans( current_state );
|  */
|     static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
| {
| 	register int yy_is_jam;
|     
| 	register YY_CHAR yy_c = 1;
| 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 		{
| 		yy_current_state = (int) yy_def[yy_current_state];
| 		if ( yy_current_state >= 13 )
| 			yy_c = yy_meta[(unsigned int) yy_c];
| 		}
| 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 	yy_is_jam = (yy_current_state == 12);
| 	if ( ! yy_is_jam )
| 		*(yy_state_ptr)++ = yy_current_state;
| 
| 		return yy_is_jam ? 0 : yy_current_state;
| }
| 
|     static void yyunput (int c, register char * yy_bp )
| {
| 	register char *yy_cp;
|     
|     yy_cp = (yy_c_buf_p);
| 
| 	/* undo effects of setting up yytext */
| 	*yy_cp = (yy_hold_char);
| 
| 	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
| 		{ /* need to shift things up to make room */
| 		/* +2 for EOB chars. */
| 		register yy_size_t number_to_move = (yy_n_chars) + 2;
| 		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
| 					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
| 		register char *source =
| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
| 
| 		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
| 			*--dest = *--source;
| 
| 		yy_cp += (int) (dest - source);
| 		yy_bp += (int) (dest - source);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
| 
| 		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
| 			YY_FATAL_ERROR( "flex scanner push-back overflow" );
| 		}
| 
| 	*--yy_cp = (char) c;
| 
| 	(yytext_ptr) = yy_bp;
| 	(yy_hold_char) = *yy_cp;
| 	(yy_c_buf_p) = yy_cp;
| }
| 
| #ifndef YY_NO_INPUT
| #ifdef __cplusplus
|     static int yyinput (void)
| #else
|     static int input  (void)
| #endif
| 
| {
| 	int c;
|     
| 	*(yy_c_buf_p) = (yy_hold_char);
| 
| 	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
| 		{
| 		/* yy_c_buf_p now points to the character we want to return.
| 		 * If this occurs *before* the EOB characters, then it's a
| 		 * valid NUL; if not, then we've hit the end of the buffer.
| 		 */
| 		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
| 			/* This was really a NUL. */
| 			*(yy_c_buf_p) = '\0';
| 
| 		else
| 			{ /* need more input */
| 			yy_size_t offset = (yy_c_buf_p) - (yytext_ptr);
| 			++(yy_c_buf_p);
| 
| 			switch ( yy_get_next_buffer(  ) )
| 				{
| 				case EOB_ACT_LAST_MATCH:
| 					/* This happens because yy_g_n_b()
| 					 * sees that we've accumulated a
| 					 * token and flags that we need to
| 					 * try matching the token before
| 					 * proceeding.  But for input(),
| 					 * there's no matching to consider.
| 					 * So convert the EOB_ACT_LAST_MATCH
| 					 * to EOB_ACT_END_OF_FILE.
| 					 */
| 
| 					/* Reset buffer status. */
| 					yyrestart(yyin );
| 
| 					/*FALLTHROUGH*/
| 
| 				case EOB_ACT_END_OF_FILE:
| 					{
| 					if ( yywrap( ) )
| 						return EOF;
| 
| 					if ( ! (yy_did_buffer_switch_on_eof) )
| 						YY_NEW_FILE;
| #ifdef __cplusplus
| 					return yyinput();
| #else
| 					return input();
| #endif
| 					}
| 
| 				case EOB_ACT_CONTINUE_SCAN:
| 					(yy_c_buf_p) = (yytext_ptr) + offset;
| 					break;
| 				}
| 			}
| 		}
| 
| 	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
| 	*(yy_c_buf_p) = '\0';	/* preserve yytext */
| 	(yy_hold_char) = *++(yy_c_buf_p);
| 
| 	return c;
| }
| #endif	/* ifndef YY_NO_INPUT */
| 
| /** Immediately switch to a different input stream.
|  * @param input_file A readable stream.
|  * 
|  * @note This function does not reset the start condition to @c INITIAL .
|  */
|     void yyrestart  (FILE * input_file )
| {
|     
| 	if ( ! YY_CURRENT_BUFFER ){
|         yyensure_buffer_stack ();
| 		YY_CURRENT_BUFFER_LVALUE =
|             yy_create_buffer(yyin,YY_BUF_SIZE );
| 	}
| 
| 	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
| 	yy_load_buffer_state( );
| }
| 
| /** Switch to a different input buffer.
|  * @param new_buffer The new input buffer.
|  * 
|  */
|     void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
| {
|     
| 	/* TODO. We should be able to replace this entire function body
| 	 * with
| 	 *		yypop_buffer_state();
| 	 *		yypush_buffer_state(new_buffer);
|      */
| 	yyensure_buffer_stack ();
| 	if ( YY_CURRENT_BUFFER == new_buffer )
| 		return;
| 
| 	if ( YY_CURRENT_BUFFER )
| 		{
| 		/* Flush out information for old buffer. */
| 		*(yy_c_buf_p) = (yy_hold_char);
| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
| 	yy_load_buffer_state( );
| 
| 	/* We don't actually know whether we did this switch during
| 	 * EOF (yywrap()) processing, but the only time this flag
| 	 * is looked at is after yywrap() is called, so it's safe
| 	 * to go ahead and always set it.
| 	 */
| 	(yy_did_buffer_switch_on_eof) = 1;
| }
| 
| static void yy_load_buffer_state  (void)
| {
|     	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
| 	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
| 	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
| 	(yy_hold_char) = *(yy_c_buf_p);
| }
| 
| /** Allocate and initialize an input buffer state.
|  * @param file A readable stream.
|  * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
|  * 
|  * @return the allocated buffer state.
|  */
|     YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
| {
| 	YY_BUFFER_STATE b;
|     
| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_buf_size = size;
| 
| 	/* yy_ch_buf has to be 2 characters longer than the size given because
| 	 * we need to put in 2 end-of-buffer characters.
| 	 */
| 	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
| 	if ( ! b->yy_ch_buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_is_our_buffer = 1;
| 
| 	yy_init_buffer(b,file );
| 
| 	return b;
| }
| 
| /** Destroy the buffer.
|  * @param b a buffer created with yy_create_buffer()
|  * 
|  */
|     void yy_delete_buffer (YY_BUFFER_STATE  b )
| {
|     
| 	if ( ! b )
| 		return;
| 
| 	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
| 		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
| 
| 	if ( b->yy_is_our_buffer )
| 		yyfree((void *) b->yy_ch_buf  );
| 
| 	yyfree((void *) b  );
| }
| 
| /* Initializes or reinitializes a buffer.
|  * This function is sometimes called more than once on the same buffer,
|  * such as during a yyrestart() or at EOF.
|  */
|     static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
| 
| {
| 	int oerrno = errno;
|     
| 	yy_flush_buffer(b );
| 
| 	b->yy_input_file = file;
| 	b->yy_fill_buffer = 1;
| 
|     /* If b is the current buffer, then yy_init_buffer was _probably_
|      * called from yyrestart() or through yy_get_next_buffer.
|      * In that case, we don't want to reset the lineno or column.
|      */
|     if (b != YY_CURRENT_BUFFER){
|         b->yy_bs_lineno = 1;
|         b->yy_bs_column = 0;
|     }
| 
|         b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
|     
| 	errno = oerrno;
| }
| 
| /** Discard all buffered characters. On the next scan, YY_INPUT will be called.
|  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
|  * 
|  */
|     void yy_flush_buffer (YY_BUFFER_STATE  b )
| {
|     	if ( ! b )
| 		return;
| 
| 	b->yy_n_chars = 0;
| 
| 	/* We always need two end-of-buffer characters.  The first causes
| 	 * a transition to the end-of-buffer state.  The second causes
| 	 * a jam in that state.
| 	 */
| 	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
| 	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b->yy_buf_pos = &b->yy_ch_buf[0];
| 
| 	b->yy_at_bol = 1;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	if ( b == YY_CURRENT_BUFFER )
| 		yy_load_buffer_state( );
| }
| 
| /** Pushes the new state onto the stack. The new state becomes
|  *  the current state. This function will allocate the stack
|  *  if necessary.
|  *  @param new_buffer The new state.
|  *  
|  */
| void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
| {
|     	if (new_buffer == NULL)
| 		return;
| 
| 	yyensure_buffer_stack();
| 
| 	/* This block is copied from yy_switch_to_buffer. */
| 	if ( YY_CURRENT_BUFFER )
| 		{
| 		/* Flush out information for old buffer. */
| 		*(yy_c_buf_p) = (yy_hold_char);
| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	/* Only push if top exists. Otherwise, replace top. */
| 	if (YY_CURRENT_BUFFER)
| 		(yy_buffer_stack_top)++;
| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
| 
| 	/* copied from yy_switch_to_buffer. */
| 	yy_load_buffer_state( );
| 	(yy_did_buffer_switch_on_eof) = 1;
| }
| 
| /** Removes and deletes the top of the stack, if present.
|  *  The next element becomes the new top.
|  *  
|  */
| void yypop_buffer_state (void)
| {
|     	if (!YY_CURRENT_BUFFER)
| 		return;
| 
| 	yy_delete_buffer(YY_CURRENT_BUFFER );
| 	YY_CURRENT_BUFFER_LVALUE = NULL;
| 	if ((yy_buffer_stack_top) > 0)
| 		--(yy_buffer_stack_top);
| 
| 	if (YY_CURRENT_BUFFER) {
| 		yy_load_buffer_state( );
| 		(yy_did_buffer_switch_on_eof) = 1;
| 	}
| }
| 
| /* Allocates the stack if it does not exist.
|  *  Guarantees space for at least one push.
|  */
| static void yyensure_buffer_stack (void)
| {
| 	yy_size_t num_to_alloc;
|     
| 	if (!(yy_buffer_stack)) {
| 
| 		/* First allocation is just for 2 elements, since we don't know if this
| 		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
| 		 * immediate realloc on the next call.
|          */
| 		num_to_alloc = 1;
| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
| 								(num_to_alloc * sizeof(struct yy_buffer_state*)
| 								);
| 		if ( ! (yy_buffer_stack) )
| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
| 								  
| 		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
| 				
| 		(yy_buffer_stack_max) = num_to_alloc;
| 		(yy_buffer_stack_top) = 0;
| 		return;
| 	}
| 
| 	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
| 
| 		/* Increase the buffer to prepare for a possible push. */
| 		int grow_size = 8 /* arbitrary grow size */;
| 
| 		num_to_alloc = (yy_buffer_stack_max) + grow_size;
| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
| 								((yy_buffer_stack),
| 								num_to_alloc * sizeof(struct yy_buffer_state*)
| 								);
| 		if ( ! (yy_buffer_stack) )
| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
| 
| 		/* zero only the new slots.*/
| 		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
| 		(yy_buffer_stack_max) = num_to_alloc;
| 	}
| }
| 
| /** Setup the input buffer state to scan directly from a user-specified character buffer.
|  * @param base the character buffer
|  * @param size the size in bytes of the character buffer
|  * 
|  * @return the newly allocated buffer state object. 
|  */
| YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
| {
| 	YY_BUFFER_STATE b;
|     
| 	if ( size < 2 ||
| 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
| 	     base[size-1] != YY_END_OF_BUFFER_CHAR )
| 		/* They forgot to leave room for the EOB's. */
| 		return 0;
| 
| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
| 
| 	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
| 	b->yy_buf_pos = b->yy_ch_buf = base;
| 	b->yy_is_our_buffer = 0;
| 	b->yy_input_file = 0;
| 	b->yy_n_chars = b->yy_buf_size;
| 	b->yy_is_interactive = 0;
| 	b->yy_at_bol = 1;
| 	b->yy_fill_buffer = 0;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	yy_switch_to_buffer(b  );
| 
| 	return b;
| }
| 
| /** Setup the input buffer state to scan a string. The next call to yylex() will
|  * scan from a @e copy of @a str.
|  * @param yystr a NUL-terminated string to scan
|  * 
|  * @return the newly allocated buffer state object.
|  * @note If you want to scan bytes that may contain NUL values, then use
|  *       yy_scan_bytes() instead.
|  */
| YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
| {
|     
| 	return yy_scan_bytes(yystr,strlen(yystr) );
| }
| 
| /** Setup the input buffer state to scan the given bytes. The next call to yylex() will
|  * scan from a @e copy of @a bytes.
|  * @param yybytes the byte buffer to scan
|  * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
|  * 
|  * @return the newly allocated buffer state object.
|  */
| YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len )
| {
| 	YY_BUFFER_STATE b;
| 	char *buf;
| 	yy_size_t n;
| 	yy_size_t i;
|     
| 	/* Get memory for full buffer, including space for trailing EOB's. */
| 	n = _yybytes_len + 2;
| 	buf = (char *) yyalloc(n  );
| 	if ( ! buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
| 
| 	for ( i = 0; i < _yybytes_len; ++i )
| 		buf[i] = yybytes[i];
| 
| 	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b = yy_scan_buffer(buf,n );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
| 
| 	/* It's okay to grow etc. this buffer, and we should throw it
| 	 * away when we're done.
| 	 */
| 	b->yy_is_our_buffer = 1;
| 
| 	return b;
| }
| 
| #ifndef YY_EXIT_FAILURE
| #define YY_EXIT_FAILURE 2
| #endif
| 
| static void yy_fatal_error (yyconst char* msg )
| {
|     	(void) fprintf( stderr, "%s\n", msg );
| 	exit( YY_EXIT_FAILURE );
| }
| 
| /* Redefine yyless() so it works in section 3 code. */
| 
| #undef yyless
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
|         int yyless_macro_arg = (n); \
|         YY_LESS_LINENO(yyless_macro_arg);\
| 		yytext[yyleng] = (yy_hold_char); \
| 		(yy_c_buf_p) = yytext + yyless_macro_arg; \
| 		(yy_hold_char) = *(yy_c_buf_p); \
| 		*(yy_c_buf_p) = '\0'; \
| 		yyleng = yyless_macro_arg; \
| 		} \
| 	while ( 0 )
| 
| /* Accessor  methods (get/set functions) to struct members. */
| 
| /** Get the current line number.
|  * 
|  */
| int yyget_lineno  (void)
| {
|         
|     return yylineno;
| }
| 
| /** Get the input stream.
|  * 
|  */
| FILE *yyget_in  (void)
| {
|         return yyin;
| }
| 
| /** Get the output stream.
|  * 
|  */
| FILE *yyget_out  (void)
| {
|         return yyout;
| }
| 
| /** Get the length of the current token.
|  * 
|  */
| yy_size_t yyget_leng  (void)
| {
|         return yyleng;
| }
| 
| /** Get the current token.
|  * 
|  */
| 
| char *yyget_text  (void)
| {
|         return yytext;
| }
| 
| /** Set the current line number.
|  * @param line_number
|  * 
|  */
| void yyset_lineno (int  line_number )
| {
|     
|     yylineno = line_number;
| }
| 
| /** Set the input stream. This does not discard the current
|  * input buffer.
|  * @param in_str A readable stream.
|  * 
|  * @see yy_switch_to_buffer
|  */
| void yyset_in (FILE *  in_str )
| {
|         yyin = in_str ;
| }
| 
| void yyset_out (FILE *  out_str )
| {
|         yyout = out_str ;
| }
| 
| int yyget_debug  (void)
| {
|         return yy_flex_debug;
| }
| 
| void yyset_debug (int  bdebug )
| {
|         yy_flex_debug = bdebug ;
| }
| 
| static int yy_init_globals (void)
| {
|         /* Initialization is the same as for the non-reentrant scanner.
|      * This function is called from yylex_destroy(), so don't allocate here.
|      */
| 
|     (yy_buffer_stack) = 0;
|     (yy_buffer_stack_top) = 0;
|     (yy_buffer_stack_max) = 0;
|     (yy_c_buf_p) = (char *) 0;
|     (yy_init) = 0;
|     (yy_start) = 0;
| 
|     (yy_state_buf) = 0;
|     (yy_state_ptr) = 0;
|     (yy_full_match) = 0;
|     (yy_lp) = 0;
| 
| /* Defined in main.c */
| #ifdef YY_STDINIT
|     yyin = stdin;
|     yyout = stdout;
| #else
|     yyin = (FILE *) 0;
|     yyout = (FILE *) 0;
| #endif
| 
|     /* For future reference: Set errno on error, since we are called by
|      * yylex_init()
|      */
|     return 0;
| }
| 
| /* yylex_destroy is for both reentrant and non-reentrant scanners. */
| int yylex_destroy  (void)
| {
|     
|     /* Pop the buffer stack, destroying each element. */
| 	while(YY_CURRENT_BUFFER){
| 		yy_delete_buffer(YY_CURRENT_BUFFER  );
| 		YY_CURRENT_BUFFER_LVALUE = NULL;
| 		yypop_buffer_state();
| 	}
| 
| 	/* Destroy the stack itself. */
| 	yyfree((yy_buffer_stack) );
| 	(yy_buffer_stack) = NULL;
| 
|     yyfree ( (yy_state_buf) );
|     (yy_state_buf)  = NULL;
| 
|     /* Reset the globals. This is important in a non-reentrant scanner so the next time
|      * yylex() is called, initialization will occur. */
|     yy_init_globals( );
| 
|     return 0;
| }
| 
| /*
|  * Internal utility routines.
|  */
| 
| #ifndef yytext_ptr
| static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
| {
| 	register int i;
| 	for ( i = 0; i < n; ++i )
| 		s1[i] = s2[i];
| }
| #endif
| 
| #ifdef YY_NEED_STRLEN
| static int yy_flex_strlen (yyconst char * s )
| {
| 	register int n;
| 	for ( n = 0; s[n]; ++n )
| 		;
| 
| 	return n;
| }
| #endif
| 
| void *yyalloc (yy_size_t  size )
| {
| 	return (void *) malloc( size );
| }
| 
| void *yyrealloc  (void * ptr, yy_size_t  size )
| {
| 	/* The cast to (char *) in the following accommodates both
| 	 * implementations that use char* generic pointers, and those
| 	 * that use void* generic pointers.  It works with the latter
| 	 * because both ANSI C and C++ allow castless assignment from
| 	 * any pointer type to void*, and deal with argument conversions
| 	 * as though doing an assignment.
| 	 */
| 	return (void *) realloc( (char *) ptr, size );
| }
| 
| void yyfree (void * ptr )
| {
| 	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
| }
| 
| #define YYTABLES_NAME "yytables"
| 
| #line 9 "conftest.l"
| 
| 
| #ifdef YYTEXT_POINTER
| extern char *yytext;
| #endif
| int
| main (void)
| {
|   return ! yylex () + ! yywrap ();
| }
configure:16191: result: none needed
configure:16197: checking whether yytext is a pointer
configure:16213: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c   >&5
/tmp/ccpGGPzA.o:conftest.c:function yylex: error: undefined reference to 'yywrap'
/tmp/ccpGGPzA.o:conftest.c:function input: error: undefined reference to 'yywrap'
/tmp/ccpGGPzA.o:conftest.c:function main: error: undefined reference to 'yywrap'
collect2: error: ld returned 1 exit status
configure:16213: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "ld"
| #define PACKAGE_TARNAME "ld"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "ld 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "ld"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define GOT_HANDLING_DEFAULT GOT_HANDLING_TARGET_DEFAULT
| #define HAVE_LC_MESSAGES 1
| /* end confdefs.h.  */
| #define YYTEXT_POINTER 1
| 
| #line 3 "lex.yy.c"
| 
| #define  YY_INT_ALIGNED short int
| 
| /* A lexical scanner generated by flex */
| 
| #define FLEX_SCANNER
| #define YY_FLEX_MAJOR_VERSION 2
| #define YY_FLEX_MINOR_VERSION 5
| #define YY_FLEX_SUBMINOR_VERSION 39
| #if YY_FLEX_SUBMINOR_VERSION > 0
| #define FLEX_BETA
| #endif
| 
| /* First, we deal with  platform-specific or compiler-specific issues. */
| 
| /* begin standard C headers. */
| #include <stdio.h>
| #include <string.h>
| #include <errno.h>
| #include <stdlib.h>
| 
| /* end standard C headers. */
| 
| /* flex integer type definitions */
| 
| #ifndef FLEXINT_H
| #define FLEXINT_H
| 
| /* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
| 
| #if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
| 
| /* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
|  * if you want the limit (max/min) macros for int types. 
|  */
| #ifndef __STDC_LIMIT_MACROS
| #define __STDC_LIMIT_MACROS 1
| #endif
| 
| #include <inttypes.h>
| typedef int8_t flex_int8_t;
| typedef uint8_t flex_uint8_t;
| typedef int16_t flex_int16_t;
| typedef uint16_t flex_uint16_t;
| typedef int32_t flex_int32_t;
| typedef uint32_t flex_uint32_t;
| #else
| typedef signed char flex_int8_t;
| typedef short int flex_int16_t;
| typedef int flex_int32_t;
| typedef unsigned char flex_uint8_t; 
| typedef unsigned short int flex_uint16_t;
| typedef unsigned int flex_uint32_t;
| 
| /* Limits of integral types. */
| #ifndef INT8_MIN
| #define INT8_MIN               (-128)
| #endif
| #ifndef INT16_MIN
| #define INT16_MIN              (-32767-1)
| #endif
| #ifndef INT32_MIN
| #define INT32_MIN              (-2147483647-1)
| #endif
| #ifndef INT8_MAX
| #define INT8_MAX               (127)
| #endif
| #ifndef INT16_MAX
| #define INT16_MAX              (32767)
| #endif
| #ifndef INT32_MAX
| #define INT32_MAX              (2147483647)
| #endif
| #ifndef UINT8_MAX
| #define UINT8_MAX              (255U)
| #endif
| #ifndef UINT16_MAX
| #define UINT16_MAX             (65535U)
| #endif
| #ifndef UINT32_MAX
| #define UINT32_MAX             (4294967295U)
| #endif
| 
| #endif /* ! C99 */
| 
| #endif /* ! FLEXINT_H */
| 
| #ifdef __cplusplus
| 
| /* The "const" storage-class-modifier is valid. */
| #define YY_USE_CONST
| 
| #else	/* ! __cplusplus */
| 
| /* C99 requires __STDC__ to be defined as 1. */
| #if defined (__STDC__)
| 
| #define YY_USE_CONST
| 
| #endif	/* defined (__STDC__) */
| #endif	/* ! __cplusplus */
| 
| #ifdef YY_USE_CONST
| #define yyconst const
| #else
| #define yyconst
| #endif
| 
| /* Returned upon end-of-file. */
| #define YY_NULL 0
| 
| /* Promotes a possibly negative, possibly signed char to an unsigned
|  * integer for use as an array index.  If the signed char is negative,
|  * we want to instead treat it as an 8-bit unsigned char, hence the
|  * double cast.
|  */
| #define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
| 
| /* Enter a start condition.  This macro really ought to take a parameter,
|  * but we do it the disgusting crufty way forced on us by the ()-less
|  * definition of BEGIN.
|  */
| #define BEGIN (yy_start) = 1 + 2 *
| 
| /* Translate the current start state into a value that can be later handed
|  * to BEGIN to return to the state.  The YYSTATE alias is for lex
|  * compatibility.
|  */
| #define YY_START (((yy_start) - 1) / 2)
| #define YYSTATE YY_START
| 
| /* Action number for EOF rule of a given start state. */
| #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
| 
| /* Special action meaning "start processing a new file". */
| #define YY_NEW_FILE yyrestart(yyin  )
| 
| #define YY_END_OF_BUFFER_CHAR 0
| 
| /* Size of default input buffer. */
| #ifndef YY_BUF_SIZE
| #define YY_BUF_SIZE 16384
| #endif
| 
| /* The state buf must be large enough to hold one state per character in the main buffer.
|  */
| #define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
| 
| #ifndef YY_TYPEDEF_YY_BUFFER_STATE
| #define YY_TYPEDEF_YY_BUFFER_STATE
| typedef struct yy_buffer_state *YY_BUFFER_STATE;
| #endif
| 
| #ifndef YY_TYPEDEF_YY_SIZE_T
| #define YY_TYPEDEF_YY_SIZE_T
| typedef size_t yy_size_t;
| #endif
| 
| extern yy_size_t yyleng;
| 
| extern FILE *yyin, *yyout;
| 
| #define EOB_ACT_CONTINUE_SCAN 0
| #define EOB_ACT_END_OF_FILE 1
| #define EOB_ACT_LAST_MATCH 2
| 
|     #define YY_LESS_LINENO(n)
|     #define YY_LINENO_REWIND_TO(ptr)
|     
| /* Return all but the first "n" matched characters back to the input stream. */
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
|         int yyless_macro_arg = (n); \
|         YY_LESS_LINENO(yyless_macro_arg);\
| 		*yy_cp = (yy_hold_char); \
| 		YY_RESTORE_YY_MORE_OFFSET \
| 		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
| 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
| 		} \
| 	while ( 0 )
| 
| #define unput(c) yyunput( c, (yytext_ptr)  )
| 
| #ifndef YY_STRUCT_YY_BUFFER_STATE
| #define YY_STRUCT_YY_BUFFER_STATE
| struct yy_buffer_state
| 	{
| 	FILE *yy_input_file;
| 
| 	char *yy_ch_buf;		/* input buffer */
| 	char *yy_buf_pos;		/* current position in input buffer */
| 
| 	/* Size of input buffer in bytes, not including room for EOB
| 	 * characters.
| 	 */
| 	yy_size_t yy_buf_size;
| 
| 	/* Number of characters read into yy_ch_buf, not including EOB
| 	 * characters.
| 	 */
| 	yy_size_t yy_n_chars;
| 
| 	/* Whether we "own" the buffer - i.e., we know we created it,
| 	 * and can realloc() it to grow it, and should free() it to
| 	 * delete it.
| 	 */
| 	int yy_is_our_buffer;
| 
| 	/* Whether this is an "interactive" input source; if so, and
| 	 * if we're using stdio for input, then we want to use getc()
| 	 * instead of fread(), to make sure we stop fetching input after
| 	 * each newline.
| 	 */
| 	int yy_is_interactive;
| 
| 	/* Whether we're considered to be at the beginning of a line.
| 	 * If so, '^' rules will be active on the next match, otherwise
| 	 * not.
| 	 */
| 	int yy_at_bol;
| 
|     int yy_bs_lineno; /**< The line count. */
|     int yy_bs_column; /**< The column count. */
|     
| 	/* Whether to try to fill the input buffer when we reach the
| 	 * end of it.
| 	 */
| 	int yy_fill_buffer;
| 
| 	int yy_buffer_status;
| 
| #define YY_BUFFER_NEW 0
| #define YY_BUFFER_NORMAL 1
| 	/* When an EOF's been seen but there's still some text to process
| 	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
| 	 * shouldn't try reading from the input source any more.  We might
| 	 * still have a bunch of tokens to match, though, because of
| 	 * possible backing-up.
| 	 *
| 	 * When we actually see the EOF, we change the status to "new"
| 	 * (via yyrestart()), so that the user can continue scanning by
| 	 * just pointing yyin at a new input file.
| 	 */
| #define YY_BUFFER_EOF_PENDING 2
| 
| 	};
| #endif /* !YY_STRUCT_YY_BUFFER_STATE */
| 
| /* Stack of input buffers. */
| static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
| static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
| static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
| 
| /* We provide macros for accessing buffer states in case in the
|  * future we want to put the buffer states in a more general
|  * "scanner state".
|  *
|  * Returns the top of the stack, or NULL.
|  */
| #define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
|                           ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
|                           : NULL)
| 
| /* Same as previous macro, but useful when we know that the buffer stack is not
|  * NULL or when we need an lvalue. For internal use only.
|  */
| #define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
| 
| /* yy_hold_char holds the character lost when yytext is formed. */
| static char yy_hold_char;
| static yy_size_t yy_n_chars;		/* number of characters read into yy_ch_buf */
| yy_size_t yyleng;
| 
| /* Points to current character in buffer. */
| static char *yy_c_buf_p = (char *) 0;
| static int yy_init = 0;		/* whether we need to initialize */
| static int yy_start = 0;	/* start state number */
| 
| /* Flag which is used to allow yywrap()'s to do buffer switches
|  * instead of setting up a fresh yyin.  A bit of a hack ...
|  */
| static int yy_did_buffer_switch_on_eof;
| 
| void yyrestart (FILE *input_file  );
| void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
| YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
| void yy_delete_buffer (YY_BUFFER_STATE b  );
| void yy_flush_buffer (YY_BUFFER_STATE b  );
| void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
| void yypop_buffer_state (void );
| 
| static void yyensure_buffer_stack (void );
| static void yy_load_buffer_state (void );
| static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
| 
| #define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
| 
| YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
| YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
| YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,yy_size_t len  );
| 
| void *yyalloc (yy_size_t  );
| void *yyrealloc (void *,yy_size_t  );
| void yyfree (void *  );
| 
| #define yy_new_buffer yy_create_buffer
| 
| #define yy_set_interactive(is_interactive) \
| 	{ \
| 	if ( ! YY_CURRENT_BUFFER ){ \
|         yyensure_buffer_stack (); \
| 		YY_CURRENT_BUFFER_LVALUE =    \
|             yy_create_buffer(yyin,YY_BUF_SIZE ); \
| 	} \
| 	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
| 	}
| 
| #define yy_set_bol(at_bol) \
| 	{ \
| 	if ( ! YY_CURRENT_BUFFER ){\
|         yyensure_buffer_stack (); \
| 		YY_CURRENT_BUFFER_LVALUE =    \
|             yy_create_buffer(yyin,YY_BUF_SIZE ); \
| 	} \
| 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
| 	}
| 
| #define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
| 
| /* Begin user sect3 */
| 
| typedef unsigned char YY_CHAR;
| 
| FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
| 
| typedef int yy_state_type;
| 
| extern int yylineno;
| 
| int yylineno = 1;
| 
| extern char *yytext;
| #define yytext_ptr yytext
| 
| static yy_state_type yy_get_previous_state (void );
| static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
| static int yy_get_next_buffer (void );
| static void yy_fatal_error (yyconst char msg[]  );
| 
| /* Done after the current pattern has been matched and before the
|  * corresponding action - sets up yytext.
|  */
| #define YY_DO_BEFORE_ACTION \
| 	(yytext_ptr) = yy_bp; \
| 	(yytext_ptr) -= (yy_more_len); \
| 	yyleng = (size_t) (yy_cp - (yytext_ptr)); \
| 	(yy_hold_char) = *yy_cp; \
| 	*yy_cp = '\0'; \
| 	(yy_c_buf_p) = yy_cp;
| 
| #define YY_NUM_RULES 8
| #define YY_END_OF_BUFFER 9
| /* This struct is not used in this scanner,
|    but its presence is necessary. */
| struct yy_trans_info
| 	{
| 	flex_int32_t yy_verify;
| 	flex_int32_t yy_nxt;
| 	};
| static yyconst flex_int16_t yy_acclist[23] =
|     {   0,
|         9,    7,    8,    8,    1,    7,    8,    2,    7,    8,
|         3,    7,    8,    4,    7,    8,    5,    7,    8,    6,
|         7,    8
|     } ;
| 
| static yyconst flex_int16_t yy_accept[14] =
|     {   0,
|         1,    1,    1,    2,    4,    5,    8,   11,   14,   17,
|        20,   23,   23
|     } ;
| 
| static yyconst flex_int32_t yy_ec[256] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    3,    4,    5,    6,
| 
|         7,    8,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| 
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1
|     } ;
| 
| static yyconst flex_int32_t yy_meta[9] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1
|     } ;
| 
| static yyconst flex_int16_t yy_base[13] =
|     {   0,
|         0,    0,    9,   10,   10,   10,   10,   10,   10,   10,
|        10,   10
|     } ;
| 
| static yyconst flex_int16_t yy_def[13] =
|     {   0,
|        12,    1,   12,   12,   12,   12,   12,   12,   12,   12,
|        12,    0
|     } ;
| 
| static yyconst flex_int16_t yy_nxt[19] =
|     {   0,
|         4,    5,    6,    7,    8,    9,   10,   11,   12,    3,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| static yyconst flex_int16_t yy_chk[19] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    3,   12,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| extern int yy_flex_debug;
| int yy_flex_debug = 0;
| 
| static yy_state_type *yy_state_buf=0, *yy_state_ptr=0;
| static char *yy_full_match;
| static int yy_lp;
| #define REJECT \
| { \
| *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */ \
| yy_cp = (yy_full_match); /* restore poss. backed-over text */ \
| ++(yy_lp); \
| goto find_rule; \
| }
| 
| static int yy_more_flag = 0;
| static int yy_more_len = 0;
| #define yymore() ((yy_more_flag) = 1)
| #define YY_MORE_ADJ (yy_more_len)
| #define YY_RESTORE_YY_MORE_OFFSET
| char *yytext;
| #line 1 "conftest.l"
| #line 470 "lex.yy.c"
| 
| #define INITIAL 0
| 
| #ifndef YY_NO_UNISTD_H
| /* Special case for "unistd.h", since it is non-ANSI. We include it way
|  * down here because we want the user's section 1 to have been scanned first.
|  * The user has a chance to override it with an option.
|  */
| #include <unistd.h>
| #endif
| 
| #ifndef YY_EXTRA_TYPE
| #define YY_EXTRA_TYPE void *
| #endif
| 
| static int yy_init_globals (void );
| 
| /* Accessor methods to globals.
|    These are made visible to non-reentrant scanners for convenience. */
| 
| int yylex_destroy (void );
| 
| int yyget_debug (void );
| 
| void yyset_debug (int debug_flag  );
| 
| YY_EXTRA_TYPE yyget_extra (void );
| 
| void yyset_extra (YY_EXTRA_TYPE user_defined  );
| 
| FILE *yyget_in (void );
| 
| void yyset_in  (FILE * in_str  );
| 
| FILE *yyget_out (void );
| 
| void yyset_out  (FILE * out_str  );
| 
| yy_size_t yyget_leng (void );
| 
| char *yyget_text (void );
| 
| int yyget_lineno (void );
| 
| void yyset_lineno (int line_number  );
| 
| /* Macros after this point can all be overridden by user definitions in
|  * section 1.
|  */
| 
| #ifndef YY_SKIP_YYWRAP
| #ifdef __cplusplus
| extern "C" int yywrap (void );
| #else
| extern int yywrap (void );
| #endif
| #endif
| 
|     static void yyunput (int c,char *buf_ptr  );
|     
| #ifndef yytext_ptr
| static void yy_flex_strncpy (char *,yyconst char *,int );
| #endif
| 
| #ifdef YY_NEED_STRLEN
| static int yy_flex_strlen (yyconst char * );
| #endif
| 
| #ifndef YY_NO_INPUT
| 
| #ifdef __cplusplus
| static int yyinput (void );
| #else
| static int input (void );
| #endif
| 
| #endif
| 
| /* Amount of stuff to slurp up with each read. */
| #ifndef YY_READ_BUF_SIZE
| #define YY_READ_BUF_SIZE 8192
| #endif
| 
| /* Copy whatever the last rule matched to the standard output. */
| #ifndef ECHO
| /* This used to be an fputs(), but since the string might contain NUL's,
|  * we now use fwrite().
|  */
| #define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
| #endif
| 
| /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
|  * is returned in "result".
|  */
| #ifndef YY_INPUT
| #define YY_INPUT(buf,result,max_size) \
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
| 		{ \
| 		int c = '*'; \
| 		size_t n; \
| 		for ( n = 0; n < max_size && \
| 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
| 			buf[n] = (char) c; \
| 		if ( c == '\n' ) \
| 			buf[n++] = (char) c; \
| 		if ( c == EOF && ferror( yyin ) ) \
| 			YY_FATAL_ERROR( "input in flex scanner failed" ); \
| 		result = n; \
| 		} \
| 	else \
| 		{ \
| 		errno=0; \
| 		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
| 			{ \
| 			if( errno != EINTR) \
| 				{ \
| 				YY_FATAL_ERROR( "input in flex scanner failed" ); \
| 				break; \
| 				} \
| 			errno=0; \
| 			clearerr(yyin); \
| 			} \
| 		}\
| \
| 
| #endif
| 
| /* No semi-colon after return; correct usage is to write "yyterminate();" -
|  * we don't want an extra ';' after the "return" because that will cause
|  * some compilers to complain about unreachable statements.
|  */
| #ifndef yyterminate
| #define yyterminate() return YY_NULL
| #endif
| 
| /* Number of entries by which start-condition stack grows. */
| #ifndef YY_START_STACK_INCR
| #define YY_START_STACK_INCR 25
| #endif
| 
| /* Report a fatal error. */
| #ifndef YY_FATAL_ERROR
| #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
| #endif
| 
| /* end tables serialization structures and prototypes */
| 
| /* Default declaration of generated scanner - a define so the user can
|  * easily add parameters.
|  */
| #ifndef YY_DECL
| #define YY_DECL_IS_OURS 1
| 
| extern int yylex (void);
| 
| #define YY_DECL int yylex (void)
| #endif /* !YY_DECL */
| 
| /* Code executed at the beginning of each rule, after yytext and yyleng
|  * have been set up.
|  */
| #ifndef YY_USER_ACTION
| #define YY_USER_ACTION
| #endif
| 
| /* Code executed at the end of each rule. */
| #ifndef YY_BREAK
| #define YY_BREAK break;
| #endif
| 
| #define YY_RULE_SETUP \
| 	YY_USER_ACTION
| 
| /** The main scanner function which does all the work.
|  */
| YY_DECL
| {
| 	register yy_state_type yy_current_state;
| 	register char *yy_cp, *yy_bp;
| 	register int yy_act;
|     
| 	if ( !(yy_init) )
| 		{
| 		(yy_init) = 1;
| 
| #ifdef YY_USER_INIT
| 		YY_USER_INIT;
| #endif
| 
|         /* Create the reject buffer large enough to save one state per allowed character. */
|         if ( ! (yy_state_buf) )
|             (yy_state_buf) = (yy_state_type *)yyalloc(YY_STATE_BUF_SIZE  );
|             if ( ! (yy_state_buf) )
|                 YY_FATAL_ERROR( "out of dynamic memory in yylex()" );
| 
| 		if ( ! (yy_start) )
| 			(yy_start) = 1;	/* first start state */
| 
| 		if ( ! yyin )
| 			yyin = stdin;
| 
| 		if ( ! yyout )
| 			yyout = stdout;
| 
| 		if ( ! YY_CURRENT_BUFFER ) {
| 			yyensure_buffer_stack ();
| 			YY_CURRENT_BUFFER_LVALUE =
| 				yy_create_buffer(yyin,YY_BUF_SIZE );
| 		}
| 
| 		yy_load_buffer_state( );
| 		}
| 
| 	{
| #line 1 "conftest.l"
| 
| #line 687 "lex.yy.c"
| 
| 	while ( 1 )		/* loops until end-of-file is reached */
| 		{
| 		(yy_more_len) = 0;
| 		if ( (yy_more_flag) )
| 			{
| 			(yy_more_len) = (yy_c_buf_p) - (yytext_ptr);
| 			(yy_more_flag) = 0;
| 			}
| 		yy_cp = (yy_c_buf_p);
| 
| 		/* Support of yytext. */
| 		*yy_cp = (yy_hold_char);
| 
| 		/* yy_bp points to the position in yy_ch_buf of the start of
| 		 * the current run.
| 		 */
| 		yy_bp = yy_cp;
| 
| 		yy_current_state = (yy_start);
| 
| 		(yy_state_ptr) = (yy_state_buf);
| 		*(yy_state_ptr)++ = yy_current_state;
| 
| yy_match:
| 		do
| 			{
| 			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
| 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 				{
| 				yy_current_state = (int) yy_def[yy_current_state];
| 				if ( yy_current_state >= 13 )
| 					yy_c = yy_meta[(unsigned int) yy_c];
| 				}
| 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 			*(yy_state_ptr)++ = yy_current_state;
| 			++yy_cp;
| 			}
| 		while ( yy_base[yy_current_state] != 10 );
| 
| yy_find_action:
| 		yy_current_state = *--(yy_state_ptr);
| 		(yy_lp) = yy_accept[yy_current_state];
| find_rule: /* we branch to this label when backing up */
| 		for ( ; ; ) /* until we find what rule we matched */
| 			{
| 			if ( (yy_lp) && (yy_lp) < yy_accept[yy_current_state + 1] )
| 				{
| 				yy_act = yy_acclist[(yy_lp)];
| 					{
| 					(yy_full_match) = yy_cp;
| 					break;
| 					}
| 				}
| 			--yy_cp;
| 			yy_current_state = *--(yy_state_ptr);
| 			(yy_lp) = yy_accept[yy_current_state];
| 			}
| 
| 		YY_DO_BEFORE_ACTION;
| 
| do_action:	/* This label is used only to access EOF actions. */
| 
| 		switch ( yy_act )
| 	{ /* beginning of action switch */
| case 1:
| YY_RULE_SETUP
| #line 2 "conftest.l"
| { ECHO; }
| 	YY_BREAK
| case 2:
| YY_RULE_SETUP
| #line 3 "conftest.l"
| { REJECT; }
| 	YY_BREAK
| case 3:
| YY_RULE_SETUP
| #line 4 "conftest.l"
| { yymore (); }
| 	YY_BREAK
| case 4:
| YY_RULE_SETUP
| #line 5 "conftest.l"
| { yyless (1); }
| 	YY_BREAK
| case 5:
| YY_RULE_SETUP
| #line 6 "conftest.l"
| { yyless (input () != 0); }
| 	YY_BREAK
| case 6:
| YY_RULE_SETUP
| #line 7 "conftest.l"
| { unput (yytext[0]); }
| 	YY_BREAK
| case 7:
| YY_RULE_SETUP
| #line 8 "conftest.l"
| { BEGIN INITIAL; }
| 	YY_BREAK
| case 8:
| YY_RULE_SETUP
| #line 9 "conftest.l"
| ECHO;
| 	YY_BREAK
| #line 793 "lex.yy.c"
| 			case YY_STATE_EOF(INITIAL):
| 				yyterminate();
| 
| 	case YY_END_OF_BUFFER:
| 		{
| 		/* Amount of text matched not including the EOB char. */
| 		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
| 
| 		/* Undo the effects of YY_DO_BEFORE_ACTION. */
| 		*yy_cp = (yy_hold_char);
| 		YY_RESTORE_YY_MORE_OFFSET
| 
| 		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
| 			{
| 			/* We're scanning a new file or input source.  It's
| 			 * possible that this happened because the user
| 			 * just pointed yyin at a new source and called
| 			 * yylex().  If so, then we have to assure
| 			 * consistency between YY_CURRENT_BUFFER and our
| 			 * globals.  Here is the right place to do so, because
| 			 * this is the first action (other than possibly a
| 			 * back-up) that will match for the new input source.
| 			 */
| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
| 			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
| 			}
| 
| 		/* Note that here we test for yy_c_buf_p "<=" to the position
| 		 * of the first EOB in the buffer, since yy_c_buf_p will
| 		 * already have been incremented past the NUL character
| 		 * (since all states make transitions on EOB to the
| 		 * end-of-buffer state).  Contrast this with the test
| 		 * in input().
| 		 */
| 		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
| 			{ /* This was really a NUL. */
| 			yy_state_type yy_next_state;
| 
| 			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
| 
| 			yy_current_state = yy_get_previous_state(  );
| 
| 			/* Okay, we're now positioned to make the NUL
| 			 * transition.  We couldn't have
| 			 * yy_get_previous_state() go ahead and do it
| 			 * for us because it doesn't know how to deal
| 			 * with the possibility of jamming (and we don't
| 			 * want to build jamming into it because then it
| 			 * will run more slowly).
| 			 */
| 
| 			yy_next_state = yy_try_NUL_trans( yy_current_state );
| 
| 			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 
| 			if ( yy_next_state )
| 				{
| 				/* Consume the NUL. */
| 				yy_cp = ++(yy_c_buf_p);
| 				yy_current_state = yy_next_state;
| 				goto yy_match;
| 				}
| 
| 			else
| 				{
| 				yy_cp = (yy_c_buf_p);
| 				goto yy_find_action;
| 				}
| 			}
| 
| 		else switch ( yy_get_next_buffer(  ) )
| 			{
| 			case EOB_ACT_END_OF_FILE:
| 				{
| 				(yy_did_buffer_switch_on_eof) = 0;
| 
| 				if ( yywrap( ) )
| 					{
| 					/* Note: because we've taken care in
| 					 * yy_get_next_buffer() to have set up
| 					 * yytext, we can now set up
| 					 * yy_c_buf_p so that if some total
| 					 * hoser (like flex itself) wants to
| 					 * call the scanner after we return the
| 					 * YY_NULL, it'll still work - another
| 					 * YY_NULL will get returned.
| 					 */
| 					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
| 
| 					yy_act = YY_STATE_EOF(YY_START);
| 					goto do_action;
| 					}
| 
| 				else
| 					{
| 					if ( ! (yy_did_buffer_switch_on_eof) )
| 						YY_NEW_FILE;
| 					}
| 				break;
| 				}
| 
| 			case EOB_ACT_CONTINUE_SCAN:
| 				(yy_c_buf_p) =
| 					(yytext_ptr) + yy_amount_of_matched_text;
| 
| 				yy_current_state = yy_get_previous_state(  );
| 
| 				yy_cp = (yy_c_buf_p);
| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 				goto yy_match;
| 
| 			case EOB_ACT_LAST_MATCH:
| 				(yy_c_buf_p) =
| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
| 
| 				yy_current_state = yy_get_previous_state(  );
| 
| 				yy_cp = (yy_c_buf_p);
| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 				goto yy_find_action;
| 			}
| 		break;
| 		}
| 
| 	default:
| 		YY_FATAL_ERROR(
| 			"fatal flex scanner internal error--no action found" );
| 	} /* end of action switch */
| 		} /* end of scanning one token */
| 	} /* end of user's declarations */
| } /* end of yylex */
| 
| /* yy_get_next_buffer - try to read in a new buffer
|  *
|  * Returns a code representing an action:
|  *	EOB_ACT_LAST_MATCH -
|  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
|  *	EOB_ACT_END_OF_FILE - end of file
|  */
| static int yy_get_next_buffer (void)
| {
|     	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
| 	register char *source = (yytext_ptr);
| 	register int number_to_move, i;
| 	int ret_val;
| 
| 	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
| 		YY_FATAL_ERROR(
| 		"fatal flex scanner internal error--end of buffer missed" );
| 
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
| 		{ /* Don't try to fill the buffer, so this is an EOF. */
| 		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
| 			{
| 			/* We matched a single character, the EOB, so
| 			 * treat this as a final EOF.
| 			 */
| 			return EOB_ACT_END_OF_FILE;
| 			}
| 
| 		else
| 			{
| 			/* We matched some text prior to the EOB, first
| 			 * process it.
| 			 */
| 			return EOB_ACT_LAST_MATCH;
| 			}
| 		}
| 
| 	/* Try to read more data. */
| 
| 	/* First move last chars to start of buffer. */
| 	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
| 
| 	for ( i = 0; i < number_to_move; ++i )
| 		*(dest++) = *(source++);
| 
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
| 		/* don't do the read, it's not guaranteed to return an EOF,
| 		 * just force an EOF
| 		 */
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
| 
| 	else
| 		{
| 			yy_size_t num_to_read =
| 			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
| 
| 		while ( num_to_read <= 0 )
| 			{ /* Not enough room in the buffer - grow it. */
| 
| 			YY_FATAL_ERROR(
| "input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
| 
| 			}
| 
| 		if ( num_to_read > YY_READ_BUF_SIZE )
| 			num_to_read = YY_READ_BUF_SIZE;
| 
| 		/* Read in more data. */
| 		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
| 			(yy_n_chars), num_to_read );
| 
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	if ( (yy_n_chars) == 0 )
| 		{
| 		if ( number_to_move == YY_MORE_ADJ )
| 			{
| 			ret_val = EOB_ACT_END_OF_FILE;
| 			yyrestart(yyin  );
| 			}
| 
| 		else
| 			{
| 			ret_val = EOB_ACT_LAST_MATCH;
| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
| 				YY_BUFFER_EOF_PENDING;
| 			}
| 		}
| 
| 	else
| 		ret_val = EOB_ACT_CONTINUE_SCAN;
| 
| 	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
| 		/* Extend the array by 50%, plus the number we really need. */
| 		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
| 		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
| 		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
| 			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
| 	}
| 
| 	(yy_n_chars) += number_to_move;
| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
| 
| 	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
| 
| 	return ret_val;
| }
| 
| /* yy_get_previous_state - get the state just before the EOB char was reached */
| 
|     static yy_state_type yy_get_previous_state (void)
| {
| 	register yy_state_type yy_current_state;
| 	register char *yy_cp;
|     
| 	yy_current_state = (yy_start);
| 
| 	(yy_state_ptr) = (yy_state_buf);
| 	*(yy_state_ptr)++ = yy_current_state;
| 
| 	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
| 		{
| 		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
| 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 			{
| 			yy_current_state = (int) yy_def[yy_current_state];
| 			if ( yy_current_state >= 13 )
| 				yy_c = yy_meta[(unsigned int) yy_c];
| 			}
| 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 		*(yy_state_ptr)++ = yy_current_state;
| 		}
| 
| 	return yy_current_state;
| }
| 
| /* yy_try_NUL_trans - try to make a transition on the NUL character
|  *
|  * synopsis
|  *	next_state = yy_try_NUL_trans( current_state );
|  */
|     static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
| {
| 	register int yy_is_jam;
|     
| 	register YY_CHAR yy_c = 1;
| 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 		{
| 		yy_current_state = (int) yy_def[yy_current_state];
| 		if ( yy_current_state >= 13 )
| 			yy_c = yy_meta[(unsigned int) yy_c];
| 		}
| 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 	yy_is_jam = (yy_current_state == 12);
| 	if ( ! yy_is_jam )
| 		*(yy_state_ptr)++ = yy_current_state;
| 
| 		return yy_is_jam ? 0 : yy_current_state;
| }
| 
|     static void yyunput (int c, register char * yy_bp )
| {
| 	register char *yy_cp;
|     
|     yy_cp = (yy_c_buf_p);
| 
| 	/* undo effects of setting up yytext */
| 	*yy_cp = (yy_hold_char);
| 
| 	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
| 		{ /* need to shift things up to make room */
| 		/* +2 for EOB chars. */
| 		register yy_size_t number_to_move = (yy_n_chars) + 2;
| 		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
| 					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
| 		register char *source =
| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
| 
| 		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
| 			*--dest = *--source;
| 
| 		yy_cp += (int) (dest - source);
| 		yy_bp += (int) (dest - source);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
| 
| 		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
| 			YY_FATAL_ERROR( "flex scanner push-back overflow" );
| 		}
| 
| 	*--yy_cp = (char) c;
| 
| 	(yytext_ptr) = yy_bp;
| 	(yy_hold_char) = *yy_cp;
| 	(yy_c_buf_p) = yy_cp;
| }
| 
| #ifndef YY_NO_INPUT
| #ifdef __cplusplus
|     static int yyinput (void)
| #else
|     static int input  (void)
| #endif
| 
| {
| 	int c;
|     
| 	*(yy_c_buf_p) = (yy_hold_char);
| 
| 	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
| 		{
| 		/* yy_c_buf_p now points to the character we want to return.
| 		 * If this occurs *before* the EOB characters, then it's a
| 		 * valid NUL; if not, then we've hit the end of the buffer.
| 		 */
| 		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
| 			/* This was really a NUL. */
| 			*(yy_c_buf_p) = '\0';
| 
| 		else
| 			{ /* need more input */
| 			yy_size_t offset = (yy_c_buf_p) - (yytext_ptr);
| 			++(yy_c_buf_p);
| 
| 			switch ( yy_get_next_buffer(  ) )
| 				{
| 				case EOB_ACT_LAST_MATCH:
| 					/* This happens because yy_g_n_b()
| 					 * sees that we've accumulated a
| 					 * token and flags that we need to
| 					 * try matching the token before
| 					 * proceeding.  But for input(),
| 					 * there's no matching to consider.
| 					 * So convert the EOB_ACT_LAST_MATCH
| 					 * to EOB_ACT_END_OF_FILE.
| 					 */
| 
| 					/* Reset buffer status. */
| 					yyrestart(yyin );
| 
| 					/*FALLTHROUGH*/
| 
| 				case EOB_ACT_END_OF_FILE:
| 					{
| 					if ( yywrap( ) )
| 						return EOF;
| 
| 					if ( ! (yy_did_buffer_switch_on_eof) )
| 						YY_NEW_FILE;
| #ifdef __cplusplus
| 					return yyinput();
| #else
| 					return input();
| #endif
| 					}
| 
| 				case EOB_ACT_CONTINUE_SCAN:
| 					(yy_c_buf_p) = (yytext_ptr) + offset;
| 					break;
| 				}
| 			}
| 		}
| 
| 	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
| 	*(yy_c_buf_p) = '\0';	/* preserve yytext */
| 	(yy_hold_char) = *++(yy_c_buf_p);
| 
| 	return c;
| }
| #endif	/* ifndef YY_NO_INPUT */
| 
| /** Immediately switch to a different input stream.
|  * @param input_file A readable stream.
|  * 
|  * @note This function does not reset the start condition to @c INITIAL .
|  */
|     void yyrestart  (FILE * input_file )
| {
|     
| 	if ( ! YY_CURRENT_BUFFER ){
|         yyensure_buffer_stack ();
| 		YY_CURRENT_BUFFER_LVALUE =
|             yy_create_buffer(yyin,YY_BUF_SIZE );
| 	}
| 
| 	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
| 	yy_load_buffer_state( );
| }
| 
| /** Switch to a different input buffer.
|  * @param new_buffer The new input buffer.
|  * 
|  */
|     void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
| {
|     
| 	/* TODO. We should be able to replace this entire function body
| 	 * with
| 	 *		yypop_buffer_state();
| 	 *		yypush_buffer_state(new_buffer);
|      */
| 	yyensure_buffer_stack ();
| 	if ( YY_CURRENT_BUFFER == new_buffer )
| 		return;
| 
| 	if ( YY_CURRENT_BUFFER )
| 		{
| 		/* Flush out information for old buffer. */
| 		*(yy_c_buf_p) = (yy_hold_char);
| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
| 	yy_load_buffer_state( );
| 
| 	/* We don't actually know whether we did this switch during
| 	 * EOF (yywrap()) processing, but the only time this flag
| 	 * is looked at is after yywrap() is called, so it's safe
| 	 * to go ahead and always set it.
| 	 */
| 	(yy_did_buffer_switch_on_eof) = 1;
| }
| 
| static void yy_load_buffer_state  (void)
| {
|     	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
| 	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
| 	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
| 	(yy_hold_char) = *(yy_c_buf_p);
| }
| 
| /** Allocate and initialize an input buffer state.
|  * @param file A readable stream.
|  * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
|  * 
|  * @return the allocated buffer state.
|  */
|     YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
| {
| 	YY_BUFFER_STATE b;
|     
| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_buf_size = size;
| 
| 	/* yy_ch_buf has to be 2 characters longer than the size given because
| 	 * we need to put in 2 end-of-buffer characters.
| 	 */
| 	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
| 	if ( ! b->yy_ch_buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_is_our_buffer = 1;
| 
| 	yy_init_buffer(b,file );
| 
| 	return b;
| }
| 
| /** Destroy the buffer.
|  * @param b a buffer created with yy_create_buffer()
|  * 
|  */
|     void yy_delete_buffer (YY_BUFFER_STATE  b )
| {
|     
| 	if ( ! b )
| 		return;
| 
| 	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
| 		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
| 
| 	if ( b->yy_is_our_buffer )
| 		yyfree((void *) b->yy_ch_buf  );
| 
| 	yyfree((void *) b  );
| }
| 
| /* Initializes or reinitializes a buffer.
|  * This function is sometimes called more than once on the same buffer,
|  * such as during a yyrestart() or at EOF.
|  */
|     static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
| 
| {
| 	int oerrno = errno;
|     
| 	yy_flush_buffer(b );
| 
| 	b->yy_input_file = file;
| 	b->yy_fill_buffer = 1;
| 
|     /* If b is the current buffer, then yy_init_buffer was _probably_
|      * called from yyrestart() or through yy_get_next_buffer.
|      * In that case, we don't want to reset the lineno or column.
|      */
|     if (b != YY_CURRENT_BUFFER){
|         b->yy_bs_lineno = 1;
|         b->yy_bs_column = 0;
|     }
| 
|         b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
|     
| 	errno = oerrno;
| }
| 
| /** Discard all buffered characters. On the next scan, YY_INPUT will be called.
|  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
|  * 
|  */
|     void yy_flush_buffer (YY_BUFFER_STATE  b )
| {
|     	if ( ! b )
| 		return;
| 
| 	b->yy_n_chars = 0;
| 
| 	/* We always need two end-of-buffer characters.  The first causes
| 	 * a transition to the end-of-buffer state.  The second causes
| 	 * a jam in that state.
| 	 */
| 	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
| 	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b->yy_buf_pos = &b->yy_ch_buf[0];
| 
| 	b->yy_at_bol = 1;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	if ( b == YY_CURRENT_BUFFER )
| 		yy_load_buffer_state( );
| }
| 
| /** Pushes the new state onto the stack. The new state becomes
|  *  the current state. This function will allocate the stack
|  *  if necessary.
|  *  @param new_buffer The new state.
|  *  
|  */
| void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
| {
|     	if (new_buffer == NULL)
| 		return;
| 
| 	yyensure_buffer_stack();
| 
| 	/* This block is copied from yy_switch_to_buffer. */
| 	if ( YY_CURRENT_BUFFER )
| 		{
| 		/* Flush out information for old buffer. */
| 		*(yy_c_buf_p) = (yy_hold_char);
| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	/* Only push if top exists. Otherwise, replace top. */
| 	if (YY_CURRENT_BUFFER)
| 		(yy_buffer_stack_top)++;
| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
| 
| 	/* copied from yy_switch_to_buffer. */
| 	yy_load_buffer_state( );
| 	(yy_did_buffer_switch_on_eof) = 1;
| }
| 
| /** Removes and deletes the top of the stack, if present.
|  *  The next element becomes the new top.
|  *  
|  */
| void yypop_buffer_state (void)
| {
|     	if (!YY_CURRENT_BUFFER)
| 		return;
| 
| 	yy_delete_buffer(YY_CURRENT_BUFFER );
| 	YY_CURRENT_BUFFER_LVALUE = NULL;
| 	if ((yy_buffer_stack_top) > 0)
| 		--(yy_buffer_stack_top);
| 
| 	if (YY_CURRENT_BUFFER) {
| 		yy_load_buffer_state( );
| 		(yy_did_buffer_switch_on_eof) = 1;
| 	}
| }
| 
| /* Allocates the stack if it does not exist.
|  *  Guarantees space for at least one push.
|  */
| static void yyensure_buffer_stack (void)
| {
| 	yy_size_t num_to_alloc;
|     
| 	if (!(yy_buffer_stack)) {
| 
| 		/* First allocation is just for 2 elements, since we don't know if this
| 		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
| 		 * immediate realloc on the next call.
|          */
| 		num_to_alloc = 1;
| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
| 								(num_to_alloc * sizeof(struct yy_buffer_state*)
| 								);
| 		if ( ! (yy_buffer_stack) )
| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
| 								  
| 		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
| 				
| 		(yy_buffer_stack_max) = num_to_alloc;
| 		(yy_buffer_stack_top) = 0;
| 		return;
| 	}
| 
| 	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
| 
| 		/* Increase the buffer to prepare for a possible push. */
| 		int grow_size = 8 /* arbitrary grow size */;
| 
| 		num_to_alloc = (yy_buffer_stack_max) + grow_size;
| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
| 								((yy_buffer_stack),
| 								num_to_alloc * sizeof(struct yy_buffer_state*)
| 								);
| 		if ( ! (yy_buffer_stack) )
| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
| 
| 		/* zero only the new slots.*/
| 		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
| 		(yy_buffer_stack_max) = num_to_alloc;
| 	}
| }
| 
| /** Setup the input buffer state to scan directly from a user-specified character buffer.
|  * @param base the character buffer
|  * @param size the size in bytes of the character buffer
|  * 
|  * @return the newly allocated buffer state object. 
|  */
| YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
| {
| 	YY_BUFFER_STATE b;
|     
| 	if ( size < 2 ||
| 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
| 	     base[size-1] != YY_END_OF_BUFFER_CHAR )
| 		/* They forgot to leave room for the EOB's. */
| 		return 0;
| 
| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
| 
| 	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
| 	b->yy_buf_pos = b->yy_ch_buf = base;
| 	b->yy_is_our_buffer = 0;
| 	b->yy_input_file = 0;
| 	b->yy_n_chars = b->yy_buf_size;
| 	b->yy_is_interactive = 0;
| 	b->yy_at_bol = 1;
| 	b->yy_fill_buffer = 0;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	yy_switch_to_buffer(b  );
| 
| 	return b;
| }
| 
| /** Setup the input buffer state to scan a string. The next call to yylex() will
|  * scan from a @e copy of @a str.
|  * @param yystr a NUL-terminated string to scan
|  * 
|  * @return the newly allocated buffer state object.
|  * @note If you want to scan bytes that may contain NUL values, then use
|  *       yy_scan_bytes() instead.
|  */
| YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
| {
|     
| 	return yy_scan_bytes(yystr,strlen(yystr) );
| }
| 
| /** Setup the input buffer state to scan the given bytes. The next call to yylex() will
|  * scan from a @e copy of @a bytes.
|  * @param yybytes the byte buffer to scan
|  * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
|  * 
|  * @return the newly allocated buffer state object.
|  */
| YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len )
| {
| 	YY_BUFFER_STATE b;
| 	char *buf;
| 	yy_size_t n;
| 	yy_size_t i;
|     
| 	/* Get memory for full buffer, including space for trailing EOB's. */
| 	n = _yybytes_len + 2;
| 	buf = (char *) yyalloc(n  );
| 	if ( ! buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
| 
| 	for ( i = 0; i < _yybytes_len; ++i )
| 		buf[i] = yybytes[i];
| 
| 	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b = yy_scan_buffer(buf,n );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
| 
| 	/* It's okay to grow etc. this buffer, and we should throw it
| 	 * away when we're done.
| 	 */
| 	b->yy_is_our_buffer = 1;
| 
| 	return b;
| }
| 
| #ifndef YY_EXIT_FAILURE
| #define YY_EXIT_FAILURE 2
| #endif
| 
| static void yy_fatal_error (yyconst char* msg )
| {
|     	(void) fprintf( stderr, "%s\n", msg );
| 	exit( YY_EXIT_FAILURE );
| }
| 
| /* Redefine yyless() so it works in section 3 code. */
| 
| #undef yyless
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
|         int yyless_macro_arg = (n); \
|         YY_LESS_LINENO(yyless_macro_arg);\
| 		yytext[yyleng] = (yy_hold_char); \
| 		(yy_c_buf_p) = yytext + yyless_macro_arg; \
| 		(yy_hold_char) = *(yy_c_buf_p); \
| 		*(yy_c_buf_p) = '\0'; \
| 		yyleng = yyless_macro_arg; \
| 		} \
| 	while ( 0 )
| 
| /* Accessor  methods (get/set functions) to struct members. */
| 
| /** Get the current line number.
|  * 
|  */
| int yyget_lineno  (void)
| {
|         
|     return yylineno;
| }
| 
| /** Get the input stream.
|  * 
|  */
| FILE *yyget_in  (void)
| {
|         return yyin;
| }
| 
| /** Get the output stream.
|  * 
|  */
| FILE *yyget_out  (void)
| {
|         return yyout;
| }
| 
| /** Get the length of the current token.
|  * 
|  */
| yy_size_t yyget_leng  (void)
| {
|         return yyleng;
| }
| 
| /** Get the current token.
|  * 
|  */
| 
| char *yyget_text  (void)
| {
|         return yytext;
| }
| 
| /** Set the current line number.
|  * @param line_number
|  * 
|  */
| void yyset_lineno (int  line_number )
| {
|     
|     yylineno = line_number;
| }
| 
| /** Set the input stream. This does not discard the current
|  * input buffer.
|  * @param in_str A readable stream.
|  * 
|  * @see yy_switch_to_buffer
|  */
| void yyset_in (FILE *  in_str )
| {
|         yyin = in_str ;
| }
| 
| void yyset_out (FILE *  out_str )
| {
|         yyout = out_str ;
| }
| 
| int yyget_debug  (void)
| {
|         return yy_flex_debug;
| }
| 
| void yyset_debug (int  bdebug )
| {
|         yy_flex_debug = bdebug ;
| }
| 
| static int yy_init_globals (void)
| {
|         /* Initialization is the same as for the non-reentrant scanner.
|      * This function is called from yylex_destroy(), so don't allocate here.
|      */
| 
|     (yy_buffer_stack) = 0;
|     (yy_buffer_stack_top) = 0;
|     (yy_buffer_stack_max) = 0;
|     (yy_c_buf_p) = (char *) 0;
|     (yy_init) = 0;
|     (yy_start) = 0;
| 
|     (yy_state_buf) = 0;
|     (yy_state_ptr) = 0;
|     (yy_full_match) = 0;
|     (yy_lp) = 0;
| 
| /* Defined in main.c */
| #ifdef YY_STDINIT
|     yyin = stdin;
|     yyout = stdout;
| #else
|     yyin = (FILE *) 0;
|     yyout = (FILE *) 0;
| #endif
| 
|     /* For future reference: Set errno on error, since we are called by
|      * yylex_init()
|      */
|     return 0;
| }
| 
| /* yylex_destroy is for both reentrant and non-reentrant scanners. */
| int yylex_destroy  (void)
| {
|     
|     /* Pop the buffer stack, destroying each element. */
| 	while(YY_CURRENT_BUFFER){
| 		yy_delete_buffer(YY_CURRENT_BUFFER  );
| 		YY_CURRENT_BUFFER_LVALUE = NULL;
| 		yypop_buffer_state();
| 	}
| 
| 	/* Destroy the stack itself. */
| 	yyfree((yy_buffer_stack) );
| 	(yy_buffer_stack) = NULL;
| 
|     yyfree ( (yy_state_buf) );
|     (yy_state_buf)  = NULL;
| 
|     /* Reset the globals. This is important in a non-reentrant scanner so the next time
|      * yylex() is called, initialization will occur. */
|     yy_init_globals( );
| 
|     return 0;
| }
| 
| /*
|  * Internal utility routines.
|  */
| 
| #ifndef yytext_ptr
| static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
| {
| 	register int i;
| 	for ( i = 0; i < n; ++i )
| 		s1[i] = s2[i];
| }
| #endif
| 
| #ifdef YY_NEED_STRLEN
| static int yy_flex_strlen (yyconst char * s )
| {
| 	register int n;
| 	for ( n = 0; s[n]; ++n )
| 		;
| 
| 	return n;
| }
| #endif
| 
| void *yyalloc (yy_size_t  size )
| {
| 	return (void *) malloc( size );
| }
| 
| void *yyrealloc  (void * ptr, yy_size_t  size )
| {
| 	/* The cast to (char *) in the following accommodates both
| 	 * implementations that use char* generic pointers, and those
| 	 * that use void* generic pointers.  It works with the latter
| 	 * because both ANSI C and C++ allow castless assignment from
| 	 * any pointer type to void*, and deal with argument conversions
| 	 * as though doing an assignment.
| 	 */
| 	return (void *) realloc( (char *) ptr, size );
| }
| 
| void yyfree (void * ptr )
| {
| 	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
| }
| 
| #define YYTABLES_NAME "yytables"
| 
| #line 9 "conftest.l"
| 
| 
| #ifdef YYTEXT_POINTER
| extern char *yytext;
| #endif
| int
| main (void)
| {
|   return ! yylex () + ! yywrap ();
| }
configure:16221: result: no
configure:16236: checking whether to enable maintainer-specific portions of Makefiles
configure:16245: result: no
configure:16266: checking how to compare bootstrapped objects
configure:16291: result: cmp --ignore-initial=16 $$f1 $$f2
configure:16309: checking for string.h
configure:16309: result: yes
configure:16309: checking for strings.h
configure:16309: result: yes
configure:16309: checking for stdlib.h
configure:16309: result: yes
configure:16309: checking for unistd.h
configure:16309: result: yes
configure:16309: checking elf-hints.h usability
configure:16309: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:68:23: fatal error: elf-hints.h: No such file or directory
 #include <elf-hints.h>
                       ^
compilation terminated.
configure:16309: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "ld"
| #define PACKAGE_TARNAME "ld"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "ld 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "ld"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define GOT_HANDLING_DEFAULT GOT_HANDLING_TARGET_DEFAULT
| #define HAVE_LC_MESSAGES 1
| #define HAVE_STRING_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_UNISTD_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <elf-hints.h>
configure:16309: result: no
configure:16309: checking elf-hints.h presence
configure:16309: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:35:23: fatal error: elf-hints.h: No such file or directory
 #include <elf-hints.h>
                       ^
compilation terminated.
configure:16309: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "ld"
| #define PACKAGE_TARNAME "ld"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "ld 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "ld"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define GOT_HANDLING_DEFAULT GOT_HANDLING_TARGET_DEFAULT
| #define HAVE_LC_MESSAGES 1
| #define HAVE_STRING_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_UNISTD_H 1
| /* end confdefs.h.  */
| #include <elf-hints.h>
configure:16309: result: no
configure:16309: checking for elf-hints.h
configure:16309: result: no
configure:16309: checking limits.h usability
configure:16309: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:16309: $? = 0
configure:16309: result: yes
configure:16309: checking limits.h presence
configure:16309: arm-linux-androideabi-gcc -E  conftest.c
configure:16309: $? = 0
configure:16309: result: yes
configure:16309: checking for limits.h
configure:16309: result: yes
configure:16309: checking locale.h usability
configure:16309: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:16309: $? = 0
configure:16309: result: yes
configure:16309: checking locale.h presence
configure:16309: arm-linux-androideabi-gcc -E  conftest.c
configure:16309: $? = 0
configure:16309: result: yes
configure:16309: checking for locale.h
configure:16309: result: yes
configure:16309: checking sys/param.h usability
configure:16309: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:16309: $? = 0
configure:16309: result: yes
configure:16309: checking sys/param.h presence
configure:16309: arm-linux-androideabi-gcc -E  conftest.c
configure:16309: $? = 0
configure:16309: result: yes
configure:16309: checking for sys/param.h
configure:16309: result: yes
configure:16323: checking fcntl.h usability
configure:16323: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:16323: $? = 0
configure:16323: result: yes
configure:16323: checking fcntl.h presence
configure:16323: arm-linux-androideabi-gcc -E  conftest.c
configure:16323: $? = 0
configure:16323: result: yes
configure:16323: checking for fcntl.h
configure:16323: result: yes
configure:16323: checking sys/file.h usability
configure:16323: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:16323: $? = 0
configure:16323: result: yes
configure:16323: checking sys/file.h presence
configure:16323: arm-linux-androideabi-gcc -E  conftest.c
configure:16323: $? = 0
configure:16323: result: yes
configure:16323: checking for sys/file.h
configure:16323: result: yes
configure:16323: checking sys/time.h usability
configure:16323: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:16323: $? = 0
configure:16323: result: yes
configure:16323: checking sys/time.h presence
configure:16323: arm-linux-androideabi-gcc -E  conftest.c
configure:16323: $? = 0
configure:16323: result: yes
configure:16323: checking for sys/time.h
configure:16323: result: yes
configure:16323: checking for sys/stat.h
configure:16323: result: yes
configure:16334: checking whether string.h and strings.h may both be included
configure:16351: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:16351: $? = 0
configure:16358: result: yes
configure:16369: checking for glob
configure:16369: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
/tmp/ccsPdApa.o:conftest.c:function main: error: undefined reference to 'glob'
collect2: error: ld returned 1 exit status
configure:16369: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "ld"
| #define PACKAGE_TARNAME "ld"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "ld 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "ld"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define GOT_HANDLING_DEFAULT GOT_HANDLING_TARGET_DEFAULT
| #define HAVE_LC_MESSAGES 1
| #define HAVE_STRING_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_STAT_H 1
| #define STRING_WITH_STRINGS 1
| /* end confdefs.h.  */
| /* Define glob to an innocuous variant, in case <limits.h> declares glob.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define glob innocuous_glob
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char glob (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef glob
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char glob ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_glob || defined __stub___glob
| choke me
| #endif
| 
| int
| main ()
| {
| return glob ();
|   ;
|   return 0;
| }
configure:16369: result: no
configure:16369: checking for mkstemp
configure:16369: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:16369: $? = 0
configure:16369: result: yes
configure:16369: checking for realpath
configure:16369: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:16369: $? = 0
configure:16369: result: yes
configure:16369: checking for sbrk
configure:16369: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:16369: $? = 0
configure:16369: result: yes
configure:16369: checking for setlocale
configure:16369: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:16369: $? = 0
configure:16369: result: yes
configure:16369: checking for waitpid
configure:16369: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:16369: $? = 0
configure:16369: result: yes
configure:16382: checking for open
configure:16382: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:16382: $? = 0
configure:16382: result: yes
configure:16382: checking for lseek
configure:16382: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:16382: $? = 0
configure:16382: result: yes
configure:16382: checking for close
configure:16382: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:16382: $? = 0
configure:16382: result: yes
configure:16395: checking for dirent.h that defines DIR
configure:16414: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:16414: $? = 0
configure:16422: result: yes
configure:16436: checking for library containing opendir
configure:16467: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:16467: $? = 0
configure:16484: result: none required
configure:16552: checking for library containing dlopen
configure:16600: result: none required
configure:16622: checking for .preinit_array/.init_array/.fini_array support
configure:16652: result: no
configure:16665: checking for a known getopt prototype in unistd.h
configure:16681: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:16681: $? = 0
configure:16689: result: yes
configure:16705: checking whether strstr is declared
configure:16705: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:16705: $? = 0
configure:16705: result: yes
configure:16715: checking whether free is declared
configure:16715: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:16715: $? = 0
configure:16715: result: yes
configure:16725: checking whether sbrk is declared
configure:16725: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:16725: $? = 0
configure:16725: result: yes
configure:16735: checking whether getenv is declared
configure:16735: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:16735: $? = 0
configure:16735: result: yes
configure:16745: checking whether environ is declared
configure:16745: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:16745: $? = 0
configure:16745: result: yes
configure:16771: checking for library containing zlibVersion
configure:16802: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
/tmp/ccUNpNkp.o:conftest.c:function main: error: undefined reference to 'zlibVersion'
collect2: error: ld returned 1 exit status
configure:16802: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "ld"
| #define PACKAGE_TARNAME "ld"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "ld 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "ld"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define GOT_HANDLING_DEFAULT GOT_HANDLING_TARGET_DEFAULT
| #define HAVE_LC_MESSAGES 1
| #define HAVE_STRING_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_STAT_H 1
| #define STRING_WITH_STRINGS 1
| #define HAVE_MKSTEMP 1
| #define HAVE_REALPATH 1
| #define HAVE_SBRK 1
| #define HAVE_SETLOCALE 1
| #define HAVE_WAITPID 1
| #define HAVE_OPEN 1
| #define HAVE_LSEEK 1
| #define HAVE_CLOSE 1
| #define HAVE_DIRENT_H 1
| #define HAVE_DECL_GETOPT 1
| #define HAVE_DECL_STRSTR 1
| #define HAVE_DECL_FREE 1
| #define HAVE_DECL_SBRK 1
| #define HAVE_DECL_GETENV 1
| #define HAVE_DECL_ENVIRON 1
| /* end confdefs.h.  */
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char zlibVersion ();
| int
| main ()
| {
| return zlibVersion ();
|   ;
|   return 0;
| }
configure:16802: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c -lz   >&5
configure:16802: $? = 0
configure:16819: result: -lz
configure:16826: checking zlib.h usability
configure:16826: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:16826: $? = 0
configure:16826: result: yes
configure:16826: checking zlib.h presence
configure:16826: arm-linux-androideabi-gcc -E  conftest.c
configure:16826: $? = 0
configure:16826: result: yes
configure:16826: checking for zlib.h
configure:16826: result: yes
configure:16850: checking whether ANSI C string concatenation works
configure:16866: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:16866: $? = 0
configure:16874: result: yes
configure:16900: checking size of void *
configure:16905: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:16905: $? = 0
configure:16905: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:95:12: error: size of array 'test_array' is negative
 static int test_array [1 - 2 * !(((long int) (sizeof (void *))) <= 0)];
            ^
configure:16905: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "ld"
| #define PACKAGE_TARNAME "ld"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "ld 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "ld"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define GOT_HANDLING_DEFAULT GOT_HANDLING_TARGET_DEFAULT
| #define HAVE_LC_MESSAGES 1
| #define HAVE_STRING_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_STAT_H 1
| #define STRING_WITH_STRINGS 1
| #define HAVE_MKSTEMP 1
| #define HAVE_REALPATH 1
| #define HAVE_SBRK 1
| #define HAVE_SETLOCALE 1
| #define HAVE_WAITPID 1
| #define HAVE_OPEN 1
| #define HAVE_LSEEK 1
| #define HAVE_CLOSE 1
| #define HAVE_DIRENT_H 1
| #define HAVE_DECL_GETOPT 1
| #define HAVE_DECL_STRSTR 1
| #define HAVE_DECL_FREE 1
| #define HAVE_DECL_SBRK 1
| #define HAVE_DECL_GETENV 1
| #define HAVE_DECL_ENVIRON 1
| #define HAVE_ZLIB_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static int test_array [1 - 2 * !(((long int) (sizeof (void *))) <= 0)];
| test_array [0] = 0
| 
|   ;
|   return 0;
| }
configure:16905: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:95:12: error: size of array 'test_array' is negative
 static int test_array [1 - 2 * !(((long int) (sizeof (void *))) <= 1)];
            ^
configure:16905: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "ld"
| #define PACKAGE_TARNAME "ld"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "ld 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "ld"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define GOT_HANDLING_DEFAULT GOT_HANDLING_TARGET_DEFAULT
| #define HAVE_LC_MESSAGES 1
| #define HAVE_STRING_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_STAT_H 1
| #define STRING_WITH_STRINGS 1
| #define HAVE_MKSTEMP 1
| #define HAVE_REALPATH 1
| #define HAVE_SBRK 1
| #define HAVE_SETLOCALE 1
| #define HAVE_WAITPID 1
| #define HAVE_OPEN 1
| #define HAVE_LSEEK 1
| #define HAVE_CLOSE 1
| #define HAVE_DIRENT_H 1
| #define HAVE_DECL_GETOPT 1
| #define HAVE_DECL_STRSTR 1
| #define HAVE_DECL_FREE 1
| #define HAVE_DECL_SBRK 1
| #define HAVE_DECL_GETENV 1
| #define HAVE_DECL_ENVIRON 1
| #define HAVE_ZLIB_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static int test_array [1 - 2 * !(((long int) (sizeof (void *))) <= 1)];
| test_array [0] = 0
| 
|   ;
|   return 0;
| }
configure:16905: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:95:12: error: size of array 'test_array' is negative
 static int test_array [1 - 2 * !(((long int) (sizeof (void *))) <= 3)];
            ^
configure:16905: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "ld"
| #define PACKAGE_TARNAME "ld"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "ld 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "ld"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define GOT_HANDLING_DEFAULT GOT_HANDLING_TARGET_DEFAULT
| #define HAVE_LC_MESSAGES 1
| #define HAVE_STRING_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_STAT_H 1
| #define STRING_WITH_STRINGS 1
| #define HAVE_MKSTEMP 1
| #define HAVE_REALPATH 1
| #define HAVE_SBRK 1
| #define HAVE_SETLOCALE 1
| #define HAVE_WAITPID 1
| #define HAVE_OPEN 1
| #define HAVE_LSEEK 1
| #define HAVE_CLOSE 1
| #define HAVE_DIRENT_H 1
| #define HAVE_DECL_GETOPT 1
| #define HAVE_DECL_STRSTR 1
| #define HAVE_DECL_FREE 1
| #define HAVE_DECL_SBRK 1
| #define HAVE_DECL_GETENV 1
| #define HAVE_DECL_ENVIRON 1
| #define HAVE_ZLIB_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static int test_array [1 - 2 * !(((long int) (sizeof (void *))) <= 3)];
| test_array [0] = 0
| 
|   ;
|   return 0;
| }
configure:16905: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:16905: $? = 0
configure:16905: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:16905: $? = 0
configure:16905: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:16905: $? = 0
configure:16920: result: 4
configure:17121: updating cache ./config.cache
configure:17194: creating ./config.status

## ---------------------- ##
## Running config.status. ##
## ---------------------- ##

This file was extended by ld config.status 2.25.1, which was
generated by GNU Autoconf 2.64.  Invocation command line was

  CONFIG_FILES    = 
  CONFIG_HEADERS  = 
  CONFIG_LINKS    = 
  CONFIG_COMMANDS = 
  $ ./config.status 

on d5f3793a98c0

config.status:1264: creating Makefile
config.status:1264: creating po/Makefile.in
config.status:1264: creating config.h
config.status:1482: executing depfiles commands
config.status:1482: executing libtool commands
config.status:1482: executing default-1 commands

## ---------------- ##
## Cache variables. ##
## ---------------- ##

ac_cv_build=x86_64-unknown-linux-gnu
ac_cv_c_compiler_gnu=yes
ac_cv_cxx_compiler_gnu=yes
ac_cv_env_CCC_set=
ac_cv_env_CCC_value=
ac_cv_env_CC_set=set
ac_cv_env_CC_value=arm-linux-androideabi-gcc
ac_cv_env_CFLAGS_set=set
ac_cv_env_CFLAGS_value=
ac_cv_env_CPPFLAGS_set=set
ac_cv_env_CPPFLAGS_value=
ac_cv_env_CPP_set=
ac_cv_env_CPP_value=
ac_cv_env_CXXCPP_set=
ac_cv_env_CXXCPP_value=
ac_cv_env_CXXFLAGS_set=set
ac_cv_env_CXXFLAGS_value=
ac_cv_env_CXX_set=set
ac_cv_env_CXX_value=arm-linux-androideabi-g++
ac_cv_env_LDFLAGS_set=set
ac_cv_env_LDFLAGS_value='-static-libstdc++ -static-libgcc '
ac_cv_env_LIBS_set=
ac_cv_env_LIBS_value=
ac_cv_env_YACC_set=set
ac_cv_env_YACC_value='bison -y'
ac_cv_env_YFLAGS_set=
ac_cv_env_YFLAGS_value=
ac_cv_env_build_alias_set=set
ac_cv_env_build_alias_value=x86_64-unknown-linux-gnu
ac_cv_env_host_alias_set=set
ac_cv_env_host_alias_value=x86_64-unknown-linux
ac_cv_env_target_alias_set=set
ac_cv_env_target_alias_value=i686-w64-mingw32
ac_cv_func_close=yes
ac_cv_func_glob=no
ac_cv_func_lseek=yes
ac_cv_func_mkstemp=yes
ac_cv_func_open=yes
ac_cv_func_realpath=yes
ac_cv_func_sbrk=yes
ac_cv_func_setlocale=yes
ac_cv_func_waitpid=yes
ac_cv_have_decl_environ=yes
ac_cv_have_decl_free=yes
ac_cv_have_decl_getenv=yes
ac_cv_have_decl_sbrk=yes
ac_cv_have_decl_strstr=yes
ac_cv_header_dirent_dirent_h=yes
ac_cv_header_dlfcn_h=yes
ac_cv_header_elf_hints_h=no
ac_cv_header_fcntl_h=yes
ac_cv_header_inttypes_h=yes
ac_cv_header_limits_h=yes
ac_cv_header_locale_h=yes
ac_cv_header_memory_h=yes
ac_cv_header_minix_config_h=no
ac_cv_header_stdc=yes
ac_cv_header_stdint_h=yes
ac_cv_header_stdlib_h=yes
ac_cv_header_string_h=yes
ac_cv_header_strings_h=yes
ac_cv_header_sys_file_h=yes
ac_cv_header_sys_param_h=yes
ac_cv_header_sys_stat_h=yes
ac_cv_header_sys_time_h=yes
ac_cv_header_sys_types_h=yes
ac_cv_header_unistd_h=yes
ac_cv_header_windows_h=no
ac_cv_header_zlib_h=yes
ac_cv_host=x86_64-unknown-linux-gnu
ac_cv_lib_lex='none needed'
ac_cv_objext=o
ac_cv_path_EGREP='/usr/sbin/grep -E'
ac_cv_path_FGREP='/usr/sbin/grep -F'
ac_cv_path_GMSGFMT=/usr/sbin/msgfmt
ac_cv_path_GREP=/usr/sbin/grep
ac_cv_path_MSGFMT=/usr/sbin/msgfmt
ac_cv_path_MSGMERGE=/usr/sbin/msgmerge
ac_cv_path_SED=/usr/sbin/sed
ac_cv_path_XGETTEXT=/usr/sbin/xgettext
ac_cv_path_mkdir=/usr/sbin/mkdir
ac_cv_prog_AR=ar
ac_cv_prog_AWK=gawk
ac_cv_prog_CC=arm-linux-androideabi-gcc
ac_cv_prog_CPP='arm-linux-androideabi-gcc -E'
ac_cv_prog_CXXCPP='arm-linux-androideabi-g++ -E'
ac_cv_prog_LEX=flex
ac_cv_prog_OBJDUMP=objdump
ac_cv_prog_RANLIB=ranlib
ac_cv_prog_STRIP=strip
ac_cv_prog_YACC='bison -y'
ac_cv_prog_ac_ct_STRIP=strip
ac_cv_prog_cc_c89=
ac_cv_prog_cc_g=yes
ac_cv_prog_cxx_g=yes
ac_cv_prog_lex_root=lex.yy
ac_cv_prog_lex_yytext_pointer=no
ac_cv_prog_make_make_set=yes
ac_cv_safe_to_define___extensions__=yes
ac_cv_search_dlopen='none required'
ac_cv_search_opendir='none required'
ac_cv_search_strerror='none required'
ac_cv_search_zlibVersion=-lz
ac_cv_sizeof_void_p=4
ac_cv_sys_file_offset_bits=unknown
ac_cv_sys_large_files=unknown
ac_cv_sys_largefile_CC=no
ac_cv_target=i686-w64-mingw32
am_cv_CC_dependencies_compiler_type=gcc3
am_cv_CXX_dependencies_compiler_type=gcc3
am_cv_val_LC_MESSAGES=yes
gcc_cv_header_string=yes
gcc_cv_initfini_array=no
gcc_cv_prog_cmp_skip='cmp --ignore-initial=16 $$f1 $$f2'
ld_cv_decl_getopt_unistd_h=yes
ld_cv_string_concatenation=yes
lt_cv_archive_cmds_need_lc=no
lt_cv_deplibs_check_method=pass_all
lt_cv_file_magic_cmd='$MAGIC_CMD'
lt_cv_file_magic_test_file=
lt_cv_ld_reload_flag=-r
lt_cv_nm_interface='BSD nm'
lt_cv_objdir=.libs
lt_cv_path_LD=/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld
lt_cv_path_LDCXX='/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld -m elf_i386'
lt_cv_path_NM=nm
lt_cv_prog_compiler_c_o=yes
lt_cv_prog_compiler_c_o_CXX=yes
lt_cv_prog_compiler_pic_works=yes
lt_cv_prog_compiler_pic_works_CXX=yes
lt_cv_prog_compiler_rtti_exceptions=no
lt_cv_prog_compiler_static_works=yes
lt_cv_prog_compiler_static_works_CXX=yes
lt_cv_prog_gnu_ld=yes
lt_cv_prog_gnu_ldcxx=yes
lt_cv_shlibpath_overrides_runpath=yes
lt_cv_sys_global_symbol_pipe='sed -n -e '\''s/^.*[	 ]\([ABCDGIRSTW][ABCDGIRSTW]*\)[	 ][	 ]*\([_A-Za-z][_A-Za-z0-9]*\)$/\1 \2 \2/p'\'''
lt_cv_sys_global_symbol_to_c_name_address='sed -n -e '\''s/^: \([^ ]*\) $/  {\"\1\", (void *) 0},/p'\'' -e '\''s/^[ABCDGIRSTW]* \([^ ]*\) \([^ ]*\)$/  {"\2", (void *) \&\2},/p'\'''
lt_cv_sys_global_symbol_to_c_name_address_lib_prefix='sed -n -e '\''s/^: \([^ ]*\) $/  {\"\1\", (void *) 0},/p'\'' -e '\''s/^[ABCDGIRSTW]* \([^ ]*\) \(lib[^ ]*\)$/  {"\2", (void *) \&\2},/p'\'' -e '\''s/^[ABCDGIRSTW]* \([^ ]*\) \([^ ]*\)$/  {"lib\2", (void *) \&\2},/p'\'''
lt_cv_sys_global_symbol_to_cdecl='sed -n -e '\''s/^T .* \(.*\)$/extern int \1();/p'\'' -e '\''s/^[ABCDGIRSTW]* .* \(.*\)$/extern char \1;/p'\'''
lt_cv_sys_max_cmd_len=1572864

## ----------------- ##
## Output variables. ##
## ----------------- ##

ACLOCAL='${SHELL} /tmp/mingw-w64-binutils/src/binutils-2.25.1/missing --run aclocal-1.11'
AMDEPBACKSLASH='\'
AMDEP_FALSE='#'
AMDEP_TRUE=''
AMTAR='${SHELL} /tmp/mingw-w64-binutils/src/binutils-2.25.1/missing --run tar'
AR='ar'
AUTOCONF='${SHELL} /tmp/mingw-w64-binutils/src/binutils-2.25.1/missing --run autoconf'
AUTOHEADER='${SHELL} /tmp/mingw-w64-binutils/src/binutils-2.25.1/missing --run autoheader'
AUTOMAKE='${SHELL} /tmp/mingw-w64-binutils/src/binutils-2.25.1/missing --run automake-1.11'
AWK='gawk'
CATALOGS=''
CATOBJEXT=''
CC='arm-linux-androideabi-gcc'
CCDEPMODE='depmode=gcc3'
CFLAGS=''
CPP='arm-linux-androideabi-gcc -E'
CPPFLAGS=''
CXX='arm-linux-androideabi-g++'
CXXCPP='arm-linux-androideabi-g++ -E'
CXXDEPMODE='depmode=gcc3'
CXXFLAGS=''
CYGPATH_W='echo'
DATADIRNAME=''
DEFS='-DHAVE_CONFIG_H'
DEPDIR='.deps'
DSYMUTIL=''
DUMPBIN=''
ECHO_C=''
ECHO_N='-n'
ECHO_T=''
EGREP='/usr/sbin/grep -E'
EMUL='i386pe'
EMULATION_LIBPATH='i386pe'
EMULATION_OFILES=' ei386pe.o'
EMUL_EXTRA_OFILES=' deffilep.o pe-dll.o'
ENABLE_PLUGINS_FALSE='#'
ENABLE_PLUGINS_TRUE=''
EXEEXT=''
FGREP='/usr/sbin/grep -F'
GENCAT=''
GENINSRC_NEVER_FALSE=''
GENINSRC_NEVER_TRUE='#'
GMSGFMT='/usr/sbin/msgfmt'
GREP='/usr/sbin/grep'
HDEFINES=''
HOSTING_CRT0='-dynamic-linker `${CC} --help --verbose 2>&1 | egrep "ld[^ ]*\.so" | sed -e "s,.*-dynamic-linker[ 	][ 	]*\(.*/ld[^ ]*\.so..\).*,\1,"` `${CC} --print-file-name=crt1.o` `${CC} --print-file-name=crti.o` `if [ -f ../gcc/crtbegin.o ]; then echo ../gcc/crtbegin.o; else ${CC} --print-file-name=crtbegin.o; fi`'
HOSTING_LIBS='-L`dirname \`${CC} --print-file-name=libc.so\`` `if [ -f ../gcc/libgcc.a ]; then libgcc=../gcc/libgcc.a; else libgcc=\`${CC} -print-libgcc-file-name\`; fi; if [ -f ../gcc/libgcc_eh.a ]; then libgcc="$$libgcc ../gcc/libgcc_eh.a"; else libgcc_eh=\`${CC} -print-file-name=libgcc_eh.a\`; if [ x"$$libgcc_eh" != xlibgcc_eh.a ]; then libgcc="$$libgcc $$libgcc_eh"; fi; fi; if [ -f ../gcc/libunwind.a ]; then libgcc="$$libgcc ../gcc/libunwind.a"; else libunwind=\`${CC} -print-file-name=libunwind.a\`; if [ x"$$libunwind" != xlibunwind.a ]; then libgcc="$$libgcc $$libunwind"; fi; fi; echo --start-group $$libgcc -lc --end-group` `if [ -f ../gcc/crtend.o ]; then echo ../gcc/crtend.o; else ${CC} --print-file-name=crtend.o; fi` `${CC} --print-file-name=crtn.o`'
HOSTING_SCRT0='-dynamic-linker `${CC} --help --verbose 2>&1 | egrep "ld[^ ]*\.so" | sed -e "s,.*-dynamic-linker[ 	][ 	]*\(.*/ld[^ ]*\.so..\).*,\1,"` `${CC} --print-file-name=Scrt1.o` `${CC} --print-file-name=crti.o` `if [ -f ../gcc/crtbeginS.o ]; then echo ../gcc/crtbeginS.o; else ${CC} --print-file-name=crtbeginS.o; fi`'
HOSTING_SLIBS='-L`dirname \`${CC} --print-file-name=libc.so\`` `if [ -f ../gcc/libgcc.a ]; then libgcc=../gcc/libgcc.a; else libgcc=\`${CC} -print-libgcc-file-name\`; fi; if [ -f ../gcc/libgcc_eh.a ]; then libgcc="$$libgcc ../gcc/libgcc_eh.a"; else libgcc_eh=\`${CC} -print-file-name=libgcc_eh.a\`; if [ x"$$libgcc_eh" != xlibgcc_eh.a ]; then libgcc="$$libgcc $$libgcc_eh"; fi; fi; if [ -f ../gcc/libunwind.a ]; then libgcc="$$libgcc ../gcc/libunwind.a"; else libunwind=\`${CC} -print-file-name=libunwind.a\`; if [ x"$$libunwind" != xlibunwind.a ]; then libgcc="$$libgcc $$libunwind"; fi; fi; echo --start-group $$libgcc -lc --end-group` `if [ -f ../gcc/crtendS.o ]; then echo ../gcc/crtendS.o; else ${CC} --print-file-name=crtendS.o; fi` `${CC} --print-file-name=crtn.o`'
INCINTL=''
INSTALL_DATA='/usr/bin/install -c -m 644'
INSTALL_PROGRAM='/usr/bin/install -c'
INSTALL_SCRIPT='/usr/bin/install -c'
INSTALL_STRIP_PROGRAM='$(install_sh) -c -s'
INSTOBJEXT=''
LD='/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld -m elf_i386'
LDFLAGS='-static-libstdc++ -static-libgcc '
LEX='flex'
LEXLIB=''
LEX_OUTPUT_ROOT='lex.yy'
LIBINTL=''
LIBINTL_DEP=''
LIBOBJS=''
LIBS='-lz '
LIBTOOL='$(SHELL) $(top_builddir)/libtool'
LIB_PATH=''
LIPO=''
LN_S='ln -s'
LTLIBOBJS=''
MAINT='#'
MAINTAINER_MODE_FALSE=''
MAINTAINER_MODE_TRUE='#'
MAKEINFO='makeinfo --split-size=5000000'
MKDIR_P='/usr/sbin/mkdir -p'
MKINSTALLDIRS='/tmp/mingw-w64-binutils/src/binutils-2.25.1/ld/../mkinstalldirs'
MSGFMT='/usr/sbin/msgfmt'
MSGMERGE='/usr/sbin/msgmerge'
NATIVE_LIB_DIRS='/usr/local/lib /lib /usr/lib'
NM='nm'
NMEDIT=''
NO_WERROR=''
OBJDUMP='objdump'
OBJEXT='o'
OTOOL64=''
OTOOL=''
PACKAGE='ld'
PACKAGE_BUGREPORT=''
PACKAGE_NAME='ld'
PACKAGE_STRING='ld 2.25.1'
PACKAGE_TARNAME='ld'
PACKAGE_URL=''
PACKAGE_VERSION='2.25.1'
PATH_SEPARATOR=':'
POSUB=''
RANLIB='ranlib'
SED='/usr/sbin/sed'
SET_MAKE=''
SHELL='/bin/sh'
STRINGIFY='astring.sed'
STRIP='strip'
TARGET_SYSTEM_ROOT=''
TARGET_SYSTEM_ROOT_DEFINE='-DTARGET_SYSTEM_ROOT=\"\"'
TESTBFDLIB='../bfd/.libs/libbfd.a'
USE_NLS='no'
VERSION='2.25.1'
WARN_CFLAGS='-W -Wall -Wstrict-prototypes -Wmissing-prototypes -Wshadow'
XGETTEXT='/usr/sbin/xgettext'
YACC='bison -y'
YFLAGS=''
ac_ct_CC=''
ac_ct_CXX=''
ac_ct_DUMPBIN=''
am__EXEEXT_FALSE=''
am__EXEEXT_TRUE='#'
am__fastdepCC_FALSE='#'
am__fastdepCC_TRUE=''
am__fastdepCXX_FALSE='#'
am__fastdepCXX_TRUE=''
am__include='include'
am__isrc=' -I$(srcdir)'
am__leading_dot='.'
am__quote=''
am__tar='${AMTAR} chof - "$$tardir"'
am__untar='${AMTAR} xf -'
bindir='${exec_prefix}/bin'
build='x86_64-unknown-linux-gnu'
build_alias='x86_64-unknown-linux-gnu'
build_cpu='x86_64'
build_os='linux-gnu'
build_vendor='unknown'
datadir='${datarootdir}'
datarootdir='${prefix}/share'
do_compare='cmp --ignore-initial=16 $$f1 $$f2'
docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
dvidir='${docdir}'
enable_initfini_array='no'
exec_prefix='${prefix}'
host='x86_64-unknown-linux-gnu'
host_alias='x86_64-unknown-linux'
host_cpu='x86_64'
host_os='linux-gnu'
host_vendor='unknown'
htmldir='${docdir}'
includedir='${prefix}/include'
infodir='/usr/share/info/i686-w64-mingw32'
install_as_default='yes'
install_sh='${SHELL} /tmp/mingw-w64-binutils/src/binutils-2.25.1/install-sh'
installed_linker='ld.bfd'
libdir='${exec_prefix}/lib'
libexecdir='${exec_prefix}/libexec'
localedir='${datarootdir}/locale'
localstatedir='${prefix}/var'
mandir='${datarootdir}/man'
mkdir_p='/usr/sbin/mkdir -p'
oldincludedir='/usr/include'
pdfdir='${docdir}'
prefix='/usr'
program_transform_name='s&^&i686-w64-mingw32-&'
psdir='${docdir}'
sbindir='${exec_prefix}/sbin'
sharedstatedir='${prefix}/com'
sysconfdir='${prefix}/etc'
target='i686-w64-mingw32'
target_alias='i686-w64-mingw32'
target_cpu='i686'
target_os='mingw32'
target_vendor='w64'
use_sysroot='no'

## ------------------- ##
## File substitutions. ##
## ------------------- ##

TDIRS='tdirs'

## ----------- ##
## confdefs.h. ##
## ----------- ##

/* confdefs.h */
#define PACKAGE_NAME "ld"
#define PACKAGE_TARNAME "ld"
#define PACKAGE_VERSION "2.25.1"
#define PACKAGE_STRING "ld 2.25.1"
#define PACKAGE_BUGREPORT ""
#define PACKAGE_URL ""
#define PACKAGE "ld"
#define VERSION "2.25.1"
#define STDC_HEADERS 1
#define HAVE_SYS_TYPES_H 1
#define HAVE_SYS_STAT_H 1
#define HAVE_STDLIB_H 1
#define HAVE_STRING_H 1
#define HAVE_MEMORY_H 1
#define HAVE_STRINGS_H 1
#define HAVE_INTTYPES_H 1
#define HAVE_STDINT_H 1
#define HAVE_UNISTD_H 1
#define __EXTENSIONS__ 1
#define _ALL_SOURCE 1
#define _GNU_SOURCE 1
#define _POSIX_PTHREAD_SEMANTICS 1
#define _TANDEM_SOURCE 1
#define HAVE_DLFCN_H 1
#define LT_OBJDIR ".libs/"
#define HAVE_DLFCN_H 1
#define GOT_HANDLING_DEFAULT GOT_HANDLING_TARGET_DEFAULT
#define HAVE_LC_MESSAGES 1
#define HAVE_STRING_H 1
#define HAVE_STRINGS_H 1
#define HAVE_STDLIB_H 1
#define HAVE_UNISTD_H 1
#define HAVE_LIMITS_H 1
#define HAVE_LOCALE_H 1
#define HAVE_SYS_PARAM_H 1
#define HAVE_FCNTL_H 1
#define HAVE_SYS_FILE_H 1
#define HAVE_SYS_TIME_H 1
#define HAVE_SYS_STAT_H 1
#define STRING_WITH_STRINGS 1
#define HAVE_MKSTEMP 1
#define HAVE_REALPATH 1
#define HAVE_SBRK 1
#define HAVE_SETLOCALE 1
#define HAVE_WAITPID 1
#define HAVE_OPEN 1
#define HAVE_LSEEK 1
#define HAVE_CLOSE 1
#define HAVE_DIRENT_H 1
#define HAVE_DECL_GETOPT 1
#define HAVE_DECL_STRSTR 1
#define HAVE_DECL_FREE 1
#define HAVE_DECL_SBRK 1
#define HAVE_DECL_GETENV 1
#define HAVE_DECL_ENVIRON 1
#define HAVE_ZLIB_H 1
#define SIZEOF_VOID_P 4

configure: exit 0

____
File /tmp/mingw-w64-binutils/src/binutils-i686-w64-mingw32/opcodes/config.log
This file contains any messages produced by compilers while
running configure, to aid debugging if configure makes a mistake.

It was created by opcodes configure 2.25.1, which was
generated by GNU Autoconf 2.64.  Invocation command line was

  $ /tmp/mingw-w64-binutils/src/binutils-2.25.1/opcodes/configure --cache-file=./config.cache --with-gnu-as --with-gnu-ld --with-system-zlib --prefix=/usr --infodir=/usr/share/info/i686-w64-mingw32 --enable-lto --enable-plugins --disable-multilib --disable-nls --disable-werror --program-transform-name=s&^&i686-w64-mingw32-& --disable-option-checking --build=x86_64-unknown-linux-gnu --host=x86_64-unknown-linux --target=i686-w64-mingw32 --srcdir=/tmp/mingw-w64-binutils/src/binutils-2.25.1/opcodes

## --------- ##
## Platform. ##
## --------- ##

hostname = d5f3793a98c0
uname -m = x86_64
uname -r = 3.13.0-66-generic
uname -s = Linux
uname -v = #108-Ubuntu SMP Wed Oct 7 15:20:27 UTC 2015

/usr/bin/uname -p = unknown
/bin/uname -X     = unknown

/bin/arch              = unknown
/usr/bin/arch -k       = unknown
/usr/convex/getsysinfo = unknown
/usr/bin/hostinfo      = unknown
/bin/machine           = unknown
/usr/bin/oslevel       = unknown
/bin/universe          = unknown

PATH: /tmp/toolchain/bin
PATH: /usr/local/sbin
PATH: /usr/local/bin
PATH: /usr/sbin
PATH: /usr/bin
PATH: /sbin
PATH: /bin


## ----------- ##
## Core tests. ##
## ----------- ##

configure:2184: creating cache ./config.cache
configure:2289: checking build system type
configure:2303: result: x86_64-unknown-linux-gnu
configure:2323: checking host system type
configure:2336: result: x86_64-unknown-linux-gnu
configure:2356: checking target system type
configure:2369: result: i686-w64-mingw32
configure:2403: checking for x86_64-unknown-linux-gcc
configure:2430: result: arm-linux-androideabi-gcc
configure:2699: checking for C compiler version
configure:2708: arm-linux-androideabi-gcc --version >&5
arm-linux-androideabi-gcc (GCC) 4.8
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

configure:2719: $? = 0
configure:2708: arm-linux-androideabi-gcc -v >&5
Using built-in specs.
COLLECT_GCC=arm-linux-androideabi-gcc
COLLECT_LTO_WRAPPER=/tmp/toolchain/bin/../libexec/gcc/arm-linux-androideabi/4.8/lto-wrapper
Target: arm-linux-androideabi
Configured with: /s/ndk-toolchain/src/build/../gcc/gcc-4.8/configure --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --target=arm-linux-androideabi --host=x86_64-linux-gnu --build=x86_64-linux-gnu --with-gnu-as --with-gnu-ld --enable-languages=c,c++ --with-gmp=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpfr=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpc=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-cloog=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-isl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-ppl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --disable-ppl-version-check --disable-cloog-version-check --disable-isl-version-check --enable-cloog-backend=isl --with-host-libstdcxx='-static-libgcc -Wl,-Bstatic,-lstdc++,-Bdynamic -lm' --disable-libssp --enable-threads --disable-nls --disable-libmudflap --disable-libgomp --disable-libstdc__-v3 --disable-sjlj-exceptions --disable-shared --disable-tls --disable-libitm --with-float=soft --with-fpu=vfp --with-arch=armv5te --enable-target-optspace --enable-initfini-array --disable-nls --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --with-sysroot=/tmp/ndk-andrewhsieh/build/toolchain/prefix/sysroot --with-binutils-version=2.25 --with-mpfr-version=3.1.1 --with-mpc-version=1.0.1 --with-gmp-version=5.0.5 --with-gcc-version=4.8 --with-gdb-version=7.7 --with-python=/usr/local/google/home/andrewhsieh/mydroid/ndk/prebuilt/linux-x86_64/bin/python-config.sh --with-gxx-include-dir=/tmp/ndk-andrewhsieh/build/toolchain/prefix/include/c++/4.8 --with-bugurl=http://source.android.com/source/report-bugs.html --enable-languages=c,c++ --disable-bootstrap --enable-plugins --enable-libgomp --enable-gnu-indirect-function --disable-libsanitizer --enable-gold --enable-threads --enable-graphite=yes --with-cloog-version=0.18.0 --with-isl-version=0.11.1 --enable-eh-frame-hdr-for-static --with-arch=armv5te --program-transform-name='s&^&arm-linux-androideabi-&' --enable-gold=default
Thread model: posix
gcc version 4.8 (GCC) 
configure:2719: $? = 0
configure:2708: arm-linux-androideabi-gcc -V >&5
arm-linux-androideabi-gcc: error: unrecognized command line option '-V'
arm-linux-androideabi-gcc: fatal error: no input files
compilation terminated.
configure:2719: $? = 1
configure:2708: arm-linux-androideabi-gcc -qversion >&5
arm-linux-androideabi-gcc: error: unrecognized command line option '-qversion'
arm-linux-androideabi-gcc: fatal error: no input files
compilation terminated.
configure:2719: $? = 1
configure:2739: checking for C compiler default output file name
configure:2761: arm-linux-androideabi-gcc   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:2765: $? = 0
configure:2802: result: a.out
configure:2818: checking whether the C compiler works
configure:2846: result: yes
configure:2853: checking whether we are cross compiling
configure:2855: result: yes
configure:2858: checking for suffix of executables
configure:2865: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:2869: $? = 0
configure:2891: result: 
configure:2897: checking for suffix of object files
configure:2919: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:2923: $? = 0
configure:2944: result: o
configure:2948: checking whether we are using the GNU C compiler
configure:2967: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:2967: $? = 0
configure:2976: result: yes
configure:2985: checking whether arm-linux-androideabi-gcc accepts -g
configure:3005: arm-linux-androideabi-gcc -c -g  conftest.c >&5
configure:3005: $? = 0
configure:3046: result: yes
configure:3063: checking for arm-linux-androideabi-gcc option to accept ISO C89
configure:3127: arm-linux-androideabi-gcc  -c   conftest.c >&5
configure:3127: $? = 0
configure:3140: result: none needed
configure:3161: checking for library containing strerror
configure:3192: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:3192: $? = 0
configure:3209: result: none required
configure:3234: checking for a BSD-compatible install
configure:3302: result: /usr/bin/install -c
configure:3313: checking whether build environment is sane
configure:3363: result: yes
configure:3412: checking for x86_64-unknown-linux-strip
configure:3442: result: no
configure:3452: checking for strip
configure:3468: found /usr/sbin/strip
configure:3479: result: strip
configure:3491: WARNING: using cross tools not prefixed with host triplet
configure:3504: checking for a thread-safe mkdir -p
configure:3543: result: /usr/sbin/mkdir -p
configure:3556: checking for gawk
configure:3583: result: gawk
configure:3594: checking whether make sets $(MAKE)
configure:3616: result: yes
configure:3646: checking for style of include used by make
configure:3674: result: GNU
configure:3759: checking dependency style of arm-linux-androideabi-gcc
configure:3869: result: gcc3
configure:3894: checking for x86_64-unknown-linux-gcc
configure:3921: result: arm-linux-androideabi-gcc
configure:4190: checking for C compiler version
configure:4199: arm-linux-androideabi-gcc --version >&5
arm-linux-androideabi-gcc (GCC) 4.8
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

configure:4210: $? = 0
configure:4199: arm-linux-androideabi-gcc -v >&5
Using built-in specs.
COLLECT_GCC=arm-linux-androideabi-gcc
COLLECT_LTO_WRAPPER=/tmp/toolchain/bin/../libexec/gcc/arm-linux-androideabi/4.8/lto-wrapper
Target: arm-linux-androideabi
Configured with: /s/ndk-toolchain/src/build/../gcc/gcc-4.8/configure --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --target=arm-linux-androideabi --host=x86_64-linux-gnu --build=x86_64-linux-gnu --with-gnu-as --with-gnu-ld --enable-languages=c,c++ --with-gmp=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpfr=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpc=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-cloog=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-isl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-ppl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --disable-ppl-version-check --disable-cloog-version-check --disable-isl-version-check --enable-cloog-backend=isl --with-host-libstdcxx='-static-libgcc -Wl,-Bstatic,-lstdc++,-Bdynamic -lm' --disable-libssp --enable-threads --disable-nls --disable-libmudflap --disable-libgomp --disable-libstdc__-v3 --disable-sjlj-exceptions --disable-shared --disable-tls --disable-libitm --with-float=soft --with-fpu=vfp --with-arch=armv5te --enable-target-optspace --enable-initfini-array --disable-nls --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --with-sysroot=/tmp/ndk-andrewhsieh/build/toolchain/prefix/sysroot --with-binutils-version=2.25 --with-mpfr-version=3.1.1 --with-mpc-version=1.0.1 --with-gmp-version=5.0.5 --with-gcc-version=4.8 --with-gdb-version=7.7 --with-python=/usr/local/google/home/andrewhsieh/mydroid/ndk/prebuilt/linux-x86_64/bin/python-config.sh --with-gxx-include-dir=/tmp/ndk-andrewhsieh/build/toolchain/prefix/include/c++/4.8 --with-bugurl=http://source.android.com/source/report-bugs.html --enable-languages=c,c++ --disable-bootstrap --enable-plugins --enable-libgomp --enable-gnu-indirect-function --disable-libsanitizer --enable-gold --enable-threads --enable-graphite=yes --with-cloog-version=0.18.0 --with-isl-version=0.11.1 --enable-eh-frame-hdr-for-static --with-arch=armv5te --program-transform-name='s&^&arm-linux-androideabi-&' --enable-gold=default
Thread model: posix
gcc version 4.8 (GCC) 
configure:4210: $? = 0
configure:4199: arm-linux-androideabi-gcc -V >&5
arm-linux-androideabi-gcc: error: unrecognized command line option '-V'
arm-linux-androideabi-gcc: fatal error: no input files
compilation terminated.
configure:4210: $? = 1
configure:4199: arm-linux-androideabi-gcc -qversion >&5
arm-linux-androideabi-gcc: error: unrecognized command line option '-qversion'
arm-linux-androideabi-gcc: fatal error: no input files
compilation terminated.
configure:4210: $? = 1
configure:4214: checking whether we are using the GNU C compiler
configure:4242: result: yes
configure:4251: checking whether arm-linux-androideabi-gcc accepts -g
configure:4312: result: yes
configure:4329: checking for arm-linux-androideabi-gcc option to accept ISO C89
configure:4406: result: none needed
configure:4431: checking how to run the C preprocessor
configure:4462: arm-linux-androideabi-gcc -E  conftest.c
configure:4462: $? = 0
configure:4476: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:11:28: fatal error: ac_nonexistent.h: No such file or directory
 #include <ac_nonexistent.h>
                            ^
compilation terminated.
configure:4476: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "opcodes"
| #define PACKAGE_TARNAME "opcodes"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "opcodes 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "opcodes"
| #define VERSION "2.25.1"
| /* end confdefs.h.  */
| #include <ac_nonexistent.h>
configure:4501: result: arm-linux-androideabi-gcc -E
configure:4521: arm-linux-androideabi-gcc -E  conftest.c
configure:4521: $? = 0
configure:4535: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:11:28: fatal error: ac_nonexistent.h: No such file or directory
 #include <ac_nonexistent.h>
                            ^
compilation terminated.
configure:4535: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "opcodes"
| #define PACKAGE_TARNAME "opcodes"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "opcodes 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "opcodes"
| #define VERSION "2.25.1"
| /* end confdefs.h.  */
| #include <ac_nonexistent.h>
configure:4564: checking for grep that handles long lines and -e
configure:4622: result: /usr/sbin/grep
configure:4627: checking for egrep
configure:4689: result: /usr/sbin/grep -E
configure:4694: checking for ANSI C header files
configure:4714: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4714: $? = 0
configure:4798: result: yes
configure:4811: checking for sys/types.h
configure:4811: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4811: $? = 0
configure:4811: result: yes
configure:4811: checking for sys/stat.h
configure:4811: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4811: $? = 0
configure:4811: result: yes
configure:4811: checking for stdlib.h
configure:4811: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4811: $? = 0
configure:4811: result: yes
configure:4811: checking for string.h
configure:4811: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4811: $? = 0
configure:4811: result: yes
configure:4811: checking for memory.h
configure:4811: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4811: $? = 0
configure:4811: result: yes
configure:4811: checking for strings.h
configure:4811: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4811: $? = 0
configure:4811: result: yes
configure:4811: checking for inttypes.h
configure:4811: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4811: $? = 0
configure:4811: result: yes
configure:4811: checking for stdint.h
configure:4811: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4811: $? = 0
configure:4811: result: yes
configure:4811: checking for unistd.h
configure:4811: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4811: $? = 0
configure:4811: result: yes
configure:4825: checking minix/config.h usability
configure:4825: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:54:26: fatal error: minix/config.h: No such file or directory
 #include <minix/config.h>
                          ^
compilation terminated.
configure:4825: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "opcodes"
| #define PACKAGE_TARNAME "opcodes"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "opcodes 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "opcodes"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <minix/config.h>
configure:4825: result: no
configure:4825: checking minix/config.h presence
configure:4825: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:21:26: fatal error: minix/config.h: No such file or directory
 #include <minix/config.h>
                          ^
compilation terminated.
configure:4825: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "opcodes"
| #define PACKAGE_TARNAME "opcodes"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "opcodes 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "opcodes"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| /* end confdefs.h.  */
| #include <minix/config.h>
configure:4825: result: no
configure:4825: checking for minix/config.h
configure:4825: result: no
configure:4846: checking whether it is safe to define __EXTENSIONS__
configure:4864: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4864: $? = 0
configure:4871: result: yes
configure:4891: checking for x86_64-unknown-linux-ar
configure:4918: result: ar
configure:4983: checking for x86_64-unknown-linux-ranlib
configure:5010: result: ranlib
configure:5151: checking how to print strings
configure:5178: result: printf
configure:5199: checking for a sed that does not truncate output
configure:5263: result: /usr/sbin/sed
configure:5281: checking for fgrep
configure:5343: result: /usr/sbin/grep -F
configure:5378: checking for ld used by arm-linux-androideabi-gcc
configure:5445: result: /tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld
configure:5452: checking if the linker (/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld) is GNU ld
configure:5467: result: yes
configure:5479: checking for BSD- or MS-compatible name lister (nm)
configure:5528: result: nm
configure:5658: checking the name lister (nm) interface
configure:5665: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5668: nm "conftest.o"
configure:5671: output
00000000 b $d
00000000 B some_variable
configure:5678: result: BSD nm
configure:5681: checking whether ln -s works
configure:5685: result: yes
configure:5693: checking the maximum length of command line arguments
configure:5818: result: 1572864
configure:5835: checking whether the shell understands some XSI constructs
configure:5845: result: yes
configure:5849: checking whether the shell understands "+="
configure:5855: result: yes
configure:5890: checking for /tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld option to reload object files
configure:5897: result: -r
configure:5926: checking for x86_64-unknown-linux-objdump
configure:5953: result: objdump
configure:6025: checking how to recognize dependent libraries
configure:6226: result: pass_all
configure:6246: checking for x86_64-unknown-linux-ar
configure:6273: result: ar
configure:6351: checking for x86_64-unknown-linux-strip
configure:6378: result: strip
configure:6450: checking for x86_64-unknown-linux-ranlib
configure:6477: result: ranlib
configure:6619: checking command to parse nm output from arm-linux-androideabi-gcc object
configure:6737: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:6740: $? = 0
configure:6744: nm conftest.o \| sed -n -e 's/^.*[ ]\([ABCDGIRSTW][ABCDGIRSTW]*\)[ ][ ]*\([_A-Za-z][_A-Za-z0-9]*\)$/\1 \2 \2/p' \> conftest.nm
configure:6747: $? = 0
configure:6801: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c conftstm.o >&5
configure:6804: $? = 0
configure:6842: result: ok
configure:6937: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:6940: $? = 0
configure:7690: checking for dlfcn.h
configure:7690: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:7690: $? = 0
configure:7690: result: yes
configure:7847: checking for objdir
configure:7862: result: .libs
configure:8133: checking if arm-linux-androideabi-gcc supports -fno-rtti -fno-exceptions
configure:8151: arm-linux-androideabi-gcc -c   -fno-rtti -fno-exceptions conftest.c >&5
cc1: warning: command line option '-fno-rtti' is valid for C++/ObjC++ but not for C [enabled by default]
configure:8155: $? = 0
configure:8168: result: no
configure:8188: checking for arm-linux-androideabi-gcc option to produce PIC
configure:8474: result: -fPIC -DPIC
configure:8486: checking if arm-linux-androideabi-gcc PIC flag -fPIC -DPIC works
configure:8504: arm-linux-androideabi-gcc -c   -fPIC -DPIC -DPIC conftest.c >&5
configure:8508: $? = 0
configure:8521: result: yes
configure:8545: checking if arm-linux-androideabi-gcc static flag -static works
configure:8573: result: yes
configure:8588: checking if arm-linux-androideabi-gcc supports -c -o file.o
configure:8609: arm-linux-androideabi-gcc -c   -o out/conftest2.o conftest.c >&5
configure:8613: $? = 0
configure:8635: result: yes
configure:8643: checking if arm-linux-androideabi-gcc supports -c -o file.o
configure:8690: result: yes
configure:8723: checking whether the arm-linux-androideabi-gcc linker (/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld -m elf_i386) supports shared libraries
configure:9794: result: yes
configure:10039: checking dynamic linker characteristics
configure:10490: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  -Wl,-rpath -Wl,/foo conftest.c  >&5
configure:10490: $? = 0
configure:10712: result: GNU/Linux ld.so
configure:10819: checking how to hardcode library paths into programs
configure:10844: result: immediate
configure:11384: checking whether stripping libraries is possible
configure:11389: result: yes
configure:11424: checking if libtool supports shared libraries
configure:11426: result: yes
configure:11429: checking whether to build shared libraries
configure:11450: result: no
configure:11453: checking whether to build static libraries
configure:11457: result: yes
configure:11590: checking whether arm-linux-androideabi-gcc supports -Wmissing-field-initializers
configure:11607: arm-linux-androideabi-gcc -c -Wmissing-field-initializers  conftest.c >&5
configure:11607: $? = 0
configure:11616: result: yes
configure:11636: checking whether to enable maintainer-specific portions of Makefiles
configure:11645: result: no
configure:11673: checking whether to install libbfd
configure:11686: result: no
configure:11732: checking whether NLS is requested
configure:11735: result: no
configure:11803: checking whether NLS is requested
configure:11812: result: no
configure:11850: checking for msgfmt
configure:11881: result: /usr/sbin/msgfmt
configure:11890: checking for gmsgfmt
configure:11921: result: /usr/sbin/msgfmt
configure:11961: checking for xgettext
configure:11992: result: /usr/sbin/xgettext
configure:12032: checking for msgmerge
configure:12062: result: /usr/sbin/msgmerge
configure:12113: checking for build system executable suffix
configure:12131: result: no
configure:12144: checking for string.h
configure:12144: result: yes
configure:12144: checking for strings.h
configure:12144: result: yes
configure:12144: checking for stdlib.h
configure:12144: result: yes
configure:12144: checking limits.h usability
configure:12144: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12144: $? = 0
configure:12144: result: yes
configure:12144: checking limits.h presence
configure:12144: arm-linux-androideabi-gcc -E  conftest.c
configure:12144: $? = 0
configure:12144: result: yes
configure:12144: checking for limits.h
configure:12144: result: yes
configure:12155: checking whether string.h and strings.h may both be included
configure:12172: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12172: $? = 0
configure:12179: result: yes
configure:12188: checking whether basename is declared
configure:12188: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:73:10: error: 'basename' undeclared (first use in this function)
   (void) basename;
          ^
conftest.c:73:10: note: each undeclared identifier is reported only once for each function it appears in
configure:12188: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "opcodes"
| #define PACKAGE_TARNAME "opcodes"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "opcodes 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "opcodes"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_STRING_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_LIMITS_H 1
| #define STRING_WITH_STRINGS 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| #ifndef basename
| #ifdef __cplusplus
|   (void) basename;
| #else
|   (void) basename;
| #endif
| #endif
| 
|   ;
|   return 0;
| }
configure:12188: result: no
configure:12198: checking whether stpcpy is declared
configure:12198: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12198: $? = 0
configure:12198: result: yes
configure:12212: checking for sigsetjmp
configure:12230: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12230: $? = 0
configure:12237: result: 
configure:12275: checking linker --as-needed support
configure:12286: result: yes
configure:12377: checking for cos in -lm
configure:12402: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c -lm   >&5
conftest.c:43:6: warning: conflicting types for built-in function 'cos' [enabled by default]
 char cos ();
      ^
configure:12402: $? = 0
configure:12411: result: yes
configure:12744: updating cache ./config.cache
configure:12809: creating ./config.status

## ---------------------- ##
## Running config.status. ##
## ---------------------- ##

This file was extended by opcodes config.status 2.25.1, which was
generated by GNU Autoconf 2.64.  Invocation command line was

  CONFIG_FILES    = 
  CONFIG_HEADERS  = 
  CONFIG_LINKS    = 
  CONFIG_COMMANDS = 
  $ ./config.status 

on d5f3793a98c0

config.status:1128: creating Makefile
config.status:1128: creating po/Makefile.in
config.status:1128: creating config.h
config.status:1341: executing depfiles commands
config.status:1341: executing libtool commands
config.status:1341: executing default-1 commands

## ---------------- ##
## Cache variables. ##
## ---------------- ##

ac_cv_build=x86_64-unknown-linux-gnu
ac_cv_c_compiler_gnu=yes
ac_cv_env_CC_set=set
ac_cv_env_CC_value=arm-linux-androideabi-gcc
ac_cv_env_CFLAGS_set=set
ac_cv_env_CFLAGS_value=
ac_cv_env_CPPFLAGS_set=set
ac_cv_env_CPPFLAGS_value=
ac_cv_env_CPP_set=
ac_cv_env_CPP_value=
ac_cv_env_LDFLAGS_set=set
ac_cv_env_LDFLAGS_value='-static-libstdc++ -static-libgcc '
ac_cv_env_LIBS_set=
ac_cv_env_LIBS_value=
ac_cv_env_build_alias_set=set
ac_cv_env_build_alias_value=x86_64-unknown-linux-gnu
ac_cv_env_host_alias_set=set
ac_cv_env_host_alias_value=x86_64-unknown-linux
ac_cv_env_target_alias_set=set
ac_cv_env_target_alias_value=i686-w64-mingw32
ac_cv_have_decl_basename=no
ac_cv_have_decl_stpcpy=yes
ac_cv_header_dlfcn_h=yes
ac_cv_header_inttypes_h=yes
ac_cv_header_limits_h=yes
ac_cv_header_memory_h=yes
ac_cv_header_minix_config_h=no
ac_cv_header_stdc=yes
ac_cv_header_stdint_h=yes
ac_cv_header_stdlib_h=yes
ac_cv_header_string_h=yes
ac_cv_header_strings_h=yes
ac_cv_header_sys_stat_h=yes
ac_cv_header_sys_types_h=yes
ac_cv_header_unistd_h=yes
ac_cv_host=x86_64-unknown-linux-gnu
ac_cv_lib_m_cos=yes
ac_cv_objext=o
ac_cv_path_EGREP='/usr/sbin/grep -E'
ac_cv_path_FGREP='/usr/sbin/grep -F'
ac_cv_path_GMSGFMT=/usr/sbin/msgfmt
ac_cv_path_GREP=/usr/sbin/grep
ac_cv_path_MSGFMT=/usr/sbin/msgfmt
ac_cv_path_MSGMERGE=/usr/sbin/msgmerge
ac_cv_path_SED=/usr/sbin/sed
ac_cv_path_XGETTEXT=/usr/sbin/xgettext
ac_cv_path_mkdir=/usr/sbin/mkdir
ac_cv_prog_AR=ar
ac_cv_prog_AWK=gawk
ac_cv_prog_CC=arm-linux-androideabi-gcc
ac_cv_prog_CPP='arm-linux-androideabi-gcc -E'
ac_cv_prog_OBJDUMP=objdump
ac_cv_prog_RANLIB=ranlib
ac_cv_prog_STRIP=strip
ac_cv_prog_ac_ct_STRIP=strip
ac_cv_prog_cc_c89=
ac_cv_prog_cc_g=yes
ac_cv_prog_make_make_set=yes
ac_cv_safe_to_define___extensions__=yes
ac_cv_search_strerror='none required'
ac_cv_target=i686-w64-mingw32
acx_cv_prog_cc_warning__Wmissing_field_initializers=yes
am_cv_CC_dependencies_compiler_type=gcc3
bfd_cv_build_exeext=no
bfd_cv_func_sigsetjmp=yes
bfd_cv_ld_as_needed=yes
gcc_cv_header_string=yes
lt_cv_deplibs_check_method=pass_all
lt_cv_file_magic_cmd='$MAGIC_CMD'
lt_cv_file_magic_test_file=
lt_cv_ld_reload_flag=-r
lt_cv_nm_interface='BSD nm'
lt_cv_objdir=.libs
lt_cv_path_LD=/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld
lt_cv_path_NM=nm
lt_cv_prog_compiler_c_o=yes
lt_cv_prog_compiler_pic_works=yes
lt_cv_prog_compiler_rtti_exceptions=no
lt_cv_prog_compiler_static_works=yes
lt_cv_prog_gnu_ld=yes
lt_cv_shlibpath_overrides_runpath=yes
lt_cv_sys_global_symbol_pipe='sed -n -e '\''s/^.*[	 ]\([ABCDGIRSTW][ABCDGIRSTW]*\)[	 ][	 ]*\([_A-Za-z][_A-Za-z0-9]*\)$/\1 \2 \2/p'\'''
lt_cv_sys_global_symbol_to_c_name_address='sed -n -e '\''s/^: \([^ ]*\) $/  {\"\1\", (void *) 0},/p'\'' -e '\''s/^[ABCDGIRSTW]* \([^ ]*\) \([^ ]*\)$/  {"\2", (void *) \&\2},/p'\'''
lt_cv_sys_global_symbol_to_c_name_address_lib_prefix='sed -n -e '\''s/^: \([^ ]*\) $/  {\"\1\", (void *) 0},/p'\'' -e '\''s/^[ABCDGIRSTW]* \([^ ]*\) \(lib[^ ]*\)$/  {"\2", (void *) \&\2},/p'\'' -e '\''s/^[ABCDGIRSTW]* \([^ ]*\) \([^ ]*\)$/  {"lib\2", (void *) \&\2},/p'\'''
lt_cv_sys_global_symbol_to_cdecl='sed -n -e '\''s/^T .* \(.*\)$/extern int \1();/p'\'' -e '\''s/^[ABCDGIRSTW]* .* \(.*\)$/extern char \1;/p'\'''
lt_cv_sys_max_cmd_len=1572864

## ----------------- ##
## Output variables. ##
## ----------------- ##

ACLOCAL='${SHELL} /tmp/mingw-w64-binutils/src/binutils-2.25.1/missing --run aclocal-1.11'
AMDEPBACKSLASH='\'
AMDEP_FALSE='#'
AMDEP_TRUE=''
AMTAR='${SHELL} /tmp/mingw-w64-binutils/src/binutils-2.25.1/missing --run tar'
AR='ar'
AUTOCONF='${SHELL} /tmp/mingw-w64-binutils/src/binutils-2.25.1/missing --run autoconf'
AUTOHEADER='${SHELL} /tmp/mingw-w64-binutils/src/binutils-2.25.1/missing --run autoheader'
AUTOMAKE='${SHELL} /tmp/mingw-w64-binutils/src/binutils-2.25.1/missing --run automake-1.11'
AWK='gawk'
BFD_MACHINES=' i386-dis.lo i386-opc.lo'
BUILD_LIBS='-liberty '
BUILD_LIB_DEPS=' '
CATALOGS=''
CATOBJEXT=''
CC='arm-linux-androideabi-gcc'
CCDEPMODE='depmode=gcc3'
CC_FOR_BUILD='arm-linux-androideabi-gcc'
CFLAGS=''
CGEN_MAINT_FALSE=''
CGEN_MAINT_TRUE='#'
CPP='arm-linux-androideabi-gcc -E'
CPPFLAGS=''
CYGPATH_W='echo'
DATADIRNAME=''
DEFS='-DHAVE_CONFIG_H'
DEPDIR='.deps'
DSYMUTIL=''
DUMPBIN=''
ECHO_C=''
ECHO_N='-n'
ECHO_T=''
EGREP='/usr/sbin/grep -E'
EXEEXT=''
EXEEXT_FOR_BUILD=''
FGREP='/usr/sbin/grep -F'
GENCAT=''
GMSGFMT='/usr/sbin/msgfmt'
GREP='/usr/sbin/grep'
HDEFINES=''
INCINTL=''
INSTALL_DATA='/usr/bin/install -c -m 644'
INSTALL_LIBBFD_FALSE=''
INSTALL_LIBBFD_TRUE='#'
INSTALL_PROGRAM='/usr/bin/install -c'
INSTALL_SCRIPT='/usr/bin/install -c'
INSTALL_STRIP_PROGRAM='$(install_sh) -c -s'
INSTOBJEXT=''
LD='/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld -m elf_i386'
LDFLAGS='-static-libstdc++ -static-libgcc '
LIBINTL=''
LIBINTL_DEP=''
LIBM='-lm'
LIBOBJS=''
LIBS=''
LIBTOOL='$(SHELL) $(top_builddir)/libtool'
LIPO=''
LN_S='ln -s'
LTLIBOBJS=''
MAINT='#'
MAINTAINER_MODE_FALSE=''
MAINTAINER_MODE_TRUE='#'
MAKEINFO='makeinfo --split-size=5000000'
MKDIR_P='/usr/sbin/mkdir -p'
MKINSTALLDIRS='/tmp/mingw-w64-binutils/src/binutils-2.25.1/opcodes/../mkinstalldirs'
MSGFMT='/usr/sbin/msgfmt'
MSGMERGE='/usr/sbin/msgmerge'
NM='nm'
NMEDIT=''
NO_WERROR=''
NO_WMISSING_FIELD_INITIALIZERS='-Wno-missing-field-initializers'
OBJDUMP='objdump'
OBJEXT='o'
OTOOL64=''
OTOOL=''
PACKAGE='opcodes'
PACKAGE_BUGREPORT=''
PACKAGE_NAME='opcodes'
PACKAGE_STRING='opcodes 2.25.1'
PACKAGE_TARNAME='opcodes'
PACKAGE_URL=''
PACKAGE_VERSION='2.25.1'
PATH_SEPARATOR=':'
POSUB=''
RANLIB='ranlib'
SED='/usr/sbin/sed'
SET_MAKE=''
SHARED_DEPENDENCIES=''
SHARED_LDFLAGS=''
SHARED_LIBADD=''
SHELL='/bin/sh'
STRIP='strip'
USE_NLS='no'
VERSION='2.25.1'
WARN_CFLAGS='-W -Wall -Wstrict-prototypes -Wmissing-prototypes -Wshadow'
XGETTEXT='/usr/sbin/xgettext'
ac_ct_CC=''
ac_ct_DUMPBIN=''
am__EXEEXT_FALSE=''
am__EXEEXT_TRUE='#'
am__fastdepCC_FALSE='#'
am__fastdepCC_TRUE=''
am__include='include'
am__isrc=' -I$(srcdir)'
am__leading_dot='.'
am__quote=''
am__tar='${AMTAR} chof - "$$tardir"'
am__untar='${AMTAR} xf -'
archdefs=' -DARCH_i386'
bfdincludedir='$(exec_prefix)/$(host_noncanonical)/$(target_noncanonical)/include'
bfdlibdir='$(exec_prefix)/$(host_noncanonical)/$(target_noncanonical)/lib'
bindir='${exec_prefix}/bin'
build='x86_64-unknown-linux-gnu'
build_alias='x86_64-unknown-linux-gnu'
build_cpu='x86_64'
build_os='linux-gnu'
build_vendor='unknown'
cgendir='$(srcdir)/../cgen'
datadir='${datarootdir}'
datarootdir='${prefix}/share'
docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
dvidir='${docdir}'
exec_prefix='${prefix}'
host='x86_64-unknown-linux-gnu'
host_alias='x86_64-unknown-linux'
host_cpu='x86_64'
host_noncanonical='x86_64-unknown-linux'
host_os='linux-gnu'
host_vendor='unknown'
htmldir='${docdir}'
includedir='${prefix}/include'
infodir='/usr/share/info/i686-w64-mingw32'
install_sh='${SHELL} /tmp/mingw-w64-binutils/src/binutils-2.25.1/install-sh'
libdir='${exec_prefix}/lib'
libexecdir='${exec_prefix}/libexec'
localedir='${datarootdir}/locale'
localstatedir='${prefix}/var'
mandir='${datarootdir}/man'
mkdir_p='/usr/sbin/mkdir -p'
oldincludedir='/usr/include'
pdfdir='${docdir}'
prefix='/usr'
program_transform_name='s&^&i686-w64-mingw32-&'
psdir='${docdir}'
sbindir='${exec_prefix}/sbin'
sharedstatedir='${prefix}/com'
sysconfdir='${prefix}/etc'
target='i686-w64-mingw32'
target_alias='i686-w64-mingw32'
target_cpu='i686'
target_noncanonical='i686-w64-mingw32'
target_os='mingw32'
target_vendor='w64'

## ----------- ##
## confdefs.h. ##
## ----------- ##

/* confdefs.h */
#define PACKAGE_NAME "opcodes"
#define PACKAGE_TARNAME "opcodes"
#define PACKAGE_VERSION "2.25.1"
#define PACKAGE_STRING "opcodes 2.25.1"
#define PACKAGE_BUGREPORT ""
#define PACKAGE_URL ""
#define PACKAGE "opcodes"
#define VERSION "2.25.1"
#define STDC_HEADERS 1
#define HAVE_SYS_TYPES_H 1
#define HAVE_SYS_STAT_H 1
#define HAVE_STDLIB_H 1
#define HAVE_STRING_H 1
#define HAVE_MEMORY_H 1
#define HAVE_STRINGS_H 1
#define HAVE_INTTYPES_H 1
#define HAVE_STDINT_H 1
#define HAVE_UNISTD_H 1
#define __EXTENSIONS__ 1
#define _ALL_SOURCE 1
#define _GNU_SOURCE 1
#define _POSIX_PTHREAD_SEMANTICS 1
#define _TANDEM_SOURCE 1
#define HAVE_DLFCN_H 1
#define LT_OBJDIR ".libs/"
#define HAVE_STRING_H 1
#define HAVE_STRINGS_H 1
#define HAVE_STDLIB_H 1
#define HAVE_LIMITS_H 1
#define STRING_WITH_STRINGS 1
#define HAVE_DECL_BASENAME 0
#define HAVE_DECL_STPCPY 1
#define HAVE_SIGSETJMP 1

configure: exit 0

____
File /tmp/mingw-w64-binutils/src/binutils-i686-w64-mingw32/gas/config.log
This file contains any messages produced by compilers while
running configure, to aid debugging if configure makes a mistake.

It was created by gas configure 2.25.1, which was
generated by GNU Autoconf 2.64.  Invocation command line was

  $ /tmp/mingw-w64-binutils/src/binutils-2.25.1/gas/configure --cache-file=./config.cache --with-gnu-as --with-gnu-ld --with-system-zlib --prefix=/usr --infodir=/usr/share/info/i686-w64-mingw32 --enable-lto --enable-plugins --disable-multilib --disable-nls --disable-werror --program-transform-name=s&^&i686-w64-mingw32-& --disable-option-checking --build=x86_64-unknown-linux-gnu --host=x86_64-unknown-linux --target=i686-w64-mingw32 --srcdir=/tmp/mingw-w64-binutils/src/binutils-2.25.1/gas

## --------- ##
## Platform. ##
## --------- ##

hostname = d5f3793a98c0
uname -m = x86_64
uname -r = 3.13.0-66-generic
uname -s = Linux
uname -v = #108-Ubuntu SMP Wed Oct 7 15:20:27 UTC 2015

/usr/bin/uname -p = unknown
/bin/uname -X     = unknown

/bin/arch              = unknown
/usr/bin/arch -k       = unknown
/usr/convex/getsysinfo = unknown
/usr/bin/hostinfo      = unknown
/bin/machine           = unknown
/usr/bin/oslevel       = unknown
/bin/universe          = unknown

PATH: /tmp/toolchain/bin
PATH: /usr/local/sbin
PATH: /usr/local/bin
PATH: /usr/sbin
PATH: /usr/bin
PATH: /sbin
PATH: /bin


## ----------- ##
## Core tests. ##
## ----------- ##

configure:2192: creating cache ./config.cache
configure:2297: checking build system type
configure:2311: result: x86_64-unknown-linux-gnu
configure:2331: checking host system type
configure:2344: result: x86_64-unknown-linux-gnu
configure:2364: checking target system type
configure:2377: result: i686-w64-mingw32
configure:2411: checking for x86_64-unknown-linux-gcc
configure:2438: result: arm-linux-androideabi-gcc
configure:2707: checking for C compiler version
configure:2716: arm-linux-androideabi-gcc --version >&5
arm-linux-androideabi-gcc (GCC) 4.8
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

configure:2727: $? = 0
configure:2716: arm-linux-androideabi-gcc -v >&5
Using built-in specs.
COLLECT_GCC=arm-linux-androideabi-gcc
COLLECT_LTO_WRAPPER=/tmp/toolchain/bin/../libexec/gcc/arm-linux-androideabi/4.8/lto-wrapper
Target: arm-linux-androideabi
Configured with: /s/ndk-toolchain/src/build/../gcc/gcc-4.8/configure --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --target=arm-linux-androideabi --host=x86_64-linux-gnu --build=x86_64-linux-gnu --with-gnu-as --with-gnu-ld --enable-languages=c,c++ --with-gmp=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpfr=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpc=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-cloog=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-isl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-ppl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --disable-ppl-version-check --disable-cloog-version-check --disable-isl-version-check --enable-cloog-backend=isl --with-host-libstdcxx='-static-libgcc -Wl,-Bstatic,-lstdc++,-Bdynamic -lm' --disable-libssp --enable-threads --disable-nls --disable-libmudflap --disable-libgomp --disable-libstdc__-v3 --disable-sjlj-exceptions --disable-shared --disable-tls --disable-libitm --with-float=soft --with-fpu=vfp --with-arch=armv5te --enable-target-optspace --enable-initfini-array --disable-nls --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --with-sysroot=/tmp/ndk-andrewhsieh/build/toolchain/prefix/sysroot --with-binutils-version=2.25 --with-mpfr-version=3.1.1 --with-mpc-version=1.0.1 --with-gmp-version=5.0.5 --with-gcc-version=4.8 --with-gdb-version=7.7 --with-python=/usr/local/google/home/andrewhsieh/mydroid/ndk/prebuilt/linux-x86_64/bin/python-config.sh --with-gxx-include-dir=/tmp/ndk-andrewhsieh/build/toolchain/prefix/include/c++/4.8 --with-bugurl=http://source.android.com/source/report-bugs.html --enable-languages=c,c++ --disable-bootstrap --enable-plugins --enable-libgomp --enable-gnu-indirect-function --disable-libsanitizer --enable-gold --enable-threads --enable-graphite=yes --with-cloog-version=0.18.0 --with-isl-version=0.11.1 --enable-eh-frame-hdr-for-static --with-arch=armv5te --program-transform-name='s&^&arm-linux-androideabi-&' --enable-gold=default
Thread model: posix
gcc version 4.8 (GCC) 
configure:2727: $? = 0
configure:2716: arm-linux-androideabi-gcc -V >&5
arm-linux-androideabi-gcc: error: unrecognized command line option '-V'
arm-linux-androideabi-gcc: fatal error: no input files
compilation terminated.
configure:2727: $? = 1
configure:2716: arm-linux-androideabi-gcc -qversion >&5
arm-linux-androideabi-gcc: error: unrecognized command line option '-qversion'
arm-linux-androideabi-gcc: fatal error: no input files
compilation terminated.
configure:2727: $? = 1
configure:2747: checking for C compiler default output file name
configure:2769: arm-linux-androideabi-gcc   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:2773: $? = 0
configure:2810: result: a.out
configure:2826: checking whether the C compiler works
configure:2854: result: yes
configure:2861: checking whether we are cross compiling
configure:2863: result: yes
configure:2866: checking for suffix of executables
configure:2873: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:2877: $? = 0
configure:2899: result: 
configure:2905: checking for suffix of object files
configure:2927: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:2931: $? = 0
configure:2952: result: o
configure:2956: checking whether we are using the GNU C compiler
configure:2975: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:2975: $? = 0
configure:2984: result: yes
configure:2993: checking whether arm-linux-androideabi-gcc accepts -g
configure:3013: arm-linux-androideabi-gcc -c -g  conftest.c >&5
configure:3013: $? = 0
configure:3054: result: yes
configure:3071: checking for arm-linux-androideabi-gcc option to accept ISO C89
configure:3135: arm-linux-androideabi-gcc  -c   conftest.c >&5
configure:3135: $? = 0
configure:3148: result: none needed
configure:3169: checking for library containing strerror
configure:3200: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:3200: $? = 0
configure:3217: result: none required
configure:3242: checking for a BSD-compatible install
configure:3310: result: /usr/bin/install -c
configure:3321: checking whether build environment is sane
configure:3371: result: yes
configure:3420: checking for x86_64-unknown-linux-strip
configure:3450: result: no
configure:3460: checking for strip
configure:3476: found /usr/sbin/strip
configure:3487: result: strip
configure:3499: WARNING: using cross tools not prefixed with host triplet
configure:3512: checking for a thread-safe mkdir -p
configure:3551: result: /usr/sbin/mkdir -p
configure:3564: checking for gawk
configure:3591: result: gawk
configure:3602: checking whether make sets $(MAKE)
configure:3624: result: yes
configure:3654: checking for style of include used by make
configure:3682: result: GNU
configure:3767: checking dependency style of arm-linux-androideabi-gcc
configure:3877: result: gcc3
configure:3902: checking for x86_64-unknown-linux-gcc
configure:3929: result: arm-linux-androideabi-gcc
configure:4198: checking for C compiler version
configure:4207: arm-linux-androideabi-gcc --version >&5
arm-linux-androideabi-gcc (GCC) 4.8
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

configure:4218: $? = 0
configure:4207: arm-linux-androideabi-gcc -v >&5
Using built-in specs.
COLLECT_GCC=arm-linux-androideabi-gcc
COLLECT_LTO_WRAPPER=/tmp/toolchain/bin/../libexec/gcc/arm-linux-androideabi/4.8/lto-wrapper
Target: arm-linux-androideabi
Configured with: /s/ndk-toolchain/src/build/../gcc/gcc-4.8/configure --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --target=arm-linux-androideabi --host=x86_64-linux-gnu --build=x86_64-linux-gnu --with-gnu-as --with-gnu-ld --enable-languages=c,c++ --with-gmp=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpfr=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpc=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-cloog=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-isl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-ppl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --disable-ppl-version-check --disable-cloog-version-check --disable-isl-version-check --enable-cloog-backend=isl --with-host-libstdcxx='-static-libgcc -Wl,-Bstatic,-lstdc++,-Bdynamic -lm' --disable-libssp --enable-threads --disable-nls --disable-libmudflap --disable-libgomp --disable-libstdc__-v3 --disable-sjlj-exceptions --disable-shared --disable-tls --disable-libitm --with-float=soft --with-fpu=vfp --with-arch=armv5te --enable-target-optspace --enable-initfini-array --disable-nls --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --with-sysroot=/tmp/ndk-andrewhsieh/build/toolchain/prefix/sysroot --with-binutils-version=2.25 --with-mpfr-version=3.1.1 --with-mpc-version=1.0.1 --with-gmp-version=5.0.5 --with-gcc-version=4.8 --with-gdb-version=7.7 --with-python=/usr/local/google/home/andrewhsieh/mydroid/ndk/prebuilt/linux-x86_64/bin/python-config.sh --with-gxx-include-dir=/tmp/ndk-andrewhsieh/build/toolchain/prefix/include/c++/4.8 --with-bugurl=http://source.android.com/source/report-bugs.html --enable-languages=c,c++ --disable-bootstrap --enable-plugins --enable-libgomp --enable-gnu-indirect-function --disable-libsanitizer --enable-gold --enable-threads --enable-graphite=yes --with-cloog-version=0.18.0 --with-isl-version=0.11.1 --enable-eh-frame-hdr-for-static --with-arch=armv5te --program-transform-name='s&^&arm-linux-androideabi-&' --enable-gold=default
Thread model: posix
gcc version 4.8 (GCC) 
configure:4218: $? = 0
configure:4207: arm-linux-androideabi-gcc -V >&5
arm-linux-androideabi-gcc: error: unrecognized command line option '-V'
arm-linux-androideabi-gcc: fatal error: no input files
compilation terminated.
configure:4218: $? = 1
configure:4207: arm-linux-androideabi-gcc -qversion >&5
arm-linux-androideabi-gcc: error: unrecognized command line option '-qversion'
arm-linux-androideabi-gcc: fatal error: no input files
compilation terminated.
configure:4218: $? = 1
configure:4222: checking whether we are using the GNU C compiler
configure:4250: result: yes
configure:4259: checking whether arm-linux-androideabi-gcc accepts -g
configure:4320: result: yes
configure:4337: checking for arm-linux-androideabi-gcc option to accept ISO C89
configure:4414: result: none needed
configure:4439: checking how to run the C preprocessor
configure:4470: arm-linux-androideabi-gcc -E  conftest.c
configure:4470: $? = 0
configure:4484: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:11:28: fatal error: ac_nonexistent.h: No such file or directory
 #include <ac_nonexistent.h>
                            ^
compilation terminated.
configure:4484: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "gas"
| #define PACKAGE_TARNAME "gas"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "gas 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "gas"
| #define VERSION "2.25.1"
| /* end confdefs.h.  */
| #include <ac_nonexistent.h>
configure:4509: result: arm-linux-androideabi-gcc -E
configure:4529: arm-linux-androideabi-gcc -E  conftest.c
configure:4529: $? = 0
configure:4543: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:11:28: fatal error: ac_nonexistent.h: No such file or directory
 #include <ac_nonexistent.h>
                            ^
compilation terminated.
configure:4543: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "gas"
| #define PACKAGE_TARNAME "gas"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "gas 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "gas"
| #define VERSION "2.25.1"
| /* end confdefs.h.  */
| #include <ac_nonexistent.h>
configure:4572: checking for grep that handles long lines and -e
configure:4630: result: /usr/sbin/grep
configure:4635: checking for egrep
configure:4697: result: /usr/sbin/grep -E
configure:4702: checking for ANSI C header files
configure:4722: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4722: $? = 0
configure:4806: result: yes
configure:4819: checking for sys/types.h
configure:4819: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4819: $? = 0
configure:4819: result: yes
configure:4819: checking for sys/stat.h
configure:4819: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4819: $? = 0
configure:4819: result: yes
configure:4819: checking for stdlib.h
configure:4819: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4819: $? = 0
configure:4819: result: yes
configure:4819: checking for string.h
configure:4819: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4819: $? = 0
configure:4819: result: yes
configure:4819: checking for memory.h
configure:4819: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4819: $? = 0
configure:4819: result: yes
configure:4819: checking for strings.h
configure:4819: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4819: $? = 0
configure:4819: result: yes
configure:4819: checking for inttypes.h
configure:4819: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4819: $? = 0
configure:4819: result: yes
configure:4819: checking for stdint.h
configure:4819: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4819: $? = 0
configure:4819: result: yes
configure:4819: checking for unistd.h
configure:4819: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4819: $? = 0
configure:4819: result: yes
configure:4833: checking minix/config.h usability
configure:4833: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:54:26: fatal error: minix/config.h: No such file or directory
 #include <minix/config.h>
                          ^
compilation terminated.
configure:4833: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "gas"
| #define PACKAGE_TARNAME "gas"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "gas 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "gas"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <minix/config.h>
configure:4833: result: no
configure:4833: checking minix/config.h presence
configure:4833: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:21:26: fatal error: minix/config.h: No such file or directory
 #include <minix/config.h>
                          ^
compilation terminated.
configure:4833: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "gas"
| #define PACKAGE_TARNAME "gas"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "gas 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "gas"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| /* end confdefs.h.  */
| #include <minix/config.h>
configure:4833: result: no
configure:4833: checking for minix/config.h
configure:4833: result: no
configure:4854: checking whether it is safe to define __EXTENSIONS__
configure:4872: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4872: $? = 0
configure:4879: result: yes
configure:4942: checking how to print strings
configure:4969: result: printf
configure:4990: checking for a sed that does not truncate output
configure:5054: result: /usr/sbin/sed
configure:5072: checking for fgrep
configure:5134: result: /usr/sbin/grep -F
configure:5169: checking for ld used by arm-linux-androideabi-gcc
configure:5236: result: /tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld
configure:5243: checking if the linker (/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld) is GNU ld
configure:5258: result: yes
configure:5270: checking for BSD- or MS-compatible name lister (nm)
configure:5319: result: nm
configure:5449: checking the name lister (nm) interface
configure:5456: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5459: nm "conftest.o"
configure:5462: output
00000000 b $d
00000000 B some_variable
configure:5469: result: BSD nm
configure:5472: checking whether ln -s works
configure:5476: result: yes
configure:5484: checking the maximum length of command line arguments
configure:5609: result: 1572864
configure:5626: checking whether the shell understands some XSI constructs
configure:5636: result: yes
configure:5640: checking whether the shell understands "+="
configure:5646: result: yes
configure:5681: checking for /tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld option to reload object files
configure:5688: result: -r
configure:5717: checking for x86_64-unknown-linux-objdump
configure:5744: result: objdump
configure:5816: checking how to recognize dependent libraries
configure:6017: result: pass_all
configure:6037: checking for x86_64-unknown-linux-ar
configure:6064: result: ar
configure:6142: checking for x86_64-unknown-linux-strip
configure:6169: result: strip
configure:6241: checking for x86_64-unknown-linux-ranlib
configure:6268: result: ranlib
configure:6410: checking command to parse nm output from arm-linux-androideabi-gcc object
configure:6528: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:6531: $? = 0
configure:6535: nm conftest.o \| sed -n -e 's/^.*[ ]\([ABCDGIRSTW][ABCDGIRSTW]*\)[ ][ ]*\([_A-Za-z][_A-Za-z0-9]*\)$/\1 \2 \2/p' \> conftest.nm
configure:6538: $? = 0
configure:6592: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c conftstm.o >&5
configure:6595: $? = 0
configure:6633: result: ok
configure:6728: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:6731: $? = 0
configure:7481: checking for dlfcn.h
configure:7481: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:7481: $? = 0
configure:7481: result: yes
configure:7668: checking for objdir
configure:7683: result: .libs
configure:7954: checking if arm-linux-androideabi-gcc supports -fno-rtti -fno-exceptions
configure:7972: arm-linux-androideabi-gcc -c   -fno-rtti -fno-exceptions conftest.c >&5
cc1: warning: command line option '-fno-rtti' is valid for C++/ObjC++ but not for C [enabled by default]
configure:7976: $? = 0
configure:7989: result: no
configure:8009: checking for arm-linux-androideabi-gcc option to produce PIC
configure:8295: result: -fPIC -DPIC
configure:8307: checking if arm-linux-androideabi-gcc PIC flag -fPIC -DPIC works
configure:8325: arm-linux-androideabi-gcc -c   -fPIC -DPIC -DPIC conftest.c >&5
configure:8329: $? = 0
configure:8342: result: yes
configure:8366: checking if arm-linux-androideabi-gcc static flag -static works
configure:8394: result: yes
configure:8409: checking if arm-linux-androideabi-gcc supports -c -o file.o
configure:8430: arm-linux-androideabi-gcc -c   -o out/conftest2.o conftest.c >&5
configure:8434: $? = 0
configure:8456: result: yes
configure:8464: checking if arm-linux-androideabi-gcc supports -c -o file.o
configure:8511: result: yes
configure:8544: checking whether the arm-linux-androideabi-gcc linker (/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld -m elf_i386) supports shared libraries
configure:9615: result: yes
configure:9652: checking whether -lc should be explicitly linked in
configure:9660: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:9663: $? = 0
configure:9678: arm-linux-androideabi-gcc -shared conftest.o  -v -Wl,-soname -Wl,conftest -o conftest 2\>\&1 \| /usr/sbin/grep  -lc  \>/dev/null 2\>\&1
configure:9681: $? = 0
configure:9695: result: no
configure:9860: checking dynamic linker characteristics
configure:10311: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  -Wl,-rpath -Wl,/foo conftest.c  >&5
configure:10311: $? = 0
configure:10533: result: GNU/Linux ld.so
configure:10640: checking how to hardcode library paths into programs
configure:10665: result: immediate
configure:11205: checking whether stripping libraries is possible
configure:11210: result: yes
configure:11245: checking if libtool supports shared libraries
configure:11247: result: yes
configure:11250: checking whether to build shared libraries
configure:11271: result: yes
configure:11274: checking whether to build static libraries
configure:11278: result: yes
configure:11326: checking for dlfcn.h
configure:11326: result: yes
configure:11339: checking for windows.h
configure:11339: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:63:21: fatal error: windows.h: No such file or directory
 #include <windows.h>
                     ^
compilation terminated.
configure:11339: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "gas"
| #define PACKAGE_TARNAME "gas"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "gas 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "gas"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| 
| #include <windows.h>
configure:11339: result: no
configure:11366: checking for library containing dlopen
configure:11397: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:11397: $? = 0
configure:11414: result: none required
configure:11445: checking for special C compiler options needed for large files
configure:11490: result: no
configure:11496: checking for _FILE_OFFSET_BITS value needed for large files
configure:11521: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:35:3: warning: left shift count >= width of type [enabled by default]
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
   ^
conftest.c:35:3: warning: left shift count >= width of type [enabled by default]
conftest.c:36:10: warning: left shift count >= width of type [enabled by default]
          && LARGE_OFF_T % 2147483647 == 1)
          ^
conftest.c:36:10: warning: left shift count >= width of type [enabled by default]
conftest.c:35:7: error: variably modified 'off_t_is_large' at file scope
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
       ^
configure:11521: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "gas"
| #define PACKAGE_TARNAME "gas"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "gas 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "gas"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| /* end confdefs.h.  */
| #include <sys/types.h>
|  /* Check that off_t can represent 2**63 - 1 correctly.
|     We can't simply define LARGE_OFF_T to be 9223372036854775807,
|     since some C++ compilers masquerading as C compilers
|     incorrectly reject 9223372036854775807.  */
| #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
|   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
| 		       && LARGE_OFF_T % 2147483647 == 1)
| 		      ? 1 : -1];
| int
| main ()
| {
| 
|   ;
|   return 0;
| }
configure:11545: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:36:3: warning: left shift count >= width of type [enabled by default]
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
   ^
conftest.c:36:3: warning: left shift count >= width of type [enabled by default]
conftest.c:37:10: warning: left shift count >= width of type [enabled by default]
          && LARGE_OFF_T % 2147483647 == 1)
          ^
conftest.c:37:10: warning: left shift count >= width of type [enabled by default]
conftest.c:36:7: error: variably modified 'off_t_is_large' at file scope
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
       ^
configure:11545: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "gas"
| #define PACKAGE_TARNAME "gas"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "gas 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "gas"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| /* end confdefs.h.  */
| #define _FILE_OFFSET_BITS 64
| #include <sys/types.h>
|  /* Check that off_t can represent 2**63 - 1 correctly.
|     We can't simply define LARGE_OFF_T to be 9223372036854775807,
|     since some C++ compilers masquerading as C compilers
|     incorrectly reject 9223372036854775807.  */
| #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
|   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
| 		       && LARGE_OFF_T % 2147483647 == 1)
| 		      ? 1 : -1];
| int
| main ()
| {
| 
|   ;
|   return 0;
| }
configure:11553: result: unknown
configure:11565: checking for _LARGE_FILES value needed for large files
configure:11590: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:35:3: warning: left shift count >= width of type [enabled by default]
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
   ^
conftest.c:35:3: warning: left shift count >= width of type [enabled by default]
conftest.c:36:10: warning: left shift count >= width of type [enabled by default]
          && LARGE_OFF_T % 2147483647 == 1)
          ^
conftest.c:36:10: warning: left shift count >= width of type [enabled by default]
conftest.c:35:7: error: variably modified 'off_t_is_large' at file scope
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
       ^
configure:11590: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "gas"
| #define PACKAGE_TARNAME "gas"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "gas 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "gas"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| /* end confdefs.h.  */
| #include <sys/types.h>
|  /* Check that off_t can represent 2**63 - 1 correctly.
|     We can't simply define LARGE_OFF_T to be 9223372036854775807,
|     since some C++ compilers masquerading as C compilers
|     incorrectly reject 9223372036854775807.  */
| #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
|   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
| 		       && LARGE_OFF_T % 2147483647 == 1)
| 		      ? 1 : -1];
| int
| main ()
| {
| 
|   ;
|   return 0;
| }
configure:11614: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:36:3: warning: left shift count >= width of type [enabled by default]
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
   ^
conftest.c:36:3: warning: left shift count >= width of type [enabled by default]
conftest.c:37:10: warning: left shift count >= width of type [enabled by default]
          && LARGE_OFF_T % 2147483647 == 1)
          ^
conftest.c:37:10: warning: left shift count >= width of type [enabled by default]
conftest.c:36:7: error: variably modified 'off_t_is_large' at file scope
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
       ^
configure:11614: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "gas"
| #define PACKAGE_TARNAME "gas"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "gas 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "gas"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| /* end confdefs.h.  */
| #define _LARGE_FILES 1
| #include <sys/types.h>
|  /* Check that off_t can represent 2**63 - 1 correctly.
|     We can't simply define LARGE_OFF_T to be 9223372036854775807,
|     since some C++ compilers masquerading as C compilers
|     incorrectly reject 9223372036854775807.  */
| #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
|   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
| 		       && LARGE_OFF_T % 2147483647 == 1)
| 		      ? 1 : -1];
| int
| main ()
| {
| 
|   ;
|   return 0;
| }
configure:11622: result: unknown
configure:11768: checking whether byte ordering is bigendian
configure:11783: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:31:9: error: unknown type name 'not'
         not a universal capable compiler
         ^
conftest.c:31:15: error: expected '=', ',', ';', 'asm' or '__attribute__' before 'universal'
         not a universal capable compiler
               ^
conftest.c:31:15: error: unknown type name 'universal'
configure:11783: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "gas"
| #define PACKAGE_TARNAME "gas"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "gas 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "gas"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define ENABLE_CHECKING 1
| /* end confdefs.h.  */
| #ifndef __APPLE_CC__
| 	       not a universal capable compiler
| 	     #endif
| 	     typedef int dummy;
| 
configure:11828: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:37:8: error: unknown type name 'bogus'
        bogus endian macros
        ^
conftest.c:37:21: error: expected '=', ',', ';', 'asm' or '__attribute__' before 'macros'
        bogus endian macros
                     ^
configure:11828: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "gas"
| #define PACKAGE_TARNAME "gas"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "gas 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "gas"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define ENABLE_CHECKING 1
| /* end confdefs.h.  */
| #include <sys/types.h>
| 	     #include <sys/param.h>
| 
| int
| main ()
| {
| #if ! (defined BYTE_ORDER && defined BIG_ENDIAN 		     && defined LITTLE_ENDIAN && BYTE_ORDER && BIG_ENDIAN 		     && LITTLE_ENDIAN)
| 	      bogus endian macros
| 	     #endif
| 
|   ;
|   return 0;
| }
configure:11872: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:36:8: error: unknown type name 'bogus'
        bogus endian macros
        ^
conftest.c:36:21: error: expected '=', ',', ';', 'asm' or '__attribute__' before 'macros'
        bogus endian macros
                     ^
configure:11872: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "gas"
| #define PACKAGE_TARNAME "gas"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "gas 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "gas"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define ENABLE_CHECKING 1
| /* end confdefs.h.  */
| #include <limits.h>
| 
| int
| main ()
| {
| #if ! (defined _LITTLE_ENDIAN || defined _BIG_ENDIAN)
| 	      bogus endian macros
| 	     #endif
| 
|   ;
|   return 0;
| }
configure:11928: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:11928: $? = 0
configure:11974: result: no
configure:12759: checking for bison
configure:12786: result: bison -y
configure:12802: checking for flex
configure:12829: result: flex
configure:12866: flex conftest.l
configure:12870: $? = 0
configure:12872: checking lex output file root
configure:12886: result: lex.yy
configure:12891: checking lex library
configure:12905: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c   >&5
/tmp/ccIT780H.o:conftest.c:function yylex: error: undefined reference to 'yywrap'
/tmp/ccIT780H.o:conftest.c:function input: error: undefined reference to 'yywrap'
/tmp/ccIT780H.o:conftest.c:function main: error: undefined reference to 'yywrap'
collect2: error: ld returned 1 exit status
configure:12905: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "gas"
| #define PACKAGE_TARNAME "gas"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "gas 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "gas"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define ENABLE_CHECKING 1
| #define DEFAULT_ARCH "i386"
| #define I386COFF 1
| #define EMULATIONS 
| #define DEFAULT_EMULATION ""
| #define TARGET_ALIAS "i686-w64-mingw32"
| #define TARGET_CANONICAL "i686-w64-mingw32"
| #define TARGET_CPU "i686"
| #define TARGET_VENDOR "w64"
| #define TARGET_OS "mingw32"
| /* end confdefs.h.  */
| 
| #line 3 "lex.yy.c"
| 
| #define  YY_INT_ALIGNED short int
| 
| /* A lexical scanner generated by flex */
| 
| #define FLEX_SCANNER
| #define YY_FLEX_MAJOR_VERSION 2
| #define YY_FLEX_MINOR_VERSION 5
| #define YY_FLEX_SUBMINOR_VERSION 39
| #if YY_FLEX_SUBMINOR_VERSION > 0
| #define FLEX_BETA
| #endif
| 
| /* First, we deal with  platform-specific or compiler-specific issues. */
| 
| /* begin standard C headers. */
| #include <stdio.h>
| #include <string.h>
| #include <errno.h>
| #include <stdlib.h>
| 
| /* end standard C headers. */
| 
| /* flex integer type definitions */
| 
| #ifndef FLEXINT_H
| #define FLEXINT_H
| 
| /* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
| 
| #if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
| 
| /* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
|  * if you want the limit (max/min) macros for int types. 
|  */
| #ifndef __STDC_LIMIT_MACROS
| #define __STDC_LIMIT_MACROS 1
| #endif
| 
| #include <inttypes.h>
| typedef int8_t flex_int8_t;
| typedef uint8_t flex_uint8_t;
| typedef int16_t flex_int16_t;
| typedef uint16_t flex_uint16_t;
| typedef int32_t flex_int32_t;
| typedef uint32_t flex_uint32_t;
| #else
| typedef signed char flex_int8_t;
| typedef short int flex_int16_t;
| typedef int flex_int32_t;
| typedef unsigned char flex_uint8_t; 
| typedef unsigned short int flex_uint16_t;
| typedef unsigned int flex_uint32_t;
| 
| /* Limits of integral types. */
| #ifndef INT8_MIN
| #define INT8_MIN               (-128)
| #endif
| #ifndef INT16_MIN
| #define INT16_MIN              (-32767-1)
| #endif
| #ifndef INT32_MIN
| #define INT32_MIN              (-2147483647-1)
| #endif
| #ifndef INT8_MAX
| #define INT8_MAX               (127)
| #endif
| #ifndef INT16_MAX
| #define INT16_MAX              (32767)
| #endif
| #ifndef INT32_MAX
| #define INT32_MAX              (2147483647)
| #endif
| #ifndef UINT8_MAX
| #define UINT8_MAX              (255U)
| #endif
| #ifndef UINT16_MAX
| #define UINT16_MAX             (65535U)
| #endif
| #ifndef UINT32_MAX
| #define UINT32_MAX             (4294967295U)
| #endif
| 
| #endif /* ! C99 */
| 
| #endif /* ! FLEXINT_H */
| 
| #ifdef __cplusplus
| 
| /* The "const" storage-class-modifier is valid. */
| #define YY_USE_CONST
| 
| #else	/* ! __cplusplus */
| 
| /* C99 requires __STDC__ to be defined as 1. */
| #if defined (__STDC__)
| 
| #define YY_USE_CONST
| 
| #endif	/* defined (__STDC__) */
| #endif	/* ! __cplusplus */
| 
| #ifdef YY_USE_CONST
| #define yyconst const
| #else
| #define yyconst
| #endif
| 
| /* Returned upon end-of-file. */
| #define YY_NULL 0
| 
| /* Promotes a possibly negative, possibly signed char to an unsigned
|  * integer for use as an array index.  If the signed char is negative,
|  * we want to instead treat it as an 8-bit unsigned char, hence the
|  * double cast.
|  */
| #define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
| 
| /* Enter a start condition.  This macro really ought to take a parameter,
|  * but we do it the disgusting crufty way forced on us by the ()-less
|  * definition of BEGIN.
|  */
| #define BEGIN (yy_start) = 1 + 2 *
| 
| /* Translate the current start state into a value that can be later handed
|  * to BEGIN to return to the state.  The YYSTATE alias is for lex
|  * compatibility.
|  */
| #define YY_START (((yy_start) - 1) / 2)
| #define YYSTATE YY_START
| 
| /* Action number for EOF rule of a given start state. */
| #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
| 
| /* Special action meaning "start processing a new file". */
| #define YY_NEW_FILE yyrestart(yyin  )
| 
| #define YY_END_OF_BUFFER_CHAR 0
| 
| /* Size of default input buffer. */
| #ifndef YY_BUF_SIZE
| #define YY_BUF_SIZE 16384
| #endif
| 
| /* The state buf must be large enough to hold one state per character in the main buffer.
|  */
| #define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
| 
| #ifndef YY_TYPEDEF_YY_BUFFER_STATE
| #define YY_TYPEDEF_YY_BUFFER_STATE
| typedef struct yy_buffer_state *YY_BUFFER_STATE;
| #endif
| 
| #ifndef YY_TYPEDEF_YY_SIZE_T
| #define YY_TYPEDEF_YY_SIZE_T
| typedef size_t yy_size_t;
| #endif
| 
| extern yy_size_t yyleng;
| 
| extern FILE *yyin, *yyout;
| 
| #define EOB_ACT_CONTINUE_SCAN 0
| #define EOB_ACT_END_OF_FILE 1
| #define EOB_ACT_LAST_MATCH 2
| 
|     #define YY_LESS_LINENO(n)
|     #define YY_LINENO_REWIND_TO(ptr)
|     
| /* Return all but the first "n" matched characters back to the input stream. */
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
|         int yyless_macro_arg = (n); \
|         YY_LESS_LINENO(yyless_macro_arg);\
| 		*yy_cp = (yy_hold_char); \
| 		YY_RESTORE_YY_MORE_OFFSET \
| 		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
| 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
| 		} \
| 	while ( 0 )
| 
| #define unput(c) yyunput( c, (yytext_ptr)  )
| 
| #ifndef YY_STRUCT_YY_BUFFER_STATE
| #define YY_STRUCT_YY_BUFFER_STATE
| struct yy_buffer_state
| 	{
| 	FILE *yy_input_file;
| 
| 	char *yy_ch_buf;		/* input buffer */
| 	char *yy_buf_pos;		/* current position in input buffer */
| 
| 	/* Size of input buffer in bytes, not including room for EOB
| 	 * characters.
| 	 */
| 	yy_size_t yy_buf_size;
| 
| 	/* Number of characters read into yy_ch_buf, not including EOB
| 	 * characters.
| 	 */
| 	yy_size_t yy_n_chars;
| 
| 	/* Whether we "own" the buffer - i.e., we know we created it,
| 	 * and can realloc() it to grow it, and should free() it to
| 	 * delete it.
| 	 */
| 	int yy_is_our_buffer;
| 
| 	/* Whether this is an "interactive" input source; if so, and
| 	 * if we're using stdio for input, then we want to use getc()
| 	 * instead of fread(), to make sure we stop fetching input after
| 	 * each newline.
| 	 */
| 	int yy_is_interactive;
| 
| 	/* Whether we're considered to be at the beginning of a line.
| 	 * If so, '^' rules will be active on the next match, otherwise
| 	 * not.
| 	 */
| 	int yy_at_bol;
| 
|     int yy_bs_lineno; /**< The line count. */
|     int yy_bs_column; /**< The column count. */
|     
| 	/* Whether to try to fill the input buffer when we reach the
| 	 * end of it.
| 	 */
| 	int yy_fill_buffer;
| 
| 	int yy_buffer_status;
| 
| #define YY_BUFFER_NEW 0
| #define YY_BUFFER_NORMAL 1
| 	/* When an EOF's been seen but there's still some text to process
| 	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
| 	 * shouldn't try reading from the input source any more.  We might
| 	 * still have a bunch of tokens to match, though, because of
| 	 * possible backing-up.
| 	 *
| 	 * When we actually see the EOF, we change the status to "new"
| 	 * (via yyrestart()), so that the user can continue scanning by
| 	 * just pointing yyin at a new input file.
| 	 */
| #define YY_BUFFER_EOF_PENDING 2
| 
| 	};
| #endif /* !YY_STRUCT_YY_BUFFER_STATE */
| 
| /* Stack of input buffers. */
| static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
| static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
| static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
| 
| /* We provide macros for accessing buffer states in case in the
|  * future we want to put the buffer states in a more general
|  * "scanner state".
|  *
|  * Returns the top of the stack, or NULL.
|  */
| #define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
|                           ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
|                           : NULL)
| 
| /* Same as previous macro, but useful when we know that the buffer stack is not
|  * NULL or when we need an lvalue. For internal use only.
|  */
| #define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
| 
| /* yy_hold_char holds the character lost when yytext is formed. */
| static char yy_hold_char;
| static yy_size_t yy_n_chars;		/* number of characters read into yy_ch_buf */
| yy_size_t yyleng;
| 
| /* Points to current character in buffer. */
| static char *yy_c_buf_p = (char *) 0;
| static int yy_init = 0;		/* whether we need to initialize */
| static int yy_start = 0;	/* start state number */
| 
| /* Flag which is used to allow yywrap()'s to do buffer switches
|  * instead of setting up a fresh yyin.  A bit of a hack ...
|  */
| static int yy_did_buffer_switch_on_eof;
| 
| void yyrestart (FILE *input_file  );
| void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
| YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
| void yy_delete_buffer (YY_BUFFER_STATE b  );
| void yy_flush_buffer (YY_BUFFER_STATE b  );
| void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
| void yypop_buffer_state (void );
| 
| static void yyensure_buffer_stack (void );
| static void yy_load_buffer_state (void );
| static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
| 
| #define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
| 
| YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
| YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
| YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,yy_size_t len  );
| 
| void *yyalloc (yy_size_t  );
| void *yyrealloc (void *,yy_size_t  );
| void yyfree (void *  );
| 
| #define yy_new_buffer yy_create_buffer
| 
| #define yy_set_interactive(is_interactive) \
| 	{ \
| 	if ( ! YY_CURRENT_BUFFER ){ \
|         yyensure_buffer_stack (); \
| 		YY_CURRENT_BUFFER_LVALUE =    \
|             yy_create_buffer(yyin,YY_BUF_SIZE ); \
| 	} \
| 	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
| 	}
| 
| #define yy_set_bol(at_bol) \
| 	{ \
| 	if ( ! YY_CURRENT_BUFFER ){\
|         yyensure_buffer_stack (); \
| 		YY_CURRENT_BUFFER_LVALUE =    \
|             yy_create_buffer(yyin,YY_BUF_SIZE ); \
| 	} \
| 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
| 	}
| 
| #define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
| 
| /* Begin user sect3 */
| 
| typedef unsigned char YY_CHAR;
| 
| FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
| 
| typedef int yy_state_type;
| 
| extern int yylineno;
| 
| int yylineno = 1;
| 
| extern char *yytext;
| #define yytext_ptr yytext
| 
| static yy_state_type yy_get_previous_state (void );
| static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
| static int yy_get_next_buffer (void );
| static void yy_fatal_error (yyconst char msg[]  );
| 
| /* Done after the current pattern has been matched and before the
|  * corresponding action - sets up yytext.
|  */
| #define YY_DO_BEFORE_ACTION \
| 	(yytext_ptr) = yy_bp; \
| 	(yytext_ptr) -= (yy_more_len); \
| 	yyleng = (size_t) (yy_cp - (yytext_ptr)); \
| 	(yy_hold_char) = *yy_cp; \
| 	*yy_cp = '\0'; \
| 	(yy_c_buf_p) = yy_cp;
| 
| #define YY_NUM_RULES 8
| #define YY_END_OF_BUFFER 9
| /* This struct is not used in this scanner,
|    but its presence is necessary. */
| struct yy_trans_info
| 	{
| 	flex_int32_t yy_verify;
| 	flex_int32_t yy_nxt;
| 	};
| static yyconst flex_int16_t yy_acclist[23] =
|     {   0,
|         9,    7,    8,    8,    1,    7,    8,    2,    7,    8,
|         3,    7,    8,    4,    7,    8,    5,    7,    8,    6,
|         7,    8
|     } ;
| 
| static yyconst flex_int16_t yy_accept[14] =
|     {   0,
|         1,    1,    1,    2,    4,    5,    8,   11,   14,   17,
|        20,   23,   23
|     } ;
| 
| static yyconst flex_int32_t yy_ec[256] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    3,    4,    5,    6,
| 
|         7,    8,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| 
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1
|     } ;
| 
| static yyconst flex_int32_t yy_meta[9] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1
|     } ;
| 
| static yyconst flex_int16_t yy_base[13] =
|     {   0,
|         0,    0,    9,   10,   10,   10,   10,   10,   10,   10,
|        10,   10
|     } ;
| 
| static yyconst flex_int16_t yy_def[13] =
|     {   0,
|        12,    1,   12,   12,   12,   12,   12,   12,   12,   12,
|        12,    0
|     } ;
| 
| static yyconst flex_int16_t yy_nxt[19] =
|     {   0,
|         4,    5,    6,    7,    8,    9,   10,   11,   12,    3,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| static yyconst flex_int16_t yy_chk[19] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    3,   12,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| extern int yy_flex_debug;
| int yy_flex_debug = 0;
| 
| static yy_state_type *yy_state_buf=0, *yy_state_ptr=0;
| static char *yy_full_match;
| static int yy_lp;
| #define REJECT \
| { \
| *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */ \
| yy_cp = (yy_full_match); /* restore poss. backed-over text */ \
| ++(yy_lp); \
| goto find_rule; \
| }
| 
| static int yy_more_flag = 0;
| static int yy_more_len = 0;
| #define yymore() ((yy_more_flag) = 1)
| #define YY_MORE_ADJ (yy_more_len)
| #define YY_RESTORE_YY_MORE_OFFSET
| char *yytext;
| #line 1 "conftest.l"
| #line 470 "lex.yy.c"
| 
| #define INITIAL 0
| 
| #ifndef YY_NO_UNISTD_H
| /* Special case for "unistd.h", since it is non-ANSI. We include it way
|  * down here because we want the user's section 1 to have been scanned first.
|  * The user has a chance to override it with an option.
|  */
| #include <unistd.h>
| #endif
| 
| #ifndef YY_EXTRA_TYPE
| #define YY_EXTRA_TYPE void *
| #endif
| 
| static int yy_init_globals (void );
| 
| /* Accessor methods to globals.
|    These are made visible to non-reentrant scanners for convenience. */
| 
| int yylex_destroy (void );
| 
| int yyget_debug (void );
| 
| void yyset_debug (int debug_flag  );
| 
| YY_EXTRA_TYPE yyget_extra (void );
| 
| void yyset_extra (YY_EXTRA_TYPE user_defined  );
| 
| FILE *yyget_in (void );
| 
| void yyset_in  (FILE * in_str  );
| 
| FILE *yyget_out (void );
| 
| void yyset_out  (FILE * out_str  );
| 
| yy_size_t yyget_leng (void );
| 
| char *yyget_text (void );
| 
| int yyget_lineno (void );
| 
| void yyset_lineno (int line_number  );
| 
| /* Macros after this point can all be overridden by user definitions in
|  * section 1.
|  */
| 
| #ifndef YY_SKIP_YYWRAP
| #ifdef __cplusplus
| extern "C" int yywrap (void );
| #else
| extern int yywrap (void );
| #endif
| #endif
| 
|     static void yyunput (int c,char *buf_ptr  );
|     
| #ifndef yytext_ptr
| static void yy_flex_strncpy (char *,yyconst char *,int );
| #endif
| 
| #ifdef YY_NEED_STRLEN
| static int yy_flex_strlen (yyconst char * );
| #endif
| 
| #ifndef YY_NO_INPUT
| 
| #ifdef __cplusplus
| static int yyinput (void );
| #else
| static int input (void );
| #endif
| 
| #endif
| 
| /* Amount of stuff to slurp up with each read. */
| #ifndef YY_READ_BUF_SIZE
| #define YY_READ_BUF_SIZE 8192
| #endif
| 
| /* Copy whatever the last rule matched to the standard output. */
| #ifndef ECHO
| /* This used to be an fputs(), but since the string might contain NUL's,
|  * we now use fwrite().
|  */
| #define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
| #endif
| 
| /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
|  * is returned in "result".
|  */
| #ifndef YY_INPUT
| #define YY_INPUT(buf,result,max_size) \
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
| 		{ \
| 		int c = '*'; \
| 		size_t n; \
| 		for ( n = 0; n < max_size && \
| 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
| 			buf[n] = (char) c; \
| 		if ( c == '\n' ) \
| 			buf[n++] = (char) c; \
| 		if ( c == EOF && ferror( yyin ) ) \
| 			YY_FATAL_ERROR( "input in flex scanner failed" ); \
| 		result = n; \
| 		} \
| 	else \
| 		{ \
| 		errno=0; \
| 		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
| 			{ \
| 			if( errno != EINTR) \
| 				{ \
| 				YY_FATAL_ERROR( "input in flex scanner failed" ); \
| 				break; \
| 				} \
| 			errno=0; \
| 			clearerr(yyin); \
| 			} \
| 		}\
| \
| 
| #endif
| 
| /* No semi-colon after return; correct usage is to write "yyterminate();" -
|  * we don't want an extra ';' after the "return" because that will cause
|  * some compilers to complain about unreachable statements.
|  */
| #ifndef yyterminate
| #define yyterminate() return YY_NULL
| #endif
| 
| /* Number of entries by which start-condition stack grows. */
| #ifndef YY_START_STACK_INCR
| #define YY_START_STACK_INCR 25
| #endif
| 
| /* Report a fatal error. */
| #ifndef YY_FATAL_ERROR
| #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
| #endif
| 
| /* end tables serialization structures and prototypes */
| 
| /* Default declaration of generated scanner - a define so the user can
|  * easily add parameters.
|  */
| #ifndef YY_DECL
| #define YY_DECL_IS_OURS 1
| 
| extern int yylex (void);
| 
| #define YY_DECL int yylex (void)
| #endif /* !YY_DECL */
| 
| /* Code executed at the beginning of each rule, after yytext and yyleng
|  * have been set up.
|  */
| #ifndef YY_USER_ACTION
| #define YY_USER_ACTION
| #endif
| 
| /* Code executed at the end of each rule. */
| #ifndef YY_BREAK
| #define YY_BREAK break;
| #endif
| 
| #define YY_RULE_SETUP \
| 	YY_USER_ACTION
| 
| /** The main scanner function which does all the work.
|  */
| YY_DECL
| {
| 	register yy_state_type yy_current_state;
| 	register char *yy_cp, *yy_bp;
| 	register int yy_act;
|     
| 	if ( !(yy_init) )
| 		{
| 		(yy_init) = 1;
| 
| #ifdef YY_USER_INIT
| 		YY_USER_INIT;
| #endif
| 
|         /* Create the reject buffer large enough to save one state per allowed character. */
|         if ( ! (yy_state_buf) )
|             (yy_state_buf) = (yy_state_type *)yyalloc(YY_STATE_BUF_SIZE  );
|             if ( ! (yy_state_buf) )
|                 YY_FATAL_ERROR( "out of dynamic memory in yylex()" );
| 
| 		if ( ! (yy_start) )
| 			(yy_start) = 1;	/* first start state */
| 
| 		if ( ! yyin )
| 			yyin = stdin;
| 
| 		if ( ! yyout )
| 			yyout = stdout;
| 
| 		if ( ! YY_CURRENT_BUFFER ) {
| 			yyensure_buffer_stack ();
| 			YY_CURRENT_BUFFER_LVALUE =
| 				yy_create_buffer(yyin,YY_BUF_SIZE );
| 		}
| 
| 		yy_load_buffer_state( );
| 		}
| 
| 	{
| #line 1 "conftest.l"
| 
| #line 687 "lex.yy.c"
| 
| 	while ( 1 )		/* loops until end-of-file is reached */
| 		{
| 		(yy_more_len) = 0;
| 		if ( (yy_more_flag) )
| 			{
| 			(yy_more_len) = (yy_c_buf_p) - (yytext_ptr);
| 			(yy_more_flag) = 0;
| 			}
| 		yy_cp = (yy_c_buf_p);
| 
| 		/* Support of yytext. */
| 		*yy_cp = (yy_hold_char);
| 
| 		/* yy_bp points to the position in yy_ch_buf of the start of
| 		 * the current run.
| 		 */
| 		yy_bp = yy_cp;
| 
| 		yy_current_state = (yy_start);
| 
| 		(yy_state_ptr) = (yy_state_buf);
| 		*(yy_state_ptr)++ = yy_current_state;
| 
| yy_match:
| 		do
| 			{
| 			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
| 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 				{
| 				yy_current_state = (int) yy_def[yy_current_state];
| 				if ( yy_current_state >= 13 )
| 					yy_c = yy_meta[(unsigned int) yy_c];
| 				}
| 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 			*(yy_state_ptr)++ = yy_current_state;
| 			++yy_cp;
| 			}
| 		while ( yy_base[yy_current_state] != 10 );
| 
| yy_find_action:
| 		yy_current_state = *--(yy_state_ptr);
| 		(yy_lp) = yy_accept[yy_current_state];
| find_rule: /* we branch to this label when backing up */
| 		for ( ; ; ) /* until we find what rule we matched */
| 			{
| 			if ( (yy_lp) && (yy_lp) < yy_accept[yy_current_state + 1] )
| 				{
| 				yy_act = yy_acclist[(yy_lp)];
| 					{
| 					(yy_full_match) = yy_cp;
| 					break;
| 					}
| 				}
| 			--yy_cp;
| 			yy_current_state = *--(yy_state_ptr);
| 			(yy_lp) = yy_accept[yy_current_state];
| 			}
| 
| 		YY_DO_BEFORE_ACTION;
| 
| do_action:	/* This label is used only to access EOF actions. */
| 
| 		switch ( yy_act )
| 	{ /* beginning of action switch */
| case 1:
| YY_RULE_SETUP
| #line 2 "conftest.l"
| { ECHO; }
| 	YY_BREAK
| case 2:
| YY_RULE_SETUP
| #line 3 "conftest.l"
| { REJECT; }
| 	YY_BREAK
| case 3:
| YY_RULE_SETUP
| #line 4 "conftest.l"
| { yymore (); }
| 	YY_BREAK
| case 4:
| YY_RULE_SETUP
| #line 5 "conftest.l"
| { yyless (1); }
| 	YY_BREAK
| case 5:
| YY_RULE_SETUP
| #line 6 "conftest.l"
| { yyless (input () != 0); }
| 	YY_BREAK
| case 6:
| YY_RULE_SETUP
| #line 7 "conftest.l"
| { unput (yytext[0]); }
| 	YY_BREAK
| case 7:
| YY_RULE_SETUP
| #line 8 "conftest.l"
| { BEGIN INITIAL; }
| 	YY_BREAK
| case 8:
| YY_RULE_SETUP
| #line 9 "conftest.l"
| ECHO;
| 	YY_BREAK
| #line 793 "lex.yy.c"
| 			case YY_STATE_EOF(INITIAL):
| 				yyterminate();
| 
| 	case YY_END_OF_BUFFER:
| 		{
| 		/* Amount of text matched not including the EOB char. */
| 		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
| 
| 		/* Undo the effects of YY_DO_BEFORE_ACTION. */
| 		*yy_cp = (yy_hold_char);
| 		YY_RESTORE_YY_MORE_OFFSET
| 
| 		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
| 			{
| 			/* We're scanning a new file or input source.  It's
| 			 * possible that this happened because the user
| 			 * just pointed yyin at a new source and called
| 			 * yylex().  If so, then we have to assure
| 			 * consistency between YY_CURRENT_BUFFER and our
| 			 * globals.  Here is the right place to do so, because
| 			 * this is the first action (other than possibly a
| 			 * back-up) that will match for the new input source.
| 			 */
| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
| 			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
| 			}
| 
| 		/* Note that here we test for yy_c_buf_p "<=" to the position
| 		 * of the first EOB in the buffer, since yy_c_buf_p will
| 		 * already have been incremented past the NUL character
| 		 * (since all states make transitions on EOB to the
| 		 * end-of-buffer state).  Contrast this with the test
| 		 * in input().
| 		 */
| 		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
| 			{ /* This was really a NUL. */
| 			yy_state_type yy_next_state;
| 
| 			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
| 
| 			yy_current_state = yy_get_previous_state(  );
| 
| 			/* Okay, we're now positioned to make the NUL
| 			 * transition.  We couldn't have
| 			 * yy_get_previous_state() go ahead and do it
| 			 * for us because it doesn't know how to deal
| 			 * with the possibility of jamming (and we don't
| 			 * want to build jamming into it because then it
| 			 * will run more slowly).
| 			 */
| 
| 			yy_next_state = yy_try_NUL_trans( yy_current_state );
| 
| 			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 
| 			if ( yy_next_state )
| 				{
| 				/* Consume the NUL. */
| 				yy_cp = ++(yy_c_buf_p);
| 				yy_current_state = yy_next_state;
| 				goto yy_match;
| 				}
| 
| 			else
| 				{
| 				yy_cp = (yy_c_buf_p);
| 				goto yy_find_action;
| 				}
| 			}
| 
| 		else switch ( yy_get_next_buffer(  ) )
| 			{
| 			case EOB_ACT_END_OF_FILE:
| 				{
| 				(yy_did_buffer_switch_on_eof) = 0;
| 
| 				if ( yywrap( ) )
| 					{
| 					/* Note: because we've taken care in
| 					 * yy_get_next_buffer() to have set up
| 					 * yytext, we can now set up
| 					 * yy_c_buf_p so that if some total
| 					 * hoser (like flex itself) wants to
| 					 * call the scanner after we return the
| 					 * YY_NULL, it'll still work - another
| 					 * YY_NULL will get returned.
| 					 */
| 					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
| 
| 					yy_act = YY_STATE_EOF(YY_START);
| 					goto do_action;
| 					}
| 
| 				else
| 					{
| 					if ( ! (yy_did_buffer_switch_on_eof) )
| 						YY_NEW_FILE;
| 					}
| 				break;
| 				}
| 
| 			case EOB_ACT_CONTINUE_SCAN:
| 				(yy_c_buf_p) =
| 					(yytext_ptr) + yy_amount_of_matched_text;
| 
| 				yy_current_state = yy_get_previous_state(  );
| 
| 				yy_cp = (yy_c_buf_p);
| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 				goto yy_match;
| 
| 			case EOB_ACT_LAST_MATCH:
| 				(yy_c_buf_p) =
| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
| 
| 				yy_current_state = yy_get_previous_state(  );
| 
| 				yy_cp = (yy_c_buf_p);
| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 				goto yy_find_action;
| 			}
| 		break;
| 		}
| 
| 	default:
| 		YY_FATAL_ERROR(
| 			"fatal flex scanner internal error--no action found" );
| 	} /* end of action switch */
| 		} /* end of scanning one token */
| 	} /* end of user's declarations */
| } /* end of yylex */
| 
| /* yy_get_next_buffer - try to read in a new buffer
|  *
|  * Returns a code representing an action:
|  *	EOB_ACT_LAST_MATCH -
|  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
|  *	EOB_ACT_END_OF_FILE - end of file
|  */
| static int yy_get_next_buffer (void)
| {
|     	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
| 	register char *source = (yytext_ptr);
| 	register int number_to_move, i;
| 	int ret_val;
| 
| 	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
| 		YY_FATAL_ERROR(
| 		"fatal flex scanner internal error--end of buffer missed" );
| 
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
| 		{ /* Don't try to fill the buffer, so this is an EOF. */
| 		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
| 			{
| 			/* We matched a single character, the EOB, so
| 			 * treat this as a final EOF.
| 			 */
| 			return EOB_ACT_END_OF_FILE;
| 			}
| 
| 		else
| 			{
| 			/* We matched some text prior to the EOB, first
| 			 * process it.
| 			 */
| 			return EOB_ACT_LAST_MATCH;
| 			}
| 		}
| 
| 	/* Try to read more data. */
| 
| 	/* First move last chars to start of buffer. */
| 	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
| 
| 	for ( i = 0; i < number_to_move; ++i )
| 		*(dest++) = *(source++);
| 
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
| 		/* don't do the read, it's not guaranteed to return an EOF,
| 		 * just force an EOF
| 		 */
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
| 
| 	else
| 		{
| 			yy_size_t num_to_read =
| 			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
| 
| 		while ( num_to_read <= 0 )
| 			{ /* Not enough room in the buffer - grow it. */
| 
| 			YY_FATAL_ERROR(
| "input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
| 
| 			}
| 
| 		if ( num_to_read > YY_READ_BUF_SIZE )
| 			num_to_read = YY_READ_BUF_SIZE;
| 
| 		/* Read in more data. */
| 		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
| 			(yy_n_chars), num_to_read );
| 
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	if ( (yy_n_chars) == 0 )
| 		{
| 		if ( number_to_move == YY_MORE_ADJ )
| 			{
| 			ret_val = EOB_ACT_END_OF_FILE;
| 			yyrestart(yyin  );
| 			}
| 
| 		else
| 			{
| 			ret_val = EOB_ACT_LAST_MATCH;
| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
| 				YY_BUFFER_EOF_PENDING;
| 			}
| 		}
| 
| 	else
| 		ret_val = EOB_ACT_CONTINUE_SCAN;
| 
| 	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
| 		/* Extend the array by 50%, plus the number we really need. */
| 		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
| 		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
| 		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
| 			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
| 	}
| 
| 	(yy_n_chars) += number_to_move;
| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
| 
| 	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
| 
| 	return ret_val;
| }
| 
| /* yy_get_previous_state - get the state just before the EOB char was reached */
| 
|     static yy_state_type yy_get_previous_state (void)
| {
| 	register yy_state_type yy_current_state;
| 	register char *yy_cp;
|     
| 	yy_current_state = (yy_start);
| 
| 	(yy_state_ptr) = (yy_state_buf);
| 	*(yy_state_ptr)++ = yy_current_state;
| 
| 	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
| 		{
| 		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
| 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 			{
| 			yy_current_state = (int) yy_def[yy_current_state];
| 			if ( yy_current_state >= 13 )
| 				yy_c = yy_meta[(unsigned int) yy_c];
| 			}
| 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 		*(yy_state_ptr)++ = yy_current_state;
| 		}
| 
| 	return yy_current_state;
| }
| 
| /* yy_try_NUL_trans - try to make a transition on the NUL character
|  *
|  * synopsis
|  *	next_state = yy_try_NUL_trans( current_state );
|  */
|     static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
| {
| 	register int yy_is_jam;
|     
| 	register YY_CHAR yy_c = 1;
| 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 		{
| 		yy_current_state = (int) yy_def[yy_current_state];
| 		if ( yy_current_state >= 13 )
| 			yy_c = yy_meta[(unsigned int) yy_c];
| 		}
| 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 	yy_is_jam = (yy_current_state == 12);
| 	if ( ! yy_is_jam )
| 		*(yy_state_ptr)++ = yy_current_state;
| 
| 		return yy_is_jam ? 0 : yy_current_state;
| }
| 
|     static void yyunput (int c, register char * yy_bp )
| {
| 	register char *yy_cp;
|     
|     yy_cp = (yy_c_buf_p);
| 
| 	/* undo effects of setting up yytext */
| 	*yy_cp = (yy_hold_char);
| 
| 	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
| 		{ /* need to shift things up to make room */
| 		/* +2 for EOB chars. */
| 		register yy_size_t number_to_move = (yy_n_chars) + 2;
| 		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
| 					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
| 		register char *source =
| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
| 
| 		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
| 			*--dest = *--source;
| 
| 		yy_cp += (int) (dest - source);
| 		yy_bp += (int) (dest - source);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
| 
| 		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
| 			YY_FATAL_ERROR( "flex scanner push-back overflow" );
| 		}
| 
| 	*--yy_cp = (char) c;
| 
| 	(yytext_ptr) = yy_bp;
| 	(yy_hold_char) = *yy_cp;
| 	(yy_c_buf_p) = yy_cp;
| }
| 
| #ifndef YY_NO_INPUT
| #ifdef __cplusplus
|     static int yyinput (void)
| #else
|     static int input  (void)
| #endif
| 
| {
| 	int c;
|     
| 	*(yy_c_buf_p) = (yy_hold_char);
| 
| 	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
| 		{
| 		/* yy_c_buf_p now points to the character we want to return.
| 		 * If this occurs *before* the EOB characters, then it's a
| 		 * valid NUL; if not, then we've hit the end of the buffer.
| 		 */
| 		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
| 			/* This was really a NUL. */
| 			*(yy_c_buf_p) = '\0';
| 
| 		else
| 			{ /* need more input */
| 			yy_size_t offset = (yy_c_buf_p) - (yytext_ptr);
| 			++(yy_c_buf_p);
| 
| 			switch ( yy_get_next_buffer(  ) )
| 				{
| 				case EOB_ACT_LAST_MATCH:
| 					/* This happens because yy_g_n_b()
| 					 * sees that we've accumulated a
| 					 * token and flags that we need to
| 					 * try matching the token before
| 					 * proceeding.  But for input(),
| 					 * there's no matching to consider.
| 					 * So convert the EOB_ACT_LAST_MATCH
| 					 * to EOB_ACT_END_OF_FILE.
| 					 */
| 
| 					/* Reset buffer status. */
| 					yyrestart(yyin );
| 
| 					/*FALLTHROUGH*/
| 
| 				case EOB_ACT_END_OF_FILE:
| 					{
| 					if ( yywrap( ) )
| 						return EOF;
| 
| 					if ( ! (yy_did_buffer_switch_on_eof) )
| 						YY_NEW_FILE;
| #ifdef __cplusplus
| 					return yyinput();
| #else
| 					return input();
| #endif
| 					}
| 
| 				case EOB_ACT_CONTINUE_SCAN:
| 					(yy_c_buf_p) = (yytext_ptr) + offset;
| 					break;
| 				}
| 			}
| 		}
| 
| 	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
| 	*(yy_c_buf_p) = '\0';	/* preserve yytext */
| 	(yy_hold_char) = *++(yy_c_buf_p);
| 
| 	return c;
| }
| #endif	/* ifndef YY_NO_INPUT */
| 
| /** Immediately switch to a different input stream.
|  * @param input_file A readable stream.
|  * 
|  * @note This function does not reset the start condition to @c INITIAL .
|  */
|     void yyrestart  (FILE * input_file )
| {
|     
| 	if ( ! YY_CURRENT_BUFFER ){
|         yyensure_buffer_stack ();
| 		YY_CURRENT_BUFFER_LVALUE =
|             yy_create_buffer(yyin,YY_BUF_SIZE );
| 	}
| 
| 	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
| 	yy_load_buffer_state( );
| }
| 
| /** Switch to a different input buffer.
|  * @param new_buffer The new input buffer.
|  * 
|  */
|     void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
| {
|     
| 	/* TODO. We should be able to replace this entire function body
| 	 * with
| 	 *		yypop_buffer_state();
| 	 *		yypush_buffer_state(new_buffer);
|      */
| 	yyensure_buffer_stack ();
| 	if ( YY_CURRENT_BUFFER == new_buffer )
| 		return;
| 
| 	if ( YY_CURRENT_BUFFER )
| 		{
| 		/* Flush out information for old buffer. */
| 		*(yy_c_buf_p) = (yy_hold_char);
| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
| 	yy_load_buffer_state( );
| 
| 	/* We don't actually know whether we did this switch during
| 	 * EOF (yywrap()) processing, but the only time this flag
| 	 * is looked at is after yywrap() is called, so it's safe
| 	 * to go ahead and always set it.
| 	 */
| 	(yy_did_buffer_switch_on_eof) = 1;
| }
| 
| static void yy_load_buffer_state  (void)
| {
|     	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
| 	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
| 	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
| 	(yy_hold_char) = *(yy_c_buf_p);
| }
| 
| /** Allocate and initialize an input buffer state.
|  * @param file A readable stream.
|  * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
|  * 
|  * @return the allocated buffer state.
|  */
|     YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
| {
| 	YY_BUFFER_STATE b;
|     
| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_buf_size = size;
| 
| 	/* yy_ch_buf has to be 2 characters longer than the size given because
| 	 * we need to put in 2 end-of-buffer characters.
| 	 */
| 	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
| 	if ( ! b->yy_ch_buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_is_our_buffer = 1;
| 
| 	yy_init_buffer(b,file );
| 
| 	return b;
| }
| 
| /** Destroy the buffer.
|  * @param b a buffer created with yy_create_buffer()
|  * 
|  */
|     void yy_delete_buffer (YY_BUFFER_STATE  b )
| {
|     
| 	if ( ! b )
| 		return;
| 
| 	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
| 		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
| 
| 	if ( b->yy_is_our_buffer )
| 		yyfree((void *) b->yy_ch_buf  );
| 
| 	yyfree((void *) b  );
| }
| 
| /* Initializes or reinitializes a buffer.
|  * This function is sometimes called more than once on the same buffer,
|  * such as during a yyrestart() or at EOF.
|  */
|     static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
| 
| {
| 	int oerrno = errno;
|     
| 	yy_flush_buffer(b );
| 
| 	b->yy_input_file = file;
| 	b->yy_fill_buffer = 1;
| 
|     /* If b is the current buffer, then yy_init_buffer was _probably_
|      * called from yyrestart() or through yy_get_next_buffer.
|      * In that case, we don't want to reset the lineno or column.
|      */
|     if (b != YY_CURRENT_BUFFER){
|         b->yy_bs_lineno = 1;
|         b->yy_bs_column = 0;
|     }
| 
|         b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
|     
| 	errno = oerrno;
| }
| 
| /** Discard all buffered characters. On the next scan, YY_INPUT will be called.
|  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
|  * 
|  */
|     void yy_flush_buffer (YY_BUFFER_STATE  b )
| {
|     	if ( ! b )
| 		return;
| 
| 	b->yy_n_chars = 0;
| 
| 	/* We always need two end-of-buffer characters.  The first causes
| 	 * a transition to the end-of-buffer state.  The second causes
| 	 * a jam in that state.
| 	 */
| 	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
| 	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b->yy_buf_pos = &b->yy_ch_buf[0];
| 
| 	b->yy_at_bol = 1;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	if ( b == YY_CURRENT_BUFFER )
| 		yy_load_buffer_state( );
| }
| 
| /** Pushes the new state onto the stack. The new state becomes
|  *  the current state. This function will allocate the stack
|  *  if necessary.
|  *  @param new_buffer The new state.
|  *  
|  */
| void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
| {
|     	if (new_buffer == NULL)
| 		return;
| 
| 	yyensure_buffer_stack();
| 
| 	/* This block is copied from yy_switch_to_buffer. */
| 	if ( YY_CURRENT_BUFFER )
| 		{
| 		/* Flush out information for old buffer. */
| 		*(yy_c_buf_p) = (yy_hold_char);
| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	/* Only push if top exists. Otherwise, replace top. */
| 	if (YY_CURRENT_BUFFER)
| 		(yy_buffer_stack_top)++;
| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
| 
| 	/* copied from yy_switch_to_buffer. */
| 	yy_load_buffer_state( );
| 	(yy_did_buffer_switch_on_eof) = 1;
| }
| 
| /** Removes and deletes the top of the stack, if present.
|  *  The next element becomes the new top.
|  *  
|  */
| void yypop_buffer_state (void)
| {
|     	if (!YY_CURRENT_BUFFER)
| 		return;
| 
| 	yy_delete_buffer(YY_CURRENT_BUFFER );
| 	YY_CURRENT_BUFFER_LVALUE = NULL;
| 	if ((yy_buffer_stack_top) > 0)
| 		--(yy_buffer_stack_top);
| 
| 	if (YY_CURRENT_BUFFER) {
| 		yy_load_buffer_state( );
| 		(yy_did_buffer_switch_on_eof) = 1;
| 	}
| }
| 
| /* Allocates the stack if it does not exist.
|  *  Guarantees space for at least one push.
|  */
| static void yyensure_buffer_stack (void)
| {
| 	yy_size_t num_to_alloc;
|     
| 	if (!(yy_buffer_stack)) {
| 
| 		/* First allocation is just for 2 elements, since we don't know if this
| 		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
| 		 * immediate realloc on the next call.
|          */
| 		num_to_alloc = 1;
| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
| 								(num_to_alloc * sizeof(struct yy_buffer_state*)
| 								);
| 		if ( ! (yy_buffer_stack) )
| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
| 								  
| 		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
| 				
| 		(yy_buffer_stack_max) = num_to_alloc;
| 		(yy_buffer_stack_top) = 0;
| 		return;
| 	}
| 
| 	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
| 
| 		/* Increase the buffer to prepare for a possible push. */
| 		int grow_size = 8 /* arbitrary grow size */;
| 
| 		num_to_alloc = (yy_buffer_stack_max) + grow_size;
| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
| 								((yy_buffer_stack),
| 								num_to_alloc * sizeof(struct yy_buffer_state*)
| 								);
| 		if ( ! (yy_buffer_stack) )
| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
| 
| 		/* zero only the new slots.*/
| 		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
| 		(yy_buffer_stack_max) = num_to_alloc;
| 	}
| }
| 
| /** Setup the input buffer state to scan directly from a user-specified character buffer.
|  * @param base the character buffer
|  * @param size the size in bytes of the character buffer
|  * 
|  * @return the newly allocated buffer state object. 
|  */
| YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
| {
| 	YY_BUFFER_STATE b;
|     
| 	if ( size < 2 ||
| 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
| 	     base[size-1] != YY_END_OF_BUFFER_CHAR )
| 		/* They forgot to leave room for the EOB's. */
| 		return 0;
| 
| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
| 
| 	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
| 	b->yy_buf_pos = b->yy_ch_buf = base;
| 	b->yy_is_our_buffer = 0;
| 	b->yy_input_file = 0;
| 	b->yy_n_chars = b->yy_buf_size;
| 	b->yy_is_interactive = 0;
| 	b->yy_at_bol = 1;
| 	b->yy_fill_buffer = 0;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	yy_switch_to_buffer(b  );
| 
| 	return b;
| }
| 
| /** Setup the input buffer state to scan a string. The next call to yylex() will
|  * scan from a @e copy of @a str.
|  * @param yystr a NUL-terminated string to scan
|  * 
|  * @return the newly allocated buffer state object.
|  * @note If you want to scan bytes that may contain NUL values, then use
|  *       yy_scan_bytes() instead.
|  */
| YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
| {
|     
| 	return yy_scan_bytes(yystr,strlen(yystr) );
| }
| 
| /** Setup the input buffer state to scan the given bytes. The next call to yylex() will
|  * scan from a @e copy of @a bytes.
|  * @param yybytes the byte buffer to scan
|  * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
|  * 
|  * @return the newly allocated buffer state object.
|  */
| YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len )
| {
| 	YY_BUFFER_STATE b;
| 	char *buf;
| 	yy_size_t n;
| 	yy_size_t i;
|     
| 	/* Get memory for full buffer, including space for trailing EOB's. */
| 	n = _yybytes_len + 2;
| 	buf = (char *) yyalloc(n  );
| 	if ( ! buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
| 
| 	for ( i = 0; i < _yybytes_len; ++i )
| 		buf[i] = yybytes[i];
| 
| 	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b = yy_scan_buffer(buf,n );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
| 
| 	/* It's okay to grow etc. this buffer, and we should throw it
| 	 * away when we're done.
| 	 */
| 	b->yy_is_our_buffer = 1;
| 
| 	return b;
| }
| 
| #ifndef YY_EXIT_FAILURE
| #define YY_EXIT_FAILURE 2
| #endif
| 
| static void yy_fatal_error (yyconst char* msg )
| {
|     	(void) fprintf( stderr, "%s\n", msg );
| 	exit( YY_EXIT_FAILURE );
| }
| 
| /* Redefine yyless() so it works in section 3 code. */
| 
| #undef yyless
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
|         int yyless_macro_arg = (n); \
|         YY_LESS_LINENO(yyless_macro_arg);\
| 		yytext[yyleng] = (yy_hold_char); \
| 		(yy_c_buf_p) = yytext + yyless_macro_arg; \
| 		(yy_hold_char) = *(yy_c_buf_p); \
| 		*(yy_c_buf_p) = '\0'; \
| 		yyleng = yyless_macro_arg; \
| 		} \
| 	while ( 0 )
| 
| /* Accessor  methods (get/set functions) to struct members. */
| 
| /** Get the current line number.
|  * 
|  */
| int yyget_lineno  (void)
| {
|         
|     return yylineno;
| }
| 
| /** Get the input stream.
|  * 
|  */
| FILE *yyget_in  (void)
| {
|         return yyin;
| }
| 
| /** Get the output stream.
|  * 
|  */
| FILE *yyget_out  (void)
| {
|         return yyout;
| }
| 
| /** Get the length of the current token.
|  * 
|  */
| yy_size_t yyget_leng  (void)
| {
|         return yyleng;
| }
| 
| /** Get the current token.
|  * 
|  */
| 
| char *yyget_text  (void)
| {
|         return yytext;
| }
| 
| /** Set the current line number.
|  * @param line_number
|  * 
|  */
| void yyset_lineno (int  line_number )
| {
|     
|     yylineno = line_number;
| }
| 
| /** Set the input stream. This does not discard the current
|  * input buffer.
|  * @param in_str A readable stream.
|  * 
|  * @see yy_switch_to_buffer
|  */
| void yyset_in (FILE *  in_str )
| {
|         yyin = in_str ;
| }
| 
| void yyset_out (FILE *  out_str )
| {
|         yyout = out_str ;
| }
| 
| int yyget_debug  (void)
| {
|         return yy_flex_debug;
| }
| 
| void yyset_debug (int  bdebug )
| {
|         yy_flex_debug = bdebug ;
| }
| 
| static int yy_init_globals (void)
| {
|         /* Initialization is the same as for the non-reentrant scanner.
|      * This function is called from yylex_destroy(), so don't allocate here.
|      */
| 
|     (yy_buffer_stack) = 0;
|     (yy_buffer_stack_top) = 0;
|     (yy_buffer_stack_max) = 0;
|     (yy_c_buf_p) = (char *) 0;
|     (yy_init) = 0;
|     (yy_start) = 0;
| 
|     (yy_state_buf) = 0;
|     (yy_state_ptr) = 0;
|     (yy_full_match) = 0;
|     (yy_lp) = 0;
| 
| /* Defined in main.c */
| #ifdef YY_STDINIT
|     yyin = stdin;
|     yyout = stdout;
| #else
|     yyin = (FILE *) 0;
|     yyout = (FILE *) 0;
| #endif
| 
|     /* For future reference: Set errno on error, since we are called by
|      * yylex_init()
|      */
|     return 0;
| }
| 
| /* yylex_destroy is for both reentrant and non-reentrant scanners. */
| int yylex_destroy  (void)
| {
|     
|     /* Pop the buffer stack, destroying each element. */
| 	while(YY_CURRENT_BUFFER){
| 		yy_delete_buffer(YY_CURRENT_BUFFER  );
| 		YY_CURRENT_BUFFER_LVALUE = NULL;
| 		yypop_buffer_state();
| 	}
| 
| 	/* Destroy the stack itself. */
| 	yyfree((yy_buffer_stack) );
| 	(yy_buffer_stack) = NULL;
| 
|     yyfree ( (yy_state_buf) );
|     (yy_state_buf)  = NULL;
| 
|     /* Reset the globals. This is important in a non-reentrant scanner so the next time
|      * yylex() is called, initialization will occur. */
|     yy_init_globals( );
| 
|     return 0;
| }
| 
| /*
|  * Internal utility routines.
|  */
| 
| #ifndef yytext_ptr
| static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
| {
| 	register int i;
| 	for ( i = 0; i < n; ++i )
| 		s1[i] = s2[i];
| }
| #endif
| 
| #ifdef YY_NEED_STRLEN
| static int yy_flex_strlen (yyconst char * s )
| {
| 	register int n;
| 	for ( n = 0; s[n]; ++n )
| 		;
| 
| 	return n;
| }
| #endif
| 
| void *yyalloc (yy_size_t  size )
| {
| 	return (void *) malloc( size );
| }
| 
| void *yyrealloc  (void * ptr, yy_size_t  size )
| {
| 	/* The cast to (char *) in the following accommodates both
| 	 * implementations that use char* generic pointers, and those
| 	 * that use void* generic pointers.  It works with the latter
| 	 * because both ANSI C and C++ allow castless assignment from
| 	 * any pointer type to void*, and deal with argument conversions
| 	 * as though doing an assignment.
| 	 */
| 	return (void *) realloc( (char *) ptr, size );
| }
| 
| void yyfree (void * ptr )
| {
| 	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
| }
| 
| #define YYTABLES_NAME "yytables"
| 
| #line 9 "conftest.l"
| 
| 
| #ifdef YYTEXT_POINTER
| extern char *yytext;
| #endif
| int
| main (void)
| {
|   return ! yylex () + ! yywrap ();
| }
configure:12905: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c -lfl  >&5
/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld: error: cannot find -lfl
/tmp/cci1IH02.o:conftest.c:function yylex: error: undefined reference to 'yywrap'
/tmp/cci1IH02.o:conftest.c:function input: error: undefined reference to 'yywrap'
/tmp/cci1IH02.o:conftest.c:function main: error: undefined reference to 'yywrap'
collect2: error: ld returned 1 exit status
configure:12905: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "gas"
| #define PACKAGE_TARNAME "gas"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "gas 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "gas"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define ENABLE_CHECKING 1
| #define DEFAULT_ARCH "i386"
| #define I386COFF 1
| #define EMULATIONS 
| #define DEFAULT_EMULATION ""
| #define TARGET_ALIAS "i686-w64-mingw32"
| #define TARGET_CANONICAL "i686-w64-mingw32"
| #define TARGET_CPU "i686"
| #define TARGET_VENDOR "w64"
| #define TARGET_OS "mingw32"
| /* end confdefs.h.  */
| 
| #line 3 "lex.yy.c"
| 
| #define  YY_INT_ALIGNED short int
| 
| /* A lexical scanner generated by flex */
| 
| #define FLEX_SCANNER
| #define YY_FLEX_MAJOR_VERSION 2
| #define YY_FLEX_MINOR_VERSION 5
| #define YY_FLEX_SUBMINOR_VERSION 39
| #if YY_FLEX_SUBMINOR_VERSION > 0
| #define FLEX_BETA
| #endif
| 
| /* First, we deal with  platform-specific or compiler-specific issues. */
| 
| /* begin standard C headers. */
| #include <stdio.h>
| #include <string.h>
| #include <errno.h>
| #include <stdlib.h>
| 
| /* end standard C headers. */
| 
| /* flex integer type definitions */
| 
| #ifndef FLEXINT_H
| #define FLEXINT_H
| 
| /* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
| 
| #if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
| 
| /* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
|  * if you want the limit (max/min) macros for int types. 
|  */
| #ifndef __STDC_LIMIT_MACROS
| #define __STDC_LIMIT_MACROS 1
| #endif
| 
| #include <inttypes.h>
| typedef int8_t flex_int8_t;
| typedef uint8_t flex_uint8_t;
| typedef int16_t flex_int16_t;
| typedef uint16_t flex_uint16_t;
| typedef int32_t flex_int32_t;
| typedef uint32_t flex_uint32_t;
| #else
| typedef signed char flex_int8_t;
| typedef short int flex_int16_t;
| typedef int flex_int32_t;
| typedef unsigned char flex_uint8_t; 
| typedef unsigned short int flex_uint16_t;
| typedef unsigned int flex_uint32_t;
| 
| /* Limits of integral types. */
| #ifndef INT8_MIN
| #define INT8_MIN               (-128)
| #endif
| #ifndef INT16_MIN
| #define INT16_MIN              (-32767-1)
| #endif
| #ifndef INT32_MIN
| #define INT32_MIN              (-2147483647-1)
| #endif
| #ifndef INT8_MAX
| #define INT8_MAX               (127)
| #endif
| #ifndef INT16_MAX
| #define INT16_MAX              (32767)
| #endif
| #ifndef INT32_MAX
| #define INT32_MAX              (2147483647)
| #endif
| #ifndef UINT8_MAX
| #define UINT8_MAX              (255U)
| #endif
| #ifndef UINT16_MAX
| #define UINT16_MAX             (65535U)
| #endif
| #ifndef UINT32_MAX
| #define UINT32_MAX             (4294967295U)
| #endif
| 
| #endif /* ! C99 */
| 
| #endif /* ! FLEXINT_H */
| 
| #ifdef __cplusplus
| 
| /* The "const" storage-class-modifier is valid. */
| #define YY_USE_CONST
| 
| #else	/* ! __cplusplus */
| 
| /* C99 requires __STDC__ to be defined as 1. */
| #if defined (__STDC__)
| 
| #define YY_USE_CONST
| 
| #endif	/* defined (__STDC__) */
| #endif	/* ! __cplusplus */
| 
| #ifdef YY_USE_CONST
| #define yyconst const
| #else
| #define yyconst
| #endif
| 
| /* Returned upon end-of-file. */
| #define YY_NULL 0
| 
| /* Promotes a possibly negative, possibly signed char to an unsigned
|  * integer for use as an array index.  If the signed char is negative,
|  * we want to instead treat it as an 8-bit unsigned char, hence the
|  * double cast.
|  */
| #define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
| 
| /* Enter a start condition.  This macro really ought to take a parameter,
|  * but we do it the disgusting crufty way forced on us by the ()-less
|  * definition of BEGIN.
|  */
| #define BEGIN (yy_start) = 1 + 2 *
| 
| /* Translate the current start state into a value that can be later handed
|  * to BEGIN to return to the state.  The YYSTATE alias is for lex
|  * compatibility.
|  */
| #define YY_START (((yy_start) - 1) / 2)
| #define YYSTATE YY_START
| 
| /* Action number for EOF rule of a given start state. */
| #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
| 
| /* Special action meaning "start processing a new file". */
| #define YY_NEW_FILE yyrestart(yyin  )
| 
| #define YY_END_OF_BUFFER_CHAR 0
| 
| /* Size of default input buffer. */
| #ifndef YY_BUF_SIZE
| #define YY_BUF_SIZE 16384
| #endif
| 
| /* The state buf must be large enough to hold one state per character in the main buffer.
|  */
| #define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
| 
| #ifndef YY_TYPEDEF_YY_BUFFER_STATE
| #define YY_TYPEDEF_YY_BUFFER_STATE
| typedef struct yy_buffer_state *YY_BUFFER_STATE;
| #endif
| 
| #ifndef YY_TYPEDEF_YY_SIZE_T
| #define YY_TYPEDEF_YY_SIZE_T
| typedef size_t yy_size_t;
| #endif
| 
| extern yy_size_t yyleng;
| 
| extern FILE *yyin, *yyout;
| 
| #define EOB_ACT_CONTINUE_SCAN 0
| #define EOB_ACT_END_OF_FILE 1
| #define EOB_ACT_LAST_MATCH 2
| 
|     #define YY_LESS_LINENO(n)
|     #define YY_LINENO_REWIND_TO(ptr)
|     
| /* Return all but the first "n" matched characters back to the input stream. */
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
|         int yyless_macro_arg = (n); \
|         YY_LESS_LINENO(yyless_macro_arg);\
| 		*yy_cp = (yy_hold_char); \
| 		YY_RESTORE_YY_MORE_OFFSET \
| 		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
| 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
| 		} \
| 	while ( 0 )
| 
| #define unput(c) yyunput( c, (yytext_ptr)  )
| 
| #ifndef YY_STRUCT_YY_BUFFER_STATE
| #define YY_STRUCT_YY_BUFFER_STATE
| struct yy_buffer_state
| 	{
| 	FILE *yy_input_file;
| 
| 	char *yy_ch_buf;		/* input buffer */
| 	char *yy_buf_pos;		/* current position in input buffer */
| 
| 	/* Size of input buffer in bytes, not including room for EOB
| 	 * characters.
| 	 */
| 	yy_size_t yy_buf_size;
| 
| 	/* Number of characters read into yy_ch_buf, not including EOB
| 	 * characters.
| 	 */
| 	yy_size_t yy_n_chars;
| 
| 	/* Whether we "own" the buffer - i.e., we know we created it,
| 	 * and can realloc() it to grow it, and should free() it to
| 	 * delete it.
| 	 */
| 	int yy_is_our_buffer;
| 
| 	/* Whether this is an "interactive" input source; if so, and
| 	 * if we're using stdio for input, then we want to use getc()
| 	 * instead of fread(), to make sure we stop fetching input after
| 	 * each newline.
| 	 */
| 	int yy_is_interactive;
| 
| 	/* Whether we're considered to be at the beginning of a line.
| 	 * If so, '^' rules will be active on the next match, otherwise
| 	 * not.
| 	 */
| 	int yy_at_bol;
| 
|     int yy_bs_lineno; /**< The line count. */
|     int yy_bs_column; /**< The column count. */
|     
| 	/* Whether to try to fill the input buffer when we reach the
| 	 * end of it.
| 	 */
| 	int yy_fill_buffer;
| 
| 	int yy_buffer_status;
| 
| #define YY_BUFFER_NEW 0
| #define YY_BUFFER_NORMAL 1
| 	/* When an EOF's been seen but there's still some text to process
| 	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
| 	 * shouldn't try reading from the input source any more.  We might
| 	 * still have a bunch of tokens to match, though, because of
| 	 * possible backing-up.
| 	 *
| 	 * When we actually see the EOF, we change the status to "new"
| 	 * (via yyrestart()), so that the user can continue scanning by
| 	 * just pointing yyin at a new input file.
| 	 */
| #define YY_BUFFER_EOF_PENDING 2
| 
| 	};
| #endif /* !YY_STRUCT_YY_BUFFER_STATE */
| 
| /* Stack of input buffers. */
| static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
| static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
| static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
| 
| /* We provide macros for accessing buffer states in case in the
|  * future we want to put the buffer states in a more general
|  * "scanner state".
|  *
|  * Returns the top of the stack, or NULL.
|  */
| #define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
|                           ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
|                           : NULL)
| 
| /* Same as previous macro, but useful when we know that the buffer stack is not
|  * NULL or when we need an lvalue. For internal use only.
|  */
| #define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
| 
| /* yy_hold_char holds the character lost when yytext is formed. */
| static char yy_hold_char;
| static yy_size_t yy_n_chars;		/* number of characters read into yy_ch_buf */
| yy_size_t yyleng;
| 
| /* Points to current character in buffer. */
| static char *yy_c_buf_p = (char *) 0;
| static int yy_init = 0;		/* whether we need to initialize */
| static int yy_start = 0;	/* start state number */
| 
| /* Flag which is used to allow yywrap()'s to do buffer switches
|  * instead of setting up a fresh yyin.  A bit of a hack ...
|  */
| static int yy_did_buffer_switch_on_eof;
| 
| void yyrestart (FILE *input_file  );
| void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
| YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
| void yy_delete_buffer (YY_BUFFER_STATE b  );
| void yy_flush_buffer (YY_BUFFER_STATE b  );
| void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
| void yypop_buffer_state (void );
| 
| static void yyensure_buffer_stack (void );
| static void yy_load_buffer_state (void );
| static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
| 
| #define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
| 
| YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
| YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
| YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,yy_size_t len  );
| 
| void *yyalloc (yy_size_t  );
| void *yyrealloc (void *,yy_size_t  );
| void yyfree (void *  );
| 
| #define yy_new_buffer yy_create_buffer
| 
| #define yy_set_interactive(is_interactive) \
| 	{ \
| 	if ( ! YY_CURRENT_BUFFER ){ \
|         yyensure_buffer_stack (); \
| 		YY_CURRENT_BUFFER_LVALUE =    \
|             yy_create_buffer(yyin,YY_BUF_SIZE ); \
| 	} \
| 	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
| 	}
| 
| #define yy_set_bol(at_bol) \
| 	{ \
| 	if ( ! YY_CURRENT_BUFFER ){\
|         yyensure_buffer_stack (); \
| 		YY_CURRENT_BUFFER_LVALUE =    \
|             yy_create_buffer(yyin,YY_BUF_SIZE ); \
| 	} \
| 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
| 	}
| 
| #define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
| 
| /* Begin user sect3 */
| 
| typedef unsigned char YY_CHAR;
| 
| FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
| 
| typedef int yy_state_type;
| 
| extern int yylineno;
| 
| int yylineno = 1;
| 
| extern char *yytext;
| #define yytext_ptr yytext
| 
| static yy_state_type yy_get_previous_state (void );
| static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
| static int yy_get_next_buffer (void );
| static void yy_fatal_error (yyconst char msg[]  );
| 
| /* Done after the current pattern has been matched and before the
|  * corresponding action - sets up yytext.
|  */
| #define YY_DO_BEFORE_ACTION \
| 	(yytext_ptr) = yy_bp; \
| 	(yytext_ptr) -= (yy_more_len); \
| 	yyleng = (size_t) (yy_cp - (yytext_ptr)); \
| 	(yy_hold_char) = *yy_cp; \
| 	*yy_cp = '\0'; \
| 	(yy_c_buf_p) = yy_cp;
| 
| #define YY_NUM_RULES 8
| #define YY_END_OF_BUFFER 9
| /* This struct is not used in this scanner,
|    but its presence is necessary. */
| struct yy_trans_info
| 	{
| 	flex_int32_t yy_verify;
| 	flex_int32_t yy_nxt;
| 	};
| static yyconst flex_int16_t yy_acclist[23] =
|     {   0,
|         9,    7,    8,    8,    1,    7,    8,    2,    7,    8,
|         3,    7,    8,    4,    7,    8,    5,    7,    8,    6,
|         7,    8
|     } ;
| 
| static yyconst flex_int16_t yy_accept[14] =
|     {   0,
|         1,    1,    1,    2,    4,    5,    8,   11,   14,   17,
|        20,   23,   23
|     } ;
| 
| static yyconst flex_int32_t yy_ec[256] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    3,    4,    5,    6,
| 
|         7,    8,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| 
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1
|     } ;
| 
| static yyconst flex_int32_t yy_meta[9] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1
|     } ;
| 
| static yyconst flex_int16_t yy_base[13] =
|     {   0,
|         0,    0,    9,   10,   10,   10,   10,   10,   10,   10,
|        10,   10
|     } ;
| 
| static yyconst flex_int16_t yy_def[13] =
|     {   0,
|        12,    1,   12,   12,   12,   12,   12,   12,   12,   12,
|        12,    0
|     } ;
| 
| static yyconst flex_int16_t yy_nxt[19] =
|     {   0,
|         4,    5,    6,    7,    8,    9,   10,   11,   12,    3,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| static yyconst flex_int16_t yy_chk[19] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    3,   12,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| extern int yy_flex_debug;
| int yy_flex_debug = 0;
| 
| static yy_state_type *yy_state_buf=0, *yy_state_ptr=0;
| static char *yy_full_match;
| static int yy_lp;
| #define REJECT \
| { \
| *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */ \
| yy_cp = (yy_full_match); /* restore poss. backed-over text */ \
| ++(yy_lp); \
| goto find_rule; \
| }
| 
| static int yy_more_flag = 0;
| static int yy_more_len = 0;
| #define yymore() ((yy_more_flag) = 1)
| #define YY_MORE_ADJ (yy_more_len)
| #define YY_RESTORE_YY_MORE_OFFSET
| char *yytext;
| #line 1 "conftest.l"
| #line 470 "lex.yy.c"
| 
| #define INITIAL 0
| 
| #ifndef YY_NO_UNISTD_H
| /* Special case for "unistd.h", since it is non-ANSI. We include it way
|  * down here because we want the user's section 1 to have been scanned first.
|  * The user has a chance to override it with an option.
|  */
| #include <unistd.h>
| #endif
| 
| #ifndef YY_EXTRA_TYPE
| #define YY_EXTRA_TYPE void *
| #endif
| 
| static int yy_init_globals (void );
| 
| /* Accessor methods to globals.
|    These are made visible to non-reentrant scanners for convenience. */
| 
| int yylex_destroy (void );
| 
| int yyget_debug (void );
| 
| void yyset_debug (int debug_flag  );
| 
| YY_EXTRA_TYPE yyget_extra (void );
| 
| void yyset_extra (YY_EXTRA_TYPE user_defined  );
| 
| FILE *yyget_in (void );
| 
| void yyset_in  (FILE * in_str  );
| 
| FILE *yyget_out (void );
| 
| void yyset_out  (FILE * out_str  );
| 
| yy_size_t yyget_leng (void );
| 
| char *yyget_text (void );
| 
| int yyget_lineno (void );
| 
| void yyset_lineno (int line_number  );
| 
| /* Macros after this point can all be overridden by user definitions in
|  * section 1.
|  */
| 
| #ifndef YY_SKIP_YYWRAP
| #ifdef __cplusplus
| extern "C" int yywrap (void );
| #else
| extern int yywrap (void );
| #endif
| #endif
| 
|     static void yyunput (int c,char *buf_ptr  );
|     
| #ifndef yytext_ptr
| static void yy_flex_strncpy (char *,yyconst char *,int );
| #endif
| 
| #ifdef YY_NEED_STRLEN
| static int yy_flex_strlen (yyconst char * );
| #endif
| 
| #ifndef YY_NO_INPUT
| 
| #ifdef __cplusplus
| static int yyinput (void );
| #else
| static int input (void );
| #endif
| 
| #endif
| 
| /* Amount of stuff to slurp up with each read. */
| #ifndef YY_READ_BUF_SIZE
| #define YY_READ_BUF_SIZE 8192
| #endif
| 
| /* Copy whatever the last rule matched to the standard output. */
| #ifndef ECHO
| /* This used to be an fputs(), but since the string might contain NUL's,
|  * we now use fwrite().
|  */
| #define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
| #endif
| 
| /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
|  * is returned in "result".
|  */
| #ifndef YY_INPUT
| #define YY_INPUT(buf,result,max_size) \
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
| 		{ \
| 		int c = '*'; \
| 		size_t n; \
| 		for ( n = 0; n < max_size && \
| 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
| 			buf[n] = (char) c; \
| 		if ( c == '\n' ) \
| 			buf[n++] = (char) c; \
| 		if ( c == EOF && ferror( yyin ) ) \
| 			YY_FATAL_ERROR( "input in flex scanner failed" ); \
| 		result = n; \
| 		} \
| 	else \
| 		{ \
| 		errno=0; \
| 		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
| 			{ \
| 			if( errno != EINTR) \
| 				{ \
| 				YY_FATAL_ERROR( "input in flex scanner failed" ); \
| 				break; \
| 				} \
| 			errno=0; \
| 			clearerr(yyin); \
| 			} \
| 		}\
| \
| 
| #endif
| 
| /* No semi-colon after return; correct usage is to write "yyterminate();" -
|  * we don't want an extra ';' after the "return" because that will cause
|  * some compilers to complain about unreachable statements.
|  */
| #ifndef yyterminate
| #define yyterminate() return YY_NULL
| #endif
| 
| /* Number of entries by which start-condition stack grows. */
| #ifndef YY_START_STACK_INCR
| #define YY_START_STACK_INCR 25
| #endif
| 
| /* Report a fatal error. */
| #ifndef YY_FATAL_ERROR
| #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
| #endif
| 
| /* end tables serialization structures and prototypes */
| 
| /* Default declaration of generated scanner - a define so the user can
|  * easily add parameters.
|  */
| #ifndef YY_DECL
| #define YY_DECL_IS_OURS 1
| 
| extern int yylex (void);
| 
| #define YY_DECL int yylex (void)
| #endif /* !YY_DECL */
| 
| /* Code executed at the beginning of each rule, after yytext and yyleng
|  * have been set up.
|  */
| #ifndef YY_USER_ACTION
| #define YY_USER_ACTION
| #endif
| 
| /* Code executed at the end of each rule. */
| #ifndef YY_BREAK
| #define YY_BREAK break;
| #endif
| 
| #define YY_RULE_SETUP \
| 	YY_USER_ACTION
| 
| /** The main scanner function which does all the work.
|  */
| YY_DECL
| {
| 	register yy_state_type yy_current_state;
| 	register char *yy_cp, *yy_bp;
| 	register int yy_act;
|     
| 	if ( !(yy_init) )
| 		{
| 		(yy_init) = 1;
| 
| #ifdef YY_USER_INIT
| 		YY_USER_INIT;
| #endif
| 
|         /* Create the reject buffer large enough to save one state per allowed character. */
|         if ( ! (yy_state_buf) )
|             (yy_state_buf) = (yy_state_type *)yyalloc(YY_STATE_BUF_SIZE  );
|             if ( ! (yy_state_buf) )
|                 YY_FATAL_ERROR( "out of dynamic memory in yylex()" );
| 
| 		if ( ! (yy_start) )
| 			(yy_start) = 1;	/* first start state */
| 
| 		if ( ! yyin )
| 			yyin = stdin;
| 
| 		if ( ! yyout )
| 			yyout = stdout;
| 
| 		if ( ! YY_CURRENT_BUFFER ) {
| 			yyensure_buffer_stack ();
| 			YY_CURRENT_BUFFER_LVALUE =
| 				yy_create_buffer(yyin,YY_BUF_SIZE );
| 		}
| 
| 		yy_load_buffer_state( );
| 		}
| 
| 	{
| #line 1 "conftest.l"
| 
| #line 687 "lex.yy.c"
| 
| 	while ( 1 )		/* loops until end-of-file is reached */
| 		{
| 		(yy_more_len) = 0;
| 		if ( (yy_more_flag) )
| 			{
| 			(yy_more_len) = (yy_c_buf_p) - (yytext_ptr);
| 			(yy_more_flag) = 0;
| 			}
| 		yy_cp = (yy_c_buf_p);
| 
| 		/* Support of yytext. */
| 		*yy_cp = (yy_hold_char);
| 
| 		/* yy_bp points to the position in yy_ch_buf of the start of
| 		 * the current run.
| 		 */
| 		yy_bp = yy_cp;
| 
| 		yy_current_state = (yy_start);
| 
| 		(yy_state_ptr) = (yy_state_buf);
| 		*(yy_state_ptr)++ = yy_current_state;
| 
| yy_match:
| 		do
| 			{
| 			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
| 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 				{
| 				yy_current_state = (int) yy_def[yy_current_state];
| 				if ( yy_current_state >= 13 )
| 					yy_c = yy_meta[(unsigned int) yy_c];
| 				}
| 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 			*(yy_state_ptr)++ = yy_current_state;
| 			++yy_cp;
| 			}
| 		while ( yy_base[yy_current_state] != 10 );
| 
| yy_find_action:
| 		yy_current_state = *--(yy_state_ptr);
| 		(yy_lp) = yy_accept[yy_current_state];
| find_rule: /* we branch to this label when backing up */
| 		for ( ; ; ) /* until we find what rule we matched */
| 			{
| 			if ( (yy_lp) && (yy_lp) < yy_accept[yy_current_state + 1] )
| 				{
| 				yy_act = yy_acclist[(yy_lp)];
| 					{
| 					(yy_full_match) = yy_cp;
| 					break;
| 					}
| 				}
| 			--yy_cp;
| 			yy_current_state = *--(yy_state_ptr);
| 			(yy_lp) = yy_accept[yy_current_state];
| 			}
| 
| 		YY_DO_BEFORE_ACTION;
| 
| do_action:	/* This label is used only to access EOF actions. */
| 
| 		switch ( yy_act )
| 	{ /* beginning of action switch */
| case 1:
| YY_RULE_SETUP
| #line 2 "conftest.l"
| { ECHO; }
| 	YY_BREAK
| case 2:
| YY_RULE_SETUP
| #line 3 "conftest.l"
| { REJECT; }
| 	YY_BREAK
| case 3:
| YY_RULE_SETUP
| #line 4 "conftest.l"
| { yymore (); }
| 	YY_BREAK
| case 4:
| YY_RULE_SETUP
| #line 5 "conftest.l"
| { yyless (1); }
| 	YY_BREAK
| case 5:
| YY_RULE_SETUP
| #line 6 "conftest.l"
| { yyless (input () != 0); }
| 	YY_BREAK
| case 6:
| YY_RULE_SETUP
| #line 7 "conftest.l"
| { unput (yytext[0]); }
| 	YY_BREAK
| case 7:
| YY_RULE_SETUP
| #line 8 "conftest.l"
| { BEGIN INITIAL; }
| 	YY_BREAK
| case 8:
| YY_RULE_SETUP
| #line 9 "conftest.l"
| ECHO;
| 	YY_BREAK
| #line 793 "lex.yy.c"
| 			case YY_STATE_EOF(INITIAL):
| 				yyterminate();
| 
| 	case YY_END_OF_BUFFER:
| 		{
| 		/* Amount of text matched not including the EOB char. */
| 		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
| 
| 		/* Undo the effects of YY_DO_BEFORE_ACTION. */
| 		*yy_cp = (yy_hold_char);
| 		YY_RESTORE_YY_MORE_OFFSET
| 
| 		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
| 			{
| 			/* We're scanning a new file or input source.  It's
| 			 * possible that this happened because the user
| 			 * just pointed yyin at a new source and called
| 			 * yylex().  If so, then we have to assure
| 			 * consistency between YY_CURRENT_BUFFER and our
| 			 * globals.  Here is the right place to do so, because
| 			 * this is the first action (other than possibly a
| 			 * back-up) that will match for the new input source.
| 			 */
| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
| 			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
| 			}
| 
| 		/* Note that here we test for yy_c_buf_p "<=" to the position
| 		 * of the first EOB in the buffer, since yy_c_buf_p will
| 		 * already have been incremented past the NUL character
| 		 * (since all states make transitions on EOB to the
| 		 * end-of-buffer state).  Contrast this with the test
| 		 * in input().
| 		 */
| 		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
| 			{ /* This was really a NUL. */
| 			yy_state_type yy_next_state;
| 
| 			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
| 
| 			yy_current_state = yy_get_previous_state(  );
| 
| 			/* Okay, we're now positioned to make the NUL
| 			 * transition.  We couldn't have
| 			 * yy_get_previous_state() go ahead and do it
| 			 * for us because it doesn't know how to deal
| 			 * with the possibility of jamming (and we don't
| 			 * want to build jamming into it because then it
| 			 * will run more slowly).
| 			 */
| 
| 			yy_next_state = yy_try_NUL_trans( yy_current_state );
| 
| 			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 
| 			if ( yy_next_state )
| 				{
| 				/* Consume the NUL. */
| 				yy_cp = ++(yy_c_buf_p);
| 				yy_current_state = yy_next_state;
| 				goto yy_match;
| 				}
| 
| 			else
| 				{
| 				yy_cp = (yy_c_buf_p);
| 				goto yy_find_action;
| 				}
| 			}
| 
| 		else switch ( yy_get_next_buffer(  ) )
| 			{
| 			case EOB_ACT_END_OF_FILE:
| 				{
| 				(yy_did_buffer_switch_on_eof) = 0;
| 
| 				if ( yywrap( ) )
| 					{
| 					/* Note: because we've taken care in
| 					 * yy_get_next_buffer() to have set up
| 					 * yytext, we can now set up
| 					 * yy_c_buf_p so that if some total
| 					 * hoser (like flex itself) wants to
| 					 * call the scanner after we return the
| 					 * YY_NULL, it'll still work - another
| 					 * YY_NULL will get returned.
| 					 */
| 					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
| 
| 					yy_act = YY_STATE_EOF(YY_START);
| 					goto do_action;
| 					}
| 
| 				else
| 					{
| 					if ( ! (yy_did_buffer_switch_on_eof) )
| 						YY_NEW_FILE;
| 					}
| 				break;
| 				}
| 
| 			case EOB_ACT_CONTINUE_SCAN:
| 				(yy_c_buf_p) =
| 					(yytext_ptr) + yy_amount_of_matched_text;
| 
| 				yy_current_state = yy_get_previous_state(  );
| 
| 				yy_cp = (yy_c_buf_p);
| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 				goto yy_match;
| 
| 			case EOB_ACT_LAST_MATCH:
| 				(yy_c_buf_p) =
| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
| 
| 				yy_current_state = yy_get_previous_state(  );
| 
| 				yy_cp = (yy_c_buf_p);
| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 				goto yy_find_action;
| 			}
| 		break;
| 		}
| 
| 	default:
| 		YY_FATAL_ERROR(
| 			"fatal flex scanner internal error--no action found" );
| 	} /* end of action switch */
| 		} /* end of scanning one token */
| 	} /* end of user's declarations */
| } /* end of yylex */
| 
| /* yy_get_next_buffer - try to read in a new buffer
|  *
|  * Returns a code representing an action:
|  *	EOB_ACT_LAST_MATCH -
|  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
|  *	EOB_ACT_END_OF_FILE - end of file
|  */
| static int yy_get_next_buffer (void)
| {
|     	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
| 	register char *source = (yytext_ptr);
| 	register int number_to_move, i;
| 	int ret_val;
| 
| 	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
| 		YY_FATAL_ERROR(
| 		"fatal flex scanner internal error--end of buffer missed" );
| 
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
| 		{ /* Don't try to fill the buffer, so this is an EOF. */
| 		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
| 			{
| 			/* We matched a single character, the EOB, so
| 			 * treat this as a final EOF.
| 			 */
| 			return EOB_ACT_END_OF_FILE;
| 			}
| 
| 		else
| 			{
| 			/* We matched some text prior to the EOB, first
| 			 * process it.
| 			 */
| 			return EOB_ACT_LAST_MATCH;
| 			}
| 		}
| 
| 	/* Try to read more data. */
| 
| 	/* First move last chars to start of buffer. */
| 	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
| 
| 	for ( i = 0; i < number_to_move; ++i )
| 		*(dest++) = *(source++);
| 
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
| 		/* don't do the read, it's not guaranteed to return an EOF,
| 		 * just force an EOF
| 		 */
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
| 
| 	else
| 		{
| 			yy_size_t num_to_read =
| 			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
| 
| 		while ( num_to_read <= 0 )
| 			{ /* Not enough room in the buffer - grow it. */
| 
| 			YY_FATAL_ERROR(
| "input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
| 
| 			}
| 
| 		if ( num_to_read > YY_READ_BUF_SIZE )
| 			num_to_read = YY_READ_BUF_SIZE;
| 
| 		/* Read in more data. */
| 		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
| 			(yy_n_chars), num_to_read );
| 
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	if ( (yy_n_chars) == 0 )
| 		{
| 		if ( number_to_move == YY_MORE_ADJ )
| 			{
| 			ret_val = EOB_ACT_END_OF_FILE;
| 			yyrestart(yyin  );
| 			}
| 
| 		else
| 			{
| 			ret_val = EOB_ACT_LAST_MATCH;
| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
| 				YY_BUFFER_EOF_PENDING;
| 			}
| 		}
| 
| 	else
| 		ret_val = EOB_ACT_CONTINUE_SCAN;
| 
| 	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
| 		/* Extend the array by 50%, plus the number we really need. */
| 		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
| 		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
| 		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
| 			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
| 	}
| 
| 	(yy_n_chars) += number_to_move;
| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
| 
| 	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
| 
| 	return ret_val;
| }
| 
| /* yy_get_previous_state - get the state just before the EOB char was reached */
| 
|     static yy_state_type yy_get_previous_state (void)
| {
| 	register yy_state_type yy_current_state;
| 	register char *yy_cp;
|     
| 	yy_current_state = (yy_start);
| 
| 	(yy_state_ptr) = (yy_state_buf);
| 	*(yy_state_ptr)++ = yy_current_state;
| 
| 	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
| 		{
| 		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
| 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 			{
| 			yy_current_state = (int) yy_def[yy_current_state];
| 			if ( yy_current_state >= 13 )
| 				yy_c = yy_meta[(unsigned int) yy_c];
| 			}
| 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 		*(yy_state_ptr)++ = yy_current_state;
| 		}
| 
| 	return yy_current_state;
| }
| 
| /* yy_try_NUL_trans - try to make a transition on the NUL character
|  *
|  * synopsis
|  *	next_state = yy_try_NUL_trans( current_state );
|  */
|     static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
| {
| 	register int yy_is_jam;
|     
| 	register YY_CHAR yy_c = 1;
| 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 		{
| 		yy_current_state = (int) yy_def[yy_current_state];
| 		if ( yy_current_state >= 13 )
| 			yy_c = yy_meta[(unsigned int) yy_c];
| 		}
| 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 	yy_is_jam = (yy_current_state == 12);
| 	if ( ! yy_is_jam )
| 		*(yy_state_ptr)++ = yy_current_state;
| 
| 		return yy_is_jam ? 0 : yy_current_state;
| }
| 
|     static void yyunput (int c, register char * yy_bp )
| {
| 	register char *yy_cp;
|     
|     yy_cp = (yy_c_buf_p);
| 
| 	/* undo effects of setting up yytext */
| 	*yy_cp = (yy_hold_char);
| 
| 	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
| 		{ /* need to shift things up to make room */
| 		/* +2 for EOB chars. */
| 		register yy_size_t number_to_move = (yy_n_chars) + 2;
| 		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
| 					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
| 		register char *source =
| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
| 
| 		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
| 			*--dest = *--source;
| 
| 		yy_cp += (int) (dest - source);
| 		yy_bp += (int) (dest - source);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
| 
| 		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
| 			YY_FATAL_ERROR( "flex scanner push-back overflow" );
| 		}
| 
| 	*--yy_cp = (char) c;
| 
| 	(yytext_ptr) = yy_bp;
| 	(yy_hold_char) = *yy_cp;
| 	(yy_c_buf_p) = yy_cp;
| }
| 
| #ifndef YY_NO_INPUT
| #ifdef __cplusplus
|     static int yyinput (void)
| #else
|     static int input  (void)
| #endif
| 
| {
| 	int c;
|     
| 	*(yy_c_buf_p) = (yy_hold_char);
| 
| 	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
| 		{
| 		/* yy_c_buf_p now points to the character we want to return.
| 		 * If this occurs *before* the EOB characters, then it's a
| 		 * valid NUL; if not, then we've hit the end of the buffer.
| 		 */
| 		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
| 			/* This was really a NUL. */
| 			*(yy_c_buf_p) = '\0';
| 
| 		else
| 			{ /* need more input */
| 			yy_size_t offset = (yy_c_buf_p) - (yytext_ptr);
| 			++(yy_c_buf_p);
| 
| 			switch ( yy_get_next_buffer(  ) )
| 				{
| 				case EOB_ACT_LAST_MATCH:
| 					/* This happens because yy_g_n_b()
| 					 * sees that we've accumulated a
| 					 * token and flags that we need to
| 					 * try matching the token before
| 					 * proceeding.  But for input(),
| 					 * there's no matching to consider.
| 					 * So convert the EOB_ACT_LAST_MATCH
| 					 * to EOB_ACT_END_OF_FILE.
| 					 */
| 
| 					/* Reset buffer status. */
| 					yyrestart(yyin );
| 
| 					/*FALLTHROUGH*/
| 
| 				case EOB_ACT_END_OF_FILE:
| 					{
| 					if ( yywrap( ) )
| 						return EOF;
| 
| 					if ( ! (yy_did_buffer_switch_on_eof) )
| 						YY_NEW_FILE;
| #ifdef __cplusplus
| 					return yyinput();
| #else
| 					return input();
| #endif
| 					}
| 
| 				case EOB_ACT_CONTINUE_SCAN:
| 					(yy_c_buf_p) = (yytext_ptr) + offset;
| 					break;
| 				}
| 			}
| 		}
| 
| 	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
| 	*(yy_c_buf_p) = '\0';	/* preserve yytext */
| 	(yy_hold_char) = *++(yy_c_buf_p);
| 
| 	return c;
| }
| #endif	/* ifndef YY_NO_INPUT */
| 
| /** Immediately switch to a different input stream.
|  * @param input_file A readable stream.
|  * 
|  * @note This function does not reset the start condition to @c INITIAL .
|  */
|     void yyrestart  (FILE * input_file )
| {
|     
| 	if ( ! YY_CURRENT_BUFFER ){
|         yyensure_buffer_stack ();
| 		YY_CURRENT_BUFFER_LVALUE =
|             yy_create_buffer(yyin,YY_BUF_SIZE );
| 	}
| 
| 	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
| 	yy_load_buffer_state( );
| }
| 
| /** Switch to a different input buffer.
|  * @param new_buffer The new input buffer.
|  * 
|  */
|     void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
| {
|     
| 	/* TODO. We should be able to replace this entire function body
| 	 * with
| 	 *		yypop_buffer_state();
| 	 *		yypush_buffer_state(new_buffer);
|      */
| 	yyensure_buffer_stack ();
| 	if ( YY_CURRENT_BUFFER == new_buffer )
| 		return;
| 
| 	if ( YY_CURRENT_BUFFER )
| 		{
| 		/* Flush out information for old buffer. */
| 		*(yy_c_buf_p) = (yy_hold_char);
| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
| 	yy_load_buffer_state( );
| 
| 	/* We don't actually know whether we did this switch during
| 	 * EOF (yywrap()) processing, but the only time this flag
| 	 * is looked at is after yywrap() is called, so it's safe
| 	 * to go ahead and always set it.
| 	 */
| 	(yy_did_buffer_switch_on_eof) = 1;
| }
| 
| static void yy_load_buffer_state  (void)
| {
|     	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
| 	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
| 	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
| 	(yy_hold_char) = *(yy_c_buf_p);
| }
| 
| /** Allocate and initialize an input buffer state.
|  * @param file A readable stream.
|  * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
|  * 
|  * @return the allocated buffer state.
|  */
|     YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
| {
| 	YY_BUFFER_STATE b;
|     
| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_buf_size = size;
| 
| 	/* yy_ch_buf has to be 2 characters longer than the size given because
| 	 * we need to put in 2 end-of-buffer characters.
| 	 */
| 	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
| 	if ( ! b->yy_ch_buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_is_our_buffer = 1;
| 
| 	yy_init_buffer(b,file );
| 
| 	return b;
| }
| 
| /** Destroy the buffer.
|  * @param b a buffer created with yy_create_buffer()
|  * 
|  */
|     void yy_delete_buffer (YY_BUFFER_STATE  b )
| {
|     
| 	if ( ! b )
| 		return;
| 
| 	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
| 		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
| 
| 	if ( b->yy_is_our_buffer )
| 		yyfree((void *) b->yy_ch_buf  );
| 
| 	yyfree((void *) b  );
| }
| 
| /* Initializes or reinitializes a buffer.
|  * This function is sometimes called more than once on the same buffer,
|  * such as during a yyrestart() or at EOF.
|  */
|     static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
| 
| {
| 	int oerrno = errno;
|     
| 	yy_flush_buffer(b );
| 
| 	b->yy_input_file = file;
| 	b->yy_fill_buffer = 1;
| 
|     /* If b is the current buffer, then yy_init_buffer was _probably_
|      * called from yyrestart() or through yy_get_next_buffer.
|      * In that case, we don't want to reset the lineno or column.
|      */
|     if (b != YY_CURRENT_BUFFER){
|         b->yy_bs_lineno = 1;
|         b->yy_bs_column = 0;
|     }
| 
|         b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
|     
| 	errno = oerrno;
| }
| 
| /** Discard all buffered characters. On the next scan, YY_INPUT will be called.
|  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
|  * 
|  */
|     void yy_flush_buffer (YY_BUFFER_STATE  b )
| {
|     	if ( ! b )
| 		return;
| 
| 	b->yy_n_chars = 0;
| 
| 	/* We always need two end-of-buffer characters.  The first causes
| 	 * a transition to the end-of-buffer state.  The second causes
| 	 * a jam in that state.
| 	 */
| 	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
| 	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b->yy_buf_pos = &b->yy_ch_buf[0];
| 
| 	b->yy_at_bol = 1;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	if ( b == YY_CURRENT_BUFFER )
| 		yy_load_buffer_state( );
| }
| 
| /** Pushes the new state onto the stack. The new state becomes
|  *  the current state. This function will allocate the stack
|  *  if necessary.
|  *  @param new_buffer The new state.
|  *  
|  */
| void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
| {
|     	if (new_buffer == NULL)
| 		return;
| 
| 	yyensure_buffer_stack();
| 
| 	/* This block is copied from yy_switch_to_buffer. */
| 	if ( YY_CURRENT_BUFFER )
| 		{
| 		/* Flush out information for old buffer. */
| 		*(yy_c_buf_p) = (yy_hold_char);
| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	/* Only push if top exists. Otherwise, replace top. */
| 	if (YY_CURRENT_BUFFER)
| 		(yy_buffer_stack_top)++;
| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
| 
| 	/* copied from yy_switch_to_buffer. */
| 	yy_load_buffer_state( );
| 	(yy_did_buffer_switch_on_eof) = 1;
| }
| 
| /** Removes and deletes the top of the stack, if present.
|  *  The next element becomes the new top.
|  *  
|  */
| void yypop_buffer_state (void)
| {
|     	if (!YY_CURRENT_BUFFER)
| 		return;
| 
| 	yy_delete_buffer(YY_CURRENT_BUFFER );
| 	YY_CURRENT_BUFFER_LVALUE = NULL;
| 	if ((yy_buffer_stack_top) > 0)
| 		--(yy_buffer_stack_top);
| 
| 	if (YY_CURRENT_BUFFER) {
| 		yy_load_buffer_state( );
| 		(yy_did_buffer_switch_on_eof) = 1;
| 	}
| }
| 
| /* Allocates the stack if it does not exist.
|  *  Guarantees space for at least one push.
|  */
| static void yyensure_buffer_stack (void)
| {
| 	yy_size_t num_to_alloc;
|     
| 	if (!(yy_buffer_stack)) {
| 
| 		/* First allocation is just for 2 elements, since we don't know if this
| 		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
| 		 * immediate realloc on the next call.
|          */
| 		num_to_alloc = 1;
| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
| 								(num_to_alloc * sizeof(struct yy_buffer_state*)
| 								);
| 		if ( ! (yy_buffer_stack) )
| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
| 								  
| 		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
| 				
| 		(yy_buffer_stack_max) = num_to_alloc;
| 		(yy_buffer_stack_top) = 0;
| 		return;
| 	}
| 
| 	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
| 
| 		/* Increase the buffer to prepare for a possible push. */
| 		int grow_size = 8 /* arbitrary grow size */;
| 
| 		num_to_alloc = (yy_buffer_stack_max) + grow_size;
| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
| 								((yy_buffer_stack),
| 								num_to_alloc * sizeof(struct yy_buffer_state*)
| 								);
| 		if ( ! (yy_buffer_stack) )
| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
| 
| 		/* zero only the new slots.*/
| 		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
| 		(yy_buffer_stack_max) = num_to_alloc;
| 	}
| }
| 
| /** Setup the input buffer state to scan directly from a user-specified character buffer.
|  * @param base the character buffer
|  * @param size the size in bytes of the character buffer
|  * 
|  * @return the newly allocated buffer state object. 
|  */
| YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
| {
| 	YY_BUFFER_STATE b;
|     
| 	if ( size < 2 ||
| 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
| 	     base[size-1] != YY_END_OF_BUFFER_CHAR )
| 		/* They forgot to leave room for the EOB's. */
| 		return 0;
| 
| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
| 
| 	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
| 	b->yy_buf_pos = b->yy_ch_buf = base;
| 	b->yy_is_our_buffer = 0;
| 	b->yy_input_file = 0;
| 	b->yy_n_chars = b->yy_buf_size;
| 	b->yy_is_interactive = 0;
| 	b->yy_at_bol = 1;
| 	b->yy_fill_buffer = 0;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	yy_switch_to_buffer(b  );
| 
| 	return b;
| }
| 
| /** Setup the input buffer state to scan a string. The next call to yylex() will
|  * scan from a @e copy of @a str.
|  * @param yystr a NUL-terminated string to scan
|  * 
|  * @return the newly allocated buffer state object.
|  * @note If you want to scan bytes that may contain NUL values, then use
|  *       yy_scan_bytes() instead.
|  */
| YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
| {
|     
| 	return yy_scan_bytes(yystr,strlen(yystr) );
| }
| 
| /** Setup the input buffer state to scan the given bytes. The next call to yylex() will
|  * scan from a @e copy of @a bytes.
|  * @param yybytes the byte buffer to scan
|  * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
|  * 
|  * @return the newly allocated buffer state object.
|  */
| YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len )
| {
| 	YY_BUFFER_STATE b;
| 	char *buf;
| 	yy_size_t n;
| 	yy_size_t i;
|     
| 	/* Get memory for full buffer, including space for trailing EOB's. */
| 	n = _yybytes_len + 2;
| 	buf = (char *) yyalloc(n  );
| 	if ( ! buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
| 
| 	for ( i = 0; i < _yybytes_len; ++i )
| 		buf[i] = yybytes[i];
| 
| 	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b = yy_scan_buffer(buf,n );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
| 
| 	/* It's okay to grow etc. this buffer, and we should throw it
| 	 * away when we're done.
| 	 */
| 	b->yy_is_our_buffer = 1;
| 
| 	return b;
| }
| 
| #ifndef YY_EXIT_FAILURE
| #define YY_EXIT_FAILURE 2
| #endif
| 
| static void yy_fatal_error (yyconst char* msg )
| {
|     	(void) fprintf( stderr, "%s\n", msg );
| 	exit( YY_EXIT_FAILURE );
| }
| 
| /* Redefine yyless() so it works in section 3 code. */
| 
| #undef yyless
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
|         int yyless_macro_arg = (n); \
|         YY_LESS_LINENO(yyless_macro_arg);\
| 		yytext[yyleng] = (yy_hold_char); \
| 		(yy_c_buf_p) = yytext + yyless_macro_arg; \
| 		(yy_hold_char) = *(yy_c_buf_p); \
| 		*(yy_c_buf_p) = '\0'; \
| 		yyleng = yyless_macro_arg; \
| 		} \
| 	while ( 0 )
| 
| /* Accessor  methods (get/set functions) to struct members. */
| 
| /** Get the current line number.
|  * 
|  */
| int yyget_lineno  (void)
| {
|         
|     return yylineno;
| }
| 
| /** Get the input stream.
|  * 
|  */
| FILE *yyget_in  (void)
| {
|         return yyin;
| }
| 
| /** Get the output stream.
|  * 
|  */
| FILE *yyget_out  (void)
| {
|         return yyout;
| }
| 
| /** Get the length of the current token.
|  * 
|  */
| yy_size_t yyget_leng  (void)
| {
|         return yyleng;
| }
| 
| /** Get the current token.
|  * 
|  */
| 
| char *yyget_text  (void)
| {
|         return yytext;
| }
| 
| /** Set the current line number.
|  * @param line_number
|  * 
|  */
| void yyset_lineno (int  line_number )
| {
|     
|     yylineno = line_number;
| }
| 
| /** Set the input stream. This does not discard the current
|  * input buffer.
|  * @param in_str A readable stream.
|  * 
|  * @see yy_switch_to_buffer
|  */
| void yyset_in (FILE *  in_str )
| {
|         yyin = in_str ;
| }
| 
| void yyset_out (FILE *  out_str )
| {
|         yyout = out_str ;
| }
| 
| int yyget_debug  (void)
| {
|         return yy_flex_debug;
| }
| 
| void yyset_debug (int  bdebug )
| {
|         yy_flex_debug = bdebug ;
| }
| 
| static int yy_init_globals (void)
| {
|         /* Initialization is the same as for the non-reentrant scanner.
|      * This function is called from yylex_destroy(), so don't allocate here.
|      */
| 
|     (yy_buffer_stack) = 0;
|     (yy_buffer_stack_top) = 0;
|     (yy_buffer_stack_max) = 0;
|     (yy_c_buf_p) = (char *) 0;
|     (yy_init) = 0;
|     (yy_start) = 0;
| 
|     (yy_state_buf) = 0;
|     (yy_state_ptr) = 0;
|     (yy_full_match) = 0;
|     (yy_lp) = 0;
| 
| /* Defined in main.c */
| #ifdef YY_STDINIT
|     yyin = stdin;
|     yyout = stdout;
| #else
|     yyin = (FILE *) 0;
|     yyout = (FILE *) 0;
| #endif
| 
|     /* For future reference: Set errno on error, since we are called by
|      * yylex_init()
|      */
|     return 0;
| }
| 
| /* yylex_destroy is for both reentrant and non-reentrant scanners. */
| int yylex_destroy  (void)
| {
|     
|     /* Pop the buffer stack, destroying each element. */
| 	while(YY_CURRENT_BUFFER){
| 		yy_delete_buffer(YY_CURRENT_BUFFER  );
| 		YY_CURRENT_BUFFER_LVALUE = NULL;
| 		yypop_buffer_state();
| 	}
| 
| 	/* Destroy the stack itself. */
| 	yyfree((yy_buffer_stack) );
| 	(yy_buffer_stack) = NULL;
| 
|     yyfree ( (yy_state_buf) );
|     (yy_state_buf)  = NULL;
| 
|     /* Reset the globals. This is important in a non-reentrant scanner so the next time
|      * yylex() is called, initialization will occur. */
|     yy_init_globals( );
| 
|     return 0;
| }
| 
| /*
|  * Internal utility routines.
|  */
| 
| #ifndef yytext_ptr
| static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
| {
| 	register int i;
| 	for ( i = 0; i < n; ++i )
| 		s1[i] = s2[i];
| }
| #endif
| 
| #ifdef YY_NEED_STRLEN
| static int yy_flex_strlen (yyconst char * s )
| {
| 	register int n;
| 	for ( n = 0; s[n]; ++n )
| 		;
| 
| 	return n;
| }
| #endif
| 
| void *yyalloc (yy_size_t  size )
| {
| 	return (void *) malloc( size );
| }
| 
| void *yyrealloc  (void * ptr, yy_size_t  size )
| {
| 	/* The cast to (char *) in the following accommodates both
| 	 * implementations that use char* generic pointers, and those
| 	 * that use void* generic pointers.  It works with the latter
| 	 * because both ANSI C and C++ allow castless assignment from
| 	 * any pointer type to void*, and deal with argument conversions
| 	 * as though doing an assignment.
| 	 */
| 	return (void *) realloc( (char *) ptr, size );
| }
| 
| void yyfree (void * ptr )
| {
| 	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
| }
| 
| #define YYTABLES_NAME "yytables"
| 
| #line 9 "conftest.l"
| 
| 
| #ifdef YYTEXT_POINTER
| extern char *yytext;
| #endif
| int
| main (void)
| {
|   return ! yylex () + ! yywrap ();
| }
configure:12905: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c -ll  >&5
/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld: error: cannot find -ll
/tmp/cc4n14ep.o:conftest.c:function yylex: error: undefined reference to 'yywrap'
/tmp/cc4n14ep.o:conftest.c:function input: error: undefined reference to 'yywrap'
/tmp/cc4n14ep.o:conftest.c:function main: error: undefined reference to 'yywrap'
collect2: error: ld returned 1 exit status
configure:12905: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "gas"
| #define PACKAGE_TARNAME "gas"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "gas 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "gas"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define ENABLE_CHECKING 1
| #define DEFAULT_ARCH "i386"
| #define I386COFF 1
| #define EMULATIONS 
| #define DEFAULT_EMULATION ""
| #define TARGET_ALIAS "i686-w64-mingw32"
| #define TARGET_CANONICAL "i686-w64-mingw32"
| #define TARGET_CPU "i686"
| #define TARGET_VENDOR "w64"
| #define TARGET_OS "mingw32"
| /* end confdefs.h.  */
| 
| #line 3 "lex.yy.c"
| 
| #define  YY_INT_ALIGNED short int
| 
| /* A lexical scanner generated by flex */
| 
| #define FLEX_SCANNER
| #define YY_FLEX_MAJOR_VERSION 2
| #define YY_FLEX_MINOR_VERSION 5
| #define YY_FLEX_SUBMINOR_VERSION 39
| #if YY_FLEX_SUBMINOR_VERSION > 0
| #define FLEX_BETA
| #endif
| 
| /* First, we deal with  platform-specific or compiler-specific issues. */
| 
| /* begin standard C headers. */
| #include <stdio.h>
| #include <string.h>
| #include <errno.h>
| #include <stdlib.h>
| 
| /* end standard C headers. */
| 
| /* flex integer type definitions */
| 
| #ifndef FLEXINT_H
| #define FLEXINT_H
| 
| /* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
| 
| #if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
| 
| /* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
|  * if you want the limit (max/min) macros for int types. 
|  */
| #ifndef __STDC_LIMIT_MACROS
| #define __STDC_LIMIT_MACROS 1
| #endif
| 
| #include <inttypes.h>
| typedef int8_t flex_int8_t;
| typedef uint8_t flex_uint8_t;
| typedef int16_t flex_int16_t;
| typedef uint16_t flex_uint16_t;
| typedef int32_t flex_int32_t;
| typedef uint32_t flex_uint32_t;
| #else
| typedef signed char flex_int8_t;
| typedef short int flex_int16_t;
| typedef int flex_int32_t;
| typedef unsigned char flex_uint8_t; 
| typedef unsigned short int flex_uint16_t;
| typedef unsigned int flex_uint32_t;
| 
| /* Limits of integral types. */
| #ifndef INT8_MIN
| #define INT8_MIN               (-128)
| #endif
| #ifndef INT16_MIN
| #define INT16_MIN              (-32767-1)
| #endif
| #ifndef INT32_MIN
| #define INT32_MIN              (-2147483647-1)
| #endif
| #ifndef INT8_MAX
| #define INT8_MAX               (127)
| #endif
| #ifndef INT16_MAX
| #define INT16_MAX              (32767)
| #endif
| #ifndef INT32_MAX
| #define INT32_MAX              (2147483647)
| #endif
| #ifndef UINT8_MAX
| #define UINT8_MAX              (255U)
| #endif
| #ifndef UINT16_MAX
| #define UINT16_MAX             (65535U)
| #endif
| #ifndef UINT32_MAX
| #define UINT32_MAX             (4294967295U)
| #endif
| 
| #endif /* ! C99 */
| 
| #endif /* ! FLEXINT_H */
| 
| #ifdef __cplusplus
| 
| /* The "const" storage-class-modifier is valid. */
| #define YY_USE_CONST
| 
| #else	/* ! __cplusplus */
| 
| /* C99 requires __STDC__ to be defined as 1. */
| #if defined (__STDC__)
| 
| #define YY_USE_CONST
| 
| #endif	/* defined (__STDC__) */
| #endif	/* ! __cplusplus */
| 
| #ifdef YY_USE_CONST
| #define yyconst const
| #else
| #define yyconst
| #endif
| 
| /* Returned upon end-of-file. */
| #define YY_NULL 0
| 
| /* Promotes a possibly negative, possibly signed char to an unsigned
|  * integer for use as an array index.  If the signed char is negative,
|  * we want to instead treat it as an 8-bit unsigned char, hence the
|  * double cast.
|  */
| #define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
| 
| /* Enter a start condition.  This macro really ought to take a parameter,
|  * but we do it the disgusting crufty way forced on us by the ()-less
|  * definition of BEGIN.
|  */
| #define BEGIN (yy_start) = 1 + 2 *
| 
| /* Translate the current start state into a value that can be later handed
|  * to BEGIN to return to the state.  The YYSTATE alias is for lex
|  * compatibility.
|  */
| #define YY_START (((yy_start) - 1) / 2)
| #define YYSTATE YY_START
| 
| /* Action number for EOF rule of a given start state. */
| #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
| 
| /* Special action meaning "start processing a new file". */
| #define YY_NEW_FILE yyrestart(yyin  )
| 
| #define YY_END_OF_BUFFER_CHAR 0
| 
| /* Size of default input buffer. */
| #ifndef YY_BUF_SIZE
| #define YY_BUF_SIZE 16384
| #endif
| 
| /* The state buf must be large enough to hold one state per character in the main buffer.
|  */
| #define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
| 
| #ifndef YY_TYPEDEF_YY_BUFFER_STATE
| #define YY_TYPEDEF_YY_BUFFER_STATE
| typedef struct yy_buffer_state *YY_BUFFER_STATE;
| #endif
| 
| #ifndef YY_TYPEDEF_YY_SIZE_T
| #define YY_TYPEDEF_YY_SIZE_T
| typedef size_t yy_size_t;
| #endif
| 
| extern yy_size_t yyleng;
| 
| extern FILE *yyin, *yyout;
| 
| #define EOB_ACT_CONTINUE_SCAN 0
| #define EOB_ACT_END_OF_FILE 1
| #define EOB_ACT_LAST_MATCH 2
| 
|     #define YY_LESS_LINENO(n)
|     #define YY_LINENO_REWIND_TO(ptr)
|     
| /* Return all but the first "n" matched characters back to the input stream. */
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
|         int yyless_macro_arg = (n); \
|         YY_LESS_LINENO(yyless_macro_arg);\
| 		*yy_cp = (yy_hold_char); \
| 		YY_RESTORE_YY_MORE_OFFSET \
| 		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
| 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
| 		} \
| 	while ( 0 )
| 
| #define unput(c) yyunput( c, (yytext_ptr)  )
| 
| #ifndef YY_STRUCT_YY_BUFFER_STATE
| #define YY_STRUCT_YY_BUFFER_STATE
| struct yy_buffer_state
| 	{
| 	FILE *yy_input_file;
| 
| 	char *yy_ch_buf;		/* input buffer */
| 	char *yy_buf_pos;		/* current position in input buffer */
| 
| 	/* Size of input buffer in bytes, not including room for EOB
| 	 * characters.
| 	 */
| 	yy_size_t yy_buf_size;
| 
| 	/* Number of characters read into yy_ch_buf, not including EOB
| 	 * characters.
| 	 */
| 	yy_size_t yy_n_chars;
| 
| 	/* Whether we "own" the buffer - i.e., we know we created it,
| 	 * and can realloc() it to grow it, and should free() it to
| 	 * delete it.
| 	 */
| 	int yy_is_our_buffer;
| 
| 	/* Whether this is an "interactive" input source; if so, and
| 	 * if we're using stdio for input, then we want to use getc()
| 	 * instead of fread(), to make sure we stop fetching input after
| 	 * each newline.
| 	 */
| 	int yy_is_interactive;
| 
| 	/* Whether we're considered to be at the beginning of a line.
| 	 * If so, '^' rules will be active on the next match, otherwise
| 	 * not.
| 	 */
| 	int yy_at_bol;
| 
|     int yy_bs_lineno; /**< The line count. */
|     int yy_bs_column; /**< The column count. */
|     
| 	/* Whether to try to fill the input buffer when we reach the
| 	 * end of it.
| 	 */
| 	int yy_fill_buffer;
| 
| 	int yy_buffer_status;
| 
| #define YY_BUFFER_NEW 0
| #define YY_BUFFER_NORMAL 1
| 	/* When an EOF's been seen but there's still some text to process
| 	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
| 	 * shouldn't try reading from the input source any more.  We might
| 	 * still have a bunch of tokens to match, though, because of
| 	 * possible backing-up.
| 	 *
| 	 * When we actually see the EOF, we change the status to "new"
| 	 * (via yyrestart()), so that the user can continue scanning by
| 	 * just pointing yyin at a new input file.
| 	 */
| #define YY_BUFFER_EOF_PENDING 2
| 
| 	};
| #endif /* !YY_STRUCT_YY_BUFFER_STATE */
| 
| /* Stack of input buffers. */
| static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
| static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
| static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
| 
| /* We provide macros for accessing buffer states in case in the
|  * future we want to put the buffer states in a more general
|  * "scanner state".
|  *
|  * Returns the top of the stack, or NULL.
|  */
| #define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
|                           ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
|                           : NULL)
| 
| /* Same as previous macro, but useful when we know that the buffer stack is not
|  * NULL or when we need an lvalue. For internal use only.
|  */
| #define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
| 
| /* yy_hold_char holds the character lost when yytext is formed. */
| static char yy_hold_char;
| static yy_size_t yy_n_chars;		/* number of characters read into yy_ch_buf */
| yy_size_t yyleng;
| 
| /* Points to current character in buffer. */
| static char *yy_c_buf_p = (char *) 0;
| static int yy_init = 0;		/* whether we need to initialize */
| static int yy_start = 0;	/* start state number */
| 
| /* Flag which is used to allow yywrap()'s to do buffer switches
|  * instead of setting up a fresh yyin.  A bit of a hack ...
|  */
| static int yy_did_buffer_switch_on_eof;
| 
| void yyrestart (FILE *input_file  );
| void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
| YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
| void yy_delete_buffer (YY_BUFFER_STATE b  );
| void yy_flush_buffer (YY_BUFFER_STATE b  );
| void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
| void yypop_buffer_state (void );
| 
| static void yyensure_buffer_stack (void );
| static void yy_load_buffer_state (void );
| static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
| 
| #define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
| 
| YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
| YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
| YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,yy_size_t len  );
| 
| void *yyalloc (yy_size_t  );
| void *yyrealloc (void *,yy_size_t  );
| void yyfree (void *  );
| 
| #define yy_new_buffer yy_create_buffer
| 
| #define yy_set_interactive(is_interactive) \
| 	{ \
| 	if ( ! YY_CURRENT_BUFFER ){ \
|         yyensure_buffer_stack (); \
| 		YY_CURRENT_BUFFER_LVALUE =    \
|             yy_create_buffer(yyin,YY_BUF_SIZE ); \
| 	} \
| 	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
| 	}
| 
| #define yy_set_bol(at_bol) \
| 	{ \
| 	if ( ! YY_CURRENT_BUFFER ){\
|         yyensure_buffer_stack (); \
| 		YY_CURRENT_BUFFER_LVALUE =    \
|             yy_create_buffer(yyin,YY_BUF_SIZE ); \
| 	} \
| 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
| 	}
| 
| #define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
| 
| /* Begin user sect3 */
| 
| typedef unsigned char YY_CHAR;
| 
| FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
| 
| typedef int yy_state_type;
| 
| extern int yylineno;
| 
| int yylineno = 1;
| 
| extern char *yytext;
| #define yytext_ptr yytext
| 
| static yy_state_type yy_get_previous_state (void );
| static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
| static int yy_get_next_buffer (void );
| static void yy_fatal_error (yyconst char msg[]  );
| 
| /* Done after the current pattern has been matched and before the
|  * corresponding action - sets up yytext.
|  */
| #define YY_DO_BEFORE_ACTION \
| 	(yytext_ptr) = yy_bp; \
| 	(yytext_ptr) -= (yy_more_len); \
| 	yyleng = (size_t) (yy_cp - (yytext_ptr)); \
| 	(yy_hold_char) = *yy_cp; \
| 	*yy_cp = '\0'; \
| 	(yy_c_buf_p) = yy_cp;
| 
| #define YY_NUM_RULES 8
| #define YY_END_OF_BUFFER 9
| /* This struct is not used in this scanner,
|    but its presence is necessary. */
| struct yy_trans_info
| 	{
| 	flex_int32_t yy_verify;
| 	flex_int32_t yy_nxt;
| 	};
| static yyconst flex_int16_t yy_acclist[23] =
|     {   0,
|         9,    7,    8,    8,    1,    7,    8,    2,    7,    8,
|         3,    7,    8,    4,    7,    8,    5,    7,    8,    6,
|         7,    8
|     } ;
| 
| static yyconst flex_int16_t yy_accept[14] =
|     {   0,
|         1,    1,    1,    2,    4,    5,    8,   11,   14,   17,
|        20,   23,   23
|     } ;
| 
| static yyconst flex_int32_t yy_ec[256] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    3,    4,    5,    6,
| 
|         7,    8,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| 
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1
|     } ;
| 
| static yyconst flex_int32_t yy_meta[9] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1
|     } ;
| 
| static yyconst flex_int16_t yy_base[13] =
|     {   0,
|         0,    0,    9,   10,   10,   10,   10,   10,   10,   10,
|        10,   10
|     } ;
| 
| static yyconst flex_int16_t yy_def[13] =
|     {   0,
|        12,    1,   12,   12,   12,   12,   12,   12,   12,   12,
|        12,    0
|     } ;
| 
| static yyconst flex_int16_t yy_nxt[19] =
|     {   0,
|         4,    5,    6,    7,    8,    9,   10,   11,   12,    3,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| static yyconst flex_int16_t yy_chk[19] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    3,   12,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| extern int yy_flex_debug;
| int yy_flex_debug = 0;
| 
| static yy_state_type *yy_state_buf=0, *yy_state_ptr=0;
| static char *yy_full_match;
| static int yy_lp;
| #define REJECT \
| { \
| *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */ \
| yy_cp = (yy_full_match); /* restore poss. backed-over text */ \
| ++(yy_lp); \
| goto find_rule; \
| }
| 
| static int yy_more_flag = 0;
| static int yy_more_len = 0;
| #define yymore() ((yy_more_flag) = 1)
| #define YY_MORE_ADJ (yy_more_len)
| #define YY_RESTORE_YY_MORE_OFFSET
| char *yytext;
| #line 1 "conftest.l"
| #line 470 "lex.yy.c"
| 
| #define INITIAL 0
| 
| #ifndef YY_NO_UNISTD_H
| /* Special case for "unistd.h", since it is non-ANSI. We include it way
|  * down here because we want the user's section 1 to have been scanned first.
|  * The user has a chance to override it with an option.
|  */
| #include <unistd.h>
| #endif
| 
| #ifndef YY_EXTRA_TYPE
| #define YY_EXTRA_TYPE void *
| #endif
| 
| static int yy_init_globals (void );
| 
| /* Accessor methods to globals.
|    These are made visible to non-reentrant scanners for convenience. */
| 
| int yylex_destroy (void );
| 
| int yyget_debug (void );
| 
| void yyset_debug (int debug_flag  );
| 
| YY_EXTRA_TYPE yyget_extra (void );
| 
| void yyset_extra (YY_EXTRA_TYPE user_defined  );
| 
| FILE *yyget_in (void );
| 
| void yyset_in  (FILE * in_str  );
| 
| FILE *yyget_out (void );
| 
| void yyset_out  (FILE * out_str  );
| 
| yy_size_t yyget_leng (void );
| 
| char *yyget_text (void );
| 
| int yyget_lineno (void );
| 
| void yyset_lineno (int line_number  );
| 
| /* Macros after this point can all be overridden by user definitions in
|  * section 1.
|  */
| 
| #ifndef YY_SKIP_YYWRAP
| #ifdef __cplusplus
| extern "C" int yywrap (void );
| #else
| extern int yywrap (void );
| #endif
| #endif
| 
|     static void yyunput (int c,char *buf_ptr  );
|     
| #ifndef yytext_ptr
| static void yy_flex_strncpy (char *,yyconst char *,int );
| #endif
| 
| #ifdef YY_NEED_STRLEN
| static int yy_flex_strlen (yyconst char * );
| #endif
| 
| #ifndef YY_NO_INPUT
| 
| #ifdef __cplusplus
| static int yyinput (void );
| #else
| static int input (void );
| #endif
| 
| #endif
| 
| /* Amount of stuff to slurp up with each read. */
| #ifndef YY_READ_BUF_SIZE
| #define YY_READ_BUF_SIZE 8192
| #endif
| 
| /* Copy whatever the last rule matched to the standard output. */
| #ifndef ECHO
| /* This used to be an fputs(), but since the string might contain NUL's,
|  * we now use fwrite().
|  */
| #define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
| #endif
| 
| /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
|  * is returned in "result".
|  */
| #ifndef YY_INPUT
| #define YY_INPUT(buf,result,max_size) \
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
| 		{ \
| 		int c = '*'; \
| 		size_t n; \
| 		for ( n = 0; n < max_size && \
| 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
| 			buf[n] = (char) c; \
| 		if ( c == '\n' ) \
| 			buf[n++] = (char) c; \
| 		if ( c == EOF && ferror( yyin ) ) \
| 			YY_FATAL_ERROR( "input in flex scanner failed" ); \
| 		result = n; \
| 		} \
| 	else \
| 		{ \
| 		errno=0; \
| 		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
| 			{ \
| 			if( errno != EINTR) \
| 				{ \
| 				YY_FATAL_ERROR( "input in flex scanner failed" ); \
| 				break; \
| 				} \
| 			errno=0; \
| 			clearerr(yyin); \
| 			} \
| 		}\
| \
| 
| #endif
| 
| /* No semi-colon after return; correct usage is to write "yyterminate();" -
|  * we don't want an extra ';' after the "return" because that will cause
|  * some compilers to complain about unreachable statements.
|  */
| #ifndef yyterminate
| #define yyterminate() return YY_NULL
| #endif
| 
| /* Number of entries by which start-condition stack grows. */
| #ifndef YY_START_STACK_INCR
| #define YY_START_STACK_INCR 25
| #endif
| 
| /* Report a fatal error. */
| #ifndef YY_FATAL_ERROR
| #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
| #endif
| 
| /* end tables serialization structures and prototypes */
| 
| /* Default declaration of generated scanner - a define so the user can
|  * easily add parameters.
|  */
| #ifndef YY_DECL
| #define YY_DECL_IS_OURS 1
| 
| extern int yylex (void);
| 
| #define YY_DECL int yylex (void)
| #endif /* !YY_DECL */
| 
| /* Code executed at the beginning of each rule, after yytext and yyleng
|  * have been set up.
|  */
| #ifndef YY_USER_ACTION
| #define YY_USER_ACTION
| #endif
| 
| /* Code executed at the end of each rule. */
| #ifndef YY_BREAK
| #define YY_BREAK break;
| #endif
| 
| #define YY_RULE_SETUP \
| 	YY_USER_ACTION
| 
| /** The main scanner function which does all the work.
|  */
| YY_DECL
| {
| 	register yy_state_type yy_current_state;
| 	register char *yy_cp, *yy_bp;
| 	register int yy_act;
|     
| 	if ( !(yy_init) )
| 		{
| 		(yy_init) = 1;
| 
| #ifdef YY_USER_INIT
| 		YY_USER_INIT;
| #endif
| 
|         /* Create the reject buffer large enough to save one state per allowed character. */
|         if ( ! (yy_state_buf) )
|             (yy_state_buf) = (yy_state_type *)yyalloc(YY_STATE_BUF_SIZE  );
|             if ( ! (yy_state_buf) )
|                 YY_FATAL_ERROR( "out of dynamic memory in yylex()" );
| 
| 		if ( ! (yy_start) )
| 			(yy_start) = 1;	/* first start state */
| 
| 		if ( ! yyin )
| 			yyin = stdin;
| 
| 		if ( ! yyout )
| 			yyout = stdout;
| 
| 		if ( ! YY_CURRENT_BUFFER ) {
| 			yyensure_buffer_stack ();
| 			YY_CURRENT_BUFFER_LVALUE =
| 				yy_create_buffer(yyin,YY_BUF_SIZE );
| 		}
| 
| 		yy_load_buffer_state( );
| 		}
| 
| 	{
| #line 1 "conftest.l"
| 
| #line 687 "lex.yy.c"
| 
| 	while ( 1 )		/* loops until end-of-file is reached */
| 		{
| 		(yy_more_len) = 0;
| 		if ( (yy_more_flag) )
| 			{
| 			(yy_more_len) = (yy_c_buf_p) - (yytext_ptr);
| 			(yy_more_flag) = 0;
| 			}
| 		yy_cp = (yy_c_buf_p);
| 
| 		/* Support of yytext. */
| 		*yy_cp = (yy_hold_char);
| 
| 		/* yy_bp points to the position in yy_ch_buf of the start of
| 		 * the current run.
| 		 */
| 		yy_bp = yy_cp;
| 
| 		yy_current_state = (yy_start);
| 
| 		(yy_state_ptr) = (yy_state_buf);
| 		*(yy_state_ptr)++ = yy_current_state;
| 
| yy_match:
| 		do
| 			{
| 			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
| 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 				{
| 				yy_current_state = (int) yy_def[yy_current_state];
| 				if ( yy_current_state >= 13 )
| 					yy_c = yy_meta[(unsigned int) yy_c];
| 				}
| 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 			*(yy_state_ptr)++ = yy_current_state;
| 			++yy_cp;
| 			}
| 		while ( yy_base[yy_current_state] != 10 );
| 
| yy_find_action:
| 		yy_current_state = *--(yy_state_ptr);
| 		(yy_lp) = yy_accept[yy_current_state];
| find_rule: /* we branch to this label when backing up */
| 		for ( ; ; ) /* until we find what rule we matched */
| 			{
| 			if ( (yy_lp) && (yy_lp) < yy_accept[yy_current_state + 1] )
| 				{
| 				yy_act = yy_acclist[(yy_lp)];
| 					{
| 					(yy_full_match) = yy_cp;
| 					break;
| 					}
| 				}
| 			--yy_cp;
| 			yy_current_state = *--(yy_state_ptr);
| 			(yy_lp) = yy_accept[yy_current_state];
| 			}
| 
| 		YY_DO_BEFORE_ACTION;
| 
| do_action:	/* This label is used only to access EOF actions. */
| 
| 		switch ( yy_act )
| 	{ /* beginning of action switch */
| case 1:
| YY_RULE_SETUP
| #line 2 "conftest.l"
| { ECHO; }
| 	YY_BREAK
| case 2:
| YY_RULE_SETUP
| #line 3 "conftest.l"
| { REJECT; }
| 	YY_BREAK
| case 3:
| YY_RULE_SETUP
| #line 4 "conftest.l"
| { yymore (); }
| 	YY_BREAK
| case 4:
| YY_RULE_SETUP
| #line 5 "conftest.l"
| { yyless (1); }
| 	YY_BREAK
| case 5:
| YY_RULE_SETUP
| #line 6 "conftest.l"
| { yyless (input () != 0); }
| 	YY_BREAK
| case 6:
| YY_RULE_SETUP
| #line 7 "conftest.l"
| { unput (yytext[0]); }
| 	YY_BREAK
| case 7:
| YY_RULE_SETUP
| #line 8 "conftest.l"
| { BEGIN INITIAL; }
| 	YY_BREAK
| case 8:
| YY_RULE_SETUP
| #line 9 "conftest.l"
| ECHO;
| 	YY_BREAK
| #line 793 "lex.yy.c"
| 			case YY_STATE_EOF(INITIAL):
| 				yyterminate();
| 
| 	case YY_END_OF_BUFFER:
| 		{
| 		/* Amount of text matched not including the EOB char. */
| 		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
| 
| 		/* Undo the effects of YY_DO_BEFORE_ACTION. */
| 		*yy_cp = (yy_hold_char);
| 		YY_RESTORE_YY_MORE_OFFSET
| 
| 		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
| 			{
| 			/* We're scanning a new file or input source.  It's
| 			 * possible that this happened because the user
| 			 * just pointed yyin at a new source and called
| 			 * yylex().  If so, then we have to assure
| 			 * consistency between YY_CURRENT_BUFFER and our
| 			 * globals.  Here is the right place to do so, because
| 			 * this is the first action (other than possibly a
| 			 * back-up) that will match for the new input source.
| 			 */
| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
| 			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
| 			}
| 
| 		/* Note that here we test for yy_c_buf_p "<=" to the position
| 		 * of the first EOB in the buffer, since yy_c_buf_p will
| 		 * already have been incremented past the NUL character
| 		 * (since all states make transitions on EOB to the
| 		 * end-of-buffer state).  Contrast this with the test
| 		 * in input().
| 		 */
| 		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
| 			{ /* This was really a NUL. */
| 			yy_state_type yy_next_state;
| 
| 			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
| 
| 			yy_current_state = yy_get_previous_state(  );
| 
| 			/* Okay, we're now positioned to make the NUL
| 			 * transition.  We couldn't have
| 			 * yy_get_previous_state() go ahead and do it
| 			 * for us because it doesn't know how to deal
| 			 * with the possibility of jamming (and we don't
| 			 * want to build jamming into it because then it
| 			 * will run more slowly).
| 			 */
| 
| 			yy_next_state = yy_try_NUL_trans( yy_current_state );
| 
| 			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 
| 			if ( yy_next_state )
| 				{
| 				/* Consume the NUL. */
| 				yy_cp = ++(yy_c_buf_p);
| 				yy_current_state = yy_next_state;
| 				goto yy_match;
| 				}
| 
| 			else
| 				{
| 				yy_cp = (yy_c_buf_p);
| 				goto yy_find_action;
| 				}
| 			}
| 
| 		else switch ( yy_get_next_buffer(  ) )
| 			{
| 			case EOB_ACT_END_OF_FILE:
| 				{
| 				(yy_did_buffer_switch_on_eof) = 0;
| 
| 				if ( yywrap( ) )
| 					{
| 					/* Note: because we've taken care in
| 					 * yy_get_next_buffer() to have set up
| 					 * yytext, we can now set up
| 					 * yy_c_buf_p so that if some total
| 					 * hoser (like flex itself) wants to
| 					 * call the scanner after we return the
| 					 * YY_NULL, it'll still work - another
| 					 * YY_NULL will get returned.
| 					 */
| 					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
| 
| 					yy_act = YY_STATE_EOF(YY_START);
| 					goto do_action;
| 					}
| 
| 				else
| 					{
| 					if ( ! (yy_did_buffer_switch_on_eof) )
| 						YY_NEW_FILE;
| 					}
| 				break;
| 				}
| 
| 			case EOB_ACT_CONTINUE_SCAN:
| 				(yy_c_buf_p) =
| 					(yytext_ptr) + yy_amount_of_matched_text;
| 
| 				yy_current_state = yy_get_previous_state(  );
| 
| 				yy_cp = (yy_c_buf_p);
| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 				goto yy_match;
| 
| 			case EOB_ACT_LAST_MATCH:
| 				(yy_c_buf_p) =
| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
| 
| 				yy_current_state = yy_get_previous_state(  );
| 
| 				yy_cp = (yy_c_buf_p);
| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 				goto yy_find_action;
| 			}
| 		break;
| 		}
| 
| 	default:
| 		YY_FATAL_ERROR(
| 			"fatal flex scanner internal error--no action found" );
| 	} /* end of action switch */
| 		} /* end of scanning one token */
| 	} /* end of user's declarations */
| } /* end of yylex */
| 
| /* yy_get_next_buffer - try to read in a new buffer
|  *
|  * Returns a code representing an action:
|  *	EOB_ACT_LAST_MATCH -
|  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
|  *	EOB_ACT_END_OF_FILE - end of file
|  */
| static int yy_get_next_buffer (void)
| {
|     	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
| 	register char *source = (yytext_ptr);
| 	register int number_to_move, i;
| 	int ret_val;
| 
| 	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
| 		YY_FATAL_ERROR(
| 		"fatal flex scanner internal error--end of buffer missed" );
| 
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
| 		{ /* Don't try to fill the buffer, so this is an EOF. */
| 		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
| 			{
| 			/* We matched a single character, the EOB, so
| 			 * treat this as a final EOF.
| 			 */
| 			return EOB_ACT_END_OF_FILE;
| 			}
| 
| 		else
| 			{
| 			/* We matched some text prior to the EOB, first
| 			 * process it.
| 			 */
| 			return EOB_ACT_LAST_MATCH;
| 			}
| 		}
| 
| 	/* Try to read more data. */
| 
| 	/* First move last chars to start of buffer. */
| 	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
| 
| 	for ( i = 0; i < number_to_move; ++i )
| 		*(dest++) = *(source++);
| 
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
| 		/* don't do the read, it's not guaranteed to return an EOF,
| 		 * just force an EOF
| 		 */
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
| 
| 	else
| 		{
| 			yy_size_t num_to_read =
| 			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
| 
| 		while ( num_to_read <= 0 )
| 			{ /* Not enough room in the buffer - grow it. */
| 
| 			YY_FATAL_ERROR(
| "input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
| 
| 			}
| 
| 		if ( num_to_read > YY_READ_BUF_SIZE )
| 			num_to_read = YY_READ_BUF_SIZE;
| 
| 		/* Read in more data. */
| 		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
| 			(yy_n_chars), num_to_read );
| 
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	if ( (yy_n_chars) == 0 )
| 		{
| 		if ( number_to_move == YY_MORE_ADJ )
| 			{
| 			ret_val = EOB_ACT_END_OF_FILE;
| 			yyrestart(yyin  );
| 			}
| 
| 		else
| 			{
| 			ret_val = EOB_ACT_LAST_MATCH;
| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
| 				YY_BUFFER_EOF_PENDING;
| 			}
| 		}
| 
| 	else
| 		ret_val = EOB_ACT_CONTINUE_SCAN;
| 
| 	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
| 		/* Extend the array by 50%, plus the number we really need. */
| 		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
| 		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
| 		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
| 			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
| 	}
| 
| 	(yy_n_chars) += number_to_move;
| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
| 
| 	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
| 
| 	return ret_val;
| }
| 
| /* yy_get_previous_state - get the state just before the EOB char was reached */
| 
|     static yy_state_type yy_get_previous_state (void)
| {
| 	register yy_state_type yy_current_state;
| 	register char *yy_cp;
|     
| 	yy_current_state = (yy_start);
| 
| 	(yy_state_ptr) = (yy_state_buf);
| 	*(yy_state_ptr)++ = yy_current_state;
| 
| 	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
| 		{
| 		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
| 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 			{
| 			yy_current_state = (int) yy_def[yy_current_state];
| 			if ( yy_current_state >= 13 )
| 				yy_c = yy_meta[(unsigned int) yy_c];
| 			}
| 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 		*(yy_state_ptr)++ = yy_current_state;
| 		}
| 
| 	return yy_current_state;
| }
| 
| /* yy_try_NUL_trans - try to make a transition on the NUL character
|  *
|  * synopsis
|  *	next_state = yy_try_NUL_trans( current_state );
|  */
|     static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
| {
| 	register int yy_is_jam;
|     
| 	register YY_CHAR yy_c = 1;
| 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 		{
| 		yy_current_state = (int) yy_def[yy_current_state];
| 		if ( yy_current_state >= 13 )
| 			yy_c = yy_meta[(unsigned int) yy_c];
| 		}
| 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 	yy_is_jam = (yy_current_state == 12);
| 	if ( ! yy_is_jam )
| 		*(yy_state_ptr)++ = yy_current_state;
| 
| 		return yy_is_jam ? 0 : yy_current_state;
| }
| 
|     static void yyunput (int c, register char * yy_bp )
| {
| 	register char *yy_cp;
|     
|     yy_cp = (yy_c_buf_p);
| 
| 	/* undo effects of setting up yytext */
| 	*yy_cp = (yy_hold_char);
| 
| 	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
| 		{ /* need to shift things up to make room */
| 		/* +2 for EOB chars. */
| 		register yy_size_t number_to_move = (yy_n_chars) + 2;
| 		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
| 					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
| 		register char *source =
| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
| 
| 		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
| 			*--dest = *--source;
| 
| 		yy_cp += (int) (dest - source);
| 		yy_bp += (int) (dest - source);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
| 
| 		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
| 			YY_FATAL_ERROR( "flex scanner push-back overflow" );
| 		}
| 
| 	*--yy_cp = (char) c;
| 
| 	(yytext_ptr) = yy_bp;
| 	(yy_hold_char) = *yy_cp;
| 	(yy_c_buf_p) = yy_cp;
| }
| 
| #ifndef YY_NO_INPUT
| #ifdef __cplusplus
|     static int yyinput (void)
| #else
|     static int input  (void)
| #endif
| 
| {
| 	int c;
|     
| 	*(yy_c_buf_p) = (yy_hold_char);
| 
| 	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
| 		{
| 		/* yy_c_buf_p now points to the character we want to return.
| 		 * If this occurs *before* the EOB characters, then it's a
| 		 * valid NUL; if not, then we've hit the end of the buffer.
| 		 */
| 		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
| 			/* This was really a NUL. */
| 			*(yy_c_buf_p) = '\0';
| 
| 		else
| 			{ /* need more input */
| 			yy_size_t offset = (yy_c_buf_p) - (yytext_ptr);
| 			++(yy_c_buf_p);
| 
| 			switch ( yy_get_next_buffer(  ) )
| 				{
| 				case EOB_ACT_LAST_MATCH:
| 					/* This happens because yy_g_n_b()
| 					 * sees that we've accumulated a
| 					 * token and flags that we need to
| 					 * try matching the token before
| 					 * proceeding.  But for input(),
| 					 * there's no matching to consider.
| 					 * So convert the EOB_ACT_LAST_MATCH
| 					 * to EOB_ACT_END_OF_FILE.
| 					 */
| 
| 					/* Reset buffer status. */
| 					yyrestart(yyin );
| 
| 					/*FALLTHROUGH*/
| 
| 				case EOB_ACT_END_OF_FILE:
| 					{
| 					if ( yywrap( ) )
| 						return EOF;
| 
| 					if ( ! (yy_did_buffer_switch_on_eof) )
| 						YY_NEW_FILE;
| #ifdef __cplusplus
| 					return yyinput();
| #else
| 					return input();
| #endif
| 					}
| 
| 				case EOB_ACT_CONTINUE_SCAN:
| 					(yy_c_buf_p) = (yytext_ptr) + offset;
| 					break;
| 				}
| 			}
| 		}
| 
| 	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
| 	*(yy_c_buf_p) = '\0';	/* preserve yytext */
| 	(yy_hold_char) = *++(yy_c_buf_p);
| 
| 	return c;
| }
| #endif	/* ifndef YY_NO_INPUT */
| 
| /** Immediately switch to a different input stream.
|  * @param input_file A readable stream.
|  * 
|  * @note This function does not reset the start condition to @c INITIAL .
|  */
|     void yyrestart  (FILE * input_file )
| {
|     
| 	if ( ! YY_CURRENT_BUFFER ){
|         yyensure_buffer_stack ();
| 		YY_CURRENT_BUFFER_LVALUE =
|             yy_create_buffer(yyin,YY_BUF_SIZE );
| 	}
| 
| 	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
| 	yy_load_buffer_state( );
| }
| 
| /** Switch to a different input buffer.
|  * @param new_buffer The new input buffer.
|  * 
|  */
|     void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
| {
|     
| 	/* TODO. We should be able to replace this entire function body
| 	 * with
| 	 *		yypop_buffer_state();
| 	 *		yypush_buffer_state(new_buffer);
|      */
| 	yyensure_buffer_stack ();
| 	if ( YY_CURRENT_BUFFER == new_buffer )
| 		return;
| 
| 	if ( YY_CURRENT_BUFFER )
| 		{
| 		/* Flush out information for old buffer. */
| 		*(yy_c_buf_p) = (yy_hold_char);
| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
| 	yy_load_buffer_state( );
| 
| 	/* We don't actually know whether we did this switch during
| 	 * EOF (yywrap()) processing, but the only time this flag
| 	 * is looked at is after yywrap() is called, so it's safe
| 	 * to go ahead and always set it.
| 	 */
| 	(yy_did_buffer_switch_on_eof) = 1;
| }
| 
| static void yy_load_buffer_state  (void)
| {
|     	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
| 	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
| 	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
| 	(yy_hold_char) = *(yy_c_buf_p);
| }
| 
| /** Allocate and initialize an input buffer state.
|  * @param file A readable stream.
|  * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
|  * 
|  * @return the allocated buffer state.
|  */
|     YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
| {
| 	YY_BUFFER_STATE b;
|     
| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_buf_size = size;
| 
| 	/* yy_ch_buf has to be 2 characters longer than the size given because
| 	 * we need to put in 2 end-of-buffer characters.
| 	 */
| 	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
| 	if ( ! b->yy_ch_buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_is_our_buffer = 1;
| 
| 	yy_init_buffer(b,file );
| 
| 	return b;
| }
| 
| /** Destroy the buffer.
|  * @param b a buffer created with yy_create_buffer()
|  * 
|  */
|     void yy_delete_buffer (YY_BUFFER_STATE  b )
| {
|     
| 	if ( ! b )
| 		return;
| 
| 	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
| 		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
| 
| 	if ( b->yy_is_our_buffer )
| 		yyfree((void *) b->yy_ch_buf  );
| 
| 	yyfree((void *) b  );
| }
| 
| /* Initializes or reinitializes a buffer.
|  * This function is sometimes called more than once on the same buffer,
|  * such as during a yyrestart() or at EOF.
|  */
|     static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
| 
| {
| 	int oerrno = errno;
|     
| 	yy_flush_buffer(b );
| 
| 	b->yy_input_file = file;
| 	b->yy_fill_buffer = 1;
| 
|     /* If b is the current buffer, then yy_init_buffer was _probably_
|      * called from yyrestart() or through yy_get_next_buffer.
|      * In that case, we don't want to reset the lineno or column.
|      */
|     if (b != YY_CURRENT_BUFFER){
|         b->yy_bs_lineno = 1;
|         b->yy_bs_column = 0;
|     }
| 
|         b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
|     
| 	errno = oerrno;
| }
| 
| /** Discard all buffered characters. On the next scan, YY_INPUT will be called.
|  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
|  * 
|  */
|     void yy_flush_buffer (YY_BUFFER_STATE  b )
| {
|     	if ( ! b )
| 		return;
| 
| 	b->yy_n_chars = 0;
| 
| 	/* We always need two end-of-buffer characters.  The first causes
| 	 * a transition to the end-of-buffer state.  The second causes
| 	 * a jam in that state.
| 	 */
| 	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
| 	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b->yy_buf_pos = &b->yy_ch_buf[0];
| 
| 	b->yy_at_bol = 1;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	if ( b == YY_CURRENT_BUFFER )
| 		yy_load_buffer_state( );
| }
| 
| /** Pushes the new state onto the stack. The new state becomes
|  *  the current state. This function will allocate the stack
|  *  if necessary.
|  *  @param new_buffer The new state.
|  *  
|  */
| void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
| {
|     	if (new_buffer == NULL)
| 		return;
| 
| 	yyensure_buffer_stack();
| 
| 	/* This block is copied from yy_switch_to_buffer. */
| 	if ( YY_CURRENT_BUFFER )
| 		{
| 		/* Flush out information for old buffer. */
| 		*(yy_c_buf_p) = (yy_hold_char);
| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	/* Only push if top exists. Otherwise, replace top. */
| 	if (YY_CURRENT_BUFFER)
| 		(yy_buffer_stack_top)++;
| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
| 
| 	/* copied from yy_switch_to_buffer. */
| 	yy_load_buffer_state( );
| 	(yy_did_buffer_switch_on_eof) = 1;
| }
| 
| /** Removes and deletes the top of the stack, if present.
|  *  The next element becomes the new top.
|  *  
|  */
| void yypop_buffer_state (void)
| {
|     	if (!YY_CURRENT_BUFFER)
| 		return;
| 
| 	yy_delete_buffer(YY_CURRENT_BUFFER );
| 	YY_CURRENT_BUFFER_LVALUE = NULL;
| 	if ((yy_buffer_stack_top) > 0)
| 		--(yy_buffer_stack_top);
| 
| 	if (YY_CURRENT_BUFFER) {
| 		yy_load_buffer_state( );
| 		(yy_did_buffer_switch_on_eof) = 1;
| 	}
| }
| 
| /* Allocates the stack if it does not exist.
|  *  Guarantees space for at least one push.
|  */
| static void yyensure_buffer_stack (void)
| {
| 	yy_size_t num_to_alloc;
|     
| 	if (!(yy_buffer_stack)) {
| 
| 		/* First allocation is just for 2 elements, since we don't know if this
| 		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
| 		 * immediate realloc on the next call.
|          */
| 		num_to_alloc = 1;
| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
| 								(num_to_alloc * sizeof(struct yy_buffer_state*)
| 								);
| 		if ( ! (yy_buffer_stack) )
| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
| 								  
| 		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
| 				
| 		(yy_buffer_stack_max) = num_to_alloc;
| 		(yy_buffer_stack_top) = 0;
| 		return;
| 	}
| 
| 	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
| 
| 		/* Increase the buffer to prepare for a possible push. */
| 		int grow_size = 8 /* arbitrary grow size */;
| 
| 		num_to_alloc = (yy_buffer_stack_max) + grow_size;
| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
| 								((yy_buffer_stack),
| 								num_to_alloc * sizeof(struct yy_buffer_state*)
| 								);
| 		if ( ! (yy_buffer_stack) )
| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
| 
| 		/* zero only the new slots.*/
| 		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
| 		(yy_buffer_stack_max) = num_to_alloc;
| 	}
| }
| 
| /** Setup the input buffer state to scan directly from a user-specified character buffer.
|  * @param base the character buffer
|  * @param size the size in bytes of the character buffer
|  * 
|  * @return the newly allocated buffer state object. 
|  */
| YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
| {
| 	YY_BUFFER_STATE b;
|     
| 	if ( size < 2 ||
| 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
| 	     base[size-1] != YY_END_OF_BUFFER_CHAR )
| 		/* They forgot to leave room for the EOB's. */
| 		return 0;
| 
| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
| 
| 	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
| 	b->yy_buf_pos = b->yy_ch_buf = base;
| 	b->yy_is_our_buffer = 0;
| 	b->yy_input_file = 0;
| 	b->yy_n_chars = b->yy_buf_size;
| 	b->yy_is_interactive = 0;
| 	b->yy_at_bol = 1;
| 	b->yy_fill_buffer = 0;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	yy_switch_to_buffer(b  );
| 
| 	return b;
| }
| 
| /** Setup the input buffer state to scan a string. The next call to yylex() will
|  * scan from a @e copy of @a str.
|  * @param yystr a NUL-terminated string to scan
|  * 
|  * @return the newly allocated buffer state object.
|  * @note If you want to scan bytes that may contain NUL values, then use
|  *       yy_scan_bytes() instead.
|  */
| YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
| {
|     
| 	return yy_scan_bytes(yystr,strlen(yystr) );
| }
| 
| /** Setup the input buffer state to scan the given bytes. The next call to yylex() will
|  * scan from a @e copy of @a bytes.
|  * @param yybytes the byte buffer to scan
|  * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
|  * 
|  * @return the newly allocated buffer state object.
|  */
| YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len )
| {
| 	YY_BUFFER_STATE b;
| 	char *buf;
| 	yy_size_t n;
| 	yy_size_t i;
|     
| 	/* Get memory for full buffer, including space for trailing EOB's. */
| 	n = _yybytes_len + 2;
| 	buf = (char *) yyalloc(n  );
| 	if ( ! buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
| 
| 	for ( i = 0; i < _yybytes_len; ++i )
| 		buf[i] = yybytes[i];
| 
| 	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b = yy_scan_buffer(buf,n );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
| 
| 	/* It's okay to grow etc. this buffer, and we should throw it
| 	 * away when we're done.
| 	 */
| 	b->yy_is_our_buffer = 1;
| 
| 	return b;
| }
| 
| #ifndef YY_EXIT_FAILURE
| #define YY_EXIT_FAILURE 2
| #endif
| 
| static void yy_fatal_error (yyconst char* msg )
| {
|     	(void) fprintf( stderr, "%s\n", msg );
| 	exit( YY_EXIT_FAILURE );
| }
| 
| /* Redefine yyless() so it works in section 3 code. */
| 
| #undef yyless
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
|         int yyless_macro_arg = (n); \
|         YY_LESS_LINENO(yyless_macro_arg);\
| 		yytext[yyleng] = (yy_hold_char); \
| 		(yy_c_buf_p) = yytext + yyless_macro_arg; \
| 		(yy_hold_char) = *(yy_c_buf_p); \
| 		*(yy_c_buf_p) = '\0'; \
| 		yyleng = yyless_macro_arg; \
| 		} \
| 	while ( 0 )
| 
| /* Accessor  methods (get/set functions) to struct members. */
| 
| /** Get the current line number.
|  * 
|  */
| int yyget_lineno  (void)
| {
|         
|     return yylineno;
| }
| 
| /** Get the input stream.
|  * 
|  */
| FILE *yyget_in  (void)
| {
|         return yyin;
| }
| 
| /** Get the output stream.
|  * 
|  */
| FILE *yyget_out  (void)
| {
|         return yyout;
| }
| 
| /** Get the length of the current token.
|  * 
|  */
| yy_size_t yyget_leng  (void)
| {
|         return yyleng;
| }
| 
| /** Get the current token.
|  * 
|  */
| 
| char *yyget_text  (void)
| {
|         return yytext;
| }
| 
| /** Set the current line number.
|  * @param line_number
|  * 
|  */
| void yyset_lineno (int  line_number )
| {
|     
|     yylineno = line_number;
| }
| 
| /** Set the input stream. This does not discard the current
|  * input buffer.
|  * @param in_str A readable stream.
|  * 
|  * @see yy_switch_to_buffer
|  */
| void yyset_in (FILE *  in_str )
| {
|         yyin = in_str ;
| }
| 
| void yyset_out (FILE *  out_str )
| {
|         yyout = out_str ;
| }
| 
| int yyget_debug  (void)
| {
|         return yy_flex_debug;
| }
| 
| void yyset_debug (int  bdebug )
| {
|         yy_flex_debug = bdebug ;
| }
| 
| static int yy_init_globals (void)
| {
|         /* Initialization is the same as for the non-reentrant scanner.
|      * This function is called from yylex_destroy(), so don't allocate here.
|      */
| 
|     (yy_buffer_stack) = 0;
|     (yy_buffer_stack_top) = 0;
|     (yy_buffer_stack_max) = 0;
|     (yy_c_buf_p) = (char *) 0;
|     (yy_init) = 0;
|     (yy_start) = 0;
| 
|     (yy_state_buf) = 0;
|     (yy_state_ptr) = 0;
|     (yy_full_match) = 0;
|     (yy_lp) = 0;
| 
| /* Defined in main.c */
| #ifdef YY_STDINIT
|     yyin = stdin;
|     yyout = stdout;
| #else
|     yyin = (FILE *) 0;
|     yyout = (FILE *) 0;
| #endif
| 
|     /* For future reference: Set errno on error, since we are called by
|      * yylex_init()
|      */
|     return 0;
| }
| 
| /* yylex_destroy is for both reentrant and non-reentrant scanners. */
| int yylex_destroy  (void)
| {
|     
|     /* Pop the buffer stack, destroying each element. */
| 	while(YY_CURRENT_BUFFER){
| 		yy_delete_buffer(YY_CURRENT_BUFFER  );
| 		YY_CURRENT_BUFFER_LVALUE = NULL;
| 		yypop_buffer_state();
| 	}
| 
| 	/* Destroy the stack itself. */
| 	yyfree((yy_buffer_stack) );
| 	(yy_buffer_stack) = NULL;
| 
|     yyfree ( (yy_state_buf) );
|     (yy_state_buf)  = NULL;
| 
|     /* Reset the globals. This is important in a non-reentrant scanner so the next time
|      * yylex() is called, initialization will occur. */
|     yy_init_globals( );
| 
|     return 0;
| }
| 
| /*
|  * Internal utility routines.
|  */
| 
| #ifndef yytext_ptr
| static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
| {
| 	register int i;
| 	for ( i = 0; i < n; ++i )
| 		s1[i] = s2[i];
| }
| #endif
| 
| #ifdef YY_NEED_STRLEN
| static int yy_flex_strlen (yyconst char * s )
| {
| 	register int n;
| 	for ( n = 0; s[n]; ++n )
| 		;
| 
| 	return n;
| }
| #endif
| 
| void *yyalloc (yy_size_t  size )
| {
| 	return (void *) malloc( size );
| }
| 
| void *yyrealloc  (void * ptr, yy_size_t  size )
| {
| 	/* The cast to (char *) in the following accommodates both
| 	 * implementations that use char* generic pointers, and those
| 	 * that use void* generic pointers.  It works with the latter
| 	 * because both ANSI C and C++ allow castless assignment from
| 	 * any pointer type to void*, and deal with argument conversions
| 	 * as though doing an assignment.
| 	 */
| 	return (void *) realloc( (char *) ptr, size );
| }
| 
| void yyfree (void * ptr )
| {
| 	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
| }
| 
| #define YYTABLES_NAME "yytables"
| 
| #line 9 "conftest.l"
| 
| 
| #ifdef YYTEXT_POINTER
| extern char *yytext;
| #endif
| int
| main (void)
| {
|   return ! yylex () + ! yywrap ();
| }
configure:12915: result: none needed
configure:12921: checking whether yytext is a pointer
configure:12937: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c   >&5
/tmp/ccMi1jTL.o:conftest.c:function yylex: error: undefined reference to 'yywrap'
/tmp/ccMi1jTL.o:conftest.c:function input: error: undefined reference to 'yywrap'
/tmp/ccMi1jTL.o:conftest.c:function main: error: undefined reference to 'yywrap'
collect2: error: ld returned 1 exit status
configure:12937: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "gas"
| #define PACKAGE_TARNAME "gas"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "gas 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "gas"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define ENABLE_CHECKING 1
| #define DEFAULT_ARCH "i386"
| #define I386COFF 1
| #define EMULATIONS 
| #define DEFAULT_EMULATION ""
| #define TARGET_ALIAS "i686-w64-mingw32"
| #define TARGET_CANONICAL "i686-w64-mingw32"
| #define TARGET_CPU "i686"
| #define TARGET_VENDOR "w64"
| #define TARGET_OS "mingw32"
| /* end confdefs.h.  */
| #define YYTEXT_POINTER 1
| 
| #line 3 "lex.yy.c"
| 
| #define  YY_INT_ALIGNED short int
| 
| /* A lexical scanner generated by flex */
| 
| #define FLEX_SCANNER
| #define YY_FLEX_MAJOR_VERSION 2
| #define YY_FLEX_MINOR_VERSION 5
| #define YY_FLEX_SUBMINOR_VERSION 39
| #if YY_FLEX_SUBMINOR_VERSION > 0
| #define FLEX_BETA
| #endif
| 
| /* First, we deal with  platform-specific or compiler-specific issues. */
| 
| /* begin standard C headers. */
| #include <stdio.h>
| #include <string.h>
| #include <errno.h>
| #include <stdlib.h>
| 
| /* end standard C headers. */
| 
| /* flex integer type definitions */
| 
| #ifndef FLEXINT_H
| #define FLEXINT_H
| 
| /* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
| 
| #if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
| 
| /* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
|  * if you want the limit (max/min) macros for int types. 
|  */
| #ifndef __STDC_LIMIT_MACROS
| #define __STDC_LIMIT_MACROS 1
| #endif
| 
| #include <inttypes.h>
| typedef int8_t flex_int8_t;
| typedef uint8_t flex_uint8_t;
| typedef int16_t flex_int16_t;
| typedef uint16_t flex_uint16_t;
| typedef int32_t flex_int32_t;
| typedef uint32_t flex_uint32_t;
| #else
| typedef signed char flex_int8_t;
| typedef short int flex_int16_t;
| typedef int flex_int32_t;
| typedef unsigned char flex_uint8_t; 
| typedef unsigned short int flex_uint16_t;
| typedef unsigned int flex_uint32_t;
| 
| /* Limits of integral types. */
| #ifndef INT8_MIN
| #define INT8_MIN               (-128)
| #endif
| #ifndef INT16_MIN
| #define INT16_MIN              (-32767-1)
| #endif
| #ifndef INT32_MIN
| #define INT32_MIN              (-2147483647-1)
| #endif
| #ifndef INT8_MAX
| #define INT8_MAX               (127)
| #endif
| #ifndef INT16_MAX
| #define INT16_MAX              (32767)
| #endif
| #ifndef INT32_MAX
| #define INT32_MAX              (2147483647)
| #endif
| #ifndef UINT8_MAX
| #define UINT8_MAX              (255U)
| #endif
| #ifndef UINT16_MAX
| #define UINT16_MAX             (65535U)
| #endif
| #ifndef UINT32_MAX
| #define UINT32_MAX             (4294967295U)
| #endif
| 
| #endif /* ! C99 */
| 
| #endif /* ! FLEXINT_H */
| 
| #ifdef __cplusplus
| 
| /* The "const" storage-class-modifier is valid. */
| #define YY_USE_CONST
| 
| #else	/* ! __cplusplus */
| 
| /* C99 requires __STDC__ to be defined as 1. */
| #if defined (__STDC__)
| 
| #define YY_USE_CONST
| 
| #endif	/* defined (__STDC__) */
| #endif	/* ! __cplusplus */
| 
| #ifdef YY_USE_CONST
| #define yyconst const
| #else
| #define yyconst
| #endif
| 
| /* Returned upon end-of-file. */
| #define YY_NULL 0
| 
| /* Promotes a possibly negative, possibly signed char to an unsigned
|  * integer for use as an array index.  If the signed char is negative,
|  * we want to instead treat it as an 8-bit unsigned char, hence the
|  * double cast.
|  */
| #define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
| 
| /* Enter a start condition.  This macro really ought to take a parameter,
|  * but we do it the disgusting crufty way forced on us by the ()-less
|  * definition of BEGIN.
|  */
| #define BEGIN (yy_start) = 1 + 2 *
| 
| /* Translate the current start state into a value that can be later handed
|  * to BEGIN to return to the state.  The YYSTATE alias is for lex
|  * compatibility.
|  */
| #define YY_START (((yy_start) - 1) / 2)
| #define YYSTATE YY_START
| 
| /* Action number for EOF rule of a given start state. */
| #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
| 
| /* Special action meaning "start processing a new file". */
| #define YY_NEW_FILE yyrestart(yyin  )
| 
| #define YY_END_OF_BUFFER_CHAR 0
| 
| /* Size of default input buffer. */
| #ifndef YY_BUF_SIZE
| #define YY_BUF_SIZE 16384
| #endif
| 
| /* The state buf must be large enough to hold one state per character in the main buffer.
|  */
| #define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
| 
| #ifndef YY_TYPEDEF_YY_BUFFER_STATE
| #define YY_TYPEDEF_YY_BUFFER_STATE
| typedef struct yy_buffer_state *YY_BUFFER_STATE;
| #endif
| 
| #ifndef YY_TYPEDEF_YY_SIZE_T
| #define YY_TYPEDEF_YY_SIZE_T
| typedef size_t yy_size_t;
| #endif
| 
| extern yy_size_t yyleng;
| 
| extern FILE *yyin, *yyout;
| 
| #define EOB_ACT_CONTINUE_SCAN 0
| #define EOB_ACT_END_OF_FILE 1
| #define EOB_ACT_LAST_MATCH 2
| 
|     #define YY_LESS_LINENO(n)
|     #define YY_LINENO_REWIND_TO(ptr)
|     
| /* Return all but the first "n" matched characters back to the input stream. */
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
|         int yyless_macro_arg = (n); \
|         YY_LESS_LINENO(yyless_macro_arg);\
| 		*yy_cp = (yy_hold_char); \
| 		YY_RESTORE_YY_MORE_OFFSET \
| 		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
| 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
| 		} \
| 	while ( 0 )
| 
| #define unput(c) yyunput( c, (yytext_ptr)  )
| 
| #ifndef YY_STRUCT_YY_BUFFER_STATE
| #define YY_STRUCT_YY_BUFFER_STATE
| struct yy_buffer_state
| 	{
| 	FILE *yy_input_file;
| 
| 	char *yy_ch_buf;		/* input buffer */
| 	char *yy_buf_pos;		/* current position in input buffer */
| 
| 	/* Size of input buffer in bytes, not including room for EOB
| 	 * characters.
| 	 */
| 	yy_size_t yy_buf_size;
| 
| 	/* Number of characters read into yy_ch_buf, not including EOB
| 	 * characters.
| 	 */
| 	yy_size_t yy_n_chars;
| 
| 	/* Whether we "own" the buffer - i.e., we know we created it,
| 	 * and can realloc() it to grow it, and should free() it to
| 	 * delete it.
| 	 */
| 	int yy_is_our_buffer;
| 
| 	/* Whether this is an "interactive" input source; if so, and
| 	 * if we're using stdio for input, then we want to use getc()
| 	 * instead of fread(), to make sure we stop fetching input after
| 	 * each newline.
| 	 */
| 	int yy_is_interactive;
| 
| 	/* Whether we're considered to be at the beginning of a line.
| 	 * If so, '^' rules will be active on the next match, otherwise
| 	 * not.
| 	 */
| 	int yy_at_bol;
| 
|     int yy_bs_lineno; /**< The line count. */
|     int yy_bs_column; /**< The column count. */
|     
| 	/* Whether to try to fill the input buffer when we reach the
| 	 * end of it.
| 	 */
| 	int yy_fill_buffer;
| 
| 	int yy_buffer_status;
| 
| #define YY_BUFFER_NEW 0
| #define YY_BUFFER_NORMAL 1
| 	/* When an EOF's been seen but there's still some text to process
| 	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
| 	 * shouldn't try reading from the input source any more.  We might
| 	 * still have a bunch of tokens to match, though, because of
| 	 * possible backing-up.
| 	 *
| 	 * When we actually see the EOF, we change the status to "new"
| 	 * (via yyrestart()), so that the user can continue scanning by
| 	 * just pointing yyin at a new input file.
| 	 */
| #define YY_BUFFER_EOF_PENDING 2
| 
| 	};
| #endif /* !YY_STRUCT_YY_BUFFER_STATE */
| 
| /* Stack of input buffers. */
| static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
| static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
| static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
| 
| /* We provide macros for accessing buffer states in case in the
|  * future we want to put the buffer states in a more general
|  * "scanner state".
|  *
|  * Returns the top of the stack, or NULL.
|  */
| #define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
|                           ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
|                           : NULL)
| 
| /* Same as previous macro, but useful when we know that the buffer stack is not
|  * NULL or when we need an lvalue. For internal use only.
|  */
| #define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
| 
| /* yy_hold_char holds the character lost when yytext is formed. */
| static char yy_hold_char;
| static yy_size_t yy_n_chars;		/* number of characters read into yy_ch_buf */
| yy_size_t yyleng;
| 
| /* Points to current character in buffer. */
| static char *yy_c_buf_p = (char *) 0;
| static int yy_init = 0;		/* whether we need to initialize */
| static int yy_start = 0;	/* start state number */
| 
| /* Flag which is used to allow yywrap()'s to do buffer switches
|  * instead of setting up a fresh yyin.  A bit of a hack ...
|  */
| static int yy_did_buffer_switch_on_eof;
| 
| void yyrestart (FILE *input_file  );
| void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
| YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
| void yy_delete_buffer (YY_BUFFER_STATE b  );
| void yy_flush_buffer (YY_BUFFER_STATE b  );
| void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
| void yypop_buffer_state (void );
| 
| static void yyensure_buffer_stack (void );
| static void yy_load_buffer_state (void );
| static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
| 
| #define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
| 
| YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
| YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
| YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,yy_size_t len  );
| 
| void *yyalloc (yy_size_t  );
| void *yyrealloc (void *,yy_size_t  );
| void yyfree (void *  );
| 
| #define yy_new_buffer yy_create_buffer
| 
| #define yy_set_interactive(is_interactive) \
| 	{ \
| 	if ( ! YY_CURRENT_BUFFER ){ \
|         yyensure_buffer_stack (); \
| 		YY_CURRENT_BUFFER_LVALUE =    \
|             yy_create_buffer(yyin,YY_BUF_SIZE ); \
| 	} \
| 	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
| 	}
| 
| #define yy_set_bol(at_bol) \
| 	{ \
| 	if ( ! YY_CURRENT_BUFFER ){\
|         yyensure_buffer_stack (); \
| 		YY_CURRENT_BUFFER_LVALUE =    \
|             yy_create_buffer(yyin,YY_BUF_SIZE ); \
| 	} \
| 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
| 	}
| 
| #define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
| 
| /* Begin user sect3 */
| 
| typedef unsigned char YY_CHAR;
| 
| FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
| 
| typedef int yy_state_type;
| 
| extern int yylineno;
| 
| int yylineno = 1;
| 
| extern char *yytext;
| #define yytext_ptr yytext
| 
| static yy_state_type yy_get_previous_state (void );
| static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
| static int yy_get_next_buffer (void );
| static void yy_fatal_error (yyconst char msg[]  );
| 
| /* Done after the current pattern has been matched and before the
|  * corresponding action - sets up yytext.
|  */
| #define YY_DO_BEFORE_ACTION \
| 	(yytext_ptr) = yy_bp; \
| 	(yytext_ptr) -= (yy_more_len); \
| 	yyleng = (size_t) (yy_cp - (yytext_ptr)); \
| 	(yy_hold_char) = *yy_cp; \
| 	*yy_cp = '\0'; \
| 	(yy_c_buf_p) = yy_cp;
| 
| #define YY_NUM_RULES 8
| #define YY_END_OF_BUFFER 9
| /* This struct is not used in this scanner,
|    but its presence is necessary. */
| struct yy_trans_info
| 	{
| 	flex_int32_t yy_verify;
| 	flex_int32_t yy_nxt;
| 	};
| static yyconst flex_int16_t yy_acclist[23] =
|     {   0,
|         9,    7,    8,    8,    1,    7,    8,    2,    7,    8,
|         3,    7,    8,    4,    7,    8,    5,    7,    8,    6,
|         7,    8
|     } ;
| 
| static yyconst flex_int16_t yy_accept[14] =
|     {   0,
|         1,    1,    1,    2,    4,    5,    8,   11,   14,   17,
|        20,   23,   23
|     } ;
| 
| static yyconst flex_int32_t yy_ec[256] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    3,    4,    5,    6,
| 
|         7,    8,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| 
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1
|     } ;
| 
| static yyconst flex_int32_t yy_meta[9] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1
|     } ;
| 
| static yyconst flex_int16_t yy_base[13] =
|     {   0,
|         0,    0,    9,   10,   10,   10,   10,   10,   10,   10,
|        10,   10
|     } ;
| 
| static yyconst flex_int16_t yy_def[13] =
|     {   0,
|        12,    1,   12,   12,   12,   12,   12,   12,   12,   12,
|        12,    0
|     } ;
| 
| static yyconst flex_int16_t yy_nxt[19] =
|     {   0,
|         4,    5,    6,    7,    8,    9,   10,   11,   12,    3,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| static yyconst flex_int16_t yy_chk[19] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    3,   12,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| extern int yy_flex_debug;
| int yy_flex_debug = 0;
| 
| static yy_state_type *yy_state_buf=0, *yy_state_ptr=0;
| static char *yy_full_match;
| static int yy_lp;
| #define REJECT \
| { \
| *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */ \
| yy_cp = (yy_full_match); /* restore poss. backed-over text */ \
| ++(yy_lp); \
| goto find_rule; \
| }
| 
| static int yy_more_flag = 0;
| static int yy_more_len = 0;
| #define yymore() ((yy_more_flag) = 1)
| #define YY_MORE_ADJ (yy_more_len)
| #define YY_RESTORE_YY_MORE_OFFSET
| char *yytext;
| #line 1 "conftest.l"
| #line 470 "lex.yy.c"
| 
| #define INITIAL 0
| 
| #ifndef YY_NO_UNISTD_H
| /* Special case for "unistd.h", since it is non-ANSI. We include it way
|  * down here because we want the user's section 1 to have been scanned first.
|  * The user has a chance to override it with an option.
|  */
| #include <unistd.h>
| #endif
| 
| #ifndef YY_EXTRA_TYPE
| #define YY_EXTRA_TYPE void *
| #endif
| 
| static int yy_init_globals (void );
| 
| /* Accessor methods to globals.
|    These are made visible to non-reentrant scanners for convenience. */
| 
| int yylex_destroy (void );
| 
| int yyget_debug (void );
| 
| void yyset_debug (int debug_flag  );
| 
| YY_EXTRA_TYPE yyget_extra (void );
| 
| void yyset_extra (YY_EXTRA_TYPE user_defined  );
| 
| FILE *yyget_in (void );
| 
| void yyset_in  (FILE * in_str  );
| 
| FILE *yyget_out (void );
| 
| void yyset_out  (FILE * out_str  );
| 
| yy_size_t yyget_leng (void );
| 
| char *yyget_text (void );
| 
| int yyget_lineno (void );
| 
| void yyset_lineno (int line_number  );
| 
| /* Macros after this point can all be overridden by user definitions in
|  * section 1.
|  */
| 
| #ifndef YY_SKIP_YYWRAP
| #ifdef __cplusplus
| extern "C" int yywrap (void );
| #else
| extern int yywrap (void );
| #endif
| #endif
| 
|     static void yyunput (int c,char *buf_ptr  );
|     
| #ifndef yytext_ptr
| static void yy_flex_strncpy (char *,yyconst char *,int );
| #endif
| 
| #ifdef YY_NEED_STRLEN
| static int yy_flex_strlen (yyconst char * );
| #endif
| 
| #ifndef YY_NO_INPUT
| 
| #ifdef __cplusplus
| static int yyinput (void );
| #else
| static int input (void );
| #endif
| 
| #endif
| 
| /* Amount of stuff to slurp up with each read. */
| #ifndef YY_READ_BUF_SIZE
| #define YY_READ_BUF_SIZE 8192
| #endif
| 
| /* Copy whatever the last rule matched to the standard output. */
| #ifndef ECHO
| /* This used to be an fputs(), but since the string might contain NUL's,
|  * we now use fwrite().
|  */
| #define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
| #endif
| 
| /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
|  * is returned in "result".
|  */
| #ifndef YY_INPUT
| #define YY_INPUT(buf,result,max_size) \
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
| 		{ \
| 		int c = '*'; \
| 		size_t n; \
| 		for ( n = 0; n < max_size && \
| 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
| 			buf[n] = (char) c; \
| 		if ( c == '\n' ) \
| 			buf[n++] = (char) c; \
| 		if ( c == EOF && ferror( yyin ) ) \
| 			YY_FATAL_ERROR( "input in flex scanner failed" ); \
| 		result = n; \
| 		} \
| 	else \
| 		{ \
| 		errno=0; \
| 		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
| 			{ \
| 			if( errno != EINTR) \
| 				{ \
| 				YY_FATAL_ERROR( "input in flex scanner failed" ); \
| 				break; \
| 				} \
| 			errno=0; \
| 			clearerr(yyin); \
| 			} \
| 		}\
| \
| 
| #endif
| 
| /* No semi-colon after return; correct usage is to write "yyterminate();" -
|  * we don't want an extra ';' after the "return" because that will cause
|  * some compilers to complain about unreachable statements.
|  */
| #ifndef yyterminate
| #define yyterminate() return YY_NULL
| #endif
| 
| /* Number of entries by which start-condition stack grows. */
| #ifndef YY_START_STACK_INCR
| #define YY_START_STACK_INCR 25
| #endif
| 
| /* Report a fatal error. */
| #ifndef YY_FATAL_ERROR
| #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
| #endif
| 
| /* end tables serialization structures and prototypes */
| 
| /* Default declaration of generated scanner - a define so the user can
|  * easily add parameters.
|  */
| #ifndef YY_DECL
| #define YY_DECL_IS_OURS 1
| 
| extern int yylex (void);
| 
| #define YY_DECL int yylex (void)
| #endif /* !YY_DECL */
| 
| /* Code executed at the beginning of each rule, after yytext and yyleng
|  * have been set up.
|  */
| #ifndef YY_USER_ACTION
| #define YY_USER_ACTION
| #endif
| 
| /* Code executed at the end of each rule. */
| #ifndef YY_BREAK
| #define YY_BREAK break;
| #endif
| 
| #define YY_RULE_SETUP \
| 	YY_USER_ACTION
| 
| /** The main scanner function which does all the work.
|  */
| YY_DECL
| {
| 	register yy_state_type yy_current_state;
| 	register char *yy_cp, *yy_bp;
| 	register int yy_act;
|     
| 	if ( !(yy_init) )
| 		{
| 		(yy_init) = 1;
| 
| #ifdef YY_USER_INIT
| 		YY_USER_INIT;
| #endif
| 
|         /* Create the reject buffer large enough to save one state per allowed character. */
|         if ( ! (yy_state_buf) )
|             (yy_state_buf) = (yy_state_type *)yyalloc(YY_STATE_BUF_SIZE  );
|             if ( ! (yy_state_buf) )
|                 YY_FATAL_ERROR( "out of dynamic memory in yylex()" );
| 
| 		if ( ! (yy_start) )
| 			(yy_start) = 1;	/* first start state */
| 
| 		if ( ! yyin )
| 			yyin = stdin;
| 
| 		if ( ! yyout )
| 			yyout = stdout;
| 
| 		if ( ! YY_CURRENT_BUFFER ) {
| 			yyensure_buffer_stack ();
| 			YY_CURRENT_BUFFER_LVALUE =
| 				yy_create_buffer(yyin,YY_BUF_SIZE );
| 		}
| 
| 		yy_load_buffer_state( );
| 		}
| 
| 	{
| #line 1 "conftest.l"
| 
| #line 687 "lex.yy.c"
| 
| 	while ( 1 )		/* loops until end-of-file is reached */
| 		{
| 		(yy_more_len) = 0;
| 		if ( (yy_more_flag) )
| 			{
| 			(yy_more_len) = (yy_c_buf_p) - (yytext_ptr);
| 			(yy_more_flag) = 0;
| 			}
| 		yy_cp = (yy_c_buf_p);
| 
| 		/* Support of yytext. */
| 		*yy_cp = (yy_hold_char);
| 
| 		/* yy_bp points to the position in yy_ch_buf of the start of
| 		 * the current run.
| 		 */
| 		yy_bp = yy_cp;
| 
| 		yy_current_state = (yy_start);
| 
| 		(yy_state_ptr) = (yy_state_buf);
| 		*(yy_state_ptr)++ = yy_current_state;
| 
| yy_match:
| 		do
| 			{
| 			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
| 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 				{
| 				yy_current_state = (int) yy_def[yy_current_state];
| 				if ( yy_current_state >= 13 )
| 					yy_c = yy_meta[(unsigned int) yy_c];
| 				}
| 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 			*(yy_state_ptr)++ = yy_current_state;
| 			++yy_cp;
| 			}
| 		while ( yy_base[yy_current_state] != 10 );
| 
| yy_find_action:
| 		yy_current_state = *--(yy_state_ptr);
| 		(yy_lp) = yy_accept[yy_current_state];
| find_rule: /* we branch to this label when backing up */
| 		for ( ; ; ) /* until we find what rule we matched */
| 			{
| 			if ( (yy_lp) && (yy_lp) < yy_accept[yy_current_state + 1] )
| 				{
| 				yy_act = yy_acclist[(yy_lp)];
| 					{
| 					(yy_full_match) = yy_cp;
| 					break;
| 					}
| 				}
| 			--yy_cp;
| 			yy_current_state = *--(yy_state_ptr);
| 			(yy_lp) = yy_accept[yy_current_state];
| 			}
| 
| 		YY_DO_BEFORE_ACTION;
| 
| do_action:	/* This label is used only to access EOF actions. */
| 
| 		switch ( yy_act )
| 	{ /* beginning of action switch */
| case 1:
| YY_RULE_SETUP
| #line 2 "conftest.l"
| { ECHO; }
| 	YY_BREAK
| case 2:
| YY_RULE_SETUP
| #line 3 "conftest.l"
| { REJECT; }
| 	YY_BREAK
| case 3:
| YY_RULE_SETUP
| #line 4 "conftest.l"
| { yymore (); }
| 	YY_BREAK
| case 4:
| YY_RULE_SETUP
| #line 5 "conftest.l"
| { yyless (1); }
| 	YY_BREAK
| case 5:
| YY_RULE_SETUP
| #line 6 "conftest.l"
| { yyless (input () != 0); }
| 	YY_BREAK
| case 6:
| YY_RULE_SETUP
| #line 7 "conftest.l"
| { unput (yytext[0]); }
| 	YY_BREAK
| case 7:
| YY_RULE_SETUP
| #line 8 "conftest.l"
| { BEGIN INITIAL; }
| 	YY_BREAK
| case 8:
| YY_RULE_SETUP
| #line 9 "conftest.l"
| ECHO;
| 	YY_BREAK
| #line 793 "lex.yy.c"
| 			case YY_STATE_EOF(INITIAL):
| 				yyterminate();
| 
| 	case YY_END_OF_BUFFER:
| 		{
| 		/* Amount of text matched not including the EOB char. */
| 		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
| 
| 		/* Undo the effects of YY_DO_BEFORE_ACTION. */
| 		*yy_cp = (yy_hold_char);
| 		YY_RESTORE_YY_MORE_OFFSET
| 
| 		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
| 			{
| 			/* We're scanning a new file or input source.  It's
| 			 * possible that this happened because the user
| 			 * just pointed yyin at a new source and called
| 			 * yylex().  If so, then we have to assure
| 			 * consistency between YY_CURRENT_BUFFER and our
| 			 * globals.  Here is the right place to do so, because
| 			 * this is the first action (other than possibly a
| 			 * back-up) that will match for the new input source.
| 			 */
| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
| 			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
| 			}
| 
| 		/* Note that here we test for yy_c_buf_p "<=" to the position
| 		 * of the first EOB in the buffer, since yy_c_buf_p will
| 		 * already have been incremented past the NUL character
| 		 * (since all states make transitions on EOB to the
| 		 * end-of-buffer state).  Contrast this with the test
| 		 * in input().
| 		 */
| 		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
| 			{ /* This was really a NUL. */
| 			yy_state_type yy_next_state;
| 
| 			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
| 
| 			yy_current_state = yy_get_previous_state(  );
| 
| 			/* Okay, we're now positioned to make the NUL
| 			 * transition.  We couldn't have
| 			 * yy_get_previous_state() go ahead and do it
| 			 * for us because it doesn't know how to deal
| 			 * with the possibility of jamming (and we don't
| 			 * want to build jamming into it because then it
| 			 * will run more slowly).
| 			 */
| 
| 			yy_next_state = yy_try_NUL_trans( yy_current_state );
| 
| 			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 
| 			if ( yy_next_state )
| 				{
| 				/* Consume the NUL. */
| 				yy_cp = ++(yy_c_buf_p);
| 				yy_current_state = yy_next_state;
| 				goto yy_match;
| 				}
| 
| 			else
| 				{
| 				yy_cp = (yy_c_buf_p);
| 				goto yy_find_action;
| 				}
| 			}
| 
| 		else switch ( yy_get_next_buffer(  ) )
| 			{
| 			case EOB_ACT_END_OF_FILE:
| 				{
| 				(yy_did_buffer_switch_on_eof) = 0;
| 
| 				if ( yywrap( ) )
| 					{
| 					/* Note: because we've taken care in
| 					 * yy_get_next_buffer() to have set up
| 					 * yytext, we can now set up
| 					 * yy_c_buf_p so that if some total
| 					 * hoser (like flex itself) wants to
| 					 * call the scanner after we return the
| 					 * YY_NULL, it'll still work - another
| 					 * YY_NULL will get returned.
| 					 */
| 					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
| 
| 					yy_act = YY_STATE_EOF(YY_START);
| 					goto do_action;
| 					}
| 
| 				else
| 					{
| 					if ( ! (yy_did_buffer_switch_on_eof) )
| 						YY_NEW_FILE;
| 					}
| 				break;
| 				}
| 
| 			case EOB_ACT_CONTINUE_SCAN:
| 				(yy_c_buf_p) =
| 					(yytext_ptr) + yy_amount_of_matched_text;
| 
| 				yy_current_state = yy_get_previous_state(  );
| 
| 				yy_cp = (yy_c_buf_p);
| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 				goto yy_match;
| 
| 			case EOB_ACT_LAST_MATCH:
| 				(yy_c_buf_p) =
| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
| 
| 				yy_current_state = yy_get_previous_state(  );
| 
| 				yy_cp = (yy_c_buf_p);
| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 				goto yy_find_action;
| 			}
| 		break;
| 		}
| 
| 	default:
| 		YY_FATAL_ERROR(
| 			"fatal flex scanner internal error--no action found" );
| 	} /* end of action switch */
| 		} /* end of scanning one token */
| 	} /* end of user's declarations */
| } /* end of yylex */
| 
| /* yy_get_next_buffer - try to read in a new buffer
|  *
|  * Returns a code representing an action:
|  *	EOB_ACT_LAST_MATCH -
|  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
|  *	EOB_ACT_END_OF_FILE - end of file
|  */
| static int yy_get_next_buffer (void)
| {
|     	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
| 	register char *source = (yytext_ptr);
| 	register int number_to_move, i;
| 	int ret_val;
| 
| 	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
| 		YY_FATAL_ERROR(
| 		"fatal flex scanner internal error--end of buffer missed" );
| 
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
| 		{ /* Don't try to fill the buffer, so this is an EOF. */
| 		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
| 			{
| 			/* We matched a single character, the EOB, so
| 			 * treat this as a final EOF.
| 			 */
| 			return EOB_ACT_END_OF_FILE;
| 			}
| 
| 		else
| 			{
| 			/* We matched some text prior to the EOB, first
| 			 * process it.
| 			 */
| 			return EOB_ACT_LAST_MATCH;
| 			}
| 		}
| 
| 	/* Try to read more data. */
| 
| 	/* First move last chars to start of buffer. */
| 	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
| 
| 	for ( i = 0; i < number_to_move; ++i )
| 		*(dest++) = *(source++);
| 
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
| 		/* don't do the read, it's not guaranteed to return an EOF,
| 		 * just force an EOF
| 		 */
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
| 
| 	else
| 		{
| 			yy_size_t num_to_read =
| 			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
| 
| 		while ( num_to_read <= 0 )
| 			{ /* Not enough room in the buffer - grow it. */
| 
| 			YY_FATAL_ERROR(
| "input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
| 
| 			}
| 
| 		if ( num_to_read > YY_READ_BUF_SIZE )
| 			num_to_read = YY_READ_BUF_SIZE;
| 
| 		/* Read in more data. */
| 		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
| 			(yy_n_chars), num_to_read );
| 
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	if ( (yy_n_chars) == 0 )
| 		{
| 		if ( number_to_move == YY_MORE_ADJ )
| 			{
| 			ret_val = EOB_ACT_END_OF_FILE;
| 			yyrestart(yyin  );
| 			}
| 
| 		else
| 			{
| 			ret_val = EOB_ACT_LAST_MATCH;
| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
| 				YY_BUFFER_EOF_PENDING;
| 			}
| 		}
| 
| 	else
| 		ret_val = EOB_ACT_CONTINUE_SCAN;
| 
| 	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
| 		/* Extend the array by 50%, plus the number we really need. */
| 		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
| 		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
| 		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
| 			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
| 	}
| 
| 	(yy_n_chars) += number_to_move;
| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
| 
| 	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
| 
| 	return ret_val;
| }
| 
| /* yy_get_previous_state - get the state just before the EOB char was reached */
| 
|     static yy_state_type yy_get_previous_state (void)
| {
| 	register yy_state_type yy_current_state;
| 	register char *yy_cp;
|     
| 	yy_current_state = (yy_start);
| 
| 	(yy_state_ptr) = (yy_state_buf);
| 	*(yy_state_ptr)++ = yy_current_state;
| 
| 	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
| 		{
| 		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
| 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 			{
| 			yy_current_state = (int) yy_def[yy_current_state];
| 			if ( yy_current_state >= 13 )
| 				yy_c = yy_meta[(unsigned int) yy_c];
| 			}
| 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 		*(yy_state_ptr)++ = yy_current_state;
| 		}
| 
| 	return yy_current_state;
| }
| 
| /* yy_try_NUL_trans - try to make a transition on the NUL character
|  *
|  * synopsis
|  *	next_state = yy_try_NUL_trans( current_state );
|  */
|     static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
| {
| 	register int yy_is_jam;
|     
| 	register YY_CHAR yy_c = 1;
| 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 		{
| 		yy_current_state = (int) yy_def[yy_current_state];
| 		if ( yy_current_state >= 13 )
| 			yy_c = yy_meta[(unsigned int) yy_c];
| 		}
| 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 	yy_is_jam = (yy_current_state == 12);
| 	if ( ! yy_is_jam )
| 		*(yy_state_ptr)++ = yy_current_state;
| 
| 		return yy_is_jam ? 0 : yy_current_state;
| }
| 
|     static void yyunput (int c, register char * yy_bp )
| {
| 	register char *yy_cp;
|     
|     yy_cp = (yy_c_buf_p);
| 
| 	/* undo effects of setting up yytext */
| 	*yy_cp = (yy_hold_char);
| 
| 	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
| 		{ /* need to shift things up to make room */
| 		/* +2 for EOB chars. */
| 		register yy_size_t number_to_move = (yy_n_chars) + 2;
| 		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
| 					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
| 		register char *source =
| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
| 
| 		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
| 			*--dest = *--source;
| 
| 		yy_cp += (int) (dest - source);
| 		yy_bp += (int) (dest - source);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
| 
| 		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
| 			YY_FATAL_ERROR( "flex scanner push-back overflow" );
| 		}
| 
| 	*--yy_cp = (char) c;
| 
| 	(yytext_ptr) = yy_bp;
| 	(yy_hold_char) = *yy_cp;
| 	(yy_c_buf_p) = yy_cp;
| }
| 
| #ifndef YY_NO_INPUT
| #ifdef __cplusplus
|     static int yyinput (void)
| #else
|     static int input  (void)
| #endif
| 
| {
| 	int c;
|     
| 	*(yy_c_buf_p) = (yy_hold_char);
| 
| 	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
| 		{
| 		/* yy_c_buf_p now points to the character we want to return.
| 		 * If this occurs *before* the EOB characters, then it's a
| 		 * valid NUL; if not, then we've hit the end of the buffer.
| 		 */
| 		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
| 			/* This was really a NUL. */
| 			*(yy_c_buf_p) = '\0';
| 
| 		else
| 			{ /* need more input */
| 			yy_size_t offset = (yy_c_buf_p) - (yytext_ptr);
| 			++(yy_c_buf_p);
| 
| 			switch ( yy_get_next_buffer(  ) )
| 				{
| 				case EOB_ACT_LAST_MATCH:
| 					/* This happens because yy_g_n_b()
| 					 * sees that we've accumulated a
| 					 * token and flags that we need to
| 					 * try matching the token before
| 					 * proceeding.  But for input(),
| 					 * there's no matching to consider.
| 					 * So convert the EOB_ACT_LAST_MATCH
| 					 * to EOB_ACT_END_OF_FILE.
| 					 */
| 
| 					/* Reset buffer status. */
| 					yyrestart(yyin );
| 
| 					/*FALLTHROUGH*/
| 
| 				case EOB_ACT_END_OF_FILE:
| 					{
| 					if ( yywrap( ) )
| 						return EOF;
| 
| 					if ( ! (yy_did_buffer_switch_on_eof) )
| 						YY_NEW_FILE;
| #ifdef __cplusplus
| 					return yyinput();
| #else
| 					return input();
| #endif
| 					}
| 
| 				case EOB_ACT_CONTINUE_SCAN:
| 					(yy_c_buf_p) = (yytext_ptr) + offset;
| 					break;
| 				}
| 			}
| 		}
| 
| 	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
| 	*(yy_c_buf_p) = '\0';	/* preserve yytext */
| 	(yy_hold_char) = *++(yy_c_buf_p);
| 
| 	return c;
| }
| #endif	/* ifndef YY_NO_INPUT */
| 
| /** Immediately switch to a different input stream.
|  * @param input_file A readable stream.
|  * 
|  * @note This function does not reset the start condition to @c INITIAL .
|  */
|     void yyrestart  (FILE * input_file )
| {
|     
| 	if ( ! YY_CURRENT_BUFFER ){
|         yyensure_buffer_stack ();
| 		YY_CURRENT_BUFFER_LVALUE =
|             yy_create_buffer(yyin,YY_BUF_SIZE );
| 	}
| 
| 	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
| 	yy_load_buffer_state( );
| }
| 
| /** Switch to a different input buffer.
|  * @param new_buffer The new input buffer.
|  * 
|  */
|     void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
| {
|     
| 	/* TODO. We should be able to replace this entire function body
| 	 * with
| 	 *		yypop_buffer_state();
| 	 *		yypush_buffer_state(new_buffer);
|      */
| 	yyensure_buffer_stack ();
| 	if ( YY_CURRENT_BUFFER == new_buffer )
| 		return;
| 
| 	if ( YY_CURRENT_BUFFER )
| 		{
| 		/* Flush out information for old buffer. */
| 		*(yy_c_buf_p) = (yy_hold_char);
| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
| 	yy_load_buffer_state( );
| 
| 	/* We don't actually know whether we did this switch during
| 	 * EOF (yywrap()) processing, but the only time this flag
| 	 * is looked at is after yywrap() is called, so it's safe
| 	 * to go ahead and always set it.
| 	 */
| 	(yy_did_buffer_switch_on_eof) = 1;
| }
| 
| static void yy_load_buffer_state  (void)
| {
|     	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
| 	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
| 	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
| 	(yy_hold_char) = *(yy_c_buf_p);
| }
| 
| /** Allocate and initialize an input buffer state.
|  * @param file A readable stream.
|  * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
|  * 
|  * @return the allocated buffer state.
|  */
|     YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
| {
| 	YY_BUFFER_STATE b;
|     
| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_buf_size = size;
| 
| 	/* yy_ch_buf has to be 2 characters longer than the size given because
| 	 * we need to put in 2 end-of-buffer characters.
| 	 */
| 	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
| 	if ( ! b->yy_ch_buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_is_our_buffer = 1;
| 
| 	yy_init_buffer(b,file );
| 
| 	return b;
| }
| 
| /** Destroy the buffer.
|  * @param b a buffer created with yy_create_buffer()
|  * 
|  */
|     void yy_delete_buffer (YY_BUFFER_STATE  b )
| {
|     
| 	if ( ! b )
| 		return;
| 
| 	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
| 		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
| 
| 	if ( b->yy_is_our_buffer )
| 		yyfree((void *) b->yy_ch_buf  );
| 
| 	yyfree((void *) b  );
| }
| 
| /* Initializes or reinitializes a buffer.
|  * This function is sometimes called more than once on the same buffer,
|  * such as during a yyrestart() or at EOF.
|  */
|     static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
| 
| {
| 	int oerrno = errno;
|     
| 	yy_flush_buffer(b );
| 
| 	b->yy_input_file = file;
| 	b->yy_fill_buffer = 1;
| 
|     /* If b is the current buffer, then yy_init_buffer was _probably_
|      * called from yyrestart() or through yy_get_next_buffer.
|      * In that case, we don't want to reset the lineno or column.
|      */
|     if (b != YY_CURRENT_BUFFER){
|         b->yy_bs_lineno = 1;
|         b->yy_bs_column = 0;
|     }
| 
|         b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
|     
| 	errno = oerrno;
| }
| 
| /** Discard all buffered characters. On the next scan, YY_INPUT will be called.
|  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
|  * 
|  */
|     void yy_flush_buffer (YY_BUFFER_STATE  b )
| {
|     	if ( ! b )
| 		return;
| 
| 	b->yy_n_chars = 0;
| 
| 	/* We always need two end-of-buffer characters.  The first causes
| 	 * a transition to the end-of-buffer state.  The second causes
| 	 * a jam in that state.
| 	 */
| 	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
| 	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b->yy_buf_pos = &b->yy_ch_buf[0];
| 
| 	b->yy_at_bol = 1;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	if ( b == YY_CURRENT_BUFFER )
| 		yy_load_buffer_state( );
| }
| 
| /** Pushes the new state onto the stack. The new state becomes
|  *  the current state. This function will allocate the stack
|  *  if necessary.
|  *  @param new_buffer The new state.
|  *  
|  */
| void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
| {
|     	if (new_buffer == NULL)
| 		return;
| 
| 	yyensure_buffer_stack();
| 
| 	/* This block is copied from yy_switch_to_buffer. */
| 	if ( YY_CURRENT_BUFFER )
| 		{
| 		/* Flush out information for old buffer. */
| 		*(yy_c_buf_p) = (yy_hold_char);
| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	/* Only push if top exists. Otherwise, replace top. */
| 	if (YY_CURRENT_BUFFER)
| 		(yy_buffer_stack_top)++;
| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
| 
| 	/* copied from yy_switch_to_buffer. */
| 	yy_load_buffer_state( );
| 	(yy_did_buffer_switch_on_eof) = 1;
| }
| 
| /** Removes and deletes the top of the stack, if present.
|  *  The next element becomes the new top.
|  *  
|  */
| void yypop_buffer_state (void)
| {
|     	if (!YY_CURRENT_BUFFER)
| 		return;
| 
| 	yy_delete_buffer(YY_CURRENT_BUFFER );
| 	YY_CURRENT_BUFFER_LVALUE = NULL;
| 	if ((yy_buffer_stack_top) > 0)
| 		--(yy_buffer_stack_top);
| 
| 	if (YY_CURRENT_BUFFER) {
| 		yy_load_buffer_state( );
| 		(yy_did_buffer_switch_on_eof) = 1;
| 	}
| }
| 
| /* Allocates the stack if it does not exist.
|  *  Guarantees space for at least one push.
|  */
| static void yyensure_buffer_stack (void)
| {
| 	yy_size_t num_to_alloc;
|     
| 	if (!(yy_buffer_stack)) {
| 
| 		/* First allocation is just for 2 elements, since we don't know if this
| 		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
| 		 * immediate realloc on the next call.
|          */
| 		num_to_alloc = 1;
| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
| 								(num_to_alloc * sizeof(struct yy_buffer_state*)
| 								);
| 		if ( ! (yy_buffer_stack) )
| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
| 								  
| 		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
| 				
| 		(yy_buffer_stack_max) = num_to_alloc;
| 		(yy_buffer_stack_top) = 0;
| 		return;
| 	}
| 
| 	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
| 
| 		/* Increase the buffer to prepare for a possible push. */
| 		int grow_size = 8 /* arbitrary grow size */;
| 
| 		num_to_alloc = (yy_buffer_stack_max) + grow_size;
| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
| 								((yy_buffer_stack),
| 								num_to_alloc * sizeof(struct yy_buffer_state*)
| 								);
| 		if ( ! (yy_buffer_stack) )
| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
| 
| 		/* zero only the new slots.*/
| 		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
| 		(yy_buffer_stack_max) = num_to_alloc;
| 	}
| }
| 
| /** Setup the input buffer state to scan directly from a user-specified character buffer.
|  * @param base the character buffer
|  * @param size the size in bytes of the character buffer
|  * 
|  * @return the newly allocated buffer state object. 
|  */
| YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
| {
| 	YY_BUFFER_STATE b;
|     
| 	if ( size < 2 ||
| 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
| 	     base[size-1] != YY_END_OF_BUFFER_CHAR )
| 		/* They forgot to leave room for the EOB's. */
| 		return 0;
| 
| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
| 
| 	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
| 	b->yy_buf_pos = b->yy_ch_buf = base;
| 	b->yy_is_our_buffer = 0;
| 	b->yy_input_file = 0;
| 	b->yy_n_chars = b->yy_buf_size;
| 	b->yy_is_interactive = 0;
| 	b->yy_at_bol = 1;
| 	b->yy_fill_buffer = 0;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	yy_switch_to_buffer(b  );
| 
| 	return b;
| }
| 
| /** Setup the input buffer state to scan a string. The next call to yylex() will
|  * scan from a @e copy of @a str.
|  * @param yystr a NUL-terminated string to scan
|  * 
|  * @return the newly allocated buffer state object.
|  * @note If you want to scan bytes that may contain NUL values, then use
|  *       yy_scan_bytes() instead.
|  */
| YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
| {
|     
| 	return yy_scan_bytes(yystr,strlen(yystr) );
| }
| 
| /** Setup the input buffer state to scan the given bytes. The next call to yylex() will
|  * scan from a @e copy of @a bytes.
|  * @param yybytes the byte buffer to scan
|  * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
|  * 
|  * @return the newly allocated buffer state object.
|  */
| YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len )
| {
| 	YY_BUFFER_STATE b;
| 	char *buf;
| 	yy_size_t n;
| 	yy_size_t i;
|     
| 	/* Get memory for full buffer, including space for trailing EOB's. */
| 	n = _yybytes_len + 2;
| 	buf = (char *) yyalloc(n  );
| 	if ( ! buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
| 
| 	for ( i = 0; i < _yybytes_len; ++i )
| 		buf[i] = yybytes[i];
| 
| 	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b = yy_scan_buffer(buf,n );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
| 
| 	/* It's okay to grow etc. this buffer, and we should throw it
| 	 * away when we're done.
| 	 */
| 	b->yy_is_our_buffer = 1;
| 
| 	return b;
| }
| 
| #ifndef YY_EXIT_FAILURE
| #define YY_EXIT_FAILURE 2
| #endif
| 
| static void yy_fatal_error (yyconst char* msg )
| {
|     	(void) fprintf( stderr, "%s\n", msg );
| 	exit( YY_EXIT_FAILURE );
| }
| 
| /* Redefine yyless() so it works in section 3 code. */
| 
| #undef yyless
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
|         int yyless_macro_arg = (n); \
|         YY_LESS_LINENO(yyless_macro_arg);\
| 		yytext[yyleng] = (yy_hold_char); \
| 		(yy_c_buf_p) = yytext + yyless_macro_arg; \
| 		(yy_hold_char) = *(yy_c_buf_p); \
| 		*(yy_c_buf_p) = '\0'; \
| 		yyleng = yyless_macro_arg; \
| 		} \
| 	while ( 0 )
| 
| /* Accessor  methods (get/set functions) to struct members. */
| 
| /** Get the current line number.
|  * 
|  */
| int yyget_lineno  (void)
| {
|         
|     return yylineno;
| }
| 
| /** Get the input stream.
|  * 
|  */
| FILE *yyget_in  (void)
| {
|         return yyin;
| }
| 
| /** Get the output stream.
|  * 
|  */
| FILE *yyget_out  (void)
| {
|         return yyout;
| }
| 
| /** Get the length of the current token.
|  * 
|  */
| yy_size_t yyget_leng  (void)
| {
|         return yyleng;
| }
| 
| /** Get the current token.
|  * 
|  */
| 
| char *yyget_text  (void)
| {
|         return yytext;
| }
| 
| /** Set the current line number.
|  * @param line_number
|  * 
|  */
| void yyset_lineno (int  line_number )
| {
|     
|     yylineno = line_number;
| }
| 
| /** Set the input stream. This does not discard the current
|  * input buffer.
|  * @param in_str A readable stream.
|  * 
|  * @see yy_switch_to_buffer
|  */
| void yyset_in (FILE *  in_str )
| {
|         yyin = in_str ;
| }
| 
| void yyset_out (FILE *  out_str )
| {
|         yyout = out_str ;
| }
| 
| int yyget_debug  (void)
| {
|         return yy_flex_debug;
| }
| 
| void yyset_debug (int  bdebug )
| {
|         yy_flex_debug = bdebug ;
| }
| 
| static int yy_init_globals (void)
| {
|         /* Initialization is the same as for the non-reentrant scanner.
|      * This function is called from yylex_destroy(), so don't allocate here.
|      */
| 
|     (yy_buffer_stack) = 0;
|     (yy_buffer_stack_top) = 0;
|     (yy_buffer_stack_max) = 0;
|     (yy_c_buf_p) = (char *) 0;
|     (yy_init) = 0;
|     (yy_start) = 0;
| 
|     (yy_state_buf) = 0;
|     (yy_state_ptr) = 0;
|     (yy_full_match) = 0;
|     (yy_lp) = 0;
| 
| /* Defined in main.c */
| #ifdef YY_STDINIT
|     yyin = stdin;
|     yyout = stdout;
| #else
|     yyin = (FILE *) 0;
|     yyout = (FILE *) 0;
| #endif
| 
|     /* For future reference: Set errno on error, since we are called by
|      * yylex_init()
|      */
|     return 0;
| }
| 
| /* yylex_destroy is for both reentrant and non-reentrant scanners. */
| int yylex_destroy  (void)
| {
|     
|     /* Pop the buffer stack, destroying each element. */
| 	while(YY_CURRENT_BUFFER){
| 		yy_delete_buffer(YY_CURRENT_BUFFER  );
| 		YY_CURRENT_BUFFER_LVALUE = NULL;
| 		yypop_buffer_state();
| 	}
| 
| 	/* Destroy the stack itself. */
| 	yyfree((yy_buffer_stack) );
| 	(yy_buffer_stack) = NULL;
| 
|     yyfree ( (yy_state_buf) );
|     (yy_state_buf)  = NULL;
| 
|     /* Reset the globals. This is important in a non-reentrant scanner so the next time
|      * yylex() is called, initialization will occur. */
|     yy_init_globals( );
| 
|     return 0;
| }
| 
| /*
|  * Internal utility routines.
|  */
| 
| #ifndef yytext_ptr
| static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
| {
| 	register int i;
| 	for ( i = 0; i < n; ++i )
| 		s1[i] = s2[i];
| }
| #endif
| 
| #ifdef YY_NEED_STRLEN
| static int yy_flex_strlen (yyconst char * s )
| {
| 	register int n;
| 	for ( n = 0; s[n]; ++n )
| 		;
| 
| 	return n;
| }
| #endif
| 
| void *yyalloc (yy_size_t  size )
| {
| 	return (void *) malloc( size );
| }
| 
| void *yyrealloc  (void * ptr, yy_size_t  size )
| {
| 	/* The cast to (char *) in the following accommodates both
| 	 * implementations that use char* generic pointers, and those
| 	 * that use void* generic pointers.  It works with the latter
| 	 * because both ANSI C and C++ allow castless assignment from
| 	 * any pointer type to void*, and deal with argument conversions
| 	 * as though doing an assignment.
| 	 */
| 	return (void *) realloc( (char *) ptr, size );
| }
| 
| void yyfree (void * ptr )
| {
| 	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
| }
| 
| #define YYTABLES_NAME "yytables"
| 
| #line 9 "conftest.l"
| 
| 
| #ifdef YYTEXT_POINTER
| extern char *yytext;
| #endif
| int
| main (void)
| {
|   return ! yylex () + ! yywrap ();
| }
configure:12945: result: no
configure:12973: checking whether NLS is requested
configure:12976: result: no
configure:13044: checking whether NLS is requested
configure:13053: result: no
configure:13091: checking for msgfmt
configure:13122: result: /usr/sbin/msgfmt
configure:13131: checking for gmsgfmt
configure:13162: result: /usr/sbin/msgfmt
configure:13202: checking for xgettext
configure:13233: result: /usr/sbin/xgettext
configure:13273: checking for msgmerge
configure:13303: result: /usr/sbin/msgmerge
configure:13340: checking whether to enable maintainer-specific portions of Makefiles
configure:13349: result: no
configure:13375: checking for string.h
configure:13375: result: yes
configure:13375: checking for stdlib.h
configure:13375: result: yes
configure:13375: checking for memory.h
configure:13375: result: yes
configure:13375: checking for strings.h
configure:13375: result: yes
configure:13375: checking for unistd.h
configure:13375: result: yes
configure:13375: checking errno.h usability
configure:13375: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13375: $? = 0
configure:13375: result: yes
configure:13375: checking errno.h presence
configure:13375: arm-linux-androideabi-gcc -E  conftest.c
configure:13375: $? = 0
configure:13375: result: yes
configure:13375: checking for errno.h
configure:13375: result: yes
configure:13375: checking for sys/types.h
configure:13375: result: yes
configure:13375: checking limits.h usability
configure:13375: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13375: $? = 0
configure:13375: result: yes
configure:13375: checking limits.h presence
configure:13375: arm-linux-androideabi-gcc -E  conftest.c
configure:13375: $? = 0
configure:13375: result: yes
configure:13375: checking for limits.h
configure:13375: result: yes
configure:13375: checking locale.h usability
configure:13375: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13375: $? = 0
configure:13375: result: yes
configure:13375: checking locale.h presence
configure:13375: arm-linux-androideabi-gcc -E  conftest.c
configure:13375: $? = 0
configure:13375: result: yes
configure:13375: checking for locale.h
configure:13375: result: yes
configure:13375: checking time.h usability
configure:13375: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13375: $? = 0
configure:13375: result: yes
configure:13375: checking time.h presence
configure:13375: arm-linux-androideabi-gcc -E  conftest.c
configure:13375: $? = 0
configure:13375: result: yes
configure:13375: checking for time.h
configure:13375: result: yes
configure:13375: checking for sys/stat.h
configure:13375: result: yes
configure:13386: checking whether string.h and strings.h may both be included
configure:13403: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13403: $? = 0
configure:13410: result: yes
configure:13421: checking whether compiling a cross-assembler
configure:13431: result: yes
configure:13436: checking for working alloca.h
configure:13453: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:13453: $? = 0
configure:13461: result: yes
configure:13469: checking for alloca
configure:13506: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:13506: $? = 0
configure:13514: result: yes
configure:13624: checking for inline
configure:13640: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13640: $? = 0
configure:13648: result: inline
configure:13671: checking for unlink
configure:13671: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:13671: $? = 0
configure:13671: result: yes
configure:13684: checking for sbrk
configure:13684: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:13684: $? = 0
configure:13684: result: yes
configure:13684: checking for setlocale
configure:13684: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:13684: $? = 0
configure:13684: result: yes
configure:13696: checking for LC_MESSAGES
configure:13712: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:13712: $? = 0
configure:13720: result: yes
configure:13871: checking for working assert macro
configure:13896: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:13896: $? = 0
configure:13904: result: yes
configure:13936: checking whether declaration is required for errno
configure:13960: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:13960: $? = 0
configure:13968: result: no
configure:13977: checking for a known getopt prototype in unistd.h
configure:13993: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13993: $? = 0
configure:14001: result: yes
configure:14010: checking whether declaration is required for environ
configure:14030: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:14030: $? = 0
configure:14038: result: no
configure:14047: checking whether declaration is required for ffs
configure:14067: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:14067: $? = 0
configure:14075: result: no
configure:14084: checking whether declaration is required for free
configure:14104: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:14104: $? = 0
configure:14112: result: no
configure:14121: checking whether declaration is required for malloc
configure:14141: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:14141: $? = 0
configure:14149: result: no
configure:14158: checking whether declaration is required for sbrk
configure:14178: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:14178: $? = 0
configure:14186: result: no
configure:14195: checking whether declaration is required for strstr
configure:14215: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:14215: $? = 0
configure:14223: result: no
configure:14232: checking whether free is declared
configure:14232: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:14232: $? = 0
configure:14232: result: yes
configure:14242: checking whether getenv is declared
configure:14242: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:14242: $? = 0
configure:14242: result: yes
configure:14252: checking whether malloc is declared
configure:14252: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:14252: $? = 0
configure:14252: result: yes
configure:14262: checking whether mempcpy is declared
configure:14262: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:102:10: error: 'mempcpy' undeclared (first use in this function)
   (void) mempcpy;
          ^
conftest.c:102:10: note: each undeclared identifier is reported only once for each function it appears in
configure:14262: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "gas"
| #define PACKAGE_TARNAME "gas"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "gas 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "gas"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define ENABLE_CHECKING 1
| #define DEFAULT_ARCH "i386"
| #define I386COFF 1
| #define EMULATIONS 
| #define DEFAULT_EMULATION ""
| #define TARGET_ALIAS "i686-w64-mingw32"
| #define TARGET_CANONICAL "i686-w64-mingw32"
| #define TARGET_CPU "i686"
| #define TARGET_VENDOR "w64"
| #define TARGET_OS "mingw32"
| #define HAVE_STRING_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_STAT_H 1
| #define STRING_WITH_STRINGS 1
| #define CROSS_COMPILE 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_ALLOCA 1
| #define HAVE_UNLINK 1
| #define HAVE_SBRK 1
| #define HAVE_SETLOCALE 1
| #define HAVE_LC_MESSAGES 1
| #define HAVE_DECL_GETOPT 1
| #define HAVE_DECL_FREE 1
| #define HAVE_DECL_GETENV 1
| #define HAVE_DECL_MALLOC 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| #ifndef mempcpy
| #ifdef __cplusplus
|   (void) mempcpy;
| #else
|   (void) mempcpy;
| #endif
| #endif
| 
|   ;
|   return 0;
| }
configure:14262: result: no
configure:14272: checking whether realloc is declared
configure:14272: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:14272: $? = 0
configure:14272: result: yes
configure:14282: checking whether stpcpy is declared
configure:14282: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:14282: $? = 0
configure:14282: result: yes
configure:14292: checking whether strstr is declared
configure:14292: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:14292: $? = 0
configure:14292: result: yes
configure:14302: checking whether vsnprintf is declared
configure:14302: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:14302: $? = 0
configure:14302: result: yes
configure:14335: checking for library containing zlibVersion
configure:14366: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
/tmp/ccioilHm.o:conftest.c:function main: error: undefined reference to 'zlibVersion'
collect2: error: ld returned 1 exit status
configure:14366: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "gas"
| #define PACKAGE_TARNAME "gas"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "gas 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "gas"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define ENABLE_CHECKING 1
| #define DEFAULT_ARCH "i386"
| #define I386COFF 1
| #define EMULATIONS 
| #define DEFAULT_EMULATION ""
| #define TARGET_ALIAS "i686-w64-mingw32"
| #define TARGET_CANONICAL "i686-w64-mingw32"
| #define TARGET_CPU "i686"
| #define TARGET_VENDOR "w64"
| #define TARGET_OS "mingw32"
| #define HAVE_STRING_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_STAT_H 1
| #define STRING_WITH_STRINGS 1
| #define CROSS_COMPILE 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_ALLOCA 1
| #define HAVE_UNLINK 1
| #define HAVE_SBRK 1
| #define HAVE_SETLOCALE 1
| #define HAVE_LC_MESSAGES 1
| #define HAVE_DECL_GETOPT 1
| #define HAVE_DECL_FREE 1
| #define HAVE_DECL_GETENV 1
| #define HAVE_DECL_MALLOC 1
| #define HAVE_DECL_MEMPCPY 0
| #define HAVE_DECL_REALLOC 1
| #define HAVE_DECL_STPCPY 1
| #define HAVE_DECL_STRSTR 1
| #define HAVE_DECL_VSNPRINTF 1
| /* end confdefs.h.  */
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char zlibVersion ();
| int
| main ()
| {
| return zlibVersion ();
|   ;
|   return 0;
| }
configure:14366: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c -lz   >&5
configure:14366: $? = 0
configure:14383: result: -lz
configure:14390: checking zlib.h usability
configure:14390: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:14390: $? = 0
configure:14390: result: yes
configure:14390: checking zlib.h presence
configure:14390: arm-linux-androideabi-gcc -E  conftest.c
configure:14390: $? = 0
configure:14390: result: yes
configure:14390: checking for zlib.h
configure:14390: result: yes
configure:14411: checking for struct tm.tm_gmtoff in time.h
configure:14429: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:14429: $? = 0
configure:14443: result: yes
configure:14449: checking for struct stat.st_mtim.tv_sec in sys/stat.h
configure:14467: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:75:45: error: 'struct stat' has no member named 'st_mtim'
 struct stat avar; void* aref = (void*) &avar.st_mtim.tv_sec
                                             ^
configure:14467: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "gas"
| #define PACKAGE_TARNAME "gas"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "gas 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "gas"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define ENABLE_CHECKING 1
| #define DEFAULT_ARCH "i386"
| #define I386COFF 1
| #define EMULATIONS 
| #define DEFAULT_EMULATION ""
| #define TARGET_ALIAS "i686-w64-mingw32"
| #define TARGET_CANONICAL "i686-w64-mingw32"
| #define TARGET_CPU "i686"
| #define TARGET_VENDOR "w64"
| #define TARGET_OS "mingw32"
| #define HAVE_STRING_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_STAT_H 1
| #define STRING_WITH_STRINGS 1
| #define CROSS_COMPILE 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_ALLOCA 1
| #define HAVE_UNLINK 1
| #define HAVE_SBRK 1
| #define HAVE_SETLOCALE 1
| #define HAVE_LC_MESSAGES 1
| #define HAVE_DECL_GETOPT 1
| #define HAVE_DECL_FREE 1
| #define HAVE_DECL_GETENV 1
| #define HAVE_DECL_MALLOC 1
| #define HAVE_DECL_MEMPCPY 0
| #define HAVE_DECL_REALLOC 1
| #define HAVE_DECL_STPCPY 1
| #define HAVE_DECL_STRSTR 1
| #define HAVE_DECL_VSNPRINTF 1
| #define HAVE_ZLIB_H 1
| #define HAVE_TM_GMTOFF 1
| /* end confdefs.h.  */
| 
| #define _BSD_SOURCE 1
| #include <sys/stat.h>
| int
| main ()
| {
| struct stat avar; void* aref = (void*) &avar.st_mtim.tv_sec
|   ;
|   return 0;
| }
configure:14481: result: no
configure:14484: checking for struct stat.st_mtim.tv_nsec in sys/stat.h
configure:14502: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:75:45: error: 'struct stat' has no member named 'st_mtim'
 struct stat avar; void* aref = (void*) &avar.st_mtim.tv_nsec
                                             ^
configure:14502: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "gas"
| #define PACKAGE_TARNAME "gas"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "gas 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "gas"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define ENABLE_CHECKING 1
| #define DEFAULT_ARCH "i386"
| #define I386COFF 1
| #define EMULATIONS 
| #define DEFAULT_EMULATION ""
| #define TARGET_ALIAS "i686-w64-mingw32"
| #define TARGET_CANONICAL "i686-w64-mingw32"
| #define TARGET_CPU "i686"
| #define TARGET_VENDOR "w64"
| #define TARGET_OS "mingw32"
| #define HAVE_STRING_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_STAT_H 1
| #define STRING_WITH_STRINGS 1
| #define CROSS_COMPILE 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_ALLOCA 1
| #define HAVE_UNLINK 1
| #define HAVE_SBRK 1
| #define HAVE_SETLOCALE 1
| #define HAVE_LC_MESSAGES 1
| #define HAVE_DECL_GETOPT 1
| #define HAVE_DECL_FREE 1
| #define HAVE_DECL_GETENV 1
| #define HAVE_DECL_MALLOC 1
| #define HAVE_DECL_MEMPCPY 0
| #define HAVE_DECL_REALLOC 1
| #define HAVE_DECL_STPCPY 1
| #define HAVE_DECL_STRSTR 1
| #define HAVE_DECL_VSNPRINTF 1
| #define HAVE_ZLIB_H 1
| #define HAVE_TM_GMTOFF 1
| /* end confdefs.h.  */
| 
| #define _BSD_SOURCE 1
| #include <sys/stat.h>
| int
| main ()
| {
| struct stat avar; void* aref = (void*) &avar.st_mtim.tv_nsec
|   ;
|   return 0;
| }
configure:14516: result: no
configure:14599: updating cache ./config.cache
configure:14661: creating ./config.status

## ---------------------- ##
## Running config.status. ##
## ---------------------- ##

This file was extended by gas config.status 2.25.1, which was
generated by GNU Autoconf 2.64.  Invocation command line was

  CONFIG_FILES    = 
  CONFIG_HEADERS  = 
  CONFIG_LINKS    = 
  CONFIG_COMMANDS = 
  $ ./config.status 

on d5f3793a98c0

config.status:1166: creating .gdbinit
config.status:1166: creating Makefile
config.status:1166: creating doc/Makefile
config.status:1166: creating po/Makefile.in
config.status:1166: creating config.h
config.status:1379: executing depfiles commands
config.status:1379: executing libtool commands
config.status:1379: executing default-1 commands
config.status:1379: executing default commands

## ---------------- ##
## Cache variables. ##
## ---------------- ##

ac_cv_build=x86_64-unknown-linux-gnu
ac_cv_c_bigendian=no
ac_cv_c_compiler_gnu=yes
ac_cv_c_inline=inline
ac_cv_env_CC_set=set
ac_cv_env_CC_value=arm-linux-androideabi-gcc
ac_cv_env_CFLAGS_set=set
ac_cv_env_CFLAGS_value=
ac_cv_env_CPPFLAGS_set=set
ac_cv_env_CPPFLAGS_value=
ac_cv_env_CPP_set=
ac_cv_env_CPP_value=
ac_cv_env_LDFLAGS_set=set
ac_cv_env_LDFLAGS_value='-static-libstdc++ -static-libgcc '
ac_cv_env_LIBS_set=
ac_cv_env_LIBS_value=
ac_cv_env_YACC_set=set
ac_cv_env_YACC_value='bison -y'
ac_cv_env_YFLAGS_set=
ac_cv_env_YFLAGS_value=
ac_cv_env_build_alias_set=set
ac_cv_env_build_alias_value=x86_64-unknown-linux-gnu
ac_cv_env_host_alias_set=set
ac_cv_env_host_alias_value=x86_64-unknown-linux
ac_cv_env_target_alias_set=set
ac_cv_env_target_alias_value=i686-w64-mingw32
ac_cv_func_alloca_works=yes
ac_cv_func_sbrk=yes
ac_cv_func_setlocale=yes
ac_cv_func_unlink=yes
ac_cv_have_decl_free=yes
ac_cv_have_decl_getenv=yes
ac_cv_have_decl_malloc=yes
ac_cv_have_decl_mempcpy=no
ac_cv_have_decl_realloc=yes
ac_cv_have_decl_stpcpy=yes
ac_cv_have_decl_strstr=yes
ac_cv_have_decl_vsnprintf=yes
ac_cv_header_dlfcn_h=yes
ac_cv_header_errno_h=yes
ac_cv_header_inttypes_h=yes
ac_cv_header_limits_h=yes
ac_cv_header_locale_h=yes
ac_cv_header_memory_h=yes
ac_cv_header_minix_config_h=no
ac_cv_header_stdc=yes
ac_cv_header_stdint_h=yes
ac_cv_header_stdlib_h=yes
ac_cv_header_string_h=yes
ac_cv_header_strings_h=yes
ac_cv_header_sys_stat_h=yes
ac_cv_header_sys_types_h=yes
ac_cv_header_time_h=yes
ac_cv_header_unistd_h=yes
ac_cv_header_windows_h=no
ac_cv_header_zlib_h=yes
ac_cv_host=x86_64-unknown-linux-gnu
ac_cv_lib_lex='none needed'
ac_cv_objext=o
ac_cv_path_EGREP='/usr/sbin/grep -E'
ac_cv_path_FGREP='/usr/sbin/grep -F'
ac_cv_path_GMSGFMT=/usr/sbin/msgfmt
ac_cv_path_GREP=/usr/sbin/grep
ac_cv_path_MSGFMT=/usr/sbin/msgfmt
ac_cv_path_MSGMERGE=/usr/sbin/msgmerge
ac_cv_path_SED=/usr/sbin/sed
ac_cv_path_XGETTEXT=/usr/sbin/xgettext
ac_cv_path_mkdir=/usr/sbin/mkdir
ac_cv_prog_AR=ar
ac_cv_prog_AWK=gawk
ac_cv_prog_CC=arm-linux-androideabi-gcc
ac_cv_prog_CPP='arm-linux-androideabi-gcc -E'
ac_cv_prog_LEX=flex
ac_cv_prog_OBJDUMP=objdump
ac_cv_prog_RANLIB=ranlib
ac_cv_prog_STRIP=strip
ac_cv_prog_YACC='bison -y'
ac_cv_prog_ac_ct_STRIP=strip
ac_cv_prog_cc_c89=
ac_cv_prog_cc_g=yes
ac_cv_prog_lex_root=lex.yy
ac_cv_prog_lex_yytext_pointer=no
ac_cv_prog_make_make_set=yes
ac_cv_safe_to_define___extensions__=yes
ac_cv_search_dlopen='none required'
ac_cv_search_strerror='none required'
ac_cv_search_zlibVersion=-lz
ac_cv_sys_file_offset_bits=unknown
ac_cv_sys_large_files=unknown
ac_cv_sys_largefile_CC=no
ac_cv_target=i686-w64-mingw32
ac_cv_working_alloca_h=yes
am_cv_CC_dependencies_compiler_type=gcc3
am_cv_val_LC_MESSAGES=yes
gas_cv_assert_ok=yes
gas_cv_decl_getopt_unistd_h=yes
gas_cv_decl_needed_environ=no
gas_cv_decl_needed_errno=no
gas_cv_decl_needed_ffs=no
gas_cv_decl_needed_free=no
gas_cv_decl_needed_malloc=no
gas_cv_decl_needed_sbrk=no
gas_cv_decl_needed_strstr=no
gas_cv_have_sys_stat_type_member_st_mtim_tv_nsec=no
gas_cv_have_sys_stat_type_member_st_mtim_tv_sec=no
gas_cv_have_time_type_member_tm_gmtoff=yes
gcc_cv_header_string=yes
lt_cv_archive_cmds_need_lc=no
lt_cv_deplibs_check_method=pass_all
lt_cv_file_magic_cmd='$MAGIC_CMD'
lt_cv_file_magic_test_file=
lt_cv_ld_reload_flag=-r
lt_cv_nm_interface='BSD nm'
lt_cv_objdir=.libs
lt_cv_path_LD=/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld
lt_cv_path_NM=nm
lt_cv_prog_compiler_c_o=yes
lt_cv_prog_compiler_pic_works=yes
lt_cv_prog_compiler_rtti_exceptions=no
lt_cv_prog_compiler_static_works=yes
lt_cv_prog_gnu_ld=yes
lt_cv_shlibpath_overrides_runpath=yes
lt_cv_sys_global_symbol_pipe='sed -n -e '\''s/^.*[	 ]\([ABCDGIRSTW][ABCDGIRSTW]*\)[	 ][	 ]*\([_A-Za-z][_A-Za-z0-9]*\)$/\1 \2 \2/p'\'''
lt_cv_sys_global_symbol_to_c_name_address='sed -n -e '\''s/^: \([^ ]*\) $/  {\"\1\", (void *) 0},/p'\'' -e '\''s/^[ABCDGIRSTW]* \([^ ]*\) \([^ ]*\)$/  {"\2", (void *) \&\2},/p'\'''
lt_cv_sys_global_symbol_to_c_name_address_lib_prefix='sed -n -e '\''s/^: \([^ ]*\) $/  {\"\1\", (void *) 0},/p'\'' -e '\''s/^[ABCDGIRSTW]* \([^ ]*\) \(lib[^ ]*\)$/  {"\2", (void *) \&\2},/p'\'' -e '\''s/^[ABCDGIRSTW]* \([^ ]*\) \([^ ]*\)$/  {"lib\2", (void *) \&\2},/p'\'''
lt_cv_sys_global_symbol_to_cdecl='sed -n -e '\''s/^T .* \(.*\)$/extern int \1();/p'\'' -e '\''s/^[ABCDGIRSTW]* .* \(.*\)$/extern char \1;/p'\'''
lt_cv_sys_max_cmd_len=1572864

## ----------------- ##
## Output variables. ##
## ----------------- ##

ACLOCAL='${SHELL} /tmp/mingw-w64-binutils/src/binutils-2.25.1/missing --run aclocal-1.11'
ALLOCA=''
AMDEPBACKSLASH='\'
AMDEP_FALSE='#'
AMDEP_TRUE=''
AMTAR='${SHELL} /tmp/mingw-w64-binutils/src/binutils-2.25.1/missing --run tar'
AR='ar'
AUTOCONF='${SHELL} /tmp/mingw-w64-binutils/src/binutils-2.25.1/missing --run autoconf'
AUTOHEADER='${SHELL} /tmp/mingw-w64-binutils/src/binutils-2.25.1/missing --run autoheader'
AUTOMAKE='${SHELL} /tmp/mingw-w64-binutils/src/binutils-2.25.1/missing --run automake-1.11'
AWK='gawk'
CATALOGS=''
CATOBJEXT=''
CC='arm-linux-androideabi-gcc'
CCDEPMODE='depmode=gcc3'
CFLAGS=''
CPP='arm-linux-androideabi-gcc -E'
CPPFLAGS=''
CYGPATH_W='echo'
DATADIRNAME=''
DEFS='-DHAVE_CONFIG_H'
DEPDIR='.deps'
DSYMUTIL=''
DUMPBIN=''
ECHO_C=''
ECHO_N='-n'
ECHO_T=''
EGREP='/usr/sbin/grep -E'
EXEEXT=''
FGREP='/usr/sbin/grep -F'
GDBINIT='.gdbinit'
GENCAT=''
GENINSRC_NEVER_FALSE=''
GENINSRC_NEVER_TRUE='#'
GMSGFMT='/usr/sbin/msgfmt'
GREP='/usr/sbin/grep'
INCINTL=''
INSTALL_DATA='/usr/bin/install -c -m 644'
INSTALL_PROGRAM='/usr/bin/install -c'
INSTALL_SCRIPT='/usr/bin/install -c'
INSTALL_STRIP_PROGRAM='$(install_sh) -c -s'
INSTOBJEXT=''
LD='/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld -m elf_i386'
LDFLAGS='-static-libstdc++ -static-libgcc '
LEX='flex'
LEXLIB=''
LEX_OUTPUT_ROOT='lex.yy'
LIBINTL=''
LIBINTL_DEP=''
LIBM=''
LIBOBJS=''
LIBS='-lz '
LIBTOOL='$(SHELL) $(top_builddir)/libtool'
LIPO=''
LN_S='ln -s'
LTLIBOBJS=''
MAINT='#'
MAINTAINER_MODE_FALSE=''
MAINTAINER_MODE_TRUE='#'
MAKEINFO='makeinfo --split-size=5000000'
MKDIR_P='/usr/sbin/mkdir -p'
MKINSTALLDIRS='/tmp/mingw-w64-binutils/src/binutils-2.25.1/gas/../mkinstalldirs'
MSGFMT='/usr/sbin/msgfmt'
MSGMERGE='/usr/sbin/msgmerge'
NM='nm'
NMEDIT=''
NO_WERROR=''
OBJDUMP='objdump'
OBJEXT='o'
OPCODES_LIB='../opcodes/libopcodes.la'
OTOOL64=''
OTOOL=''
PACKAGE='gas'
PACKAGE_BUGREPORT=''
PACKAGE_NAME='gas'
PACKAGE_STRING='gas 2.25.1'
PACKAGE_TARNAME='gas'
PACKAGE_URL=''
PACKAGE_VERSION='2.25.1'
PATH_SEPARATOR=':'
POSUB=''
RANLIB='ranlib'
SED='/usr/sbin/sed'
SET_MAKE=''
SHELL='/bin/sh'
STRIP='strip'
USE_NLS='no'
VERSION='2.25.1'
WARN_CFLAGS='-W -Wall -Wstrict-prototypes -Wmissing-prototypes -Wshadow'
XGETTEXT='/usr/sbin/xgettext'
YACC='bison -y'
YFLAGS=''
ac_ct_CC=''
ac_ct_DUMPBIN=''
am__EXEEXT_FALSE=''
am__EXEEXT_TRUE='#'
am__fastdepCC_FALSE='#'
am__fastdepCC_TRUE=''
am__include='include'
am__isrc=' -I$(srcdir)'
am__leading_dot='.'
am__quote=''
am__tar='${AMTAR} chof - "$$tardir"'
am__untar='${AMTAR} xf -'
atof='ieee'
bindir='${exec_prefix}/bin'
build='x86_64-unknown-linux-gnu'
build_alias='x86_64-unknown-linux-gnu'
build_cpu='x86_64'
build_os='linux-gnu'
build_vendor='unknown'
cgen_cpu_prefix=''
datadir='${datarootdir}'
datarootdir='${prefix}/share'
docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
dvidir='${docdir}'
exec_prefix='${prefix}'
extra_objects=''
host='x86_64-unknown-linux-gnu'
host_alias='x86_64-unknown-linux'
host_cpu='x86_64'
host_os='linux-gnu'
host_vendor='unknown'
htmldir='${docdir}'
includedir='${prefix}/include'
infodir='/usr/share/info/i686-w64-mingw32'
install_sh='${SHELL} /tmp/mingw-w64-binutils/src/binutils-2.25.1/install-sh'
install_tooldir='install-exec-tooldir'
libdir='${exec_prefix}/lib'
libexecdir='${exec_prefix}/libexec'
localedir='${datarootdir}/locale'
localstatedir='${prefix}/var'
mandir='${datarootdir}/man'
mkdir_p='/usr/sbin/mkdir -p'
obj_format='coff'
oldincludedir='/usr/include'
pdfdir='${docdir}'
prefix='/usr'
program_transform_name='s&^&i686-w64-mingw32-&'
psdir='${docdir}'
sbindir='${exec_prefix}/sbin'
sharedstatedir='${prefix}/com'
sysconfdir='${prefix}/etc'
target='i686-w64-mingw32'
target_alias='i686-w64-mingw32'
target_cpu='i686'
target_cpu_type='i386'
target_os='mingw32'
target_vendor='w64'
te_file='pe'

## ----------- ##
## confdefs.h. ##
## ----------- ##

/* confdefs.h */
#define PACKAGE_NAME "gas"
#define PACKAGE_TARNAME "gas"
#define PACKAGE_VERSION "2.25.1"
#define PACKAGE_STRING "gas 2.25.1"
#define PACKAGE_BUGREPORT ""
#define PACKAGE_URL ""
#define PACKAGE "gas"
#define VERSION "2.25.1"
#define STDC_HEADERS 1
#define HAVE_SYS_TYPES_H 1
#define HAVE_SYS_STAT_H 1
#define HAVE_STDLIB_H 1
#define HAVE_STRING_H 1
#define HAVE_MEMORY_H 1
#define HAVE_STRINGS_H 1
#define HAVE_INTTYPES_H 1
#define HAVE_STDINT_H 1
#define HAVE_UNISTD_H 1
#define __EXTENSIONS__ 1
#define _ALL_SOURCE 1
#define _GNU_SOURCE 1
#define _POSIX_PTHREAD_SEMANTICS 1
#define _TANDEM_SOURCE 1
#define HAVE_DLFCN_H 1
#define LT_OBJDIR ".libs/"
#define HAVE_DLFCN_H 1
#define ENABLE_CHECKING 1
#define DEFAULT_ARCH "i386"
#define I386COFF 1
#define EMULATIONS 
#define DEFAULT_EMULATION ""
#define TARGET_ALIAS "i686-w64-mingw32"
#define TARGET_CANONICAL "i686-w64-mingw32"
#define TARGET_CPU "i686"
#define TARGET_VENDOR "w64"
#define TARGET_OS "mingw32"
#define HAVE_STRING_H 1
#define HAVE_STDLIB_H 1
#define HAVE_MEMORY_H 1
#define HAVE_STRINGS_H 1
#define HAVE_UNISTD_H 1
#define HAVE_ERRNO_H 1
#define HAVE_SYS_TYPES_H 1
#define HAVE_LIMITS_H 1
#define HAVE_LOCALE_H 1
#define HAVE_TIME_H 1
#define HAVE_SYS_STAT_H 1
#define STRING_WITH_STRINGS 1
#define CROSS_COMPILE 1
#define HAVE_ALLOCA_H 1
#define HAVE_ALLOCA 1
#define HAVE_UNLINK 1
#define HAVE_SBRK 1
#define HAVE_SETLOCALE 1
#define HAVE_LC_MESSAGES 1
#define HAVE_DECL_GETOPT 1
#define HAVE_DECL_FREE 1
#define HAVE_DECL_GETENV 1
#define HAVE_DECL_MALLOC 1
#define HAVE_DECL_MEMPCPY 0
#define HAVE_DECL_REALLOC 1
#define HAVE_DECL_STPCPY 1
#define HAVE_DECL_STRSTR 1
#define HAVE_DECL_VSNPRINTF 1
#define HAVE_ZLIB_H 1
#define HAVE_TM_GMTOFF 1

configure: exit 0

____
File /tmp/mingw-w64-binutils/src/binutils-i686-w64-mingw32/libiberty/config.log
This file contains any messages produced by compilers while
running configure, to aid debugging if configure makes a mistake.

It was created by configure, which was
generated by GNU Autoconf 2.64.  Invocation command line was

  $ /tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/configure --cache-file=./config.cache --with-gnu-as --with-gnu-ld --with-system-zlib --prefix=/usr --infodir=/usr/share/info/i686-w64-mingw32 --enable-lto --enable-plugins --disable-multilib --disable-nls --disable-werror --program-transform-name=s&^&i686-w64-mingw32-& --disable-option-checking --build=x86_64-unknown-linux-gnu --host=x86_64-unknown-linux --target=i686-w64-mingw32 --srcdir=/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty

## --------- ##
## Platform. ##
## --------- ##

hostname = d5f3793a98c0
uname -m = x86_64
uname -r = 3.13.0-66-generic
uname -s = Linux
uname -v = #108-Ubuntu SMP Wed Oct 7 15:20:27 UTC 2015

/usr/bin/uname -p = unknown
/bin/uname -X     = unknown

/bin/arch              = unknown
/usr/bin/arch -k       = unknown
/usr/convex/getsysinfo = unknown
/usr/bin/hostinfo      = unknown
/bin/machine           = unknown
/usr/bin/oslevel       = unknown
/bin/universe          = unknown

PATH: /tmp/toolchain/bin
PATH: /usr/local/sbin
PATH: /usr/local/bin
PATH: /usr/sbin
PATH: /usr/bin
PATH: /sbin
PATH: /bin


## ----------- ##
## Core tests. ##
## ----------- ##

configure:2224: creating cache ./config.cache
configure:2375: checking whether to enable maintainer-specific portions of Makefiles
configure:2385: result: no
configure:2400: checking for makeinfo
configure:2427: result: makeinfo --split-size=5000000
configure:2467: checking for perl
configure:2483: found /usr/sbin/perl
configure:2494: result: perl
configure:2513: checking build system type
configure:2527: result: x86_64-unknown-linux-gnu
configure:2547: checking host system type
configure:2560: result: x86_64-unknown-linux-gnu
configure:2585: checking for x86_64-unknown-linux-ar
configure:2612: result: ar
configure:2677: checking for x86_64-unknown-linux-ranlib
configure:2704: result: ranlib
configure:2789: checking whether to install libiberty headers and static library
configure:2812: result: no
configure:2814: target_header_dir = 
configure:2826: checking for x86_64-unknown-linux-gcc
configure:2853: result: arm-linux-androideabi-gcc
configure:3122: checking for C compiler version
configure:3131: arm-linux-androideabi-gcc --version >&5
arm-linux-androideabi-gcc (GCC) 4.8
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

configure:3142: $? = 0
configure:3131: arm-linux-androideabi-gcc -v >&5
Using built-in specs.
COLLECT_GCC=arm-linux-androideabi-gcc
COLLECT_LTO_WRAPPER=/tmp/toolchain/bin/../libexec/gcc/arm-linux-androideabi/4.8/lto-wrapper
Target: arm-linux-androideabi
Configured with: /s/ndk-toolchain/src/build/../gcc/gcc-4.8/configure --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --target=arm-linux-androideabi --host=x86_64-linux-gnu --build=x86_64-linux-gnu --with-gnu-as --with-gnu-ld --enable-languages=c,c++ --with-gmp=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpfr=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpc=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-cloog=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-isl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-ppl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --disable-ppl-version-check --disable-cloog-version-check --disable-isl-version-check --enable-cloog-backend=isl --with-host-libstdcxx='-static-libgcc -Wl,-Bstatic,-lstdc++,-Bdynamic -lm' --disable-libssp --enable-threads --disable-nls --disable-libmudflap --disable-libgomp --disable-libstdc__-v3 --disable-sjlj-exceptions --disable-shared --disable-tls --disable-libitm --with-float=soft --with-fpu=vfp --with-arch=armv5te --enable-target-optspace --enable-initfini-array --disable-nls --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --with-sysroot=/tmp/ndk-andrewhsieh/build/toolchain/prefix/sysroot --with-binutils-version=2.25 --with-mpfr-version=3.1.1 --with-mpc-version=1.0.1 --with-gmp-version=5.0.5 --with-gcc-version=4.8 --with-gdb-version=7.7 --with-python=/usr/local/google/home/andrewhsieh/mydroid/ndk/prebuilt/linux-x86_64/bin/python-config.sh --with-gxx-include-dir=/tmp/ndk-andrewhsieh/build/toolchain/prefix/include/c++/4.8 --with-bugurl=http://source.android.com/source/report-bugs.html --enable-languages=c,c++ --disable-bootstrap --enable-plugins --enable-libgomp --enable-gnu-indirect-function --disable-libsanitizer --enable-gold --enable-threads --enable-graphite=yes --with-cloog-version=0.18.0 --with-isl-version=0.11.1 --enable-eh-frame-hdr-for-static --with-arch=armv5te --program-transform-name='s&^&arm-linux-androideabi-&' --enable-gold=default
Thread model: posix
gcc version 4.8 (GCC) 
configure:3142: $? = 0
configure:3131: arm-linux-androideabi-gcc -V >&5
arm-linux-androideabi-gcc: error: unrecognized command line option '-V'
arm-linux-androideabi-gcc: fatal error: no input files
compilation terminated.
configure:3142: $? = 1
configure:3131: arm-linux-androideabi-gcc -qversion >&5
arm-linux-androideabi-gcc: error: unrecognized command line option '-qversion'
arm-linux-androideabi-gcc: fatal error: no input files
compilation terminated.
configure:3142: $? = 1
configure:3158: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:3161: $? = 0
configure:3190: checking for C compiler default output file name
configure:3212: arm-linux-androideabi-gcc   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:3216: $? = 0
configure:3253: result: a.out
configure:3269: checking whether the C compiler works
configure:3297: result: yes
configure:3304: checking whether we are cross compiling
configure:3306: result: yes
configure:3309: checking for suffix of executables
configure:3316: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:3320: $? = 0
configure:3342: result: 
configure:3349: checking for suffix of object files
configure:3371: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:3375: $? = 0
configure:3396: result: o
configure:3400: checking whether we are using the GNU C compiler
configure:3419: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:3419: $? = 0
configure:3428: result: yes
configure:3437: checking whether arm-linux-androideabi-gcc accepts -g
configure:3457: arm-linux-androideabi-gcc -c -g  conftest.c >&5
configure:3457: $? = 0
configure:3498: result: yes
configure:3515: checking for arm-linux-androideabi-gcc option to accept ISO C89
configure:3579: arm-linux-androideabi-gcc  -c   conftest.c >&5
configure:3579: $? = 0
configure:3592: result: none needed
configure:3620: checking for special C compiler options needed for large files
configure:3665: result: no
configure:3671: checking for _FILE_OFFSET_BITS value needed for large files
configure:3696: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:15:3: warning: left shift count >= width of type [enabled by default]
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
   ^
conftest.c:15:3: warning: left shift count >= width of type [enabled by default]
conftest.c:16:10: warning: left shift count >= width of type [enabled by default]
          && LARGE_OFF_T % 2147483647 == 1)
          ^
conftest.c:16:10: warning: left shift count >= width of type [enabled by default]
conftest.c:15:7: error: variably modified 'off_t_is_large' at file scope
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
       ^
configure:3696: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| /* end confdefs.h.  */
| #include <sys/types.h>
|  /* Check that off_t can represent 2**63 - 1 correctly.
|     We can't simply define LARGE_OFF_T to be 9223372036854775807,
|     since some C++ compilers masquerading as C compilers
|     incorrectly reject 9223372036854775807.  */
| #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
|   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
| 		       && LARGE_OFF_T % 2147483647 == 1)
| 		      ? 1 : -1];
| int
| main ()
| {
| 
|   ;
|   return 0;
| }
configure:3720: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:16:3: warning: left shift count >= width of type [enabled by default]
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
   ^
conftest.c:16:3: warning: left shift count >= width of type [enabled by default]
conftest.c:17:10: warning: left shift count >= width of type [enabled by default]
          && LARGE_OFF_T % 2147483647 == 1)
          ^
conftest.c:17:10: warning: left shift count >= width of type [enabled by default]
conftest.c:16:7: error: variably modified 'off_t_is_large' at file scope
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
       ^
configure:3720: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| /* end confdefs.h.  */
| #define _FILE_OFFSET_BITS 64
| #include <sys/types.h>
|  /* Check that off_t can represent 2**63 - 1 correctly.
|     We can't simply define LARGE_OFF_T to be 9223372036854775807,
|     since some C++ compilers masquerading as C compilers
|     incorrectly reject 9223372036854775807.  */
| #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
|   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
| 		       && LARGE_OFF_T % 2147483647 == 1)
| 		      ? 1 : -1];
| int
| main ()
| {
| 
|   ;
|   return 0;
| }
configure:3728: result: unknown
configure:3740: checking for _LARGE_FILES value needed for large files
configure:3765: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:15:3: warning: left shift count >= width of type [enabled by default]
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
   ^
conftest.c:15:3: warning: left shift count >= width of type [enabled by default]
conftest.c:16:10: warning: left shift count >= width of type [enabled by default]
          && LARGE_OFF_T % 2147483647 == 1)
          ^
conftest.c:16:10: warning: left shift count >= width of type [enabled by default]
conftest.c:15:7: error: variably modified 'off_t_is_large' at file scope
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
       ^
configure:3765: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| /* end confdefs.h.  */
| #include <sys/types.h>
|  /* Check that off_t can represent 2**63 - 1 correctly.
|     We can't simply define LARGE_OFF_T to be 9223372036854775807,
|     since some C++ compilers masquerading as C compilers
|     incorrectly reject 9223372036854775807.  */
| #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
|   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
| 		       && LARGE_OFF_T % 2147483647 == 1)
| 		      ? 1 : -1];
| int
| main ()
| {
| 
|   ;
|   return 0;
| }
configure:3789: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:16:3: warning: left shift count >= width of type [enabled by default]
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
   ^
conftest.c:16:3: warning: left shift count >= width of type [enabled by default]
conftest.c:17:10: warning: left shift count >= width of type [enabled by default]
          && LARGE_OFF_T % 2147483647 == 1)
          ^
conftest.c:17:10: warning: left shift count >= width of type [enabled by default]
conftest.c:16:7: error: variably modified 'off_t_is_large' at file scope
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
       ^
configure:3789: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| /* end confdefs.h.  */
| #define _LARGE_FILES 1
| #include <sys/types.h>
|  /* Check that off_t can represent 2**63 - 1 correctly.
|     We can't simply define LARGE_OFF_T to be 9223372036854775807,
|     since some C++ compilers masquerading as C compilers
|     incorrectly reject 9223372036854775807.  */
| #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
|   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
| 		       && LARGE_OFF_T % 2147483647 == 1)
| 		      ? 1 : -1];
| int
| main ()
| {
| 
|   ;
|   return 0;
| }
configure:3797: result: unknown
configure:3816: checking how to run the C preprocessor
configure:3847: arm-linux-androideabi-gcc -E  -O2 conftest.c
configure:3847: $? = 0
configure:3861: arm-linux-androideabi-gcc -E  -O2 conftest.c
conftest.c:9:28: fatal error: ac_nonexistent.h: No such file or directory
 #include <ac_nonexistent.h>
                            ^
compilation terminated.
configure:3861: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| /* end confdefs.h.  */
| #include <ac_nonexistent.h>
configure:3886: result: arm-linux-androideabi-gcc -E
configure:3906: arm-linux-androideabi-gcc -E  -O2 conftest.c
configure:3906: $? = 0
configure:3920: arm-linux-androideabi-gcc -E  -O2 conftest.c
conftest.c:9:28: fatal error: ac_nonexistent.h: No such file or directory
 #include <ac_nonexistent.h>
                            ^
compilation terminated.
configure:3920: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| /* end confdefs.h.  */
| #include <ac_nonexistent.h>
configure:3963: checking whether arm-linux-androideabi-gcc supports -W
configure:3980: arm-linux-androideabi-gcc -c -W  conftest.c >&5
configure:3980: $? = 0
configure:3989: result: yes
configure:3963: checking whether arm-linux-androideabi-gcc supports -Wall
configure:3980: arm-linux-androideabi-gcc -c -Wall  conftest.c >&5
configure:3980: $? = 0
configure:3989: result: yes
configure:3963: checking whether arm-linux-androideabi-gcc supports -Wwrite-strings
configure:3980: arm-linux-androideabi-gcc -c -Wwrite-strings  conftest.c >&5
configure:3980: $? = 0
configure:3989: result: yes
configure:3963: checking whether arm-linux-androideabi-gcc supports -Wc++-compat
configure:3980: arm-linux-androideabi-gcc -c -Wc++-compat  conftest.c >&5
configure:3980: $? = 0
configure:3989: result: yes
configure:3963: checking whether arm-linux-androideabi-gcc supports -Wstrict-prototypes
configure:3980: arm-linux-androideabi-gcc -c -Wstrict-prototypes  conftest.c >&5
conftest.c:11:1: warning: function declaration isn't a prototype [-Wstrict-prototypes]
 main ()
 ^
configure:3980: $? = 0
configure:3989: result: yes
configure:4000: checking whether arm-linux-androideabi-gcc supports -pedantic 
configure:4018: arm-linux-androideabi-gcc -c -pedantic   conftest.c >&5
configure:4018: $? = 0
configure:4026: result: yes
configure:4036: checking whether arm-linux-androideabi-gcc and cc understand -c and -o together
configure:4067: arm-linux-androideabi-gcc -c conftest.c -o conftest2.o >&5
configure:4071: $? = 0
configure:4077: arm-linux-androideabi-gcc -c conftest.c -o conftest2.o >&5
configure:4081: $? = 0
configure:4092: cc -c conftest.c >&5
configure:4096: $? = 0
configure:4104: cc -c conftest.c -o conftest2.o >&5
configure:4108: $? = 0
configure:4114: cc -c conftest.c -o conftest2.o >&5
configure:4118: $? = 0
configure:4136: result: yes
configure:4155: checking for an ANSI C-conforming const
configure:4220: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4220: $? = 0
configure:4227: result: yes
configure:4235: checking for inline
configure:4251: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4251: $? = 0
configure:4259: result: inline
configure:4278: checking for grep that handles long lines and -e
configure:4336: result: /usr/sbin/grep
configure:4341: checking for egrep
configure:4403: result: /usr/sbin/grep -E
configure:4408: checking for ANSI C header files
configure:4428: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4428: $? = 0
configure:4512: result: yes
configure:4525: checking for sys/types.h
configure:4525: arm-linux-androideabi-gcc -E  -O2 conftest.c
configure:4525: $? = 0
configure:4525: result: yes
configure:4525: checking for sys/stat.h
configure:4525: arm-linux-androideabi-gcc -E  -O2 conftest.c
configure:4525: $? = 0
configure:4525: result: yes
configure:4525: checking for stdlib.h
configure:4525: arm-linux-androideabi-gcc -E  -O2 conftest.c
configure:4525: $? = 0
configure:4525: result: yes
configure:4525: checking for string.h
configure:4525: arm-linux-androideabi-gcc -E  -O2 conftest.c
configure:4525: $? = 0
configure:4525: result: yes
configure:4525: checking for memory.h
configure:4525: arm-linux-androideabi-gcc -E  -O2 conftest.c
configure:4525: $? = 0
configure:4525: result: yes
configure:4525: checking for strings.h
configure:4525: arm-linux-androideabi-gcc -E  -O2 conftest.c
configure:4525: $? = 0
configure:4525: result: yes
configure:4525: checking for inttypes.h
configure:4525: arm-linux-androideabi-gcc -E  -O2 conftest.c
configure:4525: $? = 0
configure:4525: result: yes
configure:4525: checking for stdint.h
configure:4525: arm-linux-androideabi-gcc -E  -O2 conftest.c
configure:4525: $? = 0
configure:4525: result: yes
configure:4525: checking for unistd.h
configure:4525: arm-linux-androideabi-gcc -E  -O2 conftest.c
configure:4525: $? = 0
configure:4525: result: yes
configure:4536: checking whether byte ordering is bigendian
configure:4551: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:20:9: error: unknown type name 'not'
         not a universal capable compiler
         ^
conftest.c:20:15: error: expected '=', ',', ';', 'asm' or '__attribute__' before 'universal'
         not a universal capable compiler
               ^
conftest.c:20:15: error: unknown type name 'universal'
configure:4551: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| /* end confdefs.h.  */
| #ifndef __APPLE_CC__
| 	       not a universal capable compiler
| 	     #endif
| 	     typedef int dummy;
| 
configure:4596: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:26:8: error: unknown type name 'bogus'
        bogus endian macros
        ^
conftest.c:26:21: error: expected '=', ',', ';', 'asm' or '__attribute__' before 'macros'
        bogus endian macros
                     ^
configure:4596: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| /* end confdefs.h.  */
| #include <sys/types.h>
| 	     #include <sys/param.h>
| 
| int
| main ()
| {
| #if ! (defined BYTE_ORDER && defined BIG_ENDIAN 		     && defined LITTLE_ENDIAN && BYTE_ORDER && BIG_ENDIAN 		     && LITTLE_ENDIAN)
| 	      bogus endian macros
| 	     #endif
| 
|   ;
|   return 0;
| }
configure:4640: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:25:8: error: unknown type name 'bogus'
        bogus endian macros
        ^
conftest.c:25:21: error: expected '=', ',', ';', 'asm' or '__attribute__' before 'macros'
        bogus endian macros
                     ^
configure:4640: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| /* end confdefs.h.  */
| #include <limits.h>
| 
| int
| main ()
| {
| #if ! (defined _LITTLE_ENDIAN || defined _BIG_ENDIAN)
| 	      bogus endian macros
| 	     #endif
| 
|   ;
|   return 0;
| }
configure:4696: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4696: $? = 0
configure:4742: result: no
configure:4781: checking for a BSD-compatible install
configure:4849: result: /usr/bin/install -c
configure:5008: checking for sys/file.h
configure:5008: arm-linux-androideabi-gcc -E  -O2 conftest.c
configure:5008: $? = 0
configure:5008: result: yes
configure:5008: checking for sys/param.h
configure:5008: arm-linux-androideabi-gcc -E  -O2 conftest.c
configure:5008: $? = 0
configure:5008: result: yes
configure:5008: checking for limits.h
configure:5008: arm-linux-androideabi-gcc -E  -O2 conftest.c
configure:5008: $? = 0
configure:5008: result: yes
configure:5008: checking for stdlib.h
configure:5008: result: yes
configure:5008: checking for malloc.h
configure:5008: arm-linux-androideabi-gcc -E  -O2 conftest.c
configure:5008: $? = 0
configure:5008: result: yes
configure:5008: checking for string.h
configure:5008: result: yes
configure:5008: checking for unistd.h
configure:5008: result: yes
configure:5008: checking for strings.h
configure:5008: result: yes
configure:5008: checking for sys/time.h
configure:5008: arm-linux-androideabi-gcc -E  -O2 conftest.c
configure:5008: $? = 0
configure:5008: result: yes
configure:5008: checking for time.h
configure:5008: arm-linux-androideabi-gcc -E  -O2 conftest.c
configure:5008: $? = 0
configure:5008: result: yes
configure:5008: checking for sys/resource.h
configure:5008: arm-linux-androideabi-gcc -E  -O2 conftest.c
configure:5008: $? = 0
configure:5008: result: yes
configure:5008: checking for sys/stat.h
configure:5008: result: yes
configure:5008: checking for sys/mman.h
configure:5008: arm-linux-androideabi-gcc -E  -O2 conftest.c
configure:5008: $? = 0
configure:5008: result: yes
configure:5008: checking for fcntl.h
configure:5008: arm-linux-androideabi-gcc -E  -O2 conftest.c
configure:5008: $? = 0
configure:5008: result: yes
configure:5008: checking for alloca.h
configure:5008: arm-linux-androideabi-gcc -E  -O2 conftest.c
configure:5008: $? = 0
configure:5008: result: yes
configure:5008: checking for sys/pstat.h
configure:5008: arm-linux-androideabi-gcc -E  -O2 conftest.c
conftest.c:34:23: fatal error: sys/pstat.h: No such file or directory
 #include <sys/pstat.h>
                       ^
compilation terminated.
configure:5008: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| /* end confdefs.h.  */
| #include <sys/pstat.h>
configure:5008: result: no
configure:5008: checking for sys/sysmp.h
configure:5008: arm-linux-androideabi-gcc -E  -O2 conftest.c
conftest.c:34:23: fatal error: sys/sysmp.h: No such file or directory
 #include <sys/sysmp.h>
                       ^
compilation terminated.
configure:5008: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| /* end confdefs.h.  */
| #include <sys/sysmp.h>
configure:5008: result: no
configure:5008: checking for sys/sysinfo.h
configure:5008: arm-linux-androideabi-gcc -E  -O2 conftest.c
configure:5008: $? = 0
configure:5008: result: yes
configure:5008: checking for machine/hal_sysinfo.h
configure:5008: arm-linux-androideabi-gcc -E  -O2 conftest.c
conftest.c:35:33: fatal error: machine/hal_sysinfo.h: No such file or directory
 #include <machine/hal_sysinfo.h>
                                 ^
compilation terminated.
configure:5008: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| /* end confdefs.h.  */
| #include <machine/hal_sysinfo.h>
configure:5008: result: no
configure:5008: checking for sys/table.h
configure:5008: arm-linux-androideabi-gcc -E  -O2 conftest.c
conftest.c:35:23: fatal error: sys/table.h: No such file or directory
 #include <sys/table.h>
                       ^
compilation terminated.
configure:5008: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| /* end confdefs.h.  */
| #include <sys/table.h>
configure:5008: result: no
configure:5008: checking for sys/sysctl.h
configure:5008: arm-linux-androideabi-gcc -E  -O2 conftest.c
conftest.c:35:24: fatal error: sys/sysctl.h: No such file or directory
 #include <sys/sysctl.h>
                        ^
compilation terminated.
configure:5008: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| /* end confdefs.h.  */
| #include <sys/sysctl.h>
configure:5008: result: no
configure:5008: checking for sys/systemcfg.h
configure:5008: arm-linux-androideabi-gcc -E  -O2 conftest.c
conftest.c:35:27: fatal error: sys/systemcfg.h: No such file or directory
 #include <sys/systemcfg.h>
                           ^
compilation terminated.
configure:5008: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| /* end confdefs.h.  */
| #include <sys/systemcfg.h>
configure:5008: result: no
configure:5008: checking for stdint.h
configure:5008: result: yes
configure:5008: checking for stdio_ext.h
configure:5008: arm-linux-androideabi-gcc -E  -O2 conftest.c
conftest.c:36:23: fatal error: stdio_ext.h: No such file or directory
 #include <stdio_ext.h>
                       ^
compilation terminated.
configure:5008: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| #define HAVE_STDINT_H 1
| /* end confdefs.h.  */
| #include <stdio_ext.h>
configure:5008: result: no
configure:5008: checking for process.h
configure:5008: arm-linux-androideabi-gcc -E  -O2 conftest.c
conftest.c:36:21: fatal error: process.h: No such file or directory
 #include <process.h>
                     ^
compilation terminated.
configure:5008: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| #define HAVE_STDINT_H 1
| /* end confdefs.h.  */
| #include <process.h>
configure:5008: result: no
configure:5008: checking for sys/prctl.h
configure:5008: arm-linux-androideabi-gcc -E  -O2 conftest.c
configure:5008: $? = 0
configure:5008: result: yes
configure:5018: checking for sys/wait.h that is POSIX.1 compatible
configure:5044: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5044: $? = 0
configure:5051: result: yes
configure:5059: checking whether time.h and sys/time.h may both be included
configure:5079: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5079: $? = 0
configure:5086: result: yes
configure:5095: checking whether errno must be declared
configure:5111: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5111: $? = 0
configure:5118: result: no
configure:5132: checking size of int
configure:5137: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5137: $? = 0
configure:5137: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:75:12: error: size of array 'test_array' is negative
 static int test_array [1 - 2 * !(((long int) (sizeof (int))) <= 0)];
            ^
configure:5137: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_SYS_PRCTL_H 1
| #define HAVE_SYS_WAIT_H 1
| #define TIME_WITH_SYS_TIME 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static int test_array [1 - 2 * !(((long int) (sizeof (int))) <= 0)];
| test_array [0] = 0
| 
|   ;
|   return 0;
| }
configure:5137: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:75:12: error: size of array 'test_array' is negative
 static int test_array [1 - 2 * !(((long int) (sizeof (int))) <= 1)];
            ^
configure:5137: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_SYS_PRCTL_H 1
| #define HAVE_SYS_WAIT_H 1
| #define TIME_WITH_SYS_TIME 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static int test_array [1 - 2 * !(((long int) (sizeof (int))) <= 1)];
| test_array [0] = 0
| 
|   ;
|   return 0;
| }
configure:5137: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:75:12: error: size of array 'test_array' is negative
 static int test_array [1 - 2 * !(((long int) (sizeof (int))) <= 3)];
            ^
configure:5137: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_SYS_PRCTL_H 1
| #define HAVE_SYS_WAIT_H 1
| #define TIME_WITH_SYS_TIME 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static int test_array [1 - 2 * !(((long int) (sizeof (int))) <= 3)];
| test_array [0] = 0
| 
|   ;
|   return 0;
| }
configure:5137: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5137: $? = 0
configure:5137: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5137: $? = 0
configure:5137: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5137: $? = 0
configure:5152: result: 4
configure:5164: checking for a 64-bit type
configure:5182: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5182: $? = 0
configure:5232: result: uint64_t
configure:5243: checking for intptr_t
configure:5243: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5243: $? = 0
configure:5243: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:77:23: error: expected expression before ')' token
 if (sizeof ((intptr_t)))
                       ^
configure:5243: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_SYS_PRCTL_H 1
| #define HAVE_SYS_WAIT_H 1
| #define TIME_WITH_SYS_TIME 1
| #define SIZEOF_INT 4
| #define UNSIGNED_64BIT_TYPE uint64_t
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| if (sizeof ((intptr_t)))
| 	    return 0;
|   ;
|   return 0;
| }
configure:5243: result: yes
configure:5278: checking for uintptr_t
configure:5278: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5278: $? = 0
configure:5278: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:78:24: error: expected expression before ')' token
 if (sizeof ((uintptr_t)))
                        ^
configure:5278: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_SYS_PRCTL_H 1
| #define HAVE_SYS_WAIT_H 1
| #define TIME_WITH_SYS_TIME 1
| #define SIZEOF_INT 4
| #define UNSIGNED_64BIT_TYPE uint64_t
| #define HAVE_INTPTR_T 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| if (sizeof ((uintptr_t)))
| 	    return 0;
|   ;
|   return 0;
| }
configure:5278: result: yes
configure:5313: checking for ssize_t
configure:5313: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5313: $? = 0
configure:5313: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:79:22: error: expected expression before ')' token
 if (sizeof ((ssize_t)))
                      ^
configure:5313: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_SYS_PRCTL_H 1
| #define HAVE_SYS_WAIT_H 1
| #define TIME_WITH_SYS_TIME 1
| #define SIZEOF_INT 4
| #define UNSIGNED_64BIT_TYPE uint64_t
| #define HAVE_INTPTR_T 1
| #define HAVE_UINTPTR_T 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| if (sizeof ((ssize_t)))
| 	    return 0;
|   ;
|   return 0;
| }
configure:5313: result: yes
configure:5332: checking for pid_t
configure:5332: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5332: $? = 0
configure:5332: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:80:20: error: expected expression before ')' token
 if (sizeof ((pid_t)))
                    ^
configure:5332: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_SYS_PRCTL_H 1
| #define HAVE_SYS_WAIT_H 1
| #define TIME_WITH_SYS_TIME 1
| #define SIZEOF_INT 4
| #define UNSIGNED_64BIT_TYPE uint64_t
| #define HAVE_INTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_UINTPTR_T 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| if (sizeof ((pid_t)))
| 	    return 0;
|   ;
|   return 0;
| }
configure:5332: result: yes
configure:5956: checking for library containing strerror
configure:5990: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:5990: $? = 0
configure:6007: result: none required
configure:6018: checking for asprintf
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for atexit
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for basename
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for bcmp
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
conftest.c:70:6: warning: conflicting types for built-in function 'bcmp' [enabled by default]
 char bcmp ();
      ^
/tmp/cc8BCwZs.o:conftest.c:function main: error: undefined reference to 'bcmp'
collect2: error: ld returned 1 exit status
configure:6018: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_SYS_PRCTL_H 1
| #define HAVE_SYS_WAIT_H 1
| #define TIME_WITH_SYS_TIME 1
| #define SIZEOF_INT 4
| #define UNSIGNED_64BIT_TYPE uint64_t
| #define HAVE_INTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_ASPRINTF 1
| #define HAVE_ATEXIT 1
| #define HAVE_BASENAME 1
| /* end confdefs.h.  */
| /* Define bcmp to an innocuous variant, in case <limits.h> declares bcmp.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define bcmp innocuous_bcmp
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char bcmp (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef bcmp
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char bcmp ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_bcmp || defined __stub___bcmp
| choke me
| #endif
| 
| int
| main ()
| {
| return bcmp ();
|   ;
|   return 0;
| }
configure:6018: result: no
configure:6018: checking for bcopy
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
conftest.c:70:6: warning: conflicting types for built-in function 'bcopy' [enabled by default]
 char bcopy ();
      ^
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for bsearch
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for bzero
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
conftest.c:72:6: warning: conflicting types for built-in function 'bzero' [enabled by default]
 char bzero ();
      ^
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for calloc
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
conftest.c:73:6: warning: conflicting types for built-in function 'calloc' [enabled by default]
 char calloc ();
      ^
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for clock
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for ffs
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
conftest.c:75:6: warning: conflicting types for built-in function 'ffs' [enabled by default]
 char ffs ();
      ^
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for getcwd
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for getpagesize
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for gettimeofday
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for index
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
conftest.c:79:6: warning: conflicting types for built-in function 'index' [enabled by default]
 char index ();
      ^
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for insque
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for memchr
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
conftest.c:81:6: warning: conflicting types for built-in function 'memchr' [enabled by default]
 char memchr ();
      ^
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for memcmp
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
conftest.c:82:6: warning: conflicting types for built-in function 'memcmp' [enabled by default]
 char memcmp ();
      ^
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for memcpy
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
conftest.c:83:6: warning: conflicting types for built-in function 'memcpy' [enabled by default]
 char memcpy ();
      ^
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for memmem
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for memmove
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
conftest.c:85:6: warning: conflicting types for built-in function 'memmove' [enabled by default]
 char memmove ();
      ^
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for mempcpy
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
conftest.c:86:6: warning: conflicting types for built-in function 'mempcpy' [enabled by default]
 char mempcpy ();
      ^
/tmp/cciIPAB1.o:conftest.c:function main: error: undefined reference to 'mempcpy'
collect2: error: ld returned 1 exit status
configure:6018: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_SYS_PRCTL_H 1
| #define HAVE_SYS_WAIT_H 1
| #define TIME_WITH_SYS_TIME 1
| #define SIZEOF_INT 4
| #define UNSIGNED_64BIT_TYPE uint64_t
| #define HAVE_INTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_ASPRINTF 1
| #define HAVE_ATEXIT 1
| #define HAVE_BASENAME 1
| #define HAVE_BCOPY 1
| #define HAVE_BSEARCH 1
| #define HAVE_BZERO 1
| #define HAVE_CALLOC 1
| #define HAVE_CLOCK 1
| #define HAVE_FFS 1
| #define HAVE_GETCWD 1
| #define HAVE_GETPAGESIZE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_INDEX 1
| #define HAVE_INSQUE 1
| #define HAVE_MEMCHR 1
| #define HAVE_MEMCMP 1
| #define HAVE_MEMCPY 1
| #define HAVE_MEMMEM 1
| #define HAVE_MEMMOVE 1
| /* end confdefs.h.  */
| /* Define mempcpy to an innocuous variant, in case <limits.h> declares mempcpy.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define mempcpy innocuous_mempcpy
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char mempcpy (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef mempcpy
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char mempcpy ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_mempcpy || defined __stub___mempcpy
| choke me
| #endif
| 
| int
| main ()
| {
| return mempcpy ();
|   ;
|   return 0;
| }
configure:6018: result: no
configure:6018: checking for memset
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
conftest.c:86:6: warning: conflicting types for built-in function 'memset' [enabled by default]
 char memset ();
      ^
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for mkstemps
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for putenv
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for random
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for rename
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for rindex
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
conftest.c:91:6: warning: conflicting types for built-in function 'rindex' [enabled by default]
 char rindex ();
      ^
/tmp/ccIyW4Ba.o:conftest.c:function main: error: undefined reference to 'rindex'
collect2: error: ld returned 1 exit status
configure:6018: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_SYS_PRCTL_H 1
| #define HAVE_SYS_WAIT_H 1
| #define TIME_WITH_SYS_TIME 1
| #define SIZEOF_INT 4
| #define UNSIGNED_64BIT_TYPE uint64_t
| #define HAVE_INTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_ASPRINTF 1
| #define HAVE_ATEXIT 1
| #define HAVE_BASENAME 1
| #define HAVE_BCOPY 1
| #define HAVE_BSEARCH 1
| #define HAVE_BZERO 1
| #define HAVE_CALLOC 1
| #define HAVE_CLOCK 1
| #define HAVE_FFS 1
| #define HAVE_GETCWD 1
| #define HAVE_GETPAGESIZE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_INDEX 1
| #define HAVE_INSQUE 1
| #define HAVE_MEMCHR 1
| #define HAVE_MEMCMP 1
| #define HAVE_MEMCPY 1
| #define HAVE_MEMMEM 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKSTEMPS 1
| #define HAVE_PUTENV 1
| #define HAVE_RANDOM 1
| #define HAVE_RENAME 1
| /* end confdefs.h.  */
| /* Define rindex to an innocuous variant, in case <limits.h> declares rindex.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define rindex innocuous_rindex
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char rindex (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef rindex
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char rindex ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_rindex || defined __stub___rindex
| choke me
| #endif
| 
| int
| main ()
| {
| return rindex ();
|   ;
|   return 0;
| }
configure:6018: result: no
configure:6018: checking for setenv
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for snprintf
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
conftest.c:92:6: warning: conflicting types for built-in function 'snprintf' [enabled by default]
 char snprintf ();
      ^
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for sigsetmask
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for stpcpy
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
conftest.c:94:6: warning: conflicting types for built-in function 'stpcpy' [enabled by default]
 char stpcpy ();
      ^
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for stpncpy
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
conftest.c:95:6: warning: conflicting types for built-in function 'stpncpy' [enabled by default]
 char stpncpy ();
      ^
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for strcasecmp
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
conftest.c:96:6: warning: conflicting types for built-in function 'strcasecmp' [enabled by default]
 char strcasecmp ();
      ^
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for strchr
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
conftest.c:97:6: warning: conflicting types for built-in function 'strchr' [enabled by default]
 char strchr ();
      ^
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for strdup
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
conftest.c:98:6: warning: conflicting types for built-in function 'strdup' [enabled by default]
 char strdup ();
      ^
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for strncasecmp
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
conftest.c:99:6: warning: conflicting types for built-in function 'strncasecmp' [enabled by default]
 char strncasecmp ();
      ^
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for strndup
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
conftest.c:100:6: warning: conflicting types for built-in function 'strndup' [enabled by default]
 char strndup ();
      ^
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for strnlen
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for strrchr
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
conftest.c:102:6: warning: conflicting types for built-in function 'strrchr' [enabled by default]
 char strrchr ();
      ^
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for strstr
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
conftest.c:103:6: warning: conflicting types for built-in function 'strstr' [enabled by default]
 char strstr ();
      ^
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for strtod
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for strtol
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for strtoul
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for strverscmp
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
/tmp/cciSuRc5.o:conftest.c:function main: error: undefined reference to 'strverscmp'
collect2: error: ld returned 1 exit status
configure:6018: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_SYS_PRCTL_H 1
| #define HAVE_SYS_WAIT_H 1
| #define TIME_WITH_SYS_TIME 1
| #define SIZEOF_INT 4
| #define UNSIGNED_64BIT_TYPE uint64_t
| #define HAVE_INTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_ASPRINTF 1
| #define HAVE_ATEXIT 1
| #define HAVE_BASENAME 1
| #define HAVE_BCOPY 1
| #define HAVE_BSEARCH 1
| #define HAVE_BZERO 1
| #define HAVE_CALLOC 1
| #define HAVE_CLOCK 1
| #define HAVE_FFS 1
| #define HAVE_GETCWD 1
| #define HAVE_GETPAGESIZE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_INDEX 1
| #define HAVE_INSQUE 1
| #define HAVE_MEMCHR 1
| #define HAVE_MEMCMP 1
| #define HAVE_MEMCPY 1
| #define HAVE_MEMMEM 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKSTEMPS 1
| #define HAVE_PUTENV 1
| #define HAVE_RANDOM 1
| #define HAVE_RENAME 1
| #define HAVE_SETENV 1
| #define HAVE_SNPRINTF 1
| #define HAVE_SIGSETMASK 1
| #define HAVE_STPCPY 1
| #define HAVE_STPNCPY 1
| #define HAVE_STRCASECMP 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRNCASECMP 1
| #define HAVE_STRNDUP 1
| #define HAVE_STRNLEN 1
| #define HAVE_STRRCHR 1
| #define HAVE_STRSTR 1
| #define HAVE_STRTOD 1
| #define HAVE_STRTOL 1
| #define HAVE_STRTOUL 1
| /* end confdefs.h.  */
| /* Define strverscmp to an innocuous variant, in case <limits.h> declares strverscmp.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define strverscmp innocuous_strverscmp
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char strverscmp (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef strverscmp
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char strverscmp ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_strverscmp || defined __stub___strverscmp
| choke me
| #endif
| 
| int
| main ()
| {
| return strverscmp ();
|   ;
|   return 0;
| }
configure:6018: result: no
configure:6018: checking for tmpnam
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for vasprintf
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for vfprintf
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
conftest.c:109:6: warning: conflicting types for built-in function 'vfprintf' [enabled by default]
 char vfprintf ();
      ^
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for vprintf
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
conftest.c:110:6: warning: conflicting types for built-in function 'vprintf' [enabled by default]
 char vprintf ();
      ^
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for vsnprintf
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
conftest.c:111:6: warning: conflicting types for built-in function 'vsnprintf' [enabled by default]
 char vsnprintf ();
      ^
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for vsprintf
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
conftest.c:112:6: warning: conflicting types for built-in function 'vsprintf' [enabled by default]
 char vsprintf ();
      ^
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for waitpid
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6018: $? = 0
configure:6018: result: yes
configure:6018: checking for setproctitle
configure:6018: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
/tmp/ccISzX2A.o:conftest.c:function main: error: undefined reference to 'setproctitle'
collect2: error: ld returned 1 exit status
configure:6018: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_SYS_PRCTL_H 1
| #define HAVE_SYS_WAIT_H 1
| #define TIME_WITH_SYS_TIME 1
| #define SIZEOF_INT 4
| #define UNSIGNED_64BIT_TYPE uint64_t
| #define HAVE_INTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_ASPRINTF 1
| #define HAVE_ATEXIT 1
| #define HAVE_BASENAME 1
| #define HAVE_BCOPY 1
| #define HAVE_BSEARCH 1
| #define HAVE_BZERO 1
| #define HAVE_CALLOC 1
| #define HAVE_CLOCK 1
| #define HAVE_FFS 1
| #define HAVE_GETCWD 1
| #define HAVE_GETPAGESIZE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_INDEX 1
| #define HAVE_INSQUE 1
| #define HAVE_MEMCHR 1
| #define HAVE_MEMCMP 1
| #define HAVE_MEMCPY 1
| #define HAVE_MEMMEM 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKSTEMPS 1
| #define HAVE_PUTENV 1
| #define HAVE_RANDOM 1
| #define HAVE_RENAME 1
| #define HAVE_SETENV 1
| #define HAVE_SNPRINTF 1
| #define HAVE_SIGSETMASK 1
| #define HAVE_STPCPY 1
| #define HAVE_STPNCPY 1
| #define HAVE_STRCASECMP 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRNCASECMP 1
| #define HAVE_STRNDUP 1
| #define HAVE_STRNLEN 1
| #define HAVE_STRRCHR 1
| #define HAVE_STRSTR 1
| #define HAVE_STRTOD 1
| #define HAVE_STRTOL 1
| #define HAVE_STRTOUL 1
| #define HAVE_TMPNAM 1
| #define HAVE_VASPRINTF 1
| #define HAVE_VFPRINTF 1
| #define HAVE_VPRINTF 1
| #define HAVE_VSNPRINTF 1
| #define HAVE_VSPRINTF 1
| #define HAVE_WAITPID 1
| /* end confdefs.h.  */
| /* Define setproctitle to an innocuous variant, in case <limits.h> declares setproctitle.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define setproctitle innocuous_setproctitle
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char setproctitle (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef setproctitle
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char setproctitle ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_setproctitle || defined __stub___setproctitle
| choke me
| #endif
| 
| int
| main ()
| {
| return setproctitle ();
|   ;
|   return 0;
| }
configure:6018: result: no
configure:6036: checking whether alloca needs Cray hooks
configure:6059: result: no
configure:6077: checking stack direction for C alloca
configure:6114: result: 0
configure:6124: checking for vfork.h
configure:6124: arm-linux-androideabi-gcc -E  -O2 conftest.c
conftest.c:92:19: fatal error: vfork.h: No such file or directory
 #include <vfork.h>
                   ^
compilation terminated.
configure:6124: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_SYS_PRCTL_H 1
| #define HAVE_SYS_WAIT_H 1
| #define TIME_WITH_SYS_TIME 1
| #define SIZEOF_INT 4
| #define UNSIGNED_64BIT_TYPE uint64_t
| #define HAVE_INTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_ASPRINTF 1
| #define HAVE_ATEXIT 1
| #define HAVE_BASENAME 1
| #define HAVE_BCOPY 1
| #define HAVE_BSEARCH 1
| #define HAVE_BZERO 1
| #define HAVE_CALLOC 1
| #define HAVE_CLOCK 1
| #define HAVE_FFS 1
| #define HAVE_GETCWD 1
| #define HAVE_GETPAGESIZE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_INDEX 1
| #define HAVE_INSQUE 1
| #define HAVE_MEMCHR 1
| #define HAVE_MEMCMP 1
| #define HAVE_MEMCPY 1
| #define HAVE_MEMMEM 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKSTEMPS 1
| #define HAVE_PUTENV 1
| #define HAVE_RANDOM 1
| #define HAVE_RENAME 1
| #define HAVE_SETENV 1
| #define HAVE_SNPRINTF 1
| #define HAVE_SIGSETMASK 1
| #define HAVE_STPCPY 1
| #define HAVE_STPNCPY 1
| #define HAVE_STRCASECMP 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRNCASECMP 1
| #define HAVE_STRNDUP 1
| #define HAVE_STRNLEN 1
| #define HAVE_STRRCHR 1
| #define HAVE_STRSTR 1
| #define HAVE_STRTOD 1
| #define HAVE_STRTOL 1
| #define HAVE_STRTOUL 1
| #define HAVE_TMPNAM 1
| #define HAVE_VASPRINTF 1
| #define HAVE_VFPRINTF 1
| #define HAVE_VPRINTF 1
| #define HAVE_VSNPRINTF 1
| #define HAVE_VSPRINTF 1
| #define HAVE_WAITPID 1
| #define STACK_DIRECTION 0
| /* end confdefs.h.  */
| #include <vfork.h>
configure:6124: result: no
configure:6136: checking for fork
configure:6136: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
conftest.c:115:6: warning: conflicting types for built-in function 'fork' [enabled by default]
 char fork ();
      ^
configure:6136: $? = 0
configure:6136: result: yes
configure:6136: checking for vfork
configure:6136: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6136: $? = 0
configure:6136: result: yes
configure:6147: checking for working fork
configure:6179: result: cross
configure:6195: WARNING: result yes guessed because of cross compilation
configure:6200: checking for working vfork
configure:6310: result: yes
configure:6369: checking for _doprnt
configure:6369: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
/tmp/ccs9b08j.o:conftest.c:function main: error: undefined reference to '_doprnt'
collect2: error: ld returned 1 exit status
configure:6369: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_SYS_PRCTL_H 1
| #define HAVE_SYS_WAIT_H 1
| #define TIME_WITH_SYS_TIME 1
| #define SIZEOF_INT 4
| #define UNSIGNED_64BIT_TYPE uint64_t
| #define HAVE_INTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_ASPRINTF 1
| #define HAVE_ATEXIT 1
| #define HAVE_BASENAME 1
| #define HAVE_BCOPY 1
| #define HAVE_BSEARCH 1
| #define HAVE_BZERO 1
| #define HAVE_CALLOC 1
| #define HAVE_CLOCK 1
| #define HAVE_FFS 1
| #define HAVE_GETCWD 1
| #define HAVE_GETPAGESIZE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_INDEX 1
| #define HAVE_INSQUE 1
| #define HAVE_MEMCHR 1
| #define HAVE_MEMCMP 1
| #define HAVE_MEMCPY 1
| #define HAVE_MEMMEM 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKSTEMPS 1
| #define HAVE_PUTENV 1
| #define HAVE_RANDOM 1
| #define HAVE_RENAME 1
| #define HAVE_SETENV 1
| #define HAVE_SNPRINTF 1
| #define HAVE_SIGSETMASK 1
| #define HAVE_STPCPY 1
| #define HAVE_STPNCPY 1
| #define HAVE_STRCASECMP 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRNCASECMP 1
| #define HAVE_STRNDUP 1
| #define HAVE_STRNLEN 1
| #define HAVE_STRRCHR 1
| #define HAVE_STRSTR 1
| #define HAVE_STRTOD 1
| #define HAVE_STRTOL 1
| #define HAVE_STRTOUL 1
| #define HAVE_TMPNAM 1
| #define HAVE_VASPRINTF 1
| #define HAVE_VFPRINTF 1
| #define HAVE_VPRINTF 1
| #define HAVE_VSNPRINTF 1
| #define HAVE_VSPRINTF 1
| #define HAVE_WAITPID 1
| #define STACK_DIRECTION 0
| #define HAVE_FORK 1
| #define HAVE_VFORK 1
| #define HAVE_WORKING_VFORK 1
| #define HAVE_WORKING_FORK 1
| /* end confdefs.h.  */
| /* Define _doprnt to an innocuous variant, in case <limits.h> declares _doprnt.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define _doprnt innocuous__doprnt
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char _doprnt (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef _doprnt
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char _doprnt ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub__doprnt || defined __stub____doprnt
| choke me
| #endif
| 
| int
| main ()
| {
| return _doprnt ();
|   ;
|   return 0;
| }
configure:6369: result: no
configure:6381: checking for sys_errlist
configure:6400: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
/tmp/ccCGEcCy.o:conftest.c:function main: error: undefined reference to 'sys_errlist'
collect2: error: ld returned 1 exit status
configure:6400: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_SYS_PRCTL_H 1
| #define HAVE_SYS_WAIT_H 1
| #define TIME_WITH_SYS_TIME 1
| #define SIZEOF_INT 4
| #define UNSIGNED_64BIT_TYPE uint64_t
| #define HAVE_INTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_ASPRINTF 1
| #define HAVE_ATEXIT 1
| #define HAVE_BASENAME 1
| #define HAVE_BCOPY 1
| #define HAVE_BSEARCH 1
| #define HAVE_BZERO 1
| #define HAVE_CALLOC 1
| #define HAVE_CLOCK 1
| #define HAVE_FFS 1
| #define HAVE_GETCWD 1
| #define HAVE_GETPAGESIZE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_INDEX 1
| #define HAVE_INSQUE 1
| #define HAVE_MEMCHR 1
| #define HAVE_MEMCMP 1
| #define HAVE_MEMCPY 1
| #define HAVE_MEMMEM 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKSTEMPS 1
| #define HAVE_PUTENV 1
| #define HAVE_RANDOM 1
| #define HAVE_RENAME 1
| #define HAVE_SETENV 1
| #define HAVE_SNPRINTF 1
| #define HAVE_SIGSETMASK 1
| #define HAVE_STPCPY 1
| #define HAVE_STPNCPY 1
| #define HAVE_STRCASECMP 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRNCASECMP 1
| #define HAVE_STRNDUP 1
| #define HAVE_STRNLEN 1
| #define HAVE_STRRCHR 1
| #define HAVE_STRSTR 1
| #define HAVE_STRTOD 1
| #define HAVE_STRTOL 1
| #define HAVE_STRTOUL 1
| #define HAVE_TMPNAM 1
| #define HAVE_VASPRINTF 1
| #define HAVE_VFPRINTF 1
| #define HAVE_VPRINTF 1
| #define HAVE_VSNPRINTF 1
| #define HAVE_VSPRINTF 1
| #define HAVE_WAITPID 1
| #define STACK_DIRECTION 0
| #define HAVE_FORK 1
| #define HAVE_VFORK 1
| #define HAVE_WORKING_VFORK 1
| #define HAVE_WORKING_FORK 1
| /* end confdefs.h.  */
| int *p;
| int
| main ()
| {
| extern int sys_errlist []; p = sys_errlist;
|   ;
|   return 0;
| }
configure:6418: result: no
configure:6381: checking for sys_nerr
configure:6400: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
/tmp/ccASiHND.o:conftest.c:function main: error: undefined reference to 'sys_nerr'
collect2: error: ld returned 1 exit status
configure:6400: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_SYS_PRCTL_H 1
| #define HAVE_SYS_WAIT_H 1
| #define TIME_WITH_SYS_TIME 1
| #define SIZEOF_INT 4
| #define UNSIGNED_64BIT_TYPE uint64_t
| #define HAVE_INTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_ASPRINTF 1
| #define HAVE_ATEXIT 1
| #define HAVE_BASENAME 1
| #define HAVE_BCOPY 1
| #define HAVE_BSEARCH 1
| #define HAVE_BZERO 1
| #define HAVE_CALLOC 1
| #define HAVE_CLOCK 1
| #define HAVE_FFS 1
| #define HAVE_GETCWD 1
| #define HAVE_GETPAGESIZE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_INDEX 1
| #define HAVE_INSQUE 1
| #define HAVE_MEMCHR 1
| #define HAVE_MEMCMP 1
| #define HAVE_MEMCPY 1
| #define HAVE_MEMMEM 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKSTEMPS 1
| #define HAVE_PUTENV 1
| #define HAVE_RANDOM 1
| #define HAVE_RENAME 1
| #define HAVE_SETENV 1
| #define HAVE_SNPRINTF 1
| #define HAVE_SIGSETMASK 1
| #define HAVE_STPCPY 1
| #define HAVE_STPNCPY 1
| #define HAVE_STRCASECMP 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRNCASECMP 1
| #define HAVE_STRNDUP 1
| #define HAVE_STRNLEN 1
| #define HAVE_STRRCHR 1
| #define HAVE_STRSTR 1
| #define HAVE_STRTOD 1
| #define HAVE_STRTOL 1
| #define HAVE_STRTOUL 1
| #define HAVE_TMPNAM 1
| #define HAVE_VASPRINTF 1
| #define HAVE_VFPRINTF 1
| #define HAVE_VPRINTF 1
| #define HAVE_VSNPRINTF 1
| #define HAVE_VSPRINTF 1
| #define HAVE_WAITPID 1
| #define STACK_DIRECTION 0
| #define HAVE_FORK 1
| #define HAVE_VFORK 1
| #define HAVE_WORKING_VFORK 1
| #define HAVE_WORKING_FORK 1
| /* end confdefs.h.  */
| int *p;
| int
| main ()
| {
| extern int sys_nerr []; p = sys_nerr;
|   ;
|   return 0;
| }
configure:6418: result: no
configure:6381: checking for sys_siglist
configure:6400: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6400: $? = 0
configure:6410: result: yes
configure:6425: checking for external symbol _system_configuration
configure:6438: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:97:27: fatal error: sys/systemcfg.h: No such file or directory
 #include <sys/systemcfg.h>
                           ^
compilation terminated.
configure:6438: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_SYS_PRCTL_H 1
| #define HAVE_SYS_WAIT_H 1
| #define TIME_WITH_SYS_TIME 1
| #define SIZEOF_INT 4
| #define UNSIGNED_64BIT_TYPE uint64_t
| #define HAVE_INTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_ASPRINTF 1
| #define HAVE_ATEXIT 1
| #define HAVE_BASENAME 1
| #define HAVE_BCOPY 1
| #define HAVE_BSEARCH 1
| #define HAVE_BZERO 1
| #define HAVE_CALLOC 1
| #define HAVE_CLOCK 1
| #define HAVE_FFS 1
| #define HAVE_GETCWD 1
| #define HAVE_GETPAGESIZE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_INDEX 1
| #define HAVE_INSQUE 1
| #define HAVE_MEMCHR 1
| #define HAVE_MEMCMP 1
| #define HAVE_MEMCPY 1
| #define HAVE_MEMMEM 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKSTEMPS 1
| #define HAVE_PUTENV 1
| #define HAVE_RANDOM 1
| #define HAVE_RENAME 1
| #define HAVE_SETENV 1
| #define HAVE_SNPRINTF 1
| #define HAVE_SIGSETMASK 1
| #define HAVE_STPCPY 1
| #define HAVE_STPNCPY 1
| #define HAVE_STRCASECMP 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRNCASECMP 1
| #define HAVE_STRNDUP 1
| #define HAVE_STRNLEN 1
| #define HAVE_STRRCHR 1
| #define HAVE_STRSTR 1
| #define HAVE_STRTOD 1
| #define HAVE_STRTOL 1
| #define HAVE_STRTOUL 1
| #define HAVE_TMPNAM 1
| #define HAVE_VASPRINTF 1
| #define HAVE_VFPRINTF 1
| #define HAVE_VPRINTF 1
| #define HAVE_VSNPRINTF 1
| #define HAVE_VSPRINTF 1
| #define HAVE_WAITPID 1
| #define STACK_DIRECTION 0
| #define HAVE_FORK 1
| #define HAVE_VFORK 1
| #define HAVE_WORKING_VFORK 1
| #define HAVE_WORKING_FORK 1
| #define HAVE_SYS_SIGLIST 1
| /* end confdefs.h.  */
| #include <sys/systemcfg.h>
| int
| main ()
| {
| double x = _system_configuration.physmem;
|   ;
|   return 0;
| }
configure:6445: result: no
configure:6453: checking for __fsetlocking
configure:6453: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
/tmp/cckndai1.o:conftest.c:function main: error: undefined reference to '__fsetlocking'
collect2: error: ld returned 1 exit status
configure:6453: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_SYS_PRCTL_H 1
| #define HAVE_SYS_WAIT_H 1
| #define TIME_WITH_SYS_TIME 1
| #define SIZEOF_INT 4
| #define UNSIGNED_64BIT_TYPE uint64_t
| #define HAVE_INTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_ASPRINTF 1
| #define HAVE_ATEXIT 1
| #define HAVE_BASENAME 1
| #define HAVE_BCOPY 1
| #define HAVE_BSEARCH 1
| #define HAVE_BZERO 1
| #define HAVE_CALLOC 1
| #define HAVE_CLOCK 1
| #define HAVE_FFS 1
| #define HAVE_GETCWD 1
| #define HAVE_GETPAGESIZE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_INDEX 1
| #define HAVE_INSQUE 1
| #define HAVE_MEMCHR 1
| #define HAVE_MEMCMP 1
| #define HAVE_MEMCPY 1
| #define HAVE_MEMMEM 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKSTEMPS 1
| #define HAVE_PUTENV 1
| #define HAVE_RANDOM 1
| #define HAVE_RENAME 1
| #define HAVE_SETENV 1
| #define HAVE_SNPRINTF 1
| #define HAVE_SIGSETMASK 1
| #define HAVE_STPCPY 1
| #define HAVE_STPNCPY 1
| #define HAVE_STRCASECMP 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRNCASECMP 1
| #define HAVE_STRNDUP 1
| #define HAVE_STRNLEN 1
| #define HAVE_STRRCHR 1
| #define HAVE_STRSTR 1
| #define HAVE_STRTOD 1
| #define HAVE_STRTOL 1
| #define HAVE_STRTOUL 1
| #define HAVE_TMPNAM 1
| #define HAVE_VASPRINTF 1
| #define HAVE_VFPRINTF 1
| #define HAVE_VPRINTF 1
| #define HAVE_VSNPRINTF 1
| #define HAVE_VSPRINTF 1
| #define HAVE_WAITPID 1
| #define STACK_DIRECTION 0
| #define HAVE_FORK 1
| #define HAVE_VFORK 1
| #define HAVE_WORKING_VFORK 1
| #define HAVE_WORKING_FORK 1
| #define HAVE_SYS_SIGLIST 1
| /* end confdefs.h.  */
| /* Define __fsetlocking to an innocuous variant, in case <limits.h> declares __fsetlocking.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define __fsetlocking innocuous___fsetlocking
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char __fsetlocking (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef __fsetlocking
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char __fsetlocking ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub___fsetlocking || defined __stub_____fsetlocking
| choke me
| #endif
| 
| int
| main ()
| {
| return __fsetlocking ();
|   ;
|   return 0;
| }
configure:6453: result: no
configure:6453: checking for canonicalize_file_name
configure:6453: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
/tmp/cc2vggh7.o:conftest.c:function main: error: undefined reference to 'canonicalize_file_name'
collect2: error: ld returned 1 exit status
configure:6453: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_SYS_PRCTL_H 1
| #define HAVE_SYS_WAIT_H 1
| #define TIME_WITH_SYS_TIME 1
| #define SIZEOF_INT 4
| #define UNSIGNED_64BIT_TYPE uint64_t
| #define HAVE_INTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_ASPRINTF 1
| #define HAVE_ATEXIT 1
| #define HAVE_BASENAME 1
| #define HAVE_BCOPY 1
| #define HAVE_BSEARCH 1
| #define HAVE_BZERO 1
| #define HAVE_CALLOC 1
| #define HAVE_CLOCK 1
| #define HAVE_FFS 1
| #define HAVE_GETCWD 1
| #define HAVE_GETPAGESIZE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_INDEX 1
| #define HAVE_INSQUE 1
| #define HAVE_MEMCHR 1
| #define HAVE_MEMCMP 1
| #define HAVE_MEMCPY 1
| #define HAVE_MEMMEM 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKSTEMPS 1
| #define HAVE_PUTENV 1
| #define HAVE_RANDOM 1
| #define HAVE_RENAME 1
| #define HAVE_SETENV 1
| #define HAVE_SNPRINTF 1
| #define HAVE_SIGSETMASK 1
| #define HAVE_STPCPY 1
| #define HAVE_STPNCPY 1
| #define HAVE_STRCASECMP 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRNCASECMP 1
| #define HAVE_STRNDUP 1
| #define HAVE_STRNLEN 1
| #define HAVE_STRRCHR 1
| #define HAVE_STRSTR 1
| #define HAVE_STRTOD 1
| #define HAVE_STRTOL 1
| #define HAVE_STRTOUL 1
| #define HAVE_TMPNAM 1
| #define HAVE_VASPRINTF 1
| #define HAVE_VFPRINTF 1
| #define HAVE_VPRINTF 1
| #define HAVE_VSNPRINTF 1
| #define HAVE_VSPRINTF 1
| #define HAVE_WAITPID 1
| #define STACK_DIRECTION 0
| #define HAVE_FORK 1
| #define HAVE_VFORK 1
| #define HAVE_WORKING_VFORK 1
| #define HAVE_WORKING_FORK 1
| #define HAVE_SYS_SIGLIST 1
| /* end confdefs.h.  */
| /* Define canonicalize_file_name to an innocuous variant, in case <limits.h> declares canonicalize_file_name.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define canonicalize_file_name innocuous_canonicalize_file_name
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char canonicalize_file_name (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef canonicalize_file_name
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char canonicalize_file_name ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_canonicalize_file_name || defined __stub___canonicalize_file_name
| choke me
| #endif
| 
| int
| main ()
| {
| return canonicalize_file_name ();
|   ;
|   return 0;
| }
configure:6453: result: no
configure:6453: checking for dup3
configure:6453: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6453: $? = 0
configure:6453: result: yes
configure:6453: checking for getrlimit
configure:6453: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6453: $? = 0
configure:6453: result: yes
configure:6453: checking for getrusage
configure:6453: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6453: $? = 0
configure:6453: result: yes
configure:6453: checking for getsysinfo
configure:6453: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
/tmp/ccUp8glR.o:conftest.c:function main: error: undefined reference to 'getsysinfo'
collect2: error: ld returned 1 exit status
configure:6453: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_SYS_PRCTL_H 1
| #define HAVE_SYS_WAIT_H 1
| #define TIME_WITH_SYS_TIME 1
| #define SIZEOF_INT 4
| #define UNSIGNED_64BIT_TYPE uint64_t
| #define HAVE_INTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_ASPRINTF 1
| #define HAVE_ATEXIT 1
| #define HAVE_BASENAME 1
| #define HAVE_BCOPY 1
| #define HAVE_BSEARCH 1
| #define HAVE_BZERO 1
| #define HAVE_CALLOC 1
| #define HAVE_CLOCK 1
| #define HAVE_FFS 1
| #define HAVE_GETCWD 1
| #define HAVE_GETPAGESIZE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_INDEX 1
| #define HAVE_INSQUE 1
| #define HAVE_MEMCHR 1
| #define HAVE_MEMCMP 1
| #define HAVE_MEMCPY 1
| #define HAVE_MEMMEM 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKSTEMPS 1
| #define HAVE_PUTENV 1
| #define HAVE_RANDOM 1
| #define HAVE_RENAME 1
| #define HAVE_SETENV 1
| #define HAVE_SNPRINTF 1
| #define HAVE_SIGSETMASK 1
| #define HAVE_STPCPY 1
| #define HAVE_STPNCPY 1
| #define HAVE_STRCASECMP 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRNCASECMP 1
| #define HAVE_STRNDUP 1
| #define HAVE_STRNLEN 1
| #define HAVE_STRRCHR 1
| #define HAVE_STRSTR 1
| #define HAVE_STRTOD 1
| #define HAVE_STRTOL 1
| #define HAVE_STRTOUL 1
| #define HAVE_TMPNAM 1
| #define HAVE_VASPRINTF 1
| #define HAVE_VFPRINTF 1
| #define HAVE_VPRINTF 1
| #define HAVE_VSNPRINTF 1
| #define HAVE_VSPRINTF 1
| #define HAVE_WAITPID 1
| #define STACK_DIRECTION 0
| #define HAVE_FORK 1
| #define HAVE_VFORK 1
| #define HAVE_WORKING_VFORK 1
| #define HAVE_WORKING_FORK 1
| #define HAVE_SYS_SIGLIST 1
| #define HAVE_DUP3 1
| #define HAVE_GETRLIMIT 1
| #define HAVE_GETRUSAGE 1
| /* end confdefs.h.  */
| /* Define getsysinfo to an innocuous variant, in case <limits.h> declares getsysinfo.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define getsysinfo innocuous_getsysinfo
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char getsysinfo (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef getsysinfo
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char getsysinfo ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_getsysinfo || defined __stub___getsysinfo
| choke me
| #endif
| 
| int
| main ()
| {
| return getsysinfo ();
|   ;
|   return 0;
| }
configure:6453: result: no
configure:6453: checking for gettimeofday
configure:6453: result: yes
configure:6453: checking for on_exit
configure:6453: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
/tmp/cci4sJHp.o:conftest.c:function main: error: undefined reference to 'on_exit'
collect2: error: ld returned 1 exit status
configure:6453: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_SYS_PRCTL_H 1
| #define HAVE_SYS_WAIT_H 1
| #define TIME_WITH_SYS_TIME 1
| #define SIZEOF_INT 4
| #define UNSIGNED_64BIT_TYPE uint64_t
| #define HAVE_INTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_ASPRINTF 1
| #define HAVE_ATEXIT 1
| #define HAVE_BASENAME 1
| #define HAVE_BCOPY 1
| #define HAVE_BSEARCH 1
| #define HAVE_BZERO 1
| #define HAVE_CALLOC 1
| #define HAVE_CLOCK 1
| #define HAVE_FFS 1
| #define HAVE_GETCWD 1
| #define HAVE_GETPAGESIZE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_INDEX 1
| #define HAVE_INSQUE 1
| #define HAVE_MEMCHR 1
| #define HAVE_MEMCMP 1
| #define HAVE_MEMCPY 1
| #define HAVE_MEMMEM 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKSTEMPS 1
| #define HAVE_PUTENV 1
| #define HAVE_RANDOM 1
| #define HAVE_RENAME 1
| #define HAVE_SETENV 1
| #define HAVE_SNPRINTF 1
| #define HAVE_SIGSETMASK 1
| #define HAVE_STPCPY 1
| #define HAVE_STPNCPY 1
| #define HAVE_STRCASECMP 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRNCASECMP 1
| #define HAVE_STRNDUP 1
| #define HAVE_STRNLEN 1
| #define HAVE_STRRCHR 1
| #define HAVE_STRSTR 1
| #define HAVE_STRTOD 1
| #define HAVE_STRTOL 1
| #define HAVE_STRTOUL 1
| #define HAVE_TMPNAM 1
| #define HAVE_VASPRINTF 1
| #define HAVE_VFPRINTF 1
| #define HAVE_VPRINTF 1
| #define HAVE_VSNPRINTF 1
| #define HAVE_VSPRINTF 1
| #define HAVE_WAITPID 1
| #define STACK_DIRECTION 0
| #define HAVE_FORK 1
| #define HAVE_VFORK 1
| #define HAVE_WORKING_VFORK 1
| #define HAVE_WORKING_FORK 1
| #define HAVE_SYS_SIGLIST 1
| #define HAVE_DUP3 1
| #define HAVE_GETRLIMIT 1
| #define HAVE_GETRUSAGE 1
| #define HAVE_GETTIMEOFDAY 1
| /* end confdefs.h.  */
| /* Define on_exit to an innocuous variant, in case <limits.h> declares on_exit.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define on_exit innocuous_on_exit
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char on_exit (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef on_exit
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char on_exit ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_on_exit || defined __stub___on_exit
| choke me
| #endif
| 
| int
| main ()
| {
| return on_exit ();
|   ;
|   return 0;
| }
configure:6453: result: no
configure:6453: checking for psignal
configure:6453: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6453: $? = 0
configure:6453: result: yes
configure:6453: checking for pstat_getdynamic
configure:6453: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
/tmp/ccQHHTYc.o:conftest.c:function main: error: undefined reference to 'pstat_getdynamic'
collect2: error: ld returned 1 exit status
configure:6453: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_SYS_PRCTL_H 1
| #define HAVE_SYS_WAIT_H 1
| #define TIME_WITH_SYS_TIME 1
| #define SIZEOF_INT 4
| #define UNSIGNED_64BIT_TYPE uint64_t
| #define HAVE_INTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_ASPRINTF 1
| #define HAVE_ATEXIT 1
| #define HAVE_BASENAME 1
| #define HAVE_BCOPY 1
| #define HAVE_BSEARCH 1
| #define HAVE_BZERO 1
| #define HAVE_CALLOC 1
| #define HAVE_CLOCK 1
| #define HAVE_FFS 1
| #define HAVE_GETCWD 1
| #define HAVE_GETPAGESIZE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_INDEX 1
| #define HAVE_INSQUE 1
| #define HAVE_MEMCHR 1
| #define HAVE_MEMCMP 1
| #define HAVE_MEMCPY 1
| #define HAVE_MEMMEM 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKSTEMPS 1
| #define HAVE_PUTENV 1
| #define HAVE_RANDOM 1
| #define HAVE_RENAME 1
| #define HAVE_SETENV 1
| #define HAVE_SNPRINTF 1
| #define HAVE_SIGSETMASK 1
| #define HAVE_STPCPY 1
| #define HAVE_STPNCPY 1
| #define HAVE_STRCASECMP 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRNCASECMP 1
| #define HAVE_STRNDUP 1
| #define HAVE_STRNLEN 1
| #define HAVE_STRRCHR 1
| #define HAVE_STRSTR 1
| #define HAVE_STRTOD 1
| #define HAVE_STRTOL 1
| #define HAVE_STRTOUL 1
| #define HAVE_TMPNAM 1
| #define HAVE_VASPRINTF 1
| #define HAVE_VFPRINTF 1
| #define HAVE_VPRINTF 1
| #define HAVE_VSNPRINTF 1
| #define HAVE_VSPRINTF 1
| #define HAVE_WAITPID 1
| #define STACK_DIRECTION 0
| #define HAVE_FORK 1
| #define HAVE_VFORK 1
| #define HAVE_WORKING_VFORK 1
| #define HAVE_WORKING_FORK 1
| #define HAVE_SYS_SIGLIST 1
| #define HAVE_DUP3 1
| #define HAVE_GETRLIMIT 1
| #define HAVE_GETRUSAGE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_PSIGNAL 1
| /* end confdefs.h.  */
| /* Define pstat_getdynamic to an innocuous variant, in case <limits.h> declares pstat_getdynamic.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define pstat_getdynamic innocuous_pstat_getdynamic
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char pstat_getdynamic (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef pstat_getdynamic
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char pstat_getdynamic ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_pstat_getdynamic || defined __stub___pstat_getdynamic
| choke me
| #endif
| 
| int
| main ()
| {
| return pstat_getdynamic ();
|   ;
|   return 0;
| }
configure:6453: result: no
configure:6453: checking for pstat_getstatic
configure:6453: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
/tmp/ccLQzVil.o:conftest.c:function main: error: undefined reference to 'pstat_getstatic'
collect2: error: ld returned 1 exit status
configure:6453: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_SYS_PRCTL_H 1
| #define HAVE_SYS_WAIT_H 1
| #define TIME_WITH_SYS_TIME 1
| #define SIZEOF_INT 4
| #define UNSIGNED_64BIT_TYPE uint64_t
| #define HAVE_INTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_ASPRINTF 1
| #define HAVE_ATEXIT 1
| #define HAVE_BASENAME 1
| #define HAVE_BCOPY 1
| #define HAVE_BSEARCH 1
| #define HAVE_BZERO 1
| #define HAVE_CALLOC 1
| #define HAVE_CLOCK 1
| #define HAVE_FFS 1
| #define HAVE_GETCWD 1
| #define HAVE_GETPAGESIZE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_INDEX 1
| #define HAVE_INSQUE 1
| #define HAVE_MEMCHR 1
| #define HAVE_MEMCMP 1
| #define HAVE_MEMCPY 1
| #define HAVE_MEMMEM 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKSTEMPS 1
| #define HAVE_PUTENV 1
| #define HAVE_RANDOM 1
| #define HAVE_RENAME 1
| #define HAVE_SETENV 1
| #define HAVE_SNPRINTF 1
| #define HAVE_SIGSETMASK 1
| #define HAVE_STPCPY 1
| #define HAVE_STPNCPY 1
| #define HAVE_STRCASECMP 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRNCASECMP 1
| #define HAVE_STRNDUP 1
| #define HAVE_STRNLEN 1
| #define HAVE_STRRCHR 1
| #define HAVE_STRSTR 1
| #define HAVE_STRTOD 1
| #define HAVE_STRTOL 1
| #define HAVE_STRTOUL 1
| #define HAVE_TMPNAM 1
| #define HAVE_VASPRINTF 1
| #define HAVE_VFPRINTF 1
| #define HAVE_VPRINTF 1
| #define HAVE_VSNPRINTF 1
| #define HAVE_VSPRINTF 1
| #define HAVE_WAITPID 1
| #define STACK_DIRECTION 0
| #define HAVE_FORK 1
| #define HAVE_VFORK 1
| #define HAVE_WORKING_VFORK 1
| #define HAVE_WORKING_FORK 1
| #define HAVE_SYS_SIGLIST 1
| #define HAVE_DUP3 1
| #define HAVE_GETRLIMIT 1
| #define HAVE_GETRUSAGE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_PSIGNAL 1
| /* end confdefs.h.  */
| /* Define pstat_getstatic to an innocuous variant, in case <limits.h> declares pstat_getstatic.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define pstat_getstatic innocuous_pstat_getstatic
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char pstat_getstatic (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef pstat_getstatic
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char pstat_getstatic ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_pstat_getstatic || defined __stub___pstat_getstatic
| choke me
| #endif
| 
| int
| main ()
| {
| return pstat_getstatic ();
|   ;
|   return 0;
| }
configure:6453: result: no
configure:6453: checking for realpath
configure:6453: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6453: $? = 0
configure:6453: result: yes
configure:6453: checking for setrlimit
configure:6453: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6453: $? = 0
configure:6453: result: yes
configure:6453: checking for sbrk
configure:6453: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6453: $? = 0
configure:6453: result: yes
configure:6453: checking for spawnve
configure:6453: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
/tmp/cccPzaWN.o:conftest.c:function main: error: undefined reference to 'spawnve'
collect2: error: ld returned 1 exit status
configure:6453: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_SYS_PRCTL_H 1
| #define HAVE_SYS_WAIT_H 1
| #define TIME_WITH_SYS_TIME 1
| #define SIZEOF_INT 4
| #define UNSIGNED_64BIT_TYPE uint64_t
| #define HAVE_INTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_ASPRINTF 1
| #define HAVE_ATEXIT 1
| #define HAVE_BASENAME 1
| #define HAVE_BCOPY 1
| #define HAVE_BSEARCH 1
| #define HAVE_BZERO 1
| #define HAVE_CALLOC 1
| #define HAVE_CLOCK 1
| #define HAVE_FFS 1
| #define HAVE_GETCWD 1
| #define HAVE_GETPAGESIZE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_INDEX 1
| #define HAVE_INSQUE 1
| #define HAVE_MEMCHR 1
| #define HAVE_MEMCMP 1
| #define HAVE_MEMCPY 1
| #define HAVE_MEMMEM 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKSTEMPS 1
| #define HAVE_PUTENV 1
| #define HAVE_RANDOM 1
| #define HAVE_RENAME 1
| #define HAVE_SETENV 1
| #define HAVE_SNPRINTF 1
| #define HAVE_SIGSETMASK 1
| #define HAVE_STPCPY 1
| #define HAVE_STPNCPY 1
| #define HAVE_STRCASECMP 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRNCASECMP 1
| #define HAVE_STRNDUP 1
| #define HAVE_STRNLEN 1
| #define HAVE_STRRCHR 1
| #define HAVE_STRSTR 1
| #define HAVE_STRTOD 1
| #define HAVE_STRTOL 1
| #define HAVE_STRTOUL 1
| #define HAVE_TMPNAM 1
| #define HAVE_VASPRINTF 1
| #define HAVE_VFPRINTF 1
| #define HAVE_VPRINTF 1
| #define HAVE_VSNPRINTF 1
| #define HAVE_VSPRINTF 1
| #define HAVE_WAITPID 1
| #define STACK_DIRECTION 0
| #define HAVE_FORK 1
| #define HAVE_VFORK 1
| #define HAVE_WORKING_VFORK 1
| #define HAVE_WORKING_FORK 1
| #define HAVE_SYS_SIGLIST 1
| #define HAVE_DUP3 1
| #define HAVE_GETRLIMIT 1
| #define HAVE_GETRUSAGE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_PSIGNAL 1
| #define HAVE_REALPATH 1
| #define HAVE_SETRLIMIT 1
| #define HAVE_SBRK 1
| /* end confdefs.h.  */
| /* Define spawnve to an innocuous variant, in case <limits.h> declares spawnve.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define spawnve innocuous_spawnve
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char spawnve (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef spawnve
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char spawnve ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_spawnve || defined __stub___spawnve
| choke me
| #endif
| 
| int
| main ()
| {
| return spawnve ();
|   ;
|   return 0;
| }
configure:6453: result: no
configure:6453: checking for spawnvpe
configure:6453: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
/tmp/ccsTwfn5.o:conftest.c:function main: error: undefined reference to 'spawnvpe'
collect2: error: ld returned 1 exit status
configure:6453: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_SYS_PRCTL_H 1
| #define HAVE_SYS_WAIT_H 1
| #define TIME_WITH_SYS_TIME 1
| #define SIZEOF_INT 4
| #define UNSIGNED_64BIT_TYPE uint64_t
| #define HAVE_INTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_ASPRINTF 1
| #define HAVE_ATEXIT 1
| #define HAVE_BASENAME 1
| #define HAVE_BCOPY 1
| #define HAVE_BSEARCH 1
| #define HAVE_BZERO 1
| #define HAVE_CALLOC 1
| #define HAVE_CLOCK 1
| #define HAVE_FFS 1
| #define HAVE_GETCWD 1
| #define HAVE_GETPAGESIZE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_INDEX 1
| #define HAVE_INSQUE 1
| #define HAVE_MEMCHR 1
| #define HAVE_MEMCMP 1
| #define HAVE_MEMCPY 1
| #define HAVE_MEMMEM 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKSTEMPS 1
| #define HAVE_PUTENV 1
| #define HAVE_RANDOM 1
| #define HAVE_RENAME 1
| #define HAVE_SETENV 1
| #define HAVE_SNPRINTF 1
| #define HAVE_SIGSETMASK 1
| #define HAVE_STPCPY 1
| #define HAVE_STPNCPY 1
| #define HAVE_STRCASECMP 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRNCASECMP 1
| #define HAVE_STRNDUP 1
| #define HAVE_STRNLEN 1
| #define HAVE_STRRCHR 1
| #define HAVE_STRSTR 1
| #define HAVE_STRTOD 1
| #define HAVE_STRTOL 1
| #define HAVE_STRTOUL 1
| #define HAVE_TMPNAM 1
| #define HAVE_VASPRINTF 1
| #define HAVE_VFPRINTF 1
| #define HAVE_VPRINTF 1
| #define HAVE_VSNPRINTF 1
| #define HAVE_VSPRINTF 1
| #define HAVE_WAITPID 1
| #define STACK_DIRECTION 0
| #define HAVE_FORK 1
| #define HAVE_VFORK 1
| #define HAVE_WORKING_VFORK 1
| #define HAVE_WORKING_FORK 1
| #define HAVE_SYS_SIGLIST 1
| #define HAVE_DUP3 1
| #define HAVE_GETRLIMIT 1
| #define HAVE_GETRUSAGE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_PSIGNAL 1
| #define HAVE_REALPATH 1
| #define HAVE_SETRLIMIT 1
| #define HAVE_SBRK 1
| /* end confdefs.h.  */
| /* Define spawnvpe to an innocuous variant, in case <limits.h> declares spawnvpe.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define spawnvpe innocuous_spawnvpe
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char spawnvpe (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef spawnvpe
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char spawnvpe ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_spawnvpe || defined __stub___spawnvpe
| choke me
| #endif
| 
| int
| main ()
| {
| return spawnvpe ();
|   ;
|   return 0;
| }
configure:6453: result: no
configure:6453: checking for strerror
configure:6453: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6453: $? = 0
configure:6453: result: yes
configure:6453: checking for strsignal
configure:6453: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6453: $? = 0
configure:6453: result: yes
configure:6453: checking for sysconf
configure:6453: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6453: $? = 0
configure:6453: result: yes
configure:6453: checking for sysctl
configure:6453: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
/tmp/cc4UGJek.o:conftest.c:function main: error: undefined reference to 'sysctl'
collect2: error: ld returned 1 exit status
configure:6453: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_SYS_PRCTL_H 1
| #define HAVE_SYS_WAIT_H 1
| #define TIME_WITH_SYS_TIME 1
| #define SIZEOF_INT 4
| #define UNSIGNED_64BIT_TYPE uint64_t
| #define HAVE_INTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_ASPRINTF 1
| #define HAVE_ATEXIT 1
| #define HAVE_BASENAME 1
| #define HAVE_BCOPY 1
| #define HAVE_BSEARCH 1
| #define HAVE_BZERO 1
| #define HAVE_CALLOC 1
| #define HAVE_CLOCK 1
| #define HAVE_FFS 1
| #define HAVE_GETCWD 1
| #define HAVE_GETPAGESIZE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_INDEX 1
| #define HAVE_INSQUE 1
| #define HAVE_MEMCHR 1
| #define HAVE_MEMCMP 1
| #define HAVE_MEMCPY 1
| #define HAVE_MEMMEM 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKSTEMPS 1
| #define HAVE_PUTENV 1
| #define HAVE_RANDOM 1
| #define HAVE_RENAME 1
| #define HAVE_SETENV 1
| #define HAVE_SNPRINTF 1
| #define HAVE_SIGSETMASK 1
| #define HAVE_STPCPY 1
| #define HAVE_STPNCPY 1
| #define HAVE_STRCASECMP 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRNCASECMP 1
| #define HAVE_STRNDUP 1
| #define HAVE_STRNLEN 1
| #define HAVE_STRRCHR 1
| #define HAVE_STRSTR 1
| #define HAVE_STRTOD 1
| #define HAVE_STRTOL 1
| #define HAVE_STRTOUL 1
| #define HAVE_TMPNAM 1
| #define HAVE_VASPRINTF 1
| #define HAVE_VFPRINTF 1
| #define HAVE_VPRINTF 1
| #define HAVE_VSNPRINTF 1
| #define HAVE_VSPRINTF 1
| #define HAVE_WAITPID 1
| #define STACK_DIRECTION 0
| #define HAVE_FORK 1
| #define HAVE_VFORK 1
| #define HAVE_WORKING_VFORK 1
| #define HAVE_WORKING_FORK 1
| #define HAVE_SYS_SIGLIST 1
| #define HAVE_DUP3 1
| #define HAVE_GETRLIMIT 1
| #define HAVE_GETRUSAGE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_PSIGNAL 1
| #define HAVE_REALPATH 1
| #define HAVE_SETRLIMIT 1
| #define HAVE_SBRK 1
| #define HAVE_STRERROR 1
| #define HAVE_STRSIGNAL 1
| #define HAVE_SYSCONF 1
| /* end confdefs.h.  */
| /* Define sysctl to an innocuous variant, in case <limits.h> declares sysctl.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define sysctl innocuous_sysctl
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char sysctl (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef sysctl
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char sysctl ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_sysctl || defined __stub___sysctl
| choke me
| #endif
| 
| int
| main ()
| {
| return sysctl ();
|   ;
|   return 0;
| }
configure:6453: result: no
configure:6453: checking for sysmp
configure:6453: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
/tmp/cc2TOWyv.o:conftest.c:function main: error: undefined reference to 'sysmp'
collect2: error: ld returned 1 exit status
configure:6453: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_SYS_PRCTL_H 1
| #define HAVE_SYS_WAIT_H 1
| #define TIME_WITH_SYS_TIME 1
| #define SIZEOF_INT 4
| #define UNSIGNED_64BIT_TYPE uint64_t
| #define HAVE_INTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_ASPRINTF 1
| #define HAVE_ATEXIT 1
| #define HAVE_BASENAME 1
| #define HAVE_BCOPY 1
| #define HAVE_BSEARCH 1
| #define HAVE_BZERO 1
| #define HAVE_CALLOC 1
| #define HAVE_CLOCK 1
| #define HAVE_FFS 1
| #define HAVE_GETCWD 1
| #define HAVE_GETPAGESIZE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_INDEX 1
| #define HAVE_INSQUE 1
| #define HAVE_MEMCHR 1
| #define HAVE_MEMCMP 1
| #define HAVE_MEMCPY 1
| #define HAVE_MEMMEM 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKSTEMPS 1
| #define HAVE_PUTENV 1
| #define HAVE_RANDOM 1
| #define HAVE_RENAME 1
| #define HAVE_SETENV 1
| #define HAVE_SNPRINTF 1
| #define HAVE_SIGSETMASK 1
| #define HAVE_STPCPY 1
| #define HAVE_STPNCPY 1
| #define HAVE_STRCASECMP 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRNCASECMP 1
| #define HAVE_STRNDUP 1
| #define HAVE_STRNLEN 1
| #define HAVE_STRRCHR 1
| #define HAVE_STRSTR 1
| #define HAVE_STRTOD 1
| #define HAVE_STRTOL 1
| #define HAVE_STRTOUL 1
| #define HAVE_TMPNAM 1
| #define HAVE_VASPRINTF 1
| #define HAVE_VFPRINTF 1
| #define HAVE_VPRINTF 1
| #define HAVE_VSNPRINTF 1
| #define HAVE_VSPRINTF 1
| #define HAVE_WAITPID 1
| #define STACK_DIRECTION 0
| #define HAVE_FORK 1
| #define HAVE_VFORK 1
| #define HAVE_WORKING_VFORK 1
| #define HAVE_WORKING_FORK 1
| #define HAVE_SYS_SIGLIST 1
| #define HAVE_DUP3 1
| #define HAVE_GETRLIMIT 1
| #define HAVE_GETRUSAGE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_PSIGNAL 1
| #define HAVE_REALPATH 1
| #define HAVE_SETRLIMIT 1
| #define HAVE_SBRK 1
| #define HAVE_STRERROR 1
| #define HAVE_STRSIGNAL 1
| #define HAVE_SYSCONF 1
| /* end confdefs.h.  */
| /* Define sysmp to an innocuous variant, in case <limits.h> declares sysmp.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define sysmp innocuous_sysmp
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char sysmp (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef sysmp
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char sysmp ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_sysmp || defined __stub___sysmp
| choke me
| #endif
| 
| int
| main ()
| {
| return sysmp ();
|   ;
|   return 0;
| }
configure:6453: result: no
configure:6453: checking for table
configure:6453: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
/tmp/ccwK4ChF.o:conftest.c:function main: error: undefined reference to 'table'
collect2: error: ld returned 1 exit status
configure:6453: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_SYS_PRCTL_H 1
| #define HAVE_SYS_WAIT_H 1
| #define TIME_WITH_SYS_TIME 1
| #define SIZEOF_INT 4
| #define UNSIGNED_64BIT_TYPE uint64_t
| #define HAVE_INTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_ASPRINTF 1
| #define HAVE_ATEXIT 1
| #define HAVE_BASENAME 1
| #define HAVE_BCOPY 1
| #define HAVE_BSEARCH 1
| #define HAVE_BZERO 1
| #define HAVE_CALLOC 1
| #define HAVE_CLOCK 1
| #define HAVE_FFS 1
| #define HAVE_GETCWD 1
| #define HAVE_GETPAGESIZE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_INDEX 1
| #define HAVE_INSQUE 1
| #define HAVE_MEMCHR 1
| #define HAVE_MEMCMP 1
| #define HAVE_MEMCPY 1
| #define HAVE_MEMMEM 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKSTEMPS 1
| #define HAVE_PUTENV 1
| #define HAVE_RANDOM 1
| #define HAVE_RENAME 1
| #define HAVE_SETENV 1
| #define HAVE_SNPRINTF 1
| #define HAVE_SIGSETMASK 1
| #define HAVE_STPCPY 1
| #define HAVE_STPNCPY 1
| #define HAVE_STRCASECMP 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRNCASECMP 1
| #define HAVE_STRNDUP 1
| #define HAVE_STRNLEN 1
| #define HAVE_STRRCHR 1
| #define HAVE_STRSTR 1
| #define HAVE_STRTOD 1
| #define HAVE_STRTOL 1
| #define HAVE_STRTOUL 1
| #define HAVE_TMPNAM 1
| #define HAVE_VASPRINTF 1
| #define HAVE_VFPRINTF 1
| #define HAVE_VPRINTF 1
| #define HAVE_VSNPRINTF 1
| #define HAVE_VSPRINTF 1
| #define HAVE_WAITPID 1
| #define STACK_DIRECTION 0
| #define HAVE_FORK 1
| #define HAVE_VFORK 1
| #define HAVE_WORKING_VFORK 1
| #define HAVE_WORKING_FORK 1
| #define HAVE_SYS_SIGLIST 1
| #define HAVE_DUP3 1
| #define HAVE_GETRLIMIT 1
| #define HAVE_GETRUSAGE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_PSIGNAL 1
| #define HAVE_REALPATH 1
| #define HAVE_SETRLIMIT 1
| #define HAVE_SBRK 1
| #define HAVE_STRERROR 1
| #define HAVE_STRSIGNAL 1
| #define HAVE_SYSCONF 1
| /* end confdefs.h.  */
| /* Define table to an innocuous variant, in case <limits.h> declares table.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define table innocuous_table
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char table (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef table
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char table ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_table || defined __stub___table
| choke me
| #endif
| 
| int
| main ()
| {
| return table ();
|   ;
|   return 0;
| }
configure:6453: result: no
configure:6453: checking for times
configure:6453: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6453: $? = 0
configure:6453: result: yes
configure:6453: checking for wait3
configure:6453: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6453: $? = 0
configure:6453: result: yes
configure:6453: checking for wait4
configure:6453: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:6453: $? = 0
configure:6453: result: yes
configure:6463: checking whether basename is declared
configure:6463: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:151:10: error: 'basename' undeclared (first use in this function)
   (void) basename;
          ^
conftest.c:151:10: note: each undeclared identifier is reported only once for each function it appears in
configure:6463: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_SYS_PRCTL_H 1
| #define HAVE_SYS_WAIT_H 1
| #define TIME_WITH_SYS_TIME 1
| #define SIZEOF_INT 4
| #define UNSIGNED_64BIT_TYPE uint64_t
| #define HAVE_INTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_ASPRINTF 1
| #define HAVE_ATEXIT 1
| #define HAVE_BASENAME 1
| #define HAVE_BCOPY 1
| #define HAVE_BSEARCH 1
| #define HAVE_BZERO 1
| #define HAVE_CALLOC 1
| #define HAVE_CLOCK 1
| #define HAVE_FFS 1
| #define HAVE_GETCWD 1
| #define HAVE_GETPAGESIZE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_INDEX 1
| #define HAVE_INSQUE 1
| #define HAVE_MEMCHR 1
| #define HAVE_MEMCMP 1
| #define HAVE_MEMCPY 1
| #define HAVE_MEMMEM 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKSTEMPS 1
| #define HAVE_PUTENV 1
| #define HAVE_RANDOM 1
| #define HAVE_RENAME 1
| #define HAVE_SETENV 1
| #define HAVE_SNPRINTF 1
| #define HAVE_SIGSETMASK 1
| #define HAVE_STPCPY 1
| #define HAVE_STPNCPY 1
| #define HAVE_STRCASECMP 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRNCASECMP 1
| #define HAVE_STRNDUP 1
| #define HAVE_STRNLEN 1
| #define HAVE_STRRCHR 1
| #define HAVE_STRSTR 1
| #define HAVE_STRTOD 1
| #define HAVE_STRTOL 1
| #define HAVE_STRTOUL 1
| #define HAVE_TMPNAM 1
| #define HAVE_VASPRINTF 1
| #define HAVE_VFPRINTF 1
| #define HAVE_VPRINTF 1
| #define HAVE_VSNPRINTF 1
| #define HAVE_VSPRINTF 1
| #define HAVE_WAITPID 1
| #define STACK_DIRECTION 0
| #define HAVE_FORK 1
| #define HAVE_VFORK 1
| #define HAVE_WORKING_VFORK 1
| #define HAVE_WORKING_FORK 1
| #define HAVE_SYS_SIGLIST 1
| #define HAVE_DUP3 1
| #define HAVE_GETRLIMIT 1
| #define HAVE_GETRUSAGE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_PSIGNAL 1
| #define HAVE_REALPATH 1
| #define HAVE_SETRLIMIT 1
| #define HAVE_SBRK 1
| #define HAVE_STRERROR 1
| #define HAVE_STRSIGNAL 1
| #define HAVE_SYSCONF 1
| #define HAVE_TIMES 1
| #define HAVE_WAIT3 1
| #define HAVE_WAIT4 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| #ifndef basename
| #ifdef __cplusplus
|   (void) basename((char *) 0);
| #else
|   (void) basename;
| #endif
| #endif
| 
|   ;
|   return 0;
| }
configure:6463: result: no
configure:6473: checking whether ffs is declared
configure:6473: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:6473: $? = 0
configure:6473: result: yes
configure:6483: checking whether asprintf is declared
configure:6483: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:6483: $? = 0
configure:6483: result: yes
configure:6493: checking whether vasprintf is declared
configure:6493: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:6493: $? = 0
configure:6493: result: yes
configure:6503: checking whether snprintf is declared
configure:6503: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:6503: $? = 0
configure:6503: result: yes
configure:6513: checking whether vsnprintf is declared
configure:6513: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:6513: $? = 0
configure:6513: result: yes
configure:6524: checking whether calloc is declared
configure:6524: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:6524: $? = 0
configure:6524: result: yes
configure:6534: checking whether getenv is declared
configure:6534: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:6534: $? = 0
configure:6534: result: yes
configure:6544: checking whether getopt is declared
configure:6544: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:6544: $? = 0
configure:6544: result: yes
configure:6554: checking whether malloc is declared
configure:6554: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:6554: $? = 0
configure:6554: result: yes
configure:6564: checking whether realloc is declared
configure:6564: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:6564: $? = 0
configure:6564: result: yes
configure:6574: checking whether sbrk is declared
configure:6574: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:6574: $? = 0
configure:6574: result: yes
configure:6585: checking whether strverscmp is declared
configure:6585: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:163:10: error: 'strverscmp' undeclared (first use in this function)
   (void) strverscmp;
          ^
conftest.c:163:10: note: each undeclared identifier is reported only once for each function it appears in
configure:6585: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_SYS_PRCTL_H 1
| #define HAVE_SYS_WAIT_H 1
| #define TIME_WITH_SYS_TIME 1
| #define SIZEOF_INT 4
| #define UNSIGNED_64BIT_TYPE uint64_t
| #define HAVE_INTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_ASPRINTF 1
| #define HAVE_ATEXIT 1
| #define HAVE_BASENAME 1
| #define HAVE_BCOPY 1
| #define HAVE_BSEARCH 1
| #define HAVE_BZERO 1
| #define HAVE_CALLOC 1
| #define HAVE_CLOCK 1
| #define HAVE_FFS 1
| #define HAVE_GETCWD 1
| #define HAVE_GETPAGESIZE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_INDEX 1
| #define HAVE_INSQUE 1
| #define HAVE_MEMCHR 1
| #define HAVE_MEMCMP 1
| #define HAVE_MEMCPY 1
| #define HAVE_MEMMEM 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKSTEMPS 1
| #define HAVE_PUTENV 1
| #define HAVE_RANDOM 1
| #define HAVE_RENAME 1
| #define HAVE_SETENV 1
| #define HAVE_SNPRINTF 1
| #define HAVE_SIGSETMASK 1
| #define HAVE_STPCPY 1
| #define HAVE_STPNCPY 1
| #define HAVE_STRCASECMP 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRNCASECMP 1
| #define HAVE_STRNDUP 1
| #define HAVE_STRNLEN 1
| #define HAVE_STRRCHR 1
| #define HAVE_STRSTR 1
| #define HAVE_STRTOD 1
| #define HAVE_STRTOL 1
| #define HAVE_STRTOUL 1
| #define HAVE_TMPNAM 1
| #define HAVE_VASPRINTF 1
| #define HAVE_VFPRINTF 1
| #define HAVE_VPRINTF 1
| #define HAVE_VSNPRINTF 1
| #define HAVE_VSPRINTF 1
| #define HAVE_WAITPID 1
| #define STACK_DIRECTION 0
| #define HAVE_FORK 1
| #define HAVE_VFORK 1
| #define HAVE_WORKING_VFORK 1
| #define HAVE_WORKING_FORK 1
| #define HAVE_SYS_SIGLIST 1
| #define HAVE_DUP3 1
| #define HAVE_GETRLIMIT 1
| #define HAVE_GETRUSAGE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_PSIGNAL 1
| #define HAVE_REALPATH 1
| #define HAVE_SETRLIMIT 1
| #define HAVE_SBRK 1
| #define HAVE_STRERROR 1
| #define HAVE_STRSIGNAL 1
| #define HAVE_SYSCONF 1
| #define HAVE_TIMES 1
| #define HAVE_WAIT3 1
| #define HAVE_WAIT4 1
| #define HAVE_DECL_BASENAME 0
| #define HAVE_DECL_FFS 1
| #define HAVE_DECL_ASPRINTF 1
| #define HAVE_DECL_VASPRINTF 1
| #define HAVE_DECL_SNPRINTF 1
| #define HAVE_DECL_VSNPRINTF 1
| #define HAVE_DECL_CALLOC 1
| #define HAVE_DECL_GETENV 1
| #define HAVE_DECL_GETOPT 1
| #define HAVE_DECL_MALLOC 1
| #define HAVE_DECL_REALLOC 1
| #define HAVE_DECL_SBRK 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| #ifndef strverscmp
| #ifdef __cplusplus
|   (void) strverscmp;
| #else
|   (void) strverscmp;
| #endif
| #endif
| 
|   ;
|   return 0;
| }
configure:6585: result: no
configure:6596: checking whether canonicalize_file_name must be declared
configure:6627: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:143:28: error: 'canonicalize_file_name' undeclared (first use in this function)
 char *(*pfn) = (char *(*)) canonicalize_file_name
                            ^
conftest.c:143:28: note: each undeclared identifier is reported only once for each function it appears in
configure:6627: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME ""
| #define PACKAGE_TARNAME ""
| #define PACKAGE_VERSION ""
| #define PACKAGE_STRING ""
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_MALLOC_H 1
| #define HAVE_STRING_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_TIME_H 1
| #define HAVE_SYS_RESOURCE_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_SYS_MMAN_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_SYS_SYSINFO_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_SYS_PRCTL_H 1
| #define HAVE_SYS_WAIT_H 1
| #define TIME_WITH_SYS_TIME 1
| #define SIZEOF_INT 4
| #define UNSIGNED_64BIT_TYPE uint64_t
| #define HAVE_INTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_UINTPTR_T 1
| #define HAVE_ASPRINTF 1
| #define HAVE_ATEXIT 1
| #define HAVE_BASENAME 1
| #define HAVE_BCOPY 1
| #define HAVE_BSEARCH 1
| #define HAVE_BZERO 1
| #define HAVE_CALLOC 1
| #define HAVE_CLOCK 1
| #define HAVE_FFS 1
| #define HAVE_GETCWD 1
| #define HAVE_GETPAGESIZE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_INDEX 1
| #define HAVE_INSQUE 1
| #define HAVE_MEMCHR 1
| #define HAVE_MEMCMP 1
| #define HAVE_MEMCPY 1
| #define HAVE_MEMMEM 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKSTEMPS 1
| #define HAVE_PUTENV 1
| #define HAVE_RANDOM 1
| #define HAVE_RENAME 1
| #define HAVE_SETENV 1
| #define HAVE_SNPRINTF 1
| #define HAVE_SIGSETMASK 1
| #define HAVE_STPCPY 1
| #define HAVE_STPNCPY 1
| #define HAVE_STRCASECMP 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRNCASECMP 1
| #define HAVE_STRNDUP 1
| #define HAVE_STRNLEN 1
| #define HAVE_STRRCHR 1
| #define HAVE_STRSTR 1
| #define HAVE_STRTOD 1
| #define HAVE_STRTOL 1
| #define HAVE_STRTOUL 1
| #define HAVE_TMPNAM 1
| #define HAVE_VASPRINTF 1
| #define HAVE_VFPRINTF 1
| #define HAVE_VPRINTF 1
| #define HAVE_VSNPRINTF 1
| #define HAVE_VSPRINTF 1
| #define HAVE_WAITPID 1
| #define STACK_DIRECTION 0
| #define HAVE_FORK 1
| #define HAVE_VFORK 1
| #define HAVE_WORKING_VFORK 1
| #define HAVE_WORKING_FORK 1
| #define HAVE_SYS_SIGLIST 1
| #define HAVE_DUP3 1
| #define HAVE_GETRLIMIT 1
| #define HAVE_GETRUSAGE 1
| #define HAVE_GETTIMEOFDAY 1
| #define HAVE_PSIGNAL 1
| #define HAVE_REALPATH 1
| #define HAVE_SETRLIMIT 1
| #define HAVE_SBRK 1
| #define HAVE_STRERROR 1
| #define HAVE_STRSIGNAL 1
| #define HAVE_SYSCONF 1
| #define HAVE_TIMES 1
| #define HAVE_WAIT3 1
| #define HAVE_WAIT4 1
| #define HAVE_DECL_BASENAME 0
| #define HAVE_DECL_FFS 1
| #define HAVE_DECL_ASPRINTF 1
| #define HAVE_DECL_VASPRINTF 1
| #define HAVE_DECL_SNPRINTF 1
| #define HAVE_DECL_VSNPRINTF 1
| #define HAVE_DECL_CALLOC 1
| #define HAVE_DECL_GETENV 1
| #define HAVE_DECL_GETOPT 1
| #define HAVE_DECL_MALLOC 1
| #define HAVE_DECL_REALLOC 1
| #define HAVE_DECL_SBRK 1
| #define HAVE_DECL_STRVERSCMP 0
| /* end confdefs.h.  */
| 
| #include "confdefs.h"
| #include <stdio.h>
| #ifdef HAVE_STRING_H
| #include <string.h>
| #else
| #ifdef HAVE_STRINGS_H
| #include <strings.h>
| #endif
| #endif
| #ifdef HAVE_STDLIB_H
| #include <stdlib.h>
| #endif
| #ifdef HAVE_UNISTD_H
| #include <unistd.h>
| #endif
| int
| main ()
| {
| char *(*pfn) = (char *(*)) canonicalize_file_name
|   ;
|   return 0;
| }
configure:6635: result: yes
configure:6663: checking for stdlib.h
configure:6663: result: yes
configure:6663: checking for unistd.h
configure:6663: result: yes
configure:6675: checking for getpagesize
configure:6675: result: yes
configure:6684: checking for working mmap
configure:6831: result: no
configure:6842: checking for working strncmp
configure:6925: result: yes
configure:7030: updating cache ./config.cache
configure:7068: creating ./config.status

## ---------------------- ##
## Running config.status. ##
## ---------------------- ##

This file was extended by config.status, which was
generated by GNU Autoconf 2.64.  Invocation command line was

  CONFIG_FILES    = 
  CONFIG_HEADERS  = 
  CONFIG_LINKS    = 
  CONFIG_COMMANDS = 
  $ ./config.status 

on d5f3793a98c0

config.status:982: creating Makefile
config.status:982: creating testsuite/Makefile
config.status:982: creating config.h
config.status:1160: executing default commands

## ---------------- ##
## Cache variables. ##
## ---------------- ##

ac_cv_build=x86_64-unknown-linux-gnu
ac_cv_c_bigendian=no
ac_cv_c_compiler_gnu=yes
ac_cv_c_const=yes
ac_cv_c_inline=inline
ac_cv_c_stack_direction=0
ac_cv_env_CC_set=set
ac_cv_env_CC_value=arm-linux-androideabi-gcc
ac_cv_env_CFLAGS_set=set
ac_cv_env_CFLAGS_value=
ac_cv_env_CPPFLAGS_set=set
ac_cv_env_CPPFLAGS_value=
ac_cv_env_CPP_set=
ac_cv_env_CPP_value=
ac_cv_env_LDFLAGS_set=set
ac_cv_env_LDFLAGS_value='-static-libstdc++ -static-libgcc '
ac_cv_env_LIBS_set=
ac_cv_env_LIBS_value=
ac_cv_env_build_alias_set=set
ac_cv_env_build_alias_value=x86_64-unknown-linux-gnu
ac_cv_env_host_alias_set=set
ac_cv_env_host_alias_value=x86_64-unknown-linux
ac_cv_env_target_alias_set=set
ac_cv_env_target_alias_value=i686-w64-mingw32
ac_cv_func___fsetlocking=no
ac_cv_func__doprnt=no
ac_cv_func_asprintf=yes
ac_cv_func_atexit=yes
ac_cv_func_basename=yes
ac_cv_func_bcmp=no
ac_cv_func_bcopy=yes
ac_cv_func_bsearch=yes
ac_cv_func_bzero=yes
ac_cv_func_calloc=yes
ac_cv_func_canonicalize_file_name=no
ac_cv_func_clock=yes
ac_cv_func_dup3=yes
ac_cv_func_ffs=yes
ac_cv_func_fork=yes
ac_cv_func_fork_works=yes
ac_cv_func_getcwd=yes
ac_cv_func_getpagesize=yes
ac_cv_func_getrlimit=yes
ac_cv_func_getrusage=yes
ac_cv_func_getsysinfo=no
ac_cv_func_gettimeofday=yes
ac_cv_func_index=yes
ac_cv_func_insque=yes
ac_cv_func_memchr=yes
ac_cv_func_memcmp=yes
ac_cv_func_memcpy=yes
ac_cv_func_memmem=yes
ac_cv_func_memmove=yes
ac_cv_func_mempcpy=no
ac_cv_func_memset=yes
ac_cv_func_mkstemps=yes
ac_cv_func_mmap_fixed_mapped=no
ac_cv_func_on_exit=no
ac_cv_func_psignal=yes
ac_cv_func_pstat_getdynamic=no
ac_cv_func_pstat_getstatic=no
ac_cv_func_putenv=yes
ac_cv_func_random=yes
ac_cv_func_realpath=yes
ac_cv_func_rename=yes
ac_cv_func_rindex=no
ac_cv_func_sbrk=yes
ac_cv_func_setenv=yes
ac_cv_func_setproctitle=no
ac_cv_func_setrlimit=yes
ac_cv_func_sigsetmask=yes
ac_cv_func_snprintf=yes
ac_cv_func_spawnve=no
ac_cv_func_spawnvpe=no
ac_cv_func_stpcpy=yes
ac_cv_func_stpncpy=yes
ac_cv_func_strcasecmp=yes
ac_cv_func_strchr=yes
ac_cv_func_strdup=yes
ac_cv_func_strerror=yes
ac_cv_func_strncasecmp=yes
ac_cv_func_strncmp_works=yes
ac_cv_func_strndup=yes
ac_cv_func_strnlen=yes
ac_cv_func_strrchr=yes
ac_cv_func_strsignal=yes
ac_cv_func_strstr=yes
ac_cv_func_strtod=yes
ac_cv_func_strtol=yes
ac_cv_func_strtoul=yes
ac_cv_func_strverscmp=no
ac_cv_func_sysconf=yes
ac_cv_func_sysctl=no
ac_cv_func_sysmp=no
ac_cv_func_table=no
ac_cv_func_times=yes
ac_cv_func_tmpnam=yes
ac_cv_func_vasprintf=yes
ac_cv_func_vfork=yes
ac_cv_func_vfork_works=yes
ac_cv_func_vfprintf=yes
ac_cv_func_vprintf=yes
ac_cv_func_vsnprintf=yes
ac_cv_func_vsprintf=yes
ac_cv_func_wait3=yes
ac_cv_func_wait4=yes
ac_cv_func_waitpid=yes
ac_cv_have_decl_asprintf=yes
ac_cv_have_decl_basename_char_p_=no
ac_cv_have_decl_calloc=yes
ac_cv_have_decl_ffs=yes
ac_cv_have_decl_getenv=yes
ac_cv_have_decl_getopt=yes
ac_cv_have_decl_malloc=yes
ac_cv_have_decl_realloc=yes
ac_cv_have_decl_sbrk=yes
ac_cv_have_decl_snprintf=yes
ac_cv_have_decl_strverscmp=no
ac_cv_have_decl_vasprintf=yes
ac_cv_have_decl_vsnprintf=yes
ac_cv_header_alloca_h=yes
ac_cv_header_fcntl_h=yes
ac_cv_header_inttypes_h=yes
ac_cv_header_limits_h=yes
ac_cv_header_machine_hal_sysinfo_h=no
ac_cv_header_malloc_h=yes
ac_cv_header_memory_h=yes
ac_cv_header_process_h=no
ac_cv_header_stdc=yes
ac_cv_header_stdint_h=yes
ac_cv_header_stdio_ext_h=no
ac_cv_header_stdlib_h=yes
ac_cv_header_string_h=yes
ac_cv_header_strings_h=yes
ac_cv_header_sys_file_h=yes
ac_cv_header_sys_mman_h=yes
ac_cv_header_sys_param_h=yes
ac_cv_header_sys_prctl_h=yes
ac_cv_header_sys_pstat_h=no
ac_cv_header_sys_resource_h=yes
ac_cv_header_sys_stat_h=yes
ac_cv_header_sys_sysctl_h=no
ac_cv_header_sys_sysinfo_h=yes
ac_cv_header_sys_sysmp_h=no
ac_cv_header_sys_systemcfg_h=no
ac_cv_header_sys_table_h=no
ac_cv_header_sys_time_h=yes
ac_cv_header_sys_types_h=yes
ac_cv_header_sys_wait_h=yes
ac_cv_header_time=yes
ac_cv_header_time_h=yes
ac_cv_header_unistd_h=yes
ac_cv_header_vfork_h=no
ac_cv_host=x86_64-unknown-linux-gnu
ac_cv_objext=o
ac_cv_os_cray=no
ac_cv_path_EGREP='/usr/sbin/grep -E'
ac_cv_path_GREP=/usr/sbin/grep
ac_cv_prog_AR=ar
ac_cv_prog_CC=arm-linux-androideabi-gcc
ac_cv_prog_CPP='arm-linux-androideabi-gcc -E'
ac_cv_prog_MAKEINFO='makeinfo --split-size=5000000'
ac_cv_prog_PERL=perl
ac_cv_prog_RANLIB=ranlib
ac_cv_prog_cc_arm_linux_androideabi_gcc_c_o=yes
ac_cv_prog_cc_c89=
ac_cv_prog_cc_g=yes
ac_cv_search_strerror='none required'
ac_cv_sizeof_int=4
ac_cv_sys_file_offset_bits=unknown
ac_cv_sys_large_files=unknown
ac_cv_sys_largefile_CC=no
ac_cv_type_intptr_t=yes
ac_cv_type_pid_t=yes
ac_cv_type_ssize_t=yes
ac_cv_type_uintptr_t=yes
acx_cv_prog_cc_pedantic_=yes
acx_cv_prog_cc_warning__W=yes
acx_cv_prog_cc_warning__Wall=yes
acx_cv_prog_cc_warning__Wcpp_compat=yes
acx_cv_prog_cc_warning__Wstrict_prototypes=yes
acx_cv_prog_cc_warning__Wwrite_strings=yes
liberty_cv_uint64=uint64_t
libiberty_cv_decl_needed_canonicalize_file_name=yes
libiberty_cv_declare_errno=no
libiberty_cv_var_sys_errlist=no
libiberty_cv_var_sys_nerr=no
libiberty_cv_var_sys_siglist=yes

## ----------------- ##
## Output variables. ##
## ----------------- ##

AR='ar'
BUILD_INFO='info'
CC='arm-linux-androideabi-gcc'
CFLAGS=''
CHECK='really-check'
CPP='arm-linux-androideabi-gcc -E'
CPPFLAGS=''
DEFS='-DHAVE_CONFIG_H'
ECHO_C=''
ECHO_N='-n'
ECHO_T=''
EGREP='/usr/sbin/grep -E'
EXEEXT=''
GREP='/usr/sbin/grep'
HAVE_PERL=''
INSTALL_DATA='/usr/bin/install -c -m 644'
INSTALL_DEST='libdir'
INSTALL_PROGRAM='/usr/bin/install -c'
INSTALL_SCRIPT='/usr/bin/install -c'
LDFLAGS='-static-libstdc++ -static-libgcc '
LIBOBJS=' ${LIBOBJDIR}./bcmp$U.o ${LIBOBJDIR}./mempcpy$U.o ${LIBOBJDIR}./rindex$U.o ${LIBOBJDIR}./strverscmp$U.o ${LIBOBJDIR}./setproctitle$U.o'
LIBS=''
LTLIBOBJS=' ${LIBOBJDIR}./bcmp$U.lo ${LIBOBJDIR}./mempcpy$U.lo ${LIBOBJDIR}./rindex$U.lo ${LIBOBJDIR}./strverscmp$U.lo ${LIBOBJDIR}./setproctitle$U.lo'
MAINT='#'
MAKEINFO='makeinfo --split-size=5000000'
NOASANFLAG=''
NOTMAINT=''
NO_MINUS_C_MINUS_O=''
OBJEXT='o'
OUTPUT_OPTION='-o $@'
PACKAGE_BUGREPORT=''
PACKAGE_NAME=''
PACKAGE_STRING=''
PACKAGE_TARNAME=''
PACKAGE_URL=''
PACKAGE_VERSION=''
PATH_SEPARATOR=':'
PERL='perl'
PICFLAG=''
RANLIB='ranlib'
SHELL='/bin/sh'
ac_ct_CC=''
ac_libiberty_warn_cflags='-W -Wall -Wwrite-strings -Wc++-compat -Wstrict-prototypes -pedantic '
bindir='${exec_prefix}/bin'
build='x86_64-unknown-linux-gnu'
build_alias='x86_64-unknown-linux-gnu'
build_cpu='x86_64'
build_os='linux-gnu'
build_vendor='unknown'
datadir='${datarootdir}'
datarootdir='${prefix}/share'
docdir='${datarootdir}/doc/${PACKAGE}'
dvidir='${docdir}'
exec_prefix='${prefix}'
host='x86_64-unknown-linux-gnu'
host_alias='x86_64-unknown-linux'
host_cpu='x86_64'
host_os='linux-gnu'
host_vendor='unknown'
htmldir='${docdir}'
includedir='${prefix}/include'
infodir='/usr/share/info/i686-w64-mingw32'
libdir='${exec_prefix}/lib'
libexecdir='${exec_prefix}/libexec'
libiberty_topdir='/tmp/mingw-w64-binutils/src/binutils-2.25.1/libiberty/..'
localedir='${datarootdir}/locale'
localstatedir='${prefix}/var'
mandir='${datarootdir}/man'
oldincludedir='/usr/include'
pdfdir='${docdir}'
pexecute='pex-unix'
prefix='/usr'
program_transform_name='s&^&i686-w64-mingw32-&'
psdir='${docdir}'
sbindir='${exec_prefix}/sbin'
sharedstatedir='${prefix}/com'
sysconfdir='${prefix}/etc'
target_alias='i686-w64-mingw32'
target_header_dir=''

## ------------------- ##
## File substitutions. ##
## ------------------- ##

host_makefile_frag='xhost-mkfrag'

## ----------- ##
## confdefs.h. ##
## ----------- ##

/* confdefs.h */
#define PACKAGE_NAME ""
#define PACKAGE_TARNAME ""
#define PACKAGE_VERSION ""
#define PACKAGE_STRING ""
#define PACKAGE_BUGREPORT ""
#define PACKAGE_URL ""
#define STDC_HEADERS 1
#define HAVE_SYS_TYPES_H 1
#define HAVE_SYS_STAT_H 1
#define HAVE_STDLIB_H 1
#define HAVE_STRING_H 1
#define HAVE_MEMORY_H 1
#define HAVE_STRINGS_H 1
#define HAVE_INTTYPES_H 1
#define HAVE_STDINT_H 1
#define HAVE_UNISTD_H 1
#define HAVE_SYS_FILE_H 1
#define HAVE_SYS_PARAM_H 1
#define HAVE_LIMITS_H 1
#define HAVE_STDLIB_H 1
#define HAVE_MALLOC_H 1
#define HAVE_STRING_H 1
#define HAVE_UNISTD_H 1
#define HAVE_STRINGS_H 1
#define HAVE_SYS_TIME_H 1
#define HAVE_TIME_H 1
#define HAVE_SYS_RESOURCE_H 1
#define HAVE_SYS_STAT_H 1
#define HAVE_SYS_MMAN_H 1
#define HAVE_FCNTL_H 1
#define HAVE_ALLOCA_H 1
#define HAVE_SYS_SYSINFO_H 1
#define HAVE_STDINT_H 1
#define HAVE_SYS_PRCTL_H 1
#define HAVE_SYS_WAIT_H 1
#define TIME_WITH_SYS_TIME 1
#define SIZEOF_INT 4
#define UNSIGNED_64BIT_TYPE uint64_t
#define HAVE_INTPTR_T 1
#define HAVE_UINTPTR_T 1
#define HAVE_UINTPTR_T 1
#define HAVE_ASPRINTF 1
#define HAVE_ATEXIT 1
#define HAVE_BASENAME 1
#define HAVE_BCOPY 1
#define HAVE_BSEARCH 1
#define HAVE_BZERO 1
#define HAVE_CALLOC 1
#define HAVE_CLOCK 1
#define HAVE_FFS 1
#define HAVE_GETCWD 1
#define HAVE_GETPAGESIZE 1
#define HAVE_GETTIMEOFDAY 1
#define HAVE_INDEX 1
#define HAVE_INSQUE 1
#define HAVE_MEMCHR 1
#define HAVE_MEMCMP 1
#define HAVE_MEMCPY 1
#define HAVE_MEMMEM 1
#define HAVE_MEMMOVE 1
#define HAVE_MEMSET 1
#define HAVE_MKSTEMPS 1
#define HAVE_PUTENV 1
#define HAVE_RANDOM 1
#define HAVE_RENAME 1
#define HAVE_SETENV 1
#define HAVE_SNPRINTF 1
#define HAVE_SIGSETMASK 1
#define HAVE_STPCPY 1
#define HAVE_STPNCPY 1
#define HAVE_STRCASECMP 1
#define HAVE_STRCHR 1
#define HAVE_STRDUP 1
#define HAVE_STRNCASECMP 1
#define HAVE_STRNDUP 1
#define HAVE_STRNLEN 1
#define HAVE_STRRCHR 1
#define HAVE_STRSTR 1
#define HAVE_STRTOD 1
#define HAVE_STRTOL 1
#define HAVE_STRTOUL 1
#define HAVE_TMPNAM 1
#define HAVE_VASPRINTF 1
#define HAVE_VFPRINTF 1
#define HAVE_VPRINTF 1
#define HAVE_VSNPRINTF 1
#define HAVE_VSPRINTF 1
#define HAVE_WAITPID 1
#define STACK_DIRECTION 0
#define HAVE_FORK 1
#define HAVE_VFORK 1
#define HAVE_WORKING_VFORK 1
#define HAVE_WORKING_FORK 1
#define HAVE_SYS_SIGLIST 1
#define HAVE_DUP3 1
#define HAVE_GETRLIMIT 1
#define HAVE_GETRUSAGE 1
#define HAVE_GETTIMEOFDAY 1
#define HAVE_PSIGNAL 1
#define HAVE_REALPATH 1
#define HAVE_SETRLIMIT 1
#define HAVE_SBRK 1
#define HAVE_STRERROR 1
#define HAVE_STRSIGNAL 1
#define HAVE_SYSCONF 1
#define HAVE_TIMES 1
#define HAVE_WAIT3 1
#define HAVE_WAIT4 1
#define HAVE_DECL_BASENAME 0
#define HAVE_DECL_FFS 1
#define HAVE_DECL_ASPRINTF 1
#define HAVE_DECL_VASPRINTF 1
#define HAVE_DECL_SNPRINTF 1
#define HAVE_DECL_VSNPRINTF 1
#define HAVE_DECL_CALLOC 1
#define HAVE_DECL_GETENV 1
#define HAVE_DECL_GETOPT 1
#define HAVE_DECL_MALLOC 1
#define HAVE_DECL_REALLOC 1
#define HAVE_DECL_SBRK 1
#define HAVE_DECL_STRVERSCMP 0
#define NEED_DECLARATION_CANONICALIZE_FILE_NAME 1
#define HAVE_STDLIB_H 1
#define HAVE_UNISTD_H 1
#define HAVE_GETPAGESIZE 1

configure: exit 0

____
File /tmp/mingw-w64-binutils/src/binutils-i686-w64-mingw32/etc/config.log
This file contains any messages produced by compilers while
running configure, to aid debugging if configure makes a mistake.

It was created by configure, which was
generated by GNU Autoconf 2.64.  Invocation command line was

  $ /tmp/mingw-w64-binutils/src/binutils-2.25.1/etc/configure --cache-file=./config.cache --with-gnu-as --with-gnu-ld --with-system-zlib --prefix=/usr --infodir=/usr/share/info/i686-w64-mingw32 --enable-lto --enable-plugins --disable-multilib --disable-nls --disable-werror --program-transform-name=s&^&i686-w64-mingw32-& --disable-option-checking --build=x86_64-unknown-linux-gnu --host=x86_64-unknown-linux --target=i686-w64-mingw32 --srcdir=/tmp/mingw-w64-binutils/src/binutils-2.25.1/etc

## --------- ##
## Platform. ##
## --------- ##

hostname = d5f3793a98c0
uname -m = x86_64
uname -r = 3.13.0-66-generic
uname -s = Linux
uname -v = #108-Ubuntu SMP Wed Oct 7 15:20:27 UTC 2015

/usr/bin/uname -p = unknown
/bin/uname -X     = unknown

/bin/arch              = unknown
/usr/bin/arch -k       = unknown
/usr/convex/getsysinfo = unknown
/usr/bin/hostinfo      = unknown
/bin/machine           = unknown
/usr/bin/oslevel       = unknown
/bin/universe          = unknown

PATH: /tmp/toolchain/bin
PATH: /usr/local/sbin
PATH: /usr/local/bin
PATH: /usr/sbin
PATH: /usr/bin
PATH: /sbin
PATH: /bin


## ----------- ##
## Core tests. ##
## ----------- ##

configure:1572: creating cache ./config.cache
configure:1683: checking for a BSD-compatible install
configure:1751: result: /usr/bin/install -c
configure:1850: updating cache ./config.cache
configure:1923: creating ./config.status

## ---------------------- ##
## Running config.status. ##
## ---------------------- ##

This file was extended by config.status, which was
generated by GNU Autoconf 2.64.  Invocation command line was

  CONFIG_FILES    = 
  CONFIG_HEADERS  = 
  CONFIG_LINKS    = 
  CONFIG_COMMANDS = 
  $ ./config.status 

on d5f3793a98c0

config.status:715: creating Makefile

## ---------------- ##
## Cache variables. ##
## ---------------- ##

ac_cv_env_build_alias_set=set
ac_cv_env_build_alias_value=x86_64-unknown-linux-gnu
ac_cv_env_host_alias_set=set
ac_cv_env_host_alias_value=x86_64-unknown-linux
ac_cv_env_target_alias_set=set
ac_cv_env_target_alias_value=i686-w64-mingw32

## ----------------- ##
## Output variables. ##
## ----------------- ##

DEFS='-DPACKAGE_NAME=\"\" -DPACKAGE_TARNAME=\"\" -DPACKAGE_VERSION=\"\" -DPACKAGE_STRING=\"\" -DPACKAGE_BUGREPORT=\"\" -DPACKAGE_URL=\"\"'
ECHO_C=''
ECHO_N='-n'
ECHO_T=''
INSTALL_DATA='/usr/bin/install -c -m 644'
INSTALL_PROGRAM='/usr/bin/install -c'
INSTALL_SCRIPT='/usr/bin/install -c'
LIBOBJS=''
LIBS=''
LTLIBOBJS=''
MAINT='#'
PACKAGE_BUGREPORT=''
PACKAGE_NAME=''
PACKAGE_STRING=''
PACKAGE_TARNAME=''
PACKAGE_URL=''
PACKAGE_VERSION=''
PATH_SEPARATOR=':'
SHELL='/bin/sh'
bindir='${exec_prefix}/bin'
build_alias='x86_64-unknown-linux-gnu'
datadir='${datarootdir}'
datarootdir='${prefix}/share'
docdir='${datarootdir}/doc/${PACKAGE}'
dvidir='${docdir}'
exec_prefix='${prefix}'
host_alias='x86_64-unknown-linux'
htmldir='${docdir}'
includedir='${prefix}/include'
infodir='/usr/share/info/i686-w64-mingw32'
libdir='${exec_prefix}/lib'
libexecdir='${exec_prefix}/libexec'
localedir='${datarootdir}/locale'
localstatedir='${prefix}/var'
mandir='${datarootdir}/man'
oldincludedir='/usr/include'
pdfdir='${docdir}'
prefix='/usr'
program_transform_name='s&^&i686-w64-mingw32-&'
psdir='${docdir}'
sbindir='${exec_prefix}/sbin'
sharedstatedir='${prefix}/com'
sysconfdir='${prefix}/etc'
target_alias='i686-w64-mingw32'

## ----------- ##
## confdefs.h. ##
## ----------- ##

/* confdefs.h */
#define PACKAGE_NAME ""
#define PACKAGE_TARNAME ""
#define PACKAGE_VERSION ""
#define PACKAGE_STRING ""
#define PACKAGE_BUGREPORT ""
#define PACKAGE_URL ""

configure: exit 0

____
File /tmp/mingw-w64-binutils/src/binutils-i686-w64-mingw32/gprof/config.log
This file contains any messages produced by compilers while
running configure, to aid debugging if configure makes a mistake.

It was created by gprof configure 2.25.1, which was
generated by GNU Autoconf 2.64.  Invocation command line was

  $ /tmp/mingw-w64-binutils/src/binutils-2.25.1/gprof/configure --cache-file=./config.cache --with-gnu-as --with-gnu-ld --with-system-zlib --prefix=/usr --infodir=/usr/share/info/i686-w64-mingw32 --enable-lto --enable-plugins --disable-multilib --disable-nls --disable-werror --program-transform-name=s&^&i686-w64-mingw32-& --disable-option-checking --build=x86_64-unknown-linux-gnu --host=x86_64-unknown-linux --target=i686-w64-mingw32 --srcdir=/tmp/mingw-w64-binutils/src/binutils-2.25.1/gprof

## --------- ##
## Platform. ##
## --------- ##

hostname = d5f3793a98c0
uname -m = x86_64
uname -r = 3.13.0-66-generic
uname -s = Linux
uname -v = #108-Ubuntu SMP Wed Oct 7 15:20:27 UTC 2015

/usr/bin/uname -p = unknown
/bin/uname -X     = unknown

/bin/arch              = unknown
/usr/bin/arch -k       = unknown
/usr/convex/getsysinfo = unknown
/usr/bin/hostinfo      = unknown
/bin/machine           = unknown
/usr/bin/oslevel       = unknown
/bin/universe          = unknown

PATH: /tmp/toolchain/bin
PATH: /usr/local/sbin
PATH: /usr/local/bin
PATH: /usr/sbin
PATH: /usr/bin
PATH: /sbin
PATH: /bin


## ----------- ##
## Core tests. ##
## ----------- ##

configure:2118: creating cache ./config.cache
configure:2223: checking build system type
configure:2237: result: x86_64-unknown-linux-gnu
configure:2257: checking host system type
configure:2270: result: x86_64-unknown-linux-gnu
configure:2290: checking target system type
configure:2303: result: i686-w64-mingw32
configure:2337: checking for x86_64-unknown-linux-gcc
configure:2364: result: arm-linux-androideabi-gcc
configure:2633: checking for C compiler version
configure:2642: arm-linux-androideabi-gcc --version >&5
arm-linux-androideabi-gcc (GCC) 4.8
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

configure:2653: $? = 0
configure:2642: arm-linux-androideabi-gcc -v >&5
Using built-in specs.
COLLECT_GCC=arm-linux-androideabi-gcc
COLLECT_LTO_WRAPPER=/tmp/toolchain/bin/../libexec/gcc/arm-linux-androideabi/4.8/lto-wrapper
Target: arm-linux-androideabi
Configured with: /s/ndk-toolchain/src/build/../gcc/gcc-4.8/configure --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --target=arm-linux-androideabi --host=x86_64-linux-gnu --build=x86_64-linux-gnu --with-gnu-as --with-gnu-ld --enable-languages=c,c++ --with-gmp=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpfr=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpc=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-cloog=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-isl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-ppl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --disable-ppl-version-check --disable-cloog-version-check --disable-isl-version-check --enable-cloog-backend=isl --with-host-libstdcxx='-static-libgcc -Wl,-Bstatic,-lstdc++,-Bdynamic -lm' --disable-libssp --enable-threads --disable-nls --disable-libmudflap --disable-libgomp --disable-libstdc__-v3 --disable-sjlj-exceptions --disable-shared --disable-tls --disable-libitm --with-float=soft --with-fpu=vfp --with-arch=armv5te --enable-target-optspace --enable-initfini-array --disable-nls --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --with-sysroot=/tmp/ndk-andrewhsieh/build/toolchain/prefix/sysroot --with-binutils-version=2.25 --with-mpfr-version=3.1.1 --with-mpc-version=1.0.1 --with-gmp-version=5.0.5 --with-gcc-version=4.8 --with-gdb-version=7.7 --with-python=/usr/local/google/home/andrewhsieh/mydroid/ndk/prebuilt/linux-x86_64/bin/python-config.sh --with-gxx-include-dir=/tmp/ndk-andrewhsieh/build/toolchain/prefix/include/c++/4.8 --with-bugurl=http://source.android.com/source/report-bugs.html --enable-languages=c,c++ --disable-bootstrap --enable-plugins --enable-libgomp --enable-gnu-indirect-function --disable-libsanitizer --enable-gold --enable-threads --enable-graphite=yes --with-cloog-version=0.18.0 --with-isl-version=0.11.1 --enable-eh-frame-hdr-for-static --with-arch=armv5te --program-transform-name='s&^&arm-linux-androideabi-&' --enable-gold=default
Thread model: posix
gcc version 4.8 (GCC) 
configure:2653: $? = 0
configure:2642: arm-linux-androideabi-gcc -V >&5
arm-linux-androideabi-gcc: error: unrecognized command line option '-V'
arm-linux-androideabi-gcc: fatal error: no input files
compilation terminated.
configure:2653: $? = 1
configure:2642: arm-linux-androideabi-gcc -qversion >&5
arm-linux-androideabi-gcc: error: unrecognized command line option '-qversion'
arm-linux-androideabi-gcc: fatal error: no input files
compilation terminated.
configure:2653: $? = 1
configure:2673: checking for C compiler default output file name
configure:2695: arm-linux-androideabi-gcc   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:2699: $? = 0
configure:2736: result: a.out
configure:2752: checking whether the C compiler works
configure:2780: result: yes
configure:2787: checking whether we are cross compiling
configure:2789: result: yes
configure:2792: checking for suffix of executables
configure:2799: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:2803: $? = 0
configure:2825: result: 
configure:2831: checking for suffix of object files
configure:2853: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:2857: $? = 0
configure:2878: result: o
configure:2882: checking whether we are using the GNU C compiler
configure:2901: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:2901: $? = 0
configure:2910: result: yes
configure:2919: checking whether arm-linux-androideabi-gcc accepts -g
configure:2939: arm-linux-androideabi-gcc -c -g  conftest.c >&5
configure:2939: $? = 0
configure:2980: result: yes
configure:2997: checking for arm-linux-androideabi-gcc option to accept ISO C89
configure:3061: arm-linux-androideabi-gcc  -c   conftest.c >&5
configure:3061: $? = 0
configure:3074: result: none needed
configure:3095: checking for library containing strerror
configure:3126: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:3126: $? = 0
configure:3143: result: none required
configure:3168: checking for a BSD-compatible install
configure:3236: result: /usr/bin/install -c
configure:3247: checking whether build environment is sane
configure:3297: result: yes
configure:3346: checking for x86_64-unknown-linux-strip
configure:3376: result: no
configure:3386: checking for strip
configure:3402: found /usr/sbin/strip
configure:3413: result: strip
configure:3425: WARNING: using cross tools not prefixed with host triplet
configure:3438: checking for a thread-safe mkdir -p
configure:3477: result: /usr/sbin/mkdir -p
configure:3490: checking for gawk
configure:3517: result: gawk
configure:3528: checking whether make sets $(MAKE)
configure:3550: result: yes
configure:3580: checking for style of include used by make
configure:3608: result: GNU
configure:3693: checking dependency style of arm-linux-androideabi-gcc
configure:3803: result: gcc3
configure:3831: checking for x86_64-unknown-linux-gcc
configure:3858: result: arm-linux-androideabi-gcc
configure:4127: checking for C compiler version
configure:4136: arm-linux-androideabi-gcc --version >&5
arm-linux-androideabi-gcc (GCC) 4.8
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

configure:4147: $? = 0
configure:4136: arm-linux-androideabi-gcc -v >&5
Using built-in specs.
COLLECT_GCC=arm-linux-androideabi-gcc
COLLECT_LTO_WRAPPER=/tmp/toolchain/bin/../libexec/gcc/arm-linux-androideabi/4.8/lto-wrapper
Target: arm-linux-androideabi
Configured with: /s/ndk-toolchain/src/build/../gcc/gcc-4.8/configure --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --target=arm-linux-androideabi --host=x86_64-linux-gnu --build=x86_64-linux-gnu --with-gnu-as --with-gnu-ld --enable-languages=c,c++ --with-gmp=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpfr=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpc=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-cloog=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-isl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-ppl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --disable-ppl-version-check --disable-cloog-version-check --disable-isl-version-check --enable-cloog-backend=isl --with-host-libstdcxx='-static-libgcc -Wl,-Bstatic,-lstdc++,-Bdynamic -lm' --disable-libssp --enable-threads --disable-nls --disable-libmudflap --disable-libgomp --disable-libstdc__-v3 --disable-sjlj-exceptions --disable-shared --disable-tls --disable-libitm --with-float=soft --with-fpu=vfp --with-arch=armv5te --enable-target-optspace --enable-initfini-array --disable-nls --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --with-sysroot=/tmp/ndk-andrewhsieh/build/toolchain/prefix/sysroot --with-binutils-version=2.25 --with-mpfr-version=3.1.1 --with-mpc-version=1.0.1 --with-gmp-version=5.0.5 --with-gcc-version=4.8 --with-gdb-version=7.7 --with-python=/usr/local/google/home/andrewhsieh/mydroid/ndk/prebuilt/linux-x86_64/bin/python-config.sh --with-gxx-include-dir=/tmp/ndk-andrewhsieh/build/toolchain/prefix/include/c++/4.8 --with-bugurl=http://source.android.com/source/report-bugs.html --enable-languages=c,c++ --disable-bootstrap --enable-plugins --enable-libgomp --enable-gnu-indirect-function --disable-libsanitizer --enable-gold --enable-threads --enable-graphite=yes --with-cloog-version=0.18.0 --with-isl-version=0.11.1 --enable-eh-frame-hdr-for-static --with-arch=armv5te --program-transform-name='s&^&arm-linux-androideabi-&' --enable-gold=default
Thread model: posix
gcc version 4.8 (GCC) 
configure:4147: $? = 0
configure:4136: arm-linux-androideabi-gcc -V >&5
arm-linux-androideabi-gcc: error: unrecognized command line option '-V'
arm-linux-androideabi-gcc: fatal error: no input files
compilation terminated.
configure:4147: $? = 1
configure:4136: arm-linux-androideabi-gcc -qversion >&5
arm-linux-androideabi-gcc: error: unrecognized command line option '-qversion'
arm-linux-androideabi-gcc: fatal error: no input files
compilation terminated.
configure:4147: $? = 1
configure:4151: checking whether we are using the GNU C compiler
configure:4179: result: yes
configure:4188: checking whether arm-linux-androideabi-gcc accepts -g
configure:4249: result: yes
configure:4266: checking for arm-linux-androideabi-gcc option to accept ISO C89
configure:4343: result: none needed
configure:4368: checking how to run the C preprocessor
configure:4399: arm-linux-androideabi-gcc -E  conftest.c
configure:4399: $? = 0
configure:4413: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:11:28: fatal error: ac_nonexistent.h: No such file or directory
 #include <ac_nonexistent.h>
                            ^
compilation terminated.
configure:4413: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "gprof"
| #define PACKAGE_TARNAME "gprof"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "gprof 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "gprof"
| #define VERSION "2.25.1"
| /* end confdefs.h.  */
| #include <ac_nonexistent.h>
configure:4438: result: arm-linux-androideabi-gcc -E
configure:4458: arm-linux-androideabi-gcc -E  conftest.c
configure:4458: $? = 0
configure:4472: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:11:28: fatal error: ac_nonexistent.h: No such file or directory
 #include <ac_nonexistent.h>
                            ^
compilation terminated.
configure:4472: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "gprof"
| #define PACKAGE_TARNAME "gprof"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "gprof 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "gprof"
| #define VERSION "2.25.1"
| /* end confdefs.h.  */
| #include <ac_nonexistent.h>
configure:4501: checking for grep that handles long lines and -e
configure:4559: result: /usr/sbin/grep
configure:4564: checking for egrep
configure:4626: result: /usr/sbin/grep -E
configure:4631: checking for ANSI C header files
configure:4651: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4651: $? = 0
configure:4735: result: yes
configure:4748: checking for sys/types.h
configure:4748: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4748: $? = 0
configure:4748: result: yes
configure:4748: checking for sys/stat.h
configure:4748: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4748: $? = 0
configure:4748: result: yes
configure:4748: checking for stdlib.h
configure:4748: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4748: $? = 0
configure:4748: result: yes
configure:4748: checking for string.h
configure:4748: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4748: $? = 0
configure:4748: result: yes
configure:4748: checking for memory.h
configure:4748: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4748: $? = 0
configure:4748: result: yes
configure:4748: checking for strings.h
configure:4748: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4748: $? = 0
configure:4748: result: yes
configure:4748: checking for inttypes.h
configure:4748: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4748: $? = 0
configure:4748: result: yes
configure:4748: checking for stdint.h
configure:4748: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4748: $? = 0
configure:4748: result: yes
configure:4748: checking for unistd.h
configure:4748: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4748: $? = 0
configure:4748: result: yes
configure:4762: checking minix/config.h usability
configure:4762: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:54:26: fatal error: minix/config.h: No such file or directory
 #include <minix/config.h>
                          ^
compilation terminated.
configure:4762: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "gprof"
| #define PACKAGE_TARNAME "gprof"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "gprof 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "gprof"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <minix/config.h>
configure:4762: result: no
configure:4762: checking minix/config.h presence
configure:4762: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:21:26: fatal error: minix/config.h: No such file or directory
 #include <minix/config.h>
                          ^
compilation terminated.
configure:4762: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "gprof"
| #define PACKAGE_TARNAME "gprof"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "gprof 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "gprof"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| /* end confdefs.h.  */
| #include <minix/config.h>
configure:4762: result: no
configure:4762: checking for minix/config.h
configure:4762: result: no
configure:4783: checking whether it is safe to define __EXTENSIONS__
configure:4801: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4801: $? = 0
configure:4808: result: yes
configure:4872: checking how to print strings
configure:4899: result: printf
configure:4920: checking for a sed that does not truncate output
configure:4984: result: /usr/sbin/sed
configure:5002: checking for fgrep
configure:5064: result: /usr/sbin/grep -F
configure:5099: checking for ld used by arm-linux-androideabi-gcc
configure:5166: result: /tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld
configure:5173: checking if the linker (/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld) is GNU ld
configure:5188: result: yes
configure:5200: checking for BSD- or MS-compatible name lister (nm)
configure:5249: result: nm
configure:5379: checking the name lister (nm) interface
configure:5386: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5389: nm "conftest.o"
configure:5392: output
00000000 b $d
00000000 B some_variable
configure:5399: result: BSD nm
configure:5402: checking whether ln -s works
configure:5406: result: yes
configure:5414: checking the maximum length of command line arguments
configure:5539: result: 1572864
configure:5556: checking whether the shell understands some XSI constructs
configure:5566: result: yes
configure:5570: checking whether the shell understands "+="
configure:5576: result: yes
configure:5611: checking for /tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld option to reload object files
configure:5618: result: -r
configure:5647: checking for x86_64-unknown-linux-objdump
configure:5674: result: objdump
configure:5746: checking how to recognize dependent libraries
configure:5947: result: pass_all
configure:5967: checking for x86_64-unknown-linux-ar
configure:5994: result: ar
configure:6072: checking for x86_64-unknown-linux-strip
configure:6099: result: strip
configure:6171: checking for x86_64-unknown-linux-ranlib
configure:6198: result: ranlib
configure:6340: checking command to parse nm output from arm-linux-androideabi-gcc object
configure:6458: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:6461: $? = 0
configure:6465: nm conftest.o \| sed -n -e 's/^.*[ ]\([ABCDGIRSTW][ABCDGIRSTW]*\)[ ][ ]*\([_A-Za-z][_A-Za-z0-9]*\)$/\1 \2 \2/p' \> conftest.nm
configure:6468: $? = 0
configure:6522: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c conftstm.o >&5
configure:6525: $? = 0
configure:6563: result: ok
configure:6658: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:6661: $? = 0
configure:7411: checking for dlfcn.h
configure:7411: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:7411: $? = 0
configure:7411: result: yes
configure:7598: checking for objdir
configure:7613: result: .libs
configure:7884: checking if arm-linux-androideabi-gcc supports -fno-rtti -fno-exceptions
configure:7902: arm-linux-androideabi-gcc -c   -fno-rtti -fno-exceptions conftest.c >&5
cc1: warning: command line option '-fno-rtti' is valid for C++/ObjC++ but not for C [enabled by default]
configure:7906: $? = 0
configure:7919: result: no
configure:7939: checking for arm-linux-androideabi-gcc option to produce PIC
configure:8225: result: -fPIC -DPIC
configure:8237: checking if arm-linux-androideabi-gcc PIC flag -fPIC -DPIC works
configure:8255: arm-linux-androideabi-gcc -c   -fPIC -DPIC -DPIC conftest.c >&5
configure:8259: $? = 0
configure:8272: result: yes
configure:8296: checking if arm-linux-androideabi-gcc static flag -static works
configure:8324: result: yes
configure:8339: checking if arm-linux-androideabi-gcc supports -c -o file.o
configure:8360: arm-linux-androideabi-gcc -c   -o out/conftest2.o conftest.c >&5
configure:8364: $? = 0
configure:8386: result: yes
configure:8394: checking if arm-linux-androideabi-gcc supports -c -o file.o
configure:8441: result: yes
configure:8474: checking whether the arm-linux-androideabi-gcc linker (/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld -m elf_i386) supports shared libraries
configure:9545: result: yes
configure:9582: checking whether -lc should be explicitly linked in
configure:9590: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:9593: $? = 0
configure:9608: arm-linux-androideabi-gcc -shared conftest.o  -v -Wl,-soname -Wl,conftest -o conftest 2\>\&1 \| /usr/sbin/grep  -lc  \>/dev/null 2\>\&1
configure:9611: $? = 0
configure:9625: result: no
configure:9790: checking dynamic linker characteristics
configure:10241: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  -Wl,-rpath -Wl,/foo conftest.c  >&5
configure:10241: $? = 0
configure:10463: result: GNU/Linux ld.so
configure:10570: checking how to hardcode library paths into programs
configure:10595: result: immediate
configure:11135: checking whether stripping libraries is possible
configure:11140: result: yes
configure:11175: checking if libtool supports shared libraries
configure:11177: result: yes
configure:11180: checking whether to build shared libraries
configure:11201: result: yes
configure:11204: checking whether to build static libraries
configure:11208: result: yes
configure:11256: checking for dlfcn.h
configure:11256: result: yes
configure:11269: checking for windows.h
configure:11269: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:63:21: fatal error: windows.h: No such file or directory
 #include <windows.h>
                     ^
compilation terminated.
configure:11269: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "gprof"
| #define PACKAGE_TARNAME "gprof"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "gprof 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "gprof"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| 
| #include <windows.h>
configure:11269: result: no
configure:11296: checking for library containing dlopen
configure:11327: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:11327: $? = 0
configure:11344: result: none required
configure:11375: checking for special C compiler options needed for large files
configure:11420: result: no
configure:11426: checking for _FILE_OFFSET_BITS value needed for large files
configure:11451: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:35:3: warning: left shift count >= width of type [enabled by default]
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
   ^
conftest.c:35:3: warning: left shift count >= width of type [enabled by default]
conftest.c:36:10: warning: left shift count >= width of type [enabled by default]
          && LARGE_OFF_T % 2147483647 == 1)
          ^
conftest.c:36:10: warning: left shift count >= width of type [enabled by default]
conftest.c:35:7: error: variably modified 'off_t_is_large' at file scope
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
       ^
configure:11451: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "gprof"
| #define PACKAGE_TARNAME "gprof"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "gprof 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "gprof"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| /* end confdefs.h.  */
| #include <sys/types.h>
|  /* Check that off_t can represent 2**63 - 1 correctly.
|     We can't simply define LARGE_OFF_T to be 9223372036854775807,
|     since some C++ compilers masquerading as C compilers
|     incorrectly reject 9223372036854775807.  */
| #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
|   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
| 		       && LARGE_OFF_T % 2147483647 == 1)
| 		      ? 1 : -1];
| int
| main ()
| {
| 
|   ;
|   return 0;
| }
configure:11475: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:36:3: warning: left shift count >= width of type [enabled by default]
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
   ^
conftest.c:36:3: warning: left shift count >= width of type [enabled by default]
conftest.c:37:10: warning: left shift count >= width of type [enabled by default]
          && LARGE_OFF_T % 2147483647 == 1)
          ^
conftest.c:37:10: warning: left shift count >= width of type [enabled by default]
conftest.c:36:7: error: variably modified 'off_t_is_large' at file scope
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
       ^
configure:11475: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "gprof"
| #define PACKAGE_TARNAME "gprof"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "gprof 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "gprof"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| /* end confdefs.h.  */
| #define _FILE_OFFSET_BITS 64
| #include <sys/types.h>
|  /* Check that off_t can represent 2**63 - 1 correctly.
|     We can't simply define LARGE_OFF_T to be 9223372036854775807,
|     since some C++ compilers masquerading as C compilers
|     incorrectly reject 9223372036854775807.  */
| #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
|   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
| 		       && LARGE_OFF_T % 2147483647 == 1)
| 		      ? 1 : -1];
| int
| main ()
| {
| 
|   ;
|   return 0;
| }
configure:11483: result: unknown
configure:11495: checking for _LARGE_FILES value needed for large files
configure:11520: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:35:3: warning: left shift count >= width of type [enabled by default]
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
   ^
conftest.c:35:3: warning: left shift count >= width of type [enabled by default]
conftest.c:36:10: warning: left shift count >= width of type [enabled by default]
          && LARGE_OFF_T % 2147483647 == 1)
          ^
conftest.c:36:10: warning: left shift count >= width of type [enabled by default]
conftest.c:35:7: error: variably modified 'off_t_is_large' at file scope
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
       ^
configure:11520: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "gprof"
| #define PACKAGE_TARNAME "gprof"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "gprof 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "gprof"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| /* end confdefs.h.  */
| #include <sys/types.h>
|  /* Check that off_t can represent 2**63 - 1 correctly.
|     We can't simply define LARGE_OFF_T to be 9223372036854775807,
|     since some C++ compilers masquerading as C compilers
|     incorrectly reject 9223372036854775807.  */
| #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
|   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
| 		       && LARGE_OFF_T % 2147483647 == 1)
| 		      ? 1 : -1];
| int
| main ()
| {
| 
|   ;
|   return 0;
| }
configure:11544: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:36:3: warning: left shift count >= width of type [enabled by default]
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
   ^
conftest.c:36:3: warning: left shift count >= width of type [enabled by default]
conftest.c:37:10: warning: left shift count >= width of type [enabled by default]
          && LARGE_OFF_T % 2147483647 == 1)
          ^
conftest.c:37:10: warning: left shift count >= width of type [enabled by default]
conftest.c:36:7: error: variably modified 'off_t_is_large' at file scope
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
       ^
configure:11544: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "gprof"
| #define PACKAGE_TARNAME "gprof"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "gprof 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "gprof"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| /* end confdefs.h.  */
| #define _LARGE_FILES 1
| #include <sys/types.h>
|  /* Check that off_t can represent 2**63 - 1 correctly.
|     We can't simply define LARGE_OFF_T to be 9223372036854775807,
|     since some C++ compilers masquerading as C compilers
|     incorrectly reject 9223372036854775807.  */
| #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
|   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
| 		       && LARGE_OFF_T % 2147483647 == 1)
| 		      ? 1 : -1];
| int
| main ()
| {
| 
|   ;
|   return 0;
| }
configure:11552: result: unknown
configure:11570: checking for setmode
configure:11570: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
/tmp/ccw6lYGP.o:conftest.c:function main: error: undefined reference to 'setmode'
collect2: error: ld returned 1 exit status
configure:11570: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "gprof"
| #define PACKAGE_TARNAME "gprof"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "gprof 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "gprof"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| /* end confdefs.h.  */
| /* Define setmode to an innocuous variant, in case <limits.h> declares setmode.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define setmode innocuous_setmode
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char setmode (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef setmode
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char setmode ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_setmode || defined __stub___setmode
| choke me
| #endif
| 
| int
| main ()
| {
| return setmode ();
|   ;
|   return 0;
| }
configure:11570: result: no
configure:11594: checking whether NLS is requested
configure:11597: result: no
configure:11665: checking whether NLS is requested
configure:11674: result: no
configure:11712: checking for msgfmt
configure:11743: result: /usr/sbin/msgfmt
configure:11752: checking for gmsgfmt
configure:11783: result: /usr/sbin/msgfmt
configure:11823: checking for xgettext
configure:11854: result: /usr/sbin/xgettext
configure:11894: checking for msgmerge
configure:11924: result: /usr/sbin/msgmerge
configure:11961: checking whether to enable maintainer-specific portions of Makefiles
configure:11970: result: no
configure:11995: checking sys/gmon_out.h usability
configure:11995: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:62:26: fatal error: sys/gmon_out.h: No such file or directory
 #include <sys/gmon_out.h>
                          ^
compilation terminated.
configure:11995: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "gprof"
| #define PACKAGE_TARNAME "gprof"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "gprof 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "gprof"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <sys/gmon_out.h>
configure:11995: result: no
configure:11995: checking sys/gmon_out.h presence
configure:11995: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:29:26: fatal error: sys/gmon_out.h: No such file or directory
 #include <sys/gmon_out.h>
                          ^
compilation terminated.
configure:11995: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "gprof"
| #define PACKAGE_TARNAME "gprof"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "gprof 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "gprof"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| /* end confdefs.h.  */
| #include <sys/gmon_out.h>
configure:11995: result: no
configure:11995: checking for sys/gmon_out.h
configure:11995: result: no
configure:12006: checking for a known getopt prototype in unistd.h
configure:12022: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12022: $? = 0
configure:12030: result: yes
configure:12039: checking for library containing fabs
configure:12070: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
conftest.c:37:6: warning: conflicting types for built-in function 'fabs' [enabled by default]
 char fabs ();
      ^
/tmp/ccuQ6FGh.o:conftest.c:function main: error: undefined reference to 'fabs'
collect2: error: ld returned 1 exit status
configure:12070: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "gprof"
| #define PACKAGE_TARNAME "gprof"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "gprof 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "gprof"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define HAVE_DECL_GETOPT 1
| /* end confdefs.h.  */
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char fabs ();
| int
| main ()
| {
| return fabs ();
|   ;
|   return 0;
| }
configure:12070: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c -lm   >&5
conftest.c:37:6: warning: conflicting types for built-in function 'fabs' [enabled by default]
 char fabs ();
      ^
configure:12070: $? = 0
configure:12087: result: -lm
configure:12245: updating cache ./config.cache
configure:12306: creating ./config.status

## ---------------------- ##
## Running config.status. ##
## ---------------------- ##

This file was extended by gprof config.status 2.25.1, which was
generated by GNU Autoconf 2.64.  Invocation command line was

  CONFIG_FILES    = 
  CONFIG_HEADERS  = 
  CONFIG_LINKS    = 
  CONFIG_COMMANDS = 
  $ ./config.status 

on d5f3793a98c0

config.status:1103: creating Makefile
config.status:1103: creating po/Makefile.in
config.status:1103: creating gconfig.h
config.status:1316: executing depfiles commands
config.status:1316: executing libtool commands
config.status:1316: executing default-1 commands

## ---------------- ##
## Cache variables. ##
## ---------------- ##

ac_cv_build=x86_64-unknown-linux-gnu
ac_cv_c_compiler_gnu=yes
ac_cv_env_CC_set=set
ac_cv_env_CC_value=arm-linux-androideabi-gcc
ac_cv_env_CFLAGS_set=set
ac_cv_env_CFLAGS_value=
ac_cv_env_CPPFLAGS_set=set
ac_cv_env_CPPFLAGS_value=
ac_cv_env_CPP_set=
ac_cv_env_CPP_value=
ac_cv_env_LDFLAGS_set=set
ac_cv_env_LDFLAGS_value='-static-libstdc++ -static-libgcc '
ac_cv_env_LIBS_set=
ac_cv_env_LIBS_value=
ac_cv_env_build_alias_set=set
ac_cv_env_build_alias_value=x86_64-unknown-linux-gnu
ac_cv_env_host_alias_set=set
ac_cv_env_host_alias_value=x86_64-unknown-linux
ac_cv_env_target_alias_set=set
ac_cv_env_target_alias_value=i686-w64-mingw32
ac_cv_func_setmode=no
ac_cv_header_dlfcn_h=yes
ac_cv_header_inttypes_h=yes
ac_cv_header_memory_h=yes
ac_cv_header_minix_config_h=no
ac_cv_header_stdc=yes
ac_cv_header_stdint_h=yes
ac_cv_header_stdlib_h=yes
ac_cv_header_string_h=yes
ac_cv_header_strings_h=yes
ac_cv_header_sys_gmon_out_h=no
ac_cv_header_sys_stat_h=yes
ac_cv_header_sys_types_h=yes
ac_cv_header_unistd_h=yes
ac_cv_header_windows_h=no
ac_cv_host=x86_64-unknown-linux-gnu
ac_cv_objext=o
ac_cv_path_EGREP='/usr/sbin/grep -E'
ac_cv_path_FGREP='/usr/sbin/grep -F'
ac_cv_path_GMSGFMT=/usr/sbin/msgfmt
ac_cv_path_GREP=/usr/sbin/grep
ac_cv_path_MSGFMT=/usr/sbin/msgfmt
ac_cv_path_MSGMERGE=/usr/sbin/msgmerge
ac_cv_path_SED=/usr/sbin/sed
ac_cv_path_XGETTEXT=/usr/sbin/xgettext
ac_cv_path_mkdir=/usr/sbin/mkdir
ac_cv_prog_AR=ar
ac_cv_prog_AWK=gawk
ac_cv_prog_CC=arm-linux-androideabi-gcc
ac_cv_prog_CPP='arm-linux-androideabi-gcc -E'
ac_cv_prog_OBJDUMP=objdump
ac_cv_prog_RANLIB=ranlib
ac_cv_prog_STRIP=strip
ac_cv_prog_ac_ct_STRIP=strip
ac_cv_prog_cc_c89=
ac_cv_prog_cc_g=yes
ac_cv_prog_make_make_set=yes
ac_cv_safe_to_define___extensions__=yes
ac_cv_search_dlopen='none required'
ac_cv_search_fabs=-lm
ac_cv_search_strerror='none required'
ac_cv_sys_file_offset_bits=unknown
ac_cv_sys_large_files=unknown
ac_cv_sys_largefile_CC=no
ac_cv_target=i686-w64-mingw32
am_cv_CC_dependencies_compiler_type=gcc3
gprof_cv_decl_getopt_unistd_h=yes
lt_cv_archive_cmds_need_lc=no
lt_cv_deplibs_check_method=pass_all
lt_cv_file_magic_cmd='$MAGIC_CMD'
lt_cv_file_magic_test_file=
lt_cv_ld_reload_flag=-r
lt_cv_nm_interface='BSD nm'
lt_cv_objdir=.libs
lt_cv_path_LD=/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld
lt_cv_path_NM=nm
lt_cv_prog_compiler_c_o=yes
lt_cv_prog_compiler_pic_works=yes
lt_cv_prog_compiler_rtti_exceptions=no
lt_cv_prog_compiler_static_works=yes
lt_cv_prog_gnu_ld=yes
lt_cv_shlibpath_overrides_runpath=yes
lt_cv_sys_global_symbol_pipe='sed -n -e '\''s/^.*[	 ]\([ABCDGIRSTW][ABCDGIRSTW]*\)[	 ][	 ]*\([_A-Za-z][_A-Za-z0-9]*\)$/\1 \2 \2/p'\'''
lt_cv_sys_global_symbol_to_c_name_address='sed -n -e '\''s/^: \([^ ]*\) $/  {\"\1\", (void *) 0},/p'\'' -e '\''s/^[ABCDGIRSTW]* \([^ ]*\) \([^ ]*\)$/  {"\2", (void *) \&\2},/p'\'''
lt_cv_sys_global_symbol_to_c_name_address_lib_prefix='sed -n -e '\''s/^: \([^ ]*\) $/  {\"\1\", (void *) 0},/p'\'' -e '\''s/^[ABCDGIRSTW]* \([^ ]*\) \(lib[^ ]*\)$/  {"\2", (void *) \&\2},/p'\'' -e '\''s/^[ABCDGIRSTW]* \([^ ]*\) \([^ ]*\)$/  {"lib\2", (void *) \&\2},/p'\'''
lt_cv_sys_global_symbol_to_cdecl='sed -n -e '\''s/^T .* \(.*\)$/extern int \1();/p'\'' -e '\''s/^[ABCDGIRSTW]* .* \(.*\)$/extern char \1;/p'\'''
lt_cv_sys_max_cmd_len=1572864

## ----------------- ##
## Output variables. ##
## ----------------- ##

ACLOCAL='${SHELL} /tmp/mingw-w64-binutils/src/binutils-2.25.1/missing --run aclocal-1.11'
AMDEPBACKSLASH='\'
AMDEP_FALSE='#'
AMDEP_TRUE=''
AMTAR='${SHELL} /tmp/mingw-w64-binutils/src/binutils-2.25.1/missing --run tar'
AR='ar'
AUTOCONF='${SHELL} /tmp/mingw-w64-binutils/src/binutils-2.25.1/missing --run autoconf'
AUTOHEADER='${SHELL} /tmp/mingw-w64-binutils/src/binutils-2.25.1/missing --run autoheader'
AUTOMAKE='${SHELL} /tmp/mingw-w64-binutils/src/binutils-2.25.1/missing --run automake-1.11'
AWK='gawk'
CATALOGS=''
CATOBJEXT=''
CC='arm-linux-androideabi-gcc'
CCDEPMODE='depmode=gcc3'
CFLAGS=''
CPP='arm-linux-androideabi-gcc -E'
CPPFLAGS=''
CYGPATH_W='echo'
DATADIRNAME=''
DEFS='-DHAVE_CONFIG_H'
DEPDIR='.deps'
DSYMUTIL=''
DUMPBIN=''
ECHO_C=''
ECHO_N='-n'
ECHO_T=''
EGREP='/usr/sbin/grep -E'
EXEEXT=''
FGREP='/usr/sbin/grep -F'
GENCAT=''
GENINSRC_NEVER_FALSE=''
GENINSRC_NEVER_TRUE='#'
GMSGFMT='/usr/sbin/msgfmt'
GREP='/usr/sbin/grep'
INCINTL=''
INSTALL_DATA='/usr/bin/install -c -m 644'
INSTALL_PROGRAM='/usr/bin/install -c'
INSTALL_SCRIPT='/usr/bin/install -c'
INSTALL_STRIP_PROGRAM='$(install_sh) -c -s'
INSTOBJEXT=''
LD='/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld -m elf_i386'
LDFLAGS='-static-libstdc++ -static-libgcc '
LIBINTL=''
LIBINTL_DEP=''
LIBOBJS=''
LIBS='-lm '
LIBTOOL='$(SHELL) $(top_builddir)/libtool'
LIPO=''
LN_S='ln -s'
LTLIBOBJS=''
MAINT='#'
MAINTAINER_MODE_FALSE=''
MAINTAINER_MODE_TRUE='#'
MAKEINFO='makeinfo --split-size=5000000'
MKDIR_P='/usr/sbin/mkdir -p'
MKINSTALLDIRS='/tmp/mingw-w64-binutils/src/binutils-2.25.1/gprof/../mkinstalldirs'
MSGFMT='/usr/sbin/msgfmt'
MSGMERGE='/usr/sbin/msgmerge'
NM='nm'
NMEDIT=''
NO_WERROR=''
OBJDUMP='objdump'
OBJEXT='o'
OTOOL64=''
OTOOL=''
PACKAGE='gprof'
PACKAGE_BUGREPORT=''
PACKAGE_NAME='gprof'
PACKAGE_STRING='gprof 2.25.1'
PACKAGE_TARNAME='gprof'
PACKAGE_URL=''
PACKAGE_VERSION='2.25.1'
PATH_SEPARATOR=':'
POSUB=''
RANLIB='ranlib'
SED='/usr/sbin/sed'
SET_MAKE=''
SHELL='/bin/sh'
STRIP='strip'
USE_NLS='no'
VERSION='2.25.1'
WARN_CFLAGS='-W -Wall -Wstrict-prototypes -Wmissing-prototypes -Wshadow'
XGETTEXT='/usr/sbin/xgettext'
ac_ct_CC=''
ac_ct_DUMPBIN=''
am__EXEEXT_FALSE=''
am__EXEEXT_TRUE='#'
am__fastdepCC_FALSE='#'
am__fastdepCC_TRUE=''
am__include='include'
am__isrc=' -I$(srcdir)'
am__leading_dot='.'
am__quote=''
am__tar='${AMTAR} chof - "$$tardir"'
am__untar='${AMTAR} xf -'
bindir='${exec_prefix}/bin'
build='x86_64-unknown-linux-gnu'
build_alias='x86_64-unknown-linux-gnu'
build_cpu='x86_64'
build_os='linux-gnu'
build_vendor='unknown'
datadir='${datarootdir}'
datarootdir='${prefix}/share'
docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
dvidir='${docdir}'
exec_prefix='${prefix}'
host='x86_64-unknown-linux-gnu'
host_alias='x86_64-unknown-linux'
host_cpu='x86_64'
host_os='linux-gnu'
host_vendor='unknown'
htmldir='${docdir}'
includedir='${prefix}/include'
infodir='/usr/share/info/i686-w64-mingw32'
install_sh='${SHELL} /tmp/mingw-w64-binutils/src/binutils-2.25.1/install-sh'
libdir='${exec_prefix}/lib'
libexecdir='${exec_prefix}/libexec'
localedir='${datarootdir}/locale'
localstatedir='${prefix}/var'
mandir='${datarootdir}/man'
mkdir_p='/usr/sbin/mkdir -p'
oldincludedir='/usr/include'
pdfdir='${docdir}'
prefix='/usr'
program_transform_name='s&^&i686-w64-mingw32-&'
psdir='${docdir}'
sbindir='${exec_prefix}/sbin'
sharedstatedir='${prefix}/com'
sysconfdir='${prefix}/etc'
target='i686-w64-mingw32'
target_alias='i686-w64-mingw32'
target_cpu='i686'
target_os='mingw32'
target_vendor='w64'

## ----------- ##
## confdefs.h. ##
## ----------- ##

/* confdefs.h */
#define PACKAGE_NAME "gprof"
#define PACKAGE_TARNAME "gprof"
#define PACKAGE_VERSION "2.25.1"
#define PACKAGE_STRING "gprof 2.25.1"
#define PACKAGE_BUGREPORT ""
#define PACKAGE_URL ""
#define PACKAGE "gprof"
#define VERSION "2.25.1"
#define STDC_HEADERS 1
#define HAVE_SYS_TYPES_H 1
#define HAVE_SYS_STAT_H 1
#define HAVE_STDLIB_H 1
#define HAVE_STRING_H 1
#define HAVE_MEMORY_H 1
#define HAVE_STRINGS_H 1
#define HAVE_INTTYPES_H 1
#define HAVE_STDINT_H 1
#define HAVE_UNISTD_H 1
#define __EXTENSIONS__ 1
#define _ALL_SOURCE 1
#define _GNU_SOURCE 1
#define _POSIX_PTHREAD_SEMANTICS 1
#define _TANDEM_SOURCE 1
#define HAVE_DLFCN_H 1
#define LT_OBJDIR ".libs/"
#define HAVE_DLFCN_H 1
#define HAVE_DECL_GETOPT 1

configure: exit 0

____
File /tmp/mingw-w64-binutils/src/binutils-i686-w64-mingw32/binutils/config.log
This file contains any messages produced by compilers while
running configure, to aid debugging if configure makes a mistake.

It was created by binutils configure 2.25.1, which was
generated by GNU Autoconf 2.64.  Invocation command line was

  $ /tmp/mingw-w64-binutils/src/binutils-2.25.1/binutils/configure --cache-file=./config.cache --with-gnu-as --with-gnu-ld --with-system-zlib --prefix=/usr --infodir=/usr/share/info/i686-w64-mingw32 --enable-lto --enable-plugins --disable-multilib --disable-nls --disable-werror --program-transform-name=s&^&i686-w64-mingw32-& --disable-option-checking --build=x86_64-unknown-linux-gnu --host=x86_64-unknown-linux --target=i686-w64-mingw32 --srcdir=/tmp/mingw-w64-binutils/src/binutils-2.25.1/binutils

## --------- ##
## Platform. ##
## --------- ##

hostname = d5f3793a98c0
uname -m = x86_64
uname -r = 3.13.0-66-generic
uname -s = Linux
uname -v = #108-Ubuntu SMP Wed Oct 7 15:20:27 UTC 2015

/usr/bin/uname -p = unknown
/bin/uname -X     = unknown

/bin/arch              = unknown
/usr/bin/arch -k       = unknown
/usr/convex/getsysinfo = unknown
/usr/bin/hostinfo      = unknown
/bin/machine           = unknown
/usr/bin/oslevel       = unknown
/bin/universe          = unknown

PATH: /tmp/toolchain/bin
PATH: /usr/local/sbin
PATH: /usr/local/bin
PATH: /usr/sbin
PATH: /usr/bin
PATH: /sbin
PATH: /bin


## ----------- ##
## Core tests. ##
## ----------- ##

configure:2444: creating cache ./config.cache
configure:2549: checking build system type
configure:2563: result: x86_64-unknown-linux-gnu
configure:2583: checking host system type
configure:2596: result: x86_64-unknown-linux-gnu
configure:2616: checking target system type
configure:2629: result: i686-w64-mingw32
configure:2663: checking for x86_64-unknown-linux-gcc
configure:2690: result: arm-linux-androideabi-gcc
configure:2959: checking for C compiler version
configure:2968: arm-linux-androideabi-gcc --version >&5
arm-linux-androideabi-gcc (GCC) 4.8
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

configure:2979: $? = 0
configure:2968: arm-linux-androideabi-gcc -v >&5
Using built-in specs.
COLLECT_GCC=arm-linux-androideabi-gcc
COLLECT_LTO_WRAPPER=/tmp/toolchain/bin/../libexec/gcc/arm-linux-androideabi/4.8/lto-wrapper
Target: arm-linux-androideabi
Configured with: /s/ndk-toolchain/src/build/../gcc/gcc-4.8/configure --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --target=arm-linux-androideabi --host=x86_64-linux-gnu --build=x86_64-linux-gnu --with-gnu-as --with-gnu-ld --enable-languages=c,c++ --with-gmp=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpfr=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpc=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-cloog=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-isl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-ppl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --disable-ppl-version-check --disable-cloog-version-check --disable-isl-version-check --enable-cloog-backend=isl --with-host-libstdcxx='-static-libgcc -Wl,-Bstatic,-lstdc++,-Bdynamic -lm' --disable-libssp --enable-threads --disable-nls --disable-libmudflap --disable-libgomp --disable-libstdc__-v3 --disable-sjlj-exceptions --disable-shared --disable-tls --disable-libitm --with-float=soft --with-fpu=vfp --with-arch=armv5te --enable-target-optspace --enable-initfini-array --disable-nls --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --with-sysroot=/tmp/ndk-andrewhsieh/build/toolchain/prefix/sysroot --with-binutils-version=2.25 --with-mpfr-version=3.1.1 --with-mpc-version=1.0.1 --with-gmp-version=5.0.5 --with-gcc-version=4.8 --with-gdb-version=7.7 --with-python=/usr/local/google/home/andrewhsieh/mydroid/ndk/prebuilt/linux-x86_64/bin/python-config.sh --with-gxx-include-dir=/tmp/ndk-andrewhsieh/build/toolchain/prefix/include/c++/4.8 --with-bugurl=http://source.android.com/source/report-bugs.html --enable-languages=c,c++ --disable-bootstrap --enable-plugins --enable-libgomp --enable-gnu-indirect-function --disable-libsanitizer --enable-gold --enable-threads --enable-graphite=yes --with-cloog-version=0.18.0 --with-isl-version=0.11.1 --enable-eh-frame-hdr-for-static --with-arch=armv5te --program-transform-name='s&^&arm-linux-androideabi-&' --enable-gold=default
Thread model: posix
gcc version 4.8 (GCC) 
configure:2979: $? = 0
configure:2968: arm-linux-androideabi-gcc -V >&5
arm-linux-androideabi-gcc: error: unrecognized command line option '-V'
arm-linux-androideabi-gcc: fatal error: no input files
compilation terminated.
configure:2979: $? = 1
configure:2968: arm-linux-androideabi-gcc -qversion >&5
arm-linux-androideabi-gcc: error: unrecognized command line option '-qversion'
arm-linux-androideabi-gcc: fatal error: no input files
compilation terminated.
configure:2979: $? = 1
configure:2999: checking for C compiler default output file name
configure:3021: arm-linux-androideabi-gcc   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:3025: $? = 0
configure:3062: result: a.out
configure:3078: checking whether the C compiler works
configure:3106: result: yes
configure:3113: checking whether we are cross compiling
configure:3115: result: yes
configure:3118: checking for suffix of executables
configure:3125: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:3129: $? = 0
configure:3151: result: 
configure:3157: checking for suffix of object files
configure:3179: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:3183: $? = 0
configure:3204: result: o
configure:3208: checking whether we are using the GNU C compiler
configure:3227: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:3227: $? = 0
configure:3236: result: yes
configure:3245: checking whether arm-linux-androideabi-gcc accepts -g
configure:3265: arm-linux-androideabi-gcc -c -g  conftest.c >&5
configure:3265: $? = 0
configure:3306: result: yes
configure:3323: checking for arm-linux-androideabi-gcc option to accept ISO C89
configure:3387: arm-linux-androideabi-gcc  -c   conftest.c >&5
configure:3387: $? = 0
configure:3400: result: none needed
configure:3421: checking for library containing strerror
configure:3452: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:3452: $? = 0
configure:3469: result: none required
configure:3494: checking for a BSD-compatible install
configure:3562: result: /usr/bin/install -c
configure:3573: checking whether build environment is sane
configure:3623: result: yes
configure:3672: checking for x86_64-unknown-linux-strip
configure:3702: result: no
configure:3712: checking for strip
configure:3728: found /usr/sbin/strip
configure:3739: result: strip
configure:3751: WARNING: using cross tools not prefixed with host triplet
configure:3764: checking for a thread-safe mkdir -p
configure:3803: result: /usr/sbin/mkdir -p
configure:3816: checking for gawk
configure:3843: result: gawk
configure:3854: checking whether make sets $(MAKE)
configure:3876: result: yes
configure:3906: checking for style of include used by make
configure:3934: result: GNU
configure:4019: checking dependency style of arm-linux-androideabi-gcc
configure:4129: result: gcc3
configure:4154: checking for x86_64-unknown-linux-gcc
configure:4181: result: arm-linux-androideabi-gcc
configure:4450: checking for C compiler version
configure:4459: arm-linux-androideabi-gcc --version >&5
arm-linux-androideabi-gcc (GCC) 4.8
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

configure:4470: $? = 0
configure:4459: arm-linux-androideabi-gcc -v >&5
Using built-in specs.
COLLECT_GCC=arm-linux-androideabi-gcc
COLLECT_LTO_WRAPPER=/tmp/toolchain/bin/../libexec/gcc/arm-linux-androideabi/4.8/lto-wrapper
Target: arm-linux-androideabi
Configured with: /s/ndk-toolchain/src/build/../gcc/gcc-4.8/configure --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --target=arm-linux-androideabi --host=x86_64-linux-gnu --build=x86_64-linux-gnu --with-gnu-as --with-gnu-ld --enable-languages=c,c++ --with-gmp=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpfr=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpc=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-cloog=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-isl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-ppl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --disable-ppl-version-check --disable-cloog-version-check --disable-isl-version-check --enable-cloog-backend=isl --with-host-libstdcxx='-static-libgcc -Wl,-Bstatic,-lstdc++,-Bdynamic -lm' --disable-libssp --enable-threads --disable-nls --disable-libmudflap --disable-libgomp --disable-libstdc__-v3 --disable-sjlj-exceptions --disable-shared --disable-tls --disable-libitm --with-float=soft --with-fpu=vfp --with-arch=armv5te --enable-target-optspace --enable-initfini-array --disable-nls --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --with-sysroot=/tmp/ndk-andrewhsieh/build/toolchain/prefix/sysroot --with-binutils-version=2.25 --with-mpfr-version=3.1.1 --with-mpc-version=1.0.1 --with-gmp-version=5.0.5 --with-gcc-version=4.8 --with-gdb-version=7.7 --with-python=/usr/local/google/home/andrewhsieh/mydroid/ndk/prebuilt/linux-x86_64/bin/python-config.sh --with-gxx-include-dir=/tmp/ndk-andrewhsieh/build/toolchain/prefix/include/c++/4.8 --with-bugurl=http://source.android.com/source/report-bugs.html --enable-languages=c,c++ --disable-bootstrap --enable-plugins --enable-libgomp --enable-gnu-indirect-function --disable-libsanitizer --enable-gold --enable-threads --enable-graphite=yes --with-cloog-version=0.18.0 --with-isl-version=0.11.1 --enable-eh-frame-hdr-for-static --with-arch=armv5te --program-transform-name='s&^&arm-linux-androideabi-&' --enable-gold=default
Thread model: posix
gcc version 4.8 (GCC) 
configure:4470: $? = 0
configure:4459: arm-linux-androideabi-gcc -V >&5
arm-linux-androideabi-gcc: error: unrecognized command line option '-V'
arm-linux-androideabi-gcc: fatal error: no input files
compilation terminated.
configure:4470: $? = 1
configure:4459: arm-linux-androideabi-gcc -qversion >&5
arm-linux-androideabi-gcc: error: unrecognized command line option '-qversion'
arm-linux-androideabi-gcc: fatal error: no input files
compilation terminated.
configure:4470: $? = 1
configure:4474: checking whether we are using the GNU C compiler
configure:4502: result: yes
configure:4511: checking whether arm-linux-androideabi-gcc accepts -g
configure:4572: result: yes
configure:4589: checking for arm-linux-androideabi-gcc option to accept ISO C89
configure:4666: result: none needed
configure:4691: checking how to run the C preprocessor
configure:4722: arm-linux-androideabi-gcc -E  conftest.c
configure:4722: $? = 0
configure:4736: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:11:28: fatal error: ac_nonexistent.h: No such file or directory
 #include <ac_nonexistent.h>
                            ^
compilation terminated.
configure:4736: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "binutils"
| #define PACKAGE_TARNAME "binutils"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "binutils 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "binutils"
| #define VERSION "2.25.1"
| /* end confdefs.h.  */
| #include <ac_nonexistent.h>
configure:4761: result: arm-linux-androideabi-gcc -E
configure:4781: arm-linux-androideabi-gcc -E  conftest.c
configure:4781: $? = 0
configure:4795: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:11:28: fatal error: ac_nonexistent.h: No such file or directory
 #include <ac_nonexistent.h>
                            ^
compilation terminated.
configure:4795: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "binutils"
| #define PACKAGE_TARNAME "binutils"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "binutils 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "binutils"
| #define VERSION "2.25.1"
| /* end confdefs.h.  */
| #include <ac_nonexistent.h>
configure:4824: checking for grep that handles long lines and -e
configure:4882: result: /usr/sbin/grep
configure:4887: checking for egrep
configure:4949: result: /usr/sbin/grep -E
configure:4954: checking for ANSI C header files
configure:4974: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:4974: $? = 0
configure:5058: result: yes
configure:5071: checking for sys/types.h
configure:5071: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5071: $? = 0
configure:5071: result: yes
configure:5071: checking for sys/stat.h
configure:5071: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5071: $? = 0
configure:5071: result: yes
configure:5071: checking for stdlib.h
configure:5071: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5071: $? = 0
configure:5071: result: yes
configure:5071: checking for string.h
configure:5071: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5071: $? = 0
configure:5071: result: yes
configure:5071: checking for memory.h
configure:5071: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5071: $? = 0
configure:5071: result: yes
configure:5071: checking for strings.h
configure:5071: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5071: $? = 0
configure:5071: result: yes
configure:5071: checking for inttypes.h
configure:5071: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5071: $? = 0
configure:5071: result: yes
configure:5071: checking for stdint.h
configure:5071: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5071: $? = 0
configure:5071: result: yes
configure:5071: checking for unistd.h
configure:5071: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5071: $? = 0
configure:5071: result: yes
configure:5085: checking minix/config.h usability
configure:5085: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:54:26: fatal error: minix/config.h: No such file or directory
 #include <minix/config.h>
                          ^
compilation terminated.
configure:5085: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "binutils"
| #define PACKAGE_TARNAME "binutils"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "binutils 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "binutils"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <minix/config.h>
configure:5085: result: no
configure:5085: checking minix/config.h presence
configure:5085: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:21:26: fatal error: minix/config.h: No such file or directory
 #include <minix/config.h>
                          ^
compilation terminated.
configure:5085: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "binutils"
| #define PACKAGE_TARNAME "binutils"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "binutils 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "binutils"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| /* end confdefs.h.  */
| #include <minix/config.h>
configure:5085: result: no
configure:5085: checking for minix/config.h
configure:5085: result: no
configure:5106: checking whether it is safe to define __EXTENSIONS__
configure:5124: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5124: $? = 0
configure:5131: result: yes
configure:5194: checking how to print strings
configure:5221: result: printf
configure:5242: checking for a sed that does not truncate output
configure:5306: result: /usr/sbin/sed
configure:5324: checking for fgrep
configure:5386: result: /usr/sbin/grep -F
configure:5421: checking for ld used by arm-linux-androideabi-gcc
configure:5488: result: /tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld
configure:5495: checking if the linker (/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld) is GNU ld
configure:5510: result: yes
configure:5522: checking for BSD- or MS-compatible name lister (nm)
configure:5571: result: nm
configure:5701: checking the name lister (nm) interface
configure:5708: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:5711: nm "conftest.o"
configure:5714: output
00000000 b $d
00000000 B some_variable
configure:5721: result: BSD nm
configure:5724: checking whether ln -s works
configure:5728: result: yes
configure:5736: checking the maximum length of command line arguments
configure:5861: result: 1572864
configure:5878: checking whether the shell understands some XSI constructs
configure:5888: result: yes
configure:5892: checking whether the shell understands "+="
configure:5898: result: yes
configure:5933: checking for /tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld option to reload object files
configure:5940: result: -r
configure:5969: checking for x86_64-unknown-linux-objdump
configure:5996: result: objdump
configure:6068: checking how to recognize dependent libraries
configure:6269: result: pass_all
configure:6289: checking for x86_64-unknown-linux-ar
configure:6316: result: ar
configure:6394: checking for x86_64-unknown-linux-strip
configure:6421: result: strip
configure:6493: checking for x86_64-unknown-linux-ranlib
configure:6520: result: ranlib
configure:6662: checking command to parse nm output from arm-linux-androideabi-gcc object
configure:6780: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:6783: $? = 0
configure:6787: nm conftest.o \| sed -n -e 's/^.*[ ]\([ABCDGIRSTW][ABCDGIRSTW]*\)[ ][ ]*\([_A-Za-z][_A-Za-z0-9]*\)$/\1 \2 \2/p' \> conftest.nm
configure:6790: $? = 0
configure:6844: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c conftstm.o >&5
configure:6847: $? = 0
configure:6885: result: ok
configure:6980: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:6983: $? = 0
configure:7733: checking for dlfcn.h
configure:7733: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:7733: $? = 0
configure:7733: result: yes
configure:7920: checking for objdir
configure:7935: result: .libs
configure:8206: checking if arm-linux-androideabi-gcc supports -fno-rtti -fno-exceptions
configure:8224: arm-linux-androideabi-gcc -c   -fno-rtti -fno-exceptions conftest.c >&5
cc1: warning: command line option '-fno-rtti' is valid for C++/ObjC++ but not for C [enabled by default]
configure:8228: $? = 0
configure:8241: result: no
configure:8261: checking for arm-linux-androideabi-gcc option to produce PIC
configure:8547: result: -fPIC -DPIC
configure:8559: checking if arm-linux-androideabi-gcc PIC flag -fPIC -DPIC works
configure:8577: arm-linux-androideabi-gcc -c   -fPIC -DPIC -DPIC conftest.c >&5
configure:8581: $? = 0
configure:8594: result: yes
configure:8618: checking if arm-linux-androideabi-gcc static flag -static works
configure:8646: result: yes
configure:8661: checking if arm-linux-androideabi-gcc supports -c -o file.o
configure:8682: arm-linux-androideabi-gcc -c   -o out/conftest2.o conftest.c >&5
configure:8686: $? = 0
configure:8708: result: yes
configure:8716: checking if arm-linux-androideabi-gcc supports -c -o file.o
configure:8763: result: yes
configure:8796: checking whether the arm-linux-androideabi-gcc linker (/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld -m elf_i386) supports shared libraries
configure:9867: result: yes
configure:9904: checking whether -lc should be explicitly linked in
configure:9912: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:9915: $? = 0
configure:9930: arm-linux-androideabi-gcc -shared conftest.o  -v -Wl,-soname -Wl,conftest -o conftest 2\>\&1 \| /usr/sbin/grep  -lc  \>/dev/null 2\>\&1
configure:9933: $? = 0
configure:9947: result: no
configure:10112: checking dynamic linker characteristics
configure:10563: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  -Wl,-rpath -Wl,/foo conftest.c  >&5
configure:10563: $? = 0
configure:10785: result: GNU/Linux ld.so
configure:10892: checking how to hardcode library paths into programs
configure:10917: result: immediate
configure:11457: checking whether stripping libraries is possible
configure:11462: result: yes
configure:11497: checking if libtool supports shared libraries
configure:11499: result: yes
configure:11502: checking whether to build shared libraries
configure:11523: result: yes
configure:11526: checking whether to build static libraries
configure:11530: result: yes
configure:11578: checking for dlfcn.h
configure:11578: result: yes
configure:11591: checking for windows.h
configure:11591: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:63:21: fatal error: windows.h: No such file or directory
 #include <windows.h>
                     ^
compilation terminated.
configure:11591: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "binutils"
| #define PACKAGE_TARNAME "binutils"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "binutils 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "binutils"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| 
| #include <windows.h>
configure:11591: result: no
configure:11618: checking for library containing dlopen
configure:11649: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:11649: $? = 0
configure:11666: result: none required
configure:11697: checking for special C compiler options needed for large files
configure:11742: result: no
configure:11748: checking for _FILE_OFFSET_BITS value needed for large files
configure:11773: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:35:3: warning: left shift count >= width of type [enabled by default]
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
   ^
conftest.c:35:3: warning: left shift count >= width of type [enabled by default]
conftest.c:36:10: warning: left shift count >= width of type [enabled by default]
          && LARGE_OFF_T % 2147483647 == 1)
          ^
conftest.c:36:10: warning: left shift count >= width of type [enabled by default]
conftest.c:35:7: error: variably modified 'off_t_is_large' at file scope
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
       ^
configure:11773: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "binutils"
| #define PACKAGE_TARNAME "binutils"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "binutils 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "binutils"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| /* end confdefs.h.  */
| #include <sys/types.h>
|  /* Check that off_t can represent 2**63 - 1 correctly.
|     We can't simply define LARGE_OFF_T to be 9223372036854775807,
|     since some C++ compilers masquerading as C compilers
|     incorrectly reject 9223372036854775807.  */
| #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
|   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
| 		       && LARGE_OFF_T % 2147483647 == 1)
| 		      ? 1 : -1];
| int
| main ()
| {
| 
|   ;
|   return 0;
| }
configure:11797: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:36:3: warning: left shift count >= width of type [enabled by default]
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
   ^
conftest.c:36:3: warning: left shift count >= width of type [enabled by default]
conftest.c:37:10: warning: left shift count >= width of type [enabled by default]
          && LARGE_OFF_T % 2147483647 == 1)
          ^
conftest.c:37:10: warning: left shift count >= width of type [enabled by default]
conftest.c:36:7: error: variably modified 'off_t_is_large' at file scope
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
       ^
configure:11797: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "binutils"
| #define PACKAGE_TARNAME "binutils"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "binutils 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "binutils"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| /* end confdefs.h.  */
| #define _FILE_OFFSET_BITS 64
| #include <sys/types.h>
|  /* Check that off_t can represent 2**63 - 1 correctly.
|     We can't simply define LARGE_OFF_T to be 9223372036854775807,
|     since some C++ compilers masquerading as C compilers
|     incorrectly reject 9223372036854775807.  */
| #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
|   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
| 		       && LARGE_OFF_T % 2147483647 == 1)
| 		      ? 1 : -1];
| int
| main ()
| {
| 
|   ;
|   return 0;
| }
configure:11805: result: unknown
configure:11817: checking for _LARGE_FILES value needed for large files
configure:11842: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:35:3: warning: left shift count >= width of type [enabled by default]
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
   ^
conftest.c:35:3: warning: left shift count >= width of type [enabled by default]
conftest.c:36:10: warning: left shift count >= width of type [enabled by default]
          && LARGE_OFF_T % 2147483647 == 1)
          ^
conftest.c:36:10: warning: left shift count >= width of type [enabled by default]
conftest.c:35:7: error: variably modified 'off_t_is_large' at file scope
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
       ^
configure:11842: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "binutils"
| #define PACKAGE_TARNAME "binutils"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "binutils 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "binutils"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| /* end confdefs.h.  */
| #include <sys/types.h>
|  /* Check that off_t can represent 2**63 - 1 correctly.
|     We can't simply define LARGE_OFF_T to be 9223372036854775807,
|     since some C++ compilers masquerading as C compilers
|     incorrectly reject 9223372036854775807.  */
| #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
|   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
| 		       && LARGE_OFF_T % 2147483647 == 1)
| 		      ? 1 : -1];
| int
| main ()
| {
| 
|   ;
|   return 0;
| }
configure:11866: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:36:3: warning: left shift count >= width of type [enabled by default]
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
   ^
conftest.c:36:3: warning: left shift count >= width of type [enabled by default]
conftest.c:37:10: warning: left shift count >= width of type [enabled by default]
          && LARGE_OFF_T % 2147483647 == 1)
          ^
conftest.c:37:10: warning: left shift count >= width of type [enabled by default]
conftest.c:36:7: error: variably modified 'off_t_is_large' at file scope
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
       ^
configure:11866: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "binutils"
| #define PACKAGE_TARNAME "binutils"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "binutils 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "binutils"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| /* end confdefs.h.  */
| #define _LARGE_FILES 1
| #include <sys/types.h>
|  /* Check that off_t can represent 2**63 - 1 correctly.
|     We can't simply define LARGE_OFF_T to be 9223372036854775807,
|     since some C++ compilers masquerading as C compilers
|     incorrectly reject 9223372036854775807.  */
| #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
|   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
| 		       && LARGE_OFF_T % 2147483647 == 1)
| 		      ? 1 : -1];
| int
| main ()
| {
| 
|   ;
|   return 0;
| }
configure:11874: result: unknown
configure:12031: checking for bison
configure:12058: result: bison -y
configure:12074: checking for flex
configure:12101: result: flex
configure:12138: flex conftest.l
configure:12142: $? = 0
configure:12144: checking lex output file root
configure:12158: result: lex.yy
configure:12163: checking lex library
configure:12177: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c   >&5
/tmp/ccER0rFs.o:conftest.c:function yylex: error: undefined reference to 'yywrap'
/tmp/ccER0rFs.o:conftest.c:function input: error: undefined reference to 'yywrap'
/tmp/ccER0rFs.o:conftest.c:function main: error: undefined reference to 'yywrap'
collect2: error: ld returned 1 exit status
configure:12177: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "binutils"
| #define PACKAGE_TARNAME "binutils"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "binutils 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "binutils"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define DEFAULT_AR_DETERMINISTIC 0
| #define DEFAULT_STRINGS_ALL 1
| /* end confdefs.h.  */
| 
| #line 3 "lex.yy.c"
| 
| #define  YY_INT_ALIGNED short int
| 
| /* A lexical scanner generated by flex */
| 
| #define FLEX_SCANNER
| #define YY_FLEX_MAJOR_VERSION 2
| #define YY_FLEX_MINOR_VERSION 5
| #define YY_FLEX_SUBMINOR_VERSION 39
| #if YY_FLEX_SUBMINOR_VERSION > 0
| #define FLEX_BETA
| #endif
| 
| /* First, we deal with  platform-specific or compiler-specific issues. */
| 
| /* begin standard C headers. */
| #include <stdio.h>
| #include <string.h>
| #include <errno.h>
| #include <stdlib.h>
| 
| /* end standard C headers. */
| 
| /* flex integer type definitions */
| 
| #ifndef FLEXINT_H
| #define FLEXINT_H
| 
| /* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
| 
| #if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
| 
| /* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
|  * if you want the limit (max/min) macros for int types. 
|  */
| #ifndef __STDC_LIMIT_MACROS
| #define __STDC_LIMIT_MACROS 1
| #endif
| 
| #include <inttypes.h>
| typedef int8_t flex_int8_t;
| typedef uint8_t flex_uint8_t;
| typedef int16_t flex_int16_t;
| typedef uint16_t flex_uint16_t;
| typedef int32_t flex_int32_t;
| typedef uint32_t flex_uint32_t;
| #else
| typedef signed char flex_int8_t;
| typedef short int flex_int16_t;
| typedef int flex_int32_t;
| typedef unsigned char flex_uint8_t; 
| typedef unsigned short int flex_uint16_t;
| typedef unsigned int flex_uint32_t;
| 
| /* Limits of integral types. */
| #ifndef INT8_MIN
| #define INT8_MIN               (-128)
| #endif
| #ifndef INT16_MIN
| #define INT16_MIN              (-32767-1)
| #endif
| #ifndef INT32_MIN
| #define INT32_MIN              (-2147483647-1)
| #endif
| #ifndef INT8_MAX
| #define INT8_MAX               (127)
| #endif
| #ifndef INT16_MAX
| #define INT16_MAX              (32767)
| #endif
| #ifndef INT32_MAX
| #define INT32_MAX              (2147483647)
| #endif
| #ifndef UINT8_MAX
| #define UINT8_MAX              (255U)
| #endif
| #ifndef UINT16_MAX
| #define UINT16_MAX             (65535U)
| #endif
| #ifndef UINT32_MAX
| #define UINT32_MAX             (4294967295U)
| #endif
| 
| #endif /* ! C99 */
| 
| #endif /* ! FLEXINT_H */
| 
| #ifdef __cplusplus
| 
| /* The "const" storage-class-modifier is valid. */
| #define YY_USE_CONST
| 
| #else	/* ! __cplusplus */
| 
| /* C99 requires __STDC__ to be defined as 1. */
| #if defined (__STDC__)
| 
| #define YY_USE_CONST
| 
| #endif	/* defined (__STDC__) */
| #endif	/* ! __cplusplus */
| 
| #ifdef YY_USE_CONST
| #define yyconst const
| #else
| #define yyconst
| #endif
| 
| /* Returned upon end-of-file. */
| #define YY_NULL 0
| 
| /* Promotes a possibly negative, possibly signed char to an unsigned
|  * integer for use as an array index.  If the signed char is negative,
|  * we want to instead treat it as an 8-bit unsigned char, hence the
|  * double cast.
|  */
| #define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
| 
| /* Enter a start condition.  This macro really ought to take a parameter,
|  * but we do it the disgusting crufty way forced on us by the ()-less
|  * definition of BEGIN.
|  */
| #define BEGIN (yy_start) = 1 + 2 *
| 
| /* Translate the current start state into a value that can be later handed
|  * to BEGIN to return to the state.  The YYSTATE alias is for lex
|  * compatibility.
|  */
| #define YY_START (((yy_start) - 1) / 2)
| #define YYSTATE YY_START
| 
| /* Action number for EOF rule of a given start state. */
| #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
| 
| /* Special action meaning "start processing a new file". */
| #define YY_NEW_FILE yyrestart(yyin  )
| 
| #define YY_END_OF_BUFFER_CHAR 0
| 
| /* Size of default input buffer. */
| #ifndef YY_BUF_SIZE
| #define YY_BUF_SIZE 16384
| #endif
| 
| /* The state buf must be large enough to hold one state per character in the main buffer.
|  */
| #define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
| 
| #ifndef YY_TYPEDEF_YY_BUFFER_STATE
| #define YY_TYPEDEF_YY_BUFFER_STATE
| typedef struct yy_buffer_state *YY_BUFFER_STATE;
| #endif
| 
| #ifndef YY_TYPEDEF_YY_SIZE_T
| #define YY_TYPEDEF_YY_SIZE_T
| typedef size_t yy_size_t;
| #endif
| 
| extern yy_size_t yyleng;
| 
| extern FILE *yyin, *yyout;
| 
| #define EOB_ACT_CONTINUE_SCAN 0
| #define EOB_ACT_END_OF_FILE 1
| #define EOB_ACT_LAST_MATCH 2
| 
|     #define YY_LESS_LINENO(n)
|     #define YY_LINENO_REWIND_TO(ptr)
|     
| /* Return all but the first "n" matched characters back to the input stream. */
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
|         int yyless_macro_arg = (n); \
|         YY_LESS_LINENO(yyless_macro_arg);\
| 		*yy_cp = (yy_hold_char); \
| 		YY_RESTORE_YY_MORE_OFFSET \
| 		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
| 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
| 		} \
| 	while ( 0 )
| 
| #define unput(c) yyunput( c, (yytext_ptr)  )
| 
| #ifndef YY_STRUCT_YY_BUFFER_STATE
| #define YY_STRUCT_YY_BUFFER_STATE
| struct yy_buffer_state
| 	{
| 	FILE *yy_input_file;
| 
| 	char *yy_ch_buf;		/* input buffer */
| 	char *yy_buf_pos;		/* current position in input buffer */
| 
| 	/* Size of input buffer in bytes, not including room for EOB
| 	 * characters.
| 	 */
| 	yy_size_t yy_buf_size;
| 
| 	/* Number of characters read into yy_ch_buf, not including EOB
| 	 * characters.
| 	 */
| 	yy_size_t yy_n_chars;
| 
| 	/* Whether we "own" the buffer - i.e., we know we created it,
| 	 * and can realloc() it to grow it, and should free() it to
| 	 * delete it.
| 	 */
| 	int yy_is_our_buffer;
| 
| 	/* Whether this is an "interactive" input source; if so, and
| 	 * if we're using stdio for input, then we want to use getc()
| 	 * instead of fread(), to make sure we stop fetching input after
| 	 * each newline.
| 	 */
| 	int yy_is_interactive;
| 
| 	/* Whether we're considered to be at the beginning of a line.
| 	 * If so, '^' rules will be active on the next match, otherwise
| 	 * not.
| 	 */
| 	int yy_at_bol;
| 
|     int yy_bs_lineno; /**< The line count. */
|     int yy_bs_column; /**< The column count. */
|     
| 	/* Whether to try to fill the input buffer when we reach the
| 	 * end of it.
| 	 */
| 	int yy_fill_buffer;
| 
| 	int yy_buffer_status;
| 
| #define YY_BUFFER_NEW 0
| #define YY_BUFFER_NORMAL 1
| 	/* When an EOF's been seen but there's still some text to process
| 	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
| 	 * shouldn't try reading from the input source any more.  We might
| 	 * still have a bunch of tokens to match, though, because of
| 	 * possible backing-up.
| 	 *
| 	 * When we actually see the EOF, we change the status to "new"
| 	 * (via yyrestart()), so that the user can continue scanning by
| 	 * just pointing yyin at a new input file.
| 	 */
| #define YY_BUFFER_EOF_PENDING 2
| 
| 	};
| #endif /* !YY_STRUCT_YY_BUFFER_STATE */
| 
| /* Stack of input buffers. */
| static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
| static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
| static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
| 
| /* We provide macros for accessing buffer states in case in the
|  * future we want to put the buffer states in a more general
|  * "scanner state".
|  *
|  * Returns the top of the stack, or NULL.
|  */
| #define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
|                           ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
|                           : NULL)
| 
| /* Same as previous macro, but useful when we know that the buffer stack is not
|  * NULL or when we need an lvalue. For internal use only.
|  */
| #define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
| 
| /* yy_hold_char holds the character lost when yytext is formed. */
| static char yy_hold_char;
| static yy_size_t yy_n_chars;		/* number of characters read into yy_ch_buf */
| yy_size_t yyleng;
| 
| /* Points to current character in buffer. */
| static char *yy_c_buf_p = (char *) 0;
| static int yy_init = 0;		/* whether we need to initialize */
| static int yy_start = 0;	/* start state number */
| 
| /* Flag which is used to allow yywrap()'s to do buffer switches
|  * instead of setting up a fresh yyin.  A bit of a hack ...
|  */
| static int yy_did_buffer_switch_on_eof;
| 
| void yyrestart (FILE *input_file  );
| void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
| YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
| void yy_delete_buffer (YY_BUFFER_STATE b  );
| void yy_flush_buffer (YY_BUFFER_STATE b  );
| void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
| void yypop_buffer_state (void );
| 
| static void yyensure_buffer_stack (void );
| static void yy_load_buffer_state (void );
| static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
| 
| #define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
| 
| YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
| YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
| YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,yy_size_t len  );
| 
| void *yyalloc (yy_size_t  );
| void *yyrealloc (void *,yy_size_t  );
| void yyfree (void *  );
| 
| #define yy_new_buffer yy_create_buffer
| 
| #define yy_set_interactive(is_interactive) \
| 	{ \
| 	if ( ! YY_CURRENT_BUFFER ){ \
|         yyensure_buffer_stack (); \
| 		YY_CURRENT_BUFFER_LVALUE =    \
|             yy_create_buffer(yyin,YY_BUF_SIZE ); \
| 	} \
| 	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
| 	}
| 
| #define yy_set_bol(at_bol) \
| 	{ \
| 	if ( ! YY_CURRENT_BUFFER ){\
|         yyensure_buffer_stack (); \
| 		YY_CURRENT_BUFFER_LVALUE =    \
|             yy_create_buffer(yyin,YY_BUF_SIZE ); \
| 	} \
| 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
| 	}
| 
| #define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
| 
| /* Begin user sect3 */
| 
| typedef unsigned char YY_CHAR;
| 
| FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
| 
| typedef int yy_state_type;
| 
| extern int yylineno;
| 
| int yylineno = 1;
| 
| extern char *yytext;
| #define yytext_ptr yytext
| 
| static yy_state_type yy_get_previous_state (void );
| static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
| static int yy_get_next_buffer (void );
| static void yy_fatal_error (yyconst char msg[]  );
| 
| /* Done after the current pattern has been matched and before the
|  * corresponding action - sets up yytext.
|  */
| #define YY_DO_BEFORE_ACTION \
| 	(yytext_ptr) = yy_bp; \
| 	(yytext_ptr) -= (yy_more_len); \
| 	yyleng = (size_t) (yy_cp - (yytext_ptr)); \
| 	(yy_hold_char) = *yy_cp; \
| 	*yy_cp = '\0'; \
| 	(yy_c_buf_p) = yy_cp;
| 
| #define YY_NUM_RULES 8
| #define YY_END_OF_BUFFER 9
| /* This struct is not used in this scanner,
|    but its presence is necessary. */
| struct yy_trans_info
| 	{
| 	flex_int32_t yy_verify;
| 	flex_int32_t yy_nxt;
| 	};
| static yyconst flex_int16_t yy_acclist[23] =
|     {   0,
|         9,    7,    8,    8,    1,    7,    8,    2,    7,    8,
|         3,    7,    8,    4,    7,    8,    5,    7,    8,    6,
|         7,    8
|     } ;
| 
| static yyconst flex_int16_t yy_accept[14] =
|     {   0,
|         1,    1,    1,    2,    4,    5,    8,   11,   14,   17,
|        20,   23,   23
|     } ;
| 
| static yyconst flex_int32_t yy_ec[256] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    3,    4,    5,    6,
| 
|         7,    8,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| 
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1
|     } ;
| 
| static yyconst flex_int32_t yy_meta[9] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1
|     } ;
| 
| static yyconst flex_int16_t yy_base[13] =
|     {   0,
|         0,    0,    9,   10,   10,   10,   10,   10,   10,   10,
|        10,   10
|     } ;
| 
| static yyconst flex_int16_t yy_def[13] =
|     {   0,
|        12,    1,   12,   12,   12,   12,   12,   12,   12,   12,
|        12,    0
|     } ;
| 
| static yyconst flex_int16_t yy_nxt[19] =
|     {   0,
|         4,    5,    6,    7,    8,    9,   10,   11,   12,    3,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| static yyconst flex_int16_t yy_chk[19] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    3,   12,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| extern int yy_flex_debug;
| int yy_flex_debug = 0;
| 
| static yy_state_type *yy_state_buf=0, *yy_state_ptr=0;
| static char *yy_full_match;
| static int yy_lp;
| #define REJECT \
| { \
| *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */ \
| yy_cp = (yy_full_match); /* restore poss. backed-over text */ \
| ++(yy_lp); \
| goto find_rule; \
| }
| 
| static int yy_more_flag = 0;
| static int yy_more_len = 0;
| #define yymore() ((yy_more_flag) = 1)
| #define YY_MORE_ADJ (yy_more_len)
| #define YY_RESTORE_YY_MORE_OFFSET
| char *yytext;
| #line 1 "conftest.l"
| #line 470 "lex.yy.c"
| 
| #define INITIAL 0
| 
| #ifndef YY_NO_UNISTD_H
| /* Special case for "unistd.h", since it is non-ANSI. We include it way
|  * down here because we want the user's section 1 to have been scanned first.
|  * The user has a chance to override it with an option.
|  */
| #include <unistd.h>
| #endif
| 
| #ifndef YY_EXTRA_TYPE
| #define YY_EXTRA_TYPE void *
| #endif
| 
| static int yy_init_globals (void );
| 
| /* Accessor methods to globals.
|    These are made visible to non-reentrant scanners for convenience. */
| 
| int yylex_destroy (void );
| 
| int yyget_debug (void );
| 
| void yyset_debug (int debug_flag  );
| 
| YY_EXTRA_TYPE yyget_extra (void );
| 
| void yyset_extra (YY_EXTRA_TYPE user_defined  );
| 
| FILE *yyget_in (void );
| 
| void yyset_in  (FILE * in_str  );
| 
| FILE *yyget_out (void );
| 
| void yyset_out  (FILE * out_str  );
| 
| yy_size_t yyget_leng (void );
| 
| char *yyget_text (void );
| 
| int yyget_lineno (void );
| 
| void yyset_lineno (int line_number  );
| 
| /* Macros after this point can all be overridden by user definitions in
|  * section 1.
|  */
| 
| #ifndef YY_SKIP_YYWRAP
| #ifdef __cplusplus
| extern "C" int yywrap (void );
| #else
| extern int yywrap (void );
| #endif
| #endif
| 
|     static void yyunput (int c,char *buf_ptr  );
|     
| #ifndef yytext_ptr
| static void yy_flex_strncpy (char *,yyconst char *,int );
| #endif
| 
| #ifdef YY_NEED_STRLEN
| static int yy_flex_strlen (yyconst char * );
| #endif
| 
| #ifndef YY_NO_INPUT
| 
| #ifdef __cplusplus
| static int yyinput (void );
| #else
| static int input (void );
| #endif
| 
| #endif
| 
| /* Amount of stuff to slurp up with each read. */
| #ifndef YY_READ_BUF_SIZE
| #define YY_READ_BUF_SIZE 8192
| #endif
| 
| /* Copy whatever the last rule matched to the standard output. */
| #ifndef ECHO
| /* This used to be an fputs(), but since the string might contain NUL's,
|  * we now use fwrite().
|  */
| #define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
| #endif
| 
| /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
|  * is returned in "result".
|  */
| #ifndef YY_INPUT
| #define YY_INPUT(buf,result,max_size) \
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
| 		{ \
| 		int c = '*'; \
| 		size_t n; \
| 		for ( n = 0; n < max_size && \
| 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
| 			buf[n] = (char) c; \
| 		if ( c == '\n' ) \
| 			buf[n++] = (char) c; \
| 		if ( c == EOF && ferror( yyin ) ) \
| 			YY_FATAL_ERROR( "input in flex scanner failed" ); \
| 		result = n; \
| 		} \
| 	else \
| 		{ \
| 		errno=0; \
| 		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
| 			{ \
| 			if( errno != EINTR) \
| 				{ \
| 				YY_FATAL_ERROR( "input in flex scanner failed" ); \
| 				break; \
| 				} \
| 			errno=0; \
| 			clearerr(yyin); \
| 			} \
| 		}\
| \
| 
| #endif
| 
| /* No semi-colon after return; correct usage is to write "yyterminate();" -
|  * we don't want an extra ';' after the "return" because that will cause
|  * some compilers to complain about unreachable statements.
|  */
| #ifndef yyterminate
| #define yyterminate() return YY_NULL
| #endif
| 
| /* Number of entries by which start-condition stack grows. */
| #ifndef YY_START_STACK_INCR
| #define YY_START_STACK_INCR 25
| #endif
| 
| /* Report a fatal error. */
| #ifndef YY_FATAL_ERROR
| #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
| #endif
| 
| /* end tables serialization structures and prototypes */
| 
| /* Default declaration of generated scanner - a define so the user can
|  * easily add parameters.
|  */
| #ifndef YY_DECL
| #define YY_DECL_IS_OURS 1
| 
| extern int yylex (void);
| 
| #define YY_DECL int yylex (void)
| #endif /* !YY_DECL */
| 
| /* Code executed at the beginning of each rule, after yytext and yyleng
|  * have been set up.
|  */
| #ifndef YY_USER_ACTION
| #define YY_USER_ACTION
| #endif
| 
| /* Code executed at the end of each rule. */
| #ifndef YY_BREAK
| #define YY_BREAK break;
| #endif
| 
| #define YY_RULE_SETUP \
| 	YY_USER_ACTION
| 
| /** The main scanner function which does all the work.
|  */
| YY_DECL
| {
| 	register yy_state_type yy_current_state;
| 	register char *yy_cp, *yy_bp;
| 	register int yy_act;
|     
| 	if ( !(yy_init) )
| 		{
| 		(yy_init) = 1;
| 
| #ifdef YY_USER_INIT
| 		YY_USER_INIT;
| #endif
| 
|         /* Create the reject buffer large enough to save one state per allowed character. */
|         if ( ! (yy_state_buf) )
|             (yy_state_buf) = (yy_state_type *)yyalloc(YY_STATE_BUF_SIZE  );
|             if ( ! (yy_state_buf) )
|                 YY_FATAL_ERROR( "out of dynamic memory in yylex()" );
| 
| 		if ( ! (yy_start) )
| 			(yy_start) = 1;	/* first start state */
| 
| 		if ( ! yyin )
| 			yyin = stdin;
| 
| 		if ( ! yyout )
| 			yyout = stdout;
| 
| 		if ( ! YY_CURRENT_BUFFER ) {
| 			yyensure_buffer_stack ();
| 			YY_CURRENT_BUFFER_LVALUE =
| 				yy_create_buffer(yyin,YY_BUF_SIZE );
| 		}
| 
| 		yy_load_buffer_state( );
| 		}
| 
| 	{
| #line 1 "conftest.l"
| 
| #line 687 "lex.yy.c"
| 
| 	while ( 1 )		/* loops until end-of-file is reached */
| 		{
| 		(yy_more_len) = 0;
| 		if ( (yy_more_flag) )
| 			{
| 			(yy_more_len) = (yy_c_buf_p) - (yytext_ptr);
| 			(yy_more_flag) = 0;
| 			}
| 		yy_cp = (yy_c_buf_p);
| 
| 		/* Support of yytext. */
| 		*yy_cp = (yy_hold_char);
| 
| 		/* yy_bp points to the position in yy_ch_buf of the start of
| 		 * the current run.
| 		 */
| 		yy_bp = yy_cp;
| 
| 		yy_current_state = (yy_start);
| 
| 		(yy_state_ptr) = (yy_state_buf);
| 		*(yy_state_ptr)++ = yy_current_state;
| 
| yy_match:
| 		do
| 			{
| 			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
| 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 				{
| 				yy_current_state = (int) yy_def[yy_current_state];
| 				if ( yy_current_state >= 13 )
| 					yy_c = yy_meta[(unsigned int) yy_c];
| 				}
| 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 			*(yy_state_ptr)++ = yy_current_state;
| 			++yy_cp;
| 			}
| 		while ( yy_base[yy_current_state] != 10 );
| 
| yy_find_action:
| 		yy_current_state = *--(yy_state_ptr);
| 		(yy_lp) = yy_accept[yy_current_state];
| find_rule: /* we branch to this label when backing up */
| 		for ( ; ; ) /* until we find what rule we matched */
| 			{
| 			if ( (yy_lp) && (yy_lp) < yy_accept[yy_current_state + 1] )
| 				{
| 				yy_act = yy_acclist[(yy_lp)];
| 					{
| 					(yy_full_match) = yy_cp;
| 					break;
| 					}
| 				}
| 			--yy_cp;
| 			yy_current_state = *--(yy_state_ptr);
| 			(yy_lp) = yy_accept[yy_current_state];
| 			}
| 
| 		YY_DO_BEFORE_ACTION;
| 
| do_action:	/* This label is used only to access EOF actions. */
| 
| 		switch ( yy_act )
| 	{ /* beginning of action switch */
| case 1:
| YY_RULE_SETUP
| #line 2 "conftest.l"
| { ECHO; }
| 	YY_BREAK
| case 2:
| YY_RULE_SETUP
| #line 3 "conftest.l"
| { REJECT; }
| 	YY_BREAK
| case 3:
| YY_RULE_SETUP
| #line 4 "conftest.l"
| { yymore (); }
| 	YY_BREAK
| case 4:
| YY_RULE_SETUP
| #line 5 "conftest.l"
| { yyless (1); }
| 	YY_BREAK
| case 5:
| YY_RULE_SETUP
| #line 6 "conftest.l"
| { yyless (input () != 0); }
| 	YY_BREAK
| case 6:
| YY_RULE_SETUP
| #line 7 "conftest.l"
| { unput (yytext[0]); }
| 	YY_BREAK
| case 7:
| YY_RULE_SETUP
| #line 8 "conftest.l"
| { BEGIN INITIAL; }
| 	YY_BREAK
| case 8:
| YY_RULE_SETUP
| #line 9 "conftest.l"
| ECHO;
| 	YY_BREAK
| #line 793 "lex.yy.c"
| 			case YY_STATE_EOF(INITIAL):
| 				yyterminate();
| 
| 	case YY_END_OF_BUFFER:
| 		{
| 		/* Amount of text matched not including the EOB char. */
| 		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
| 
| 		/* Undo the effects of YY_DO_BEFORE_ACTION. */
| 		*yy_cp = (yy_hold_char);
| 		YY_RESTORE_YY_MORE_OFFSET
| 
| 		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
| 			{
| 			/* We're scanning a new file or input source.  It's
| 			 * possible that this happened because the user
| 			 * just pointed yyin at a new source and called
| 			 * yylex().  If so, then we have to assure
| 			 * consistency between YY_CURRENT_BUFFER and our
| 			 * globals.  Here is the right place to do so, because
| 			 * this is the first action (other than possibly a
| 			 * back-up) that will match for the new input source.
| 			 */
| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
| 			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
| 			}
| 
| 		/* Note that here we test for yy_c_buf_p "<=" to the position
| 		 * of the first EOB in the buffer, since yy_c_buf_p will
| 		 * already have been incremented past the NUL character
| 		 * (since all states make transitions on EOB to the
| 		 * end-of-buffer state).  Contrast this with the test
| 		 * in input().
| 		 */
| 		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
| 			{ /* This was really a NUL. */
| 			yy_state_type yy_next_state;
| 
| 			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
| 
| 			yy_current_state = yy_get_previous_state(  );
| 
| 			/* Okay, we're now positioned to make the NUL
| 			 * transition.  We couldn't have
| 			 * yy_get_previous_state() go ahead and do it
| 			 * for us because it doesn't know how to deal
| 			 * with the possibility of jamming (and we don't
| 			 * want to build jamming into it because then it
| 			 * will run more slowly).
| 			 */
| 
| 			yy_next_state = yy_try_NUL_trans( yy_current_state );
| 
| 			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 
| 			if ( yy_next_state )
| 				{
| 				/* Consume the NUL. */
| 				yy_cp = ++(yy_c_buf_p);
| 				yy_current_state = yy_next_state;
| 				goto yy_match;
| 				}
| 
| 			else
| 				{
| 				yy_cp = (yy_c_buf_p);
| 				goto yy_find_action;
| 				}
| 			}
| 
| 		else switch ( yy_get_next_buffer(  ) )
| 			{
| 			case EOB_ACT_END_OF_FILE:
| 				{
| 				(yy_did_buffer_switch_on_eof) = 0;
| 
| 				if ( yywrap( ) )
| 					{
| 					/* Note: because we've taken care in
| 					 * yy_get_next_buffer() to have set up
| 					 * yytext, we can now set up
| 					 * yy_c_buf_p so that if some total
| 					 * hoser (like flex itself) wants to
| 					 * call the scanner after we return the
| 					 * YY_NULL, it'll still work - another
| 					 * YY_NULL will get returned.
| 					 */
| 					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
| 
| 					yy_act = YY_STATE_EOF(YY_START);
| 					goto do_action;
| 					}
| 
| 				else
| 					{
| 					if ( ! (yy_did_buffer_switch_on_eof) )
| 						YY_NEW_FILE;
| 					}
| 				break;
| 				}
| 
| 			case EOB_ACT_CONTINUE_SCAN:
| 				(yy_c_buf_p) =
| 					(yytext_ptr) + yy_amount_of_matched_text;
| 
| 				yy_current_state = yy_get_previous_state(  );
| 
| 				yy_cp = (yy_c_buf_p);
| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 				goto yy_match;
| 
| 			case EOB_ACT_LAST_MATCH:
| 				(yy_c_buf_p) =
| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
| 
| 				yy_current_state = yy_get_previous_state(  );
| 
| 				yy_cp = (yy_c_buf_p);
| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 				goto yy_find_action;
| 			}
| 		break;
| 		}
| 
| 	default:
| 		YY_FATAL_ERROR(
| 			"fatal flex scanner internal error--no action found" );
| 	} /* end of action switch */
| 		} /* end of scanning one token */
| 	} /* end of user's declarations */
| } /* end of yylex */
| 
| /* yy_get_next_buffer - try to read in a new buffer
|  *
|  * Returns a code representing an action:
|  *	EOB_ACT_LAST_MATCH -
|  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
|  *	EOB_ACT_END_OF_FILE - end of file
|  */
| static int yy_get_next_buffer (void)
| {
|     	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
| 	register char *source = (yytext_ptr);
| 	register int number_to_move, i;
| 	int ret_val;
| 
| 	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
| 		YY_FATAL_ERROR(
| 		"fatal flex scanner internal error--end of buffer missed" );
| 
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
| 		{ /* Don't try to fill the buffer, so this is an EOF. */
| 		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
| 			{
| 			/* We matched a single character, the EOB, so
| 			 * treat this as a final EOF.
| 			 */
| 			return EOB_ACT_END_OF_FILE;
| 			}
| 
| 		else
| 			{
| 			/* We matched some text prior to the EOB, first
| 			 * process it.
| 			 */
| 			return EOB_ACT_LAST_MATCH;
| 			}
| 		}
| 
| 	/* Try to read more data. */
| 
| 	/* First move last chars to start of buffer. */
| 	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
| 
| 	for ( i = 0; i < number_to_move; ++i )
| 		*(dest++) = *(source++);
| 
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
| 		/* don't do the read, it's not guaranteed to return an EOF,
| 		 * just force an EOF
| 		 */
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
| 
| 	else
| 		{
| 			yy_size_t num_to_read =
| 			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
| 
| 		while ( num_to_read <= 0 )
| 			{ /* Not enough room in the buffer - grow it. */
| 
| 			YY_FATAL_ERROR(
| "input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
| 
| 			}
| 
| 		if ( num_to_read > YY_READ_BUF_SIZE )
| 			num_to_read = YY_READ_BUF_SIZE;
| 
| 		/* Read in more data. */
| 		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
| 			(yy_n_chars), num_to_read );
| 
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	if ( (yy_n_chars) == 0 )
| 		{
| 		if ( number_to_move == YY_MORE_ADJ )
| 			{
| 			ret_val = EOB_ACT_END_OF_FILE;
| 			yyrestart(yyin  );
| 			}
| 
| 		else
| 			{
| 			ret_val = EOB_ACT_LAST_MATCH;
| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
| 				YY_BUFFER_EOF_PENDING;
| 			}
| 		}
| 
| 	else
| 		ret_val = EOB_ACT_CONTINUE_SCAN;
| 
| 	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
| 		/* Extend the array by 50%, plus the number we really need. */
| 		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
| 		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
| 		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
| 			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
| 	}
| 
| 	(yy_n_chars) += number_to_move;
| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
| 
| 	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
| 
| 	return ret_val;
| }
| 
| /* yy_get_previous_state - get the state just before the EOB char was reached */
| 
|     static yy_state_type yy_get_previous_state (void)
| {
| 	register yy_state_type yy_current_state;
| 	register char *yy_cp;
|     
| 	yy_current_state = (yy_start);
| 
| 	(yy_state_ptr) = (yy_state_buf);
| 	*(yy_state_ptr)++ = yy_current_state;
| 
| 	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
| 		{
| 		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
| 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 			{
| 			yy_current_state = (int) yy_def[yy_current_state];
| 			if ( yy_current_state >= 13 )
| 				yy_c = yy_meta[(unsigned int) yy_c];
| 			}
| 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 		*(yy_state_ptr)++ = yy_current_state;
| 		}
| 
| 	return yy_current_state;
| }
| 
| /* yy_try_NUL_trans - try to make a transition on the NUL character
|  *
|  * synopsis
|  *	next_state = yy_try_NUL_trans( current_state );
|  */
|     static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
| {
| 	register int yy_is_jam;
|     
| 	register YY_CHAR yy_c = 1;
| 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 		{
| 		yy_current_state = (int) yy_def[yy_current_state];
| 		if ( yy_current_state >= 13 )
| 			yy_c = yy_meta[(unsigned int) yy_c];
| 		}
| 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 	yy_is_jam = (yy_current_state == 12);
| 	if ( ! yy_is_jam )
| 		*(yy_state_ptr)++ = yy_current_state;
| 
| 		return yy_is_jam ? 0 : yy_current_state;
| }
| 
|     static void yyunput (int c, register char * yy_bp )
| {
| 	register char *yy_cp;
|     
|     yy_cp = (yy_c_buf_p);
| 
| 	/* undo effects of setting up yytext */
| 	*yy_cp = (yy_hold_char);
| 
| 	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
| 		{ /* need to shift things up to make room */
| 		/* +2 for EOB chars. */
| 		register yy_size_t number_to_move = (yy_n_chars) + 2;
| 		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
| 					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
| 		register char *source =
| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
| 
| 		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
| 			*--dest = *--source;
| 
| 		yy_cp += (int) (dest - source);
| 		yy_bp += (int) (dest - source);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
| 
| 		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
| 			YY_FATAL_ERROR( "flex scanner push-back overflow" );
| 		}
| 
| 	*--yy_cp = (char) c;
| 
| 	(yytext_ptr) = yy_bp;
| 	(yy_hold_char) = *yy_cp;
| 	(yy_c_buf_p) = yy_cp;
| }
| 
| #ifndef YY_NO_INPUT
| #ifdef __cplusplus
|     static int yyinput (void)
| #else
|     static int input  (void)
| #endif
| 
| {
| 	int c;
|     
| 	*(yy_c_buf_p) = (yy_hold_char);
| 
| 	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
| 		{
| 		/* yy_c_buf_p now points to the character we want to return.
| 		 * If this occurs *before* the EOB characters, then it's a
| 		 * valid NUL; if not, then we've hit the end of the buffer.
| 		 */
| 		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
| 			/* This was really a NUL. */
| 			*(yy_c_buf_p) = '\0';
| 
| 		else
| 			{ /* need more input */
| 			yy_size_t offset = (yy_c_buf_p) - (yytext_ptr);
| 			++(yy_c_buf_p);
| 
| 			switch ( yy_get_next_buffer(  ) )
| 				{
| 				case EOB_ACT_LAST_MATCH:
| 					/* This happens because yy_g_n_b()
| 					 * sees that we've accumulated a
| 					 * token and flags that we need to
| 					 * try matching the token before
| 					 * proceeding.  But for input(),
| 					 * there's no matching to consider.
| 					 * So convert the EOB_ACT_LAST_MATCH
| 					 * to EOB_ACT_END_OF_FILE.
| 					 */
| 
| 					/* Reset buffer status. */
| 					yyrestart(yyin );
| 
| 					/*FALLTHROUGH*/
| 
| 				case EOB_ACT_END_OF_FILE:
| 					{
| 					if ( yywrap( ) )
| 						return EOF;
| 
| 					if ( ! (yy_did_buffer_switch_on_eof) )
| 						YY_NEW_FILE;
| #ifdef __cplusplus
| 					return yyinput();
| #else
| 					return input();
| #endif
| 					}
| 
| 				case EOB_ACT_CONTINUE_SCAN:
| 					(yy_c_buf_p) = (yytext_ptr) + offset;
| 					break;
| 				}
| 			}
| 		}
| 
| 	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
| 	*(yy_c_buf_p) = '\0';	/* preserve yytext */
| 	(yy_hold_char) = *++(yy_c_buf_p);
| 
| 	return c;
| }
| #endif	/* ifndef YY_NO_INPUT */
| 
| /** Immediately switch to a different input stream.
|  * @param input_file A readable stream.
|  * 
|  * @note This function does not reset the start condition to @c INITIAL .
|  */
|     void yyrestart  (FILE * input_file )
| {
|     
| 	if ( ! YY_CURRENT_BUFFER ){
|         yyensure_buffer_stack ();
| 		YY_CURRENT_BUFFER_LVALUE =
|             yy_create_buffer(yyin,YY_BUF_SIZE );
| 	}
| 
| 	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
| 	yy_load_buffer_state( );
| }
| 
| /** Switch to a different input buffer.
|  * @param new_buffer The new input buffer.
|  * 
|  */
|     void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
| {
|     
| 	/* TODO. We should be able to replace this entire function body
| 	 * with
| 	 *		yypop_buffer_state();
| 	 *		yypush_buffer_state(new_buffer);
|      */
| 	yyensure_buffer_stack ();
| 	if ( YY_CURRENT_BUFFER == new_buffer )
| 		return;
| 
| 	if ( YY_CURRENT_BUFFER )
| 		{
| 		/* Flush out information for old buffer. */
| 		*(yy_c_buf_p) = (yy_hold_char);
| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
| 	yy_load_buffer_state( );
| 
| 	/* We don't actually know whether we did this switch during
| 	 * EOF (yywrap()) processing, but the only time this flag
| 	 * is looked at is after yywrap() is called, so it's safe
| 	 * to go ahead and always set it.
| 	 */
| 	(yy_did_buffer_switch_on_eof) = 1;
| }
| 
| static void yy_load_buffer_state  (void)
| {
|     	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
| 	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
| 	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
| 	(yy_hold_char) = *(yy_c_buf_p);
| }
| 
| /** Allocate and initialize an input buffer state.
|  * @param file A readable stream.
|  * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
|  * 
|  * @return the allocated buffer state.
|  */
|     YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
| {
| 	YY_BUFFER_STATE b;
|     
| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_buf_size = size;
| 
| 	/* yy_ch_buf has to be 2 characters longer than the size given because
| 	 * we need to put in 2 end-of-buffer characters.
| 	 */
| 	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
| 	if ( ! b->yy_ch_buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_is_our_buffer = 1;
| 
| 	yy_init_buffer(b,file );
| 
| 	return b;
| }
| 
| /** Destroy the buffer.
|  * @param b a buffer created with yy_create_buffer()
|  * 
|  */
|     void yy_delete_buffer (YY_BUFFER_STATE  b )
| {
|     
| 	if ( ! b )
| 		return;
| 
| 	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
| 		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
| 
| 	if ( b->yy_is_our_buffer )
| 		yyfree((void *) b->yy_ch_buf  );
| 
| 	yyfree((void *) b  );
| }
| 
| /* Initializes or reinitializes a buffer.
|  * This function is sometimes called more than once on the same buffer,
|  * such as during a yyrestart() or at EOF.
|  */
|     static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
| 
| {
| 	int oerrno = errno;
|     
| 	yy_flush_buffer(b );
| 
| 	b->yy_input_file = file;
| 	b->yy_fill_buffer = 1;
| 
|     /* If b is the current buffer, then yy_init_buffer was _probably_
|      * called from yyrestart() or through yy_get_next_buffer.
|      * In that case, we don't want to reset the lineno or column.
|      */
|     if (b != YY_CURRENT_BUFFER){
|         b->yy_bs_lineno = 1;
|         b->yy_bs_column = 0;
|     }
| 
|         b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
|     
| 	errno = oerrno;
| }
| 
| /** Discard all buffered characters. On the next scan, YY_INPUT will be called.
|  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
|  * 
|  */
|     void yy_flush_buffer (YY_BUFFER_STATE  b )
| {
|     	if ( ! b )
| 		return;
| 
| 	b->yy_n_chars = 0;
| 
| 	/* We always need two end-of-buffer characters.  The first causes
| 	 * a transition to the end-of-buffer state.  The second causes
| 	 * a jam in that state.
| 	 */
| 	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
| 	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b->yy_buf_pos = &b->yy_ch_buf[0];
| 
| 	b->yy_at_bol = 1;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	if ( b == YY_CURRENT_BUFFER )
| 		yy_load_buffer_state( );
| }
| 
| /** Pushes the new state onto the stack. The new state becomes
|  *  the current state. This function will allocate the stack
|  *  if necessary.
|  *  @param new_buffer The new state.
|  *  
|  */
| void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
| {
|     	if (new_buffer == NULL)
| 		return;
| 
| 	yyensure_buffer_stack();
| 
| 	/* This block is copied from yy_switch_to_buffer. */
| 	if ( YY_CURRENT_BUFFER )
| 		{
| 		/* Flush out information for old buffer. */
| 		*(yy_c_buf_p) = (yy_hold_char);
| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	/* Only push if top exists. Otherwise, replace top. */
| 	if (YY_CURRENT_BUFFER)
| 		(yy_buffer_stack_top)++;
| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
| 
| 	/* copied from yy_switch_to_buffer. */
| 	yy_load_buffer_state( );
| 	(yy_did_buffer_switch_on_eof) = 1;
| }
| 
| /** Removes and deletes the top of the stack, if present.
|  *  The next element becomes the new top.
|  *  
|  */
| void yypop_buffer_state (void)
| {
|     	if (!YY_CURRENT_BUFFER)
| 		return;
| 
| 	yy_delete_buffer(YY_CURRENT_BUFFER );
| 	YY_CURRENT_BUFFER_LVALUE = NULL;
| 	if ((yy_buffer_stack_top) > 0)
| 		--(yy_buffer_stack_top);
| 
| 	if (YY_CURRENT_BUFFER) {
| 		yy_load_buffer_state( );
| 		(yy_did_buffer_switch_on_eof) = 1;
| 	}
| }
| 
| /* Allocates the stack if it does not exist.
|  *  Guarantees space for at least one push.
|  */
| static void yyensure_buffer_stack (void)
| {
| 	yy_size_t num_to_alloc;
|     
| 	if (!(yy_buffer_stack)) {
| 
| 		/* First allocation is just for 2 elements, since we don't know if this
| 		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
| 		 * immediate realloc on the next call.
|          */
| 		num_to_alloc = 1;
| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
| 								(num_to_alloc * sizeof(struct yy_buffer_state*)
| 								);
| 		if ( ! (yy_buffer_stack) )
| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
| 								  
| 		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
| 				
| 		(yy_buffer_stack_max) = num_to_alloc;
| 		(yy_buffer_stack_top) = 0;
| 		return;
| 	}
| 
| 	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
| 
| 		/* Increase the buffer to prepare for a possible push. */
| 		int grow_size = 8 /* arbitrary grow size */;
| 
| 		num_to_alloc = (yy_buffer_stack_max) + grow_size;
| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
| 								((yy_buffer_stack),
| 								num_to_alloc * sizeof(struct yy_buffer_state*)
| 								);
| 		if ( ! (yy_buffer_stack) )
| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
| 
| 		/* zero only the new slots.*/
| 		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
| 		(yy_buffer_stack_max) = num_to_alloc;
| 	}
| }
| 
| /** Setup the input buffer state to scan directly from a user-specified character buffer.
|  * @param base the character buffer
|  * @param size the size in bytes of the character buffer
|  * 
|  * @return the newly allocated buffer state object. 
|  */
| YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
| {
| 	YY_BUFFER_STATE b;
|     
| 	if ( size < 2 ||
| 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
| 	     base[size-1] != YY_END_OF_BUFFER_CHAR )
| 		/* They forgot to leave room for the EOB's. */
| 		return 0;
| 
| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
| 
| 	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
| 	b->yy_buf_pos = b->yy_ch_buf = base;
| 	b->yy_is_our_buffer = 0;
| 	b->yy_input_file = 0;
| 	b->yy_n_chars = b->yy_buf_size;
| 	b->yy_is_interactive = 0;
| 	b->yy_at_bol = 1;
| 	b->yy_fill_buffer = 0;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	yy_switch_to_buffer(b  );
| 
| 	return b;
| }
| 
| /** Setup the input buffer state to scan a string. The next call to yylex() will
|  * scan from a @e copy of @a str.
|  * @param yystr a NUL-terminated string to scan
|  * 
|  * @return the newly allocated buffer state object.
|  * @note If you want to scan bytes that may contain NUL values, then use
|  *       yy_scan_bytes() instead.
|  */
| YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
| {
|     
| 	return yy_scan_bytes(yystr,strlen(yystr) );
| }
| 
| /** Setup the input buffer state to scan the given bytes. The next call to yylex() will
|  * scan from a @e copy of @a bytes.
|  * @param yybytes the byte buffer to scan
|  * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
|  * 
|  * @return the newly allocated buffer state object.
|  */
| YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len )
| {
| 	YY_BUFFER_STATE b;
| 	char *buf;
| 	yy_size_t n;
| 	yy_size_t i;
|     
| 	/* Get memory for full buffer, including space for trailing EOB's. */
| 	n = _yybytes_len + 2;
| 	buf = (char *) yyalloc(n  );
| 	if ( ! buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
| 
| 	for ( i = 0; i < _yybytes_len; ++i )
| 		buf[i] = yybytes[i];
| 
| 	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b = yy_scan_buffer(buf,n );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
| 
| 	/* It's okay to grow etc. this buffer, and we should throw it
| 	 * away when we're done.
| 	 */
| 	b->yy_is_our_buffer = 1;
| 
| 	return b;
| }
| 
| #ifndef YY_EXIT_FAILURE
| #define YY_EXIT_FAILURE 2
| #endif
| 
| static void yy_fatal_error (yyconst char* msg )
| {
|     	(void) fprintf( stderr, "%s\n", msg );
| 	exit( YY_EXIT_FAILURE );
| }
| 
| /* Redefine yyless() so it works in section 3 code. */
| 
| #undef yyless
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
|         int yyless_macro_arg = (n); \
|         YY_LESS_LINENO(yyless_macro_arg);\
| 		yytext[yyleng] = (yy_hold_char); \
| 		(yy_c_buf_p) = yytext + yyless_macro_arg; \
| 		(yy_hold_char) = *(yy_c_buf_p); \
| 		*(yy_c_buf_p) = '\0'; \
| 		yyleng = yyless_macro_arg; \
| 		} \
| 	while ( 0 )
| 
| /* Accessor  methods (get/set functions) to struct members. */
| 
| /** Get the current line number.
|  * 
|  */
| int yyget_lineno  (void)
| {
|         
|     return yylineno;
| }
| 
| /** Get the input stream.
|  * 
|  */
| FILE *yyget_in  (void)
| {
|         return yyin;
| }
| 
| /** Get the output stream.
|  * 
|  */
| FILE *yyget_out  (void)
| {
|         return yyout;
| }
| 
| /** Get the length of the current token.
|  * 
|  */
| yy_size_t yyget_leng  (void)
| {
|         return yyleng;
| }
| 
| /** Get the current token.
|  * 
|  */
| 
| char *yyget_text  (void)
| {
|         return yytext;
| }
| 
| /** Set the current line number.
|  * @param line_number
|  * 
|  */
| void yyset_lineno (int  line_number )
| {
|     
|     yylineno = line_number;
| }
| 
| /** Set the input stream. This does not discard the current
|  * input buffer.
|  * @param in_str A readable stream.
|  * 
|  * @see yy_switch_to_buffer
|  */
| void yyset_in (FILE *  in_str )
| {
|         yyin = in_str ;
| }
| 
| void yyset_out (FILE *  out_str )
| {
|         yyout = out_str ;
| }
| 
| int yyget_debug  (void)
| {
|         return yy_flex_debug;
| }
| 
| void yyset_debug (int  bdebug )
| {
|         yy_flex_debug = bdebug ;
| }
| 
| static int yy_init_globals (void)
| {
|         /* Initialization is the same as for the non-reentrant scanner.
|      * This function is called from yylex_destroy(), so don't allocate here.
|      */
| 
|     (yy_buffer_stack) = 0;
|     (yy_buffer_stack_top) = 0;
|     (yy_buffer_stack_max) = 0;
|     (yy_c_buf_p) = (char *) 0;
|     (yy_init) = 0;
|     (yy_start) = 0;
| 
|     (yy_state_buf) = 0;
|     (yy_state_ptr) = 0;
|     (yy_full_match) = 0;
|     (yy_lp) = 0;
| 
| /* Defined in main.c */
| #ifdef YY_STDINIT
|     yyin = stdin;
|     yyout = stdout;
| #else
|     yyin = (FILE *) 0;
|     yyout = (FILE *) 0;
| #endif
| 
|     /* For future reference: Set errno on error, since we are called by
|      * yylex_init()
|      */
|     return 0;
| }
| 
| /* yylex_destroy is for both reentrant and non-reentrant scanners. */
| int yylex_destroy  (void)
| {
|     
|     /* Pop the buffer stack, destroying each element. */
| 	while(YY_CURRENT_BUFFER){
| 		yy_delete_buffer(YY_CURRENT_BUFFER  );
| 		YY_CURRENT_BUFFER_LVALUE = NULL;
| 		yypop_buffer_state();
| 	}
| 
| 	/* Destroy the stack itself. */
| 	yyfree((yy_buffer_stack) );
| 	(yy_buffer_stack) = NULL;
| 
|     yyfree ( (yy_state_buf) );
|     (yy_state_buf)  = NULL;
| 
|     /* Reset the globals. This is important in a non-reentrant scanner so the next time
|      * yylex() is called, initialization will occur. */
|     yy_init_globals( );
| 
|     return 0;
| }
| 
| /*
|  * Internal utility routines.
|  */
| 
| #ifndef yytext_ptr
| static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
| {
| 	register int i;
| 	for ( i = 0; i < n; ++i )
| 		s1[i] = s2[i];
| }
| #endif
| 
| #ifdef YY_NEED_STRLEN
| static int yy_flex_strlen (yyconst char * s )
| {
| 	register int n;
| 	for ( n = 0; s[n]; ++n )
| 		;
| 
| 	return n;
| }
| #endif
| 
| void *yyalloc (yy_size_t  size )
| {
| 	return (void *) malloc( size );
| }
| 
| void *yyrealloc  (void * ptr, yy_size_t  size )
| {
| 	/* The cast to (char *) in the following accommodates both
| 	 * implementations that use char* generic pointers, and those
| 	 * that use void* generic pointers.  It works with the latter
| 	 * because both ANSI C and C++ allow castless assignment from
| 	 * any pointer type to void*, and deal with argument conversions
| 	 * as though doing an assignment.
| 	 */
| 	return (void *) realloc( (char *) ptr, size );
| }
| 
| void yyfree (void * ptr )
| {
| 	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
| }
| 
| #define YYTABLES_NAME "yytables"
| 
| #line 9 "conftest.l"
| 
| 
| #ifdef YYTEXT_POINTER
| extern char *yytext;
| #endif
| int
| main (void)
| {
|   return ! yylex () + ! yywrap ();
| }
configure:12177: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c -lfl  >&5
/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld: error: cannot find -lfl
/tmp/cc4AUc2w.o:conftest.c:function yylex: error: undefined reference to 'yywrap'
/tmp/cc4AUc2w.o:conftest.c:function input: error: undefined reference to 'yywrap'
/tmp/cc4AUc2w.o:conftest.c:function main: error: undefined reference to 'yywrap'
collect2: error: ld returned 1 exit status
configure:12177: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "binutils"
| #define PACKAGE_TARNAME "binutils"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "binutils 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "binutils"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define DEFAULT_AR_DETERMINISTIC 0
| #define DEFAULT_STRINGS_ALL 1
| /* end confdefs.h.  */
| 
| #line 3 "lex.yy.c"
| 
| #define  YY_INT_ALIGNED short int
| 
| /* A lexical scanner generated by flex */
| 
| #define FLEX_SCANNER
| #define YY_FLEX_MAJOR_VERSION 2
| #define YY_FLEX_MINOR_VERSION 5
| #define YY_FLEX_SUBMINOR_VERSION 39
| #if YY_FLEX_SUBMINOR_VERSION > 0
| #define FLEX_BETA
| #endif
| 
| /* First, we deal with  platform-specific or compiler-specific issues. */
| 
| /* begin standard C headers. */
| #include <stdio.h>
| #include <string.h>
| #include <errno.h>
| #include <stdlib.h>
| 
| /* end standard C headers. */
| 
| /* flex integer type definitions */
| 
| #ifndef FLEXINT_H
| #define FLEXINT_H
| 
| /* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
| 
| #if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
| 
| /* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
|  * if you want the limit (max/min) macros for int types. 
|  */
| #ifndef __STDC_LIMIT_MACROS
| #define __STDC_LIMIT_MACROS 1
| #endif
| 
| #include <inttypes.h>
| typedef int8_t flex_int8_t;
| typedef uint8_t flex_uint8_t;
| typedef int16_t flex_int16_t;
| typedef uint16_t flex_uint16_t;
| typedef int32_t flex_int32_t;
| typedef uint32_t flex_uint32_t;
| #else
| typedef signed char flex_int8_t;
| typedef short int flex_int16_t;
| typedef int flex_int32_t;
| typedef unsigned char flex_uint8_t; 
| typedef unsigned short int flex_uint16_t;
| typedef unsigned int flex_uint32_t;
| 
| /* Limits of integral types. */
| #ifndef INT8_MIN
| #define INT8_MIN               (-128)
| #endif
| #ifndef INT16_MIN
| #define INT16_MIN              (-32767-1)
| #endif
| #ifndef INT32_MIN
| #define INT32_MIN              (-2147483647-1)
| #endif
| #ifndef INT8_MAX
| #define INT8_MAX               (127)
| #endif
| #ifndef INT16_MAX
| #define INT16_MAX              (32767)
| #endif
| #ifndef INT32_MAX
| #define INT32_MAX              (2147483647)
| #endif
| #ifndef UINT8_MAX
| #define UINT8_MAX              (255U)
| #endif
| #ifndef UINT16_MAX
| #define UINT16_MAX             (65535U)
| #endif
| #ifndef UINT32_MAX
| #define UINT32_MAX             (4294967295U)
| #endif
| 
| #endif /* ! C99 */
| 
| #endif /* ! FLEXINT_H */
| 
| #ifdef __cplusplus
| 
| /* The "const" storage-class-modifier is valid. */
| #define YY_USE_CONST
| 
| #else	/* ! __cplusplus */
| 
| /* C99 requires __STDC__ to be defined as 1. */
| #if defined (__STDC__)
| 
| #define YY_USE_CONST
| 
| #endif	/* defined (__STDC__) */
| #endif	/* ! __cplusplus */
| 
| #ifdef YY_USE_CONST
| #define yyconst const
| #else
| #define yyconst
| #endif
| 
| /* Returned upon end-of-file. */
| #define YY_NULL 0
| 
| /* Promotes a possibly negative, possibly signed char to an unsigned
|  * integer for use as an array index.  If the signed char is negative,
|  * we want to instead treat it as an 8-bit unsigned char, hence the
|  * double cast.
|  */
| #define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
| 
| /* Enter a start condition.  This macro really ought to take a parameter,
|  * but we do it the disgusting crufty way forced on us by the ()-less
|  * definition of BEGIN.
|  */
| #define BEGIN (yy_start) = 1 + 2 *
| 
| /* Translate the current start state into a value that can be later handed
|  * to BEGIN to return to the state.  The YYSTATE alias is for lex
|  * compatibility.
|  */
| #define YY_START (((yy_start) - 1) / 2)
| #define YYSTATE YY_START
| 
| /* Action number for EOF rule of a given start state. */
| #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
| 
| /* Special action meaning "start processing a new file". */
| #define YY_NEW_FILE yyrestart(yyin  )
| 
| #define YY_END_OF_BUFFER_CHAR 0
| 
| /* Size of default input buffer. */
| #ifndef YY_BUF_SIZE
| #define YY_BUF_SIZE 16384
| #endif
| 
| /* The state buf must be large enough to hold one state per character in the main buffer.
|  */
| #define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
| 
| #ifndef YY_TYPEDEF_YY_BUFFER_STATE
| #define YY_TYPEDEF_YY_BUFFER_STATE
| typedef struct yy_buffer_state *YY_BUFFER_STATE;
| #endif
| 
| #ifndef YY_TYPEDEF_YY_SIZE_T
| #define YY_TYPEDEF_YY_SIZE_T
| typedef size_t yy_size_t;
| #endif
| 
| extern yy_size_t yyleng;
| 
| extern FILE *yyin, *yyout;
| 
| #define EOB_ACT_CONTINUE_SCAN 0
| #define EOB_ACT_END_OF_FILE 1
| #define EOB_ACT_LAST_MATCH 2
| 
|     #define YY_LESS_LINENO(n)
|     #define YY_LINENO_REWIND_TO(ptr)
|     
| /* Return all but the first "n" matched characters back to the input stream. */
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
|         int yyless_macro_arg = (n); \
|         YY_LESS_LINENO(yyless_macro_arg);\
| 		*yy_cp = (yy_hold_char); \
| 		YY_RESTORE_YY_MORE_OFFSET \
| 		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
| 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
| 		} \
| 	while ( 0 )
| 
| #define unput(c) yyunput( c, (yytext_ptr)  )
| 
| #ifndef YY_STRUCT_YY_BUFFER_STATE
| #define YY_STRUCT_YY_BUFFER_STATE
| struct yy_buffer_state
| 	{
| 	FILE *yy_input_file;
| 
| 	char *yy_ch_buf;		/* input buffer */
| 	char *yy_buf_pos;		/* current position in input buffer */
| 
| 	/* Size of input buffer in bytes, not including room for EOB
| 	 * characters.
| 	 */
| 	yy_size_t yy_buf_size;
| 
| 	/* Number of characters read into yy_ch_buf, not including EOB
| 	 * characters.
| 	 */
| 	yy_size_t yy_n_chars;
| 
| 	/* Whether we "own" the buffer - i.e., we know we created it,
| 	 * and can realloc() it to grow it, and should free() it to
| 	 * delete it.
| 	 */
| 	int yy_is_our_buffer;
| 
| 	/* Whether this is an "interactive" input source; if so, and
| 	 * if we're using stdio for input, then we want to use getc()
| 	 * instead of fread(), to make sure we stop fetching input after
| 	 * each newline.
| 	 */
| 	int yy_is_interactive;
| 
| 	/* Whether we're considered to be at the beginning of a line.
| 	 * If so, '^' rules will be active on the next match, otherwise
| 	 * not.
| 	 */
| 	int yy_at_bol;
| 
|     int yy_bs_lineno; /**< The line count. */
|     int yy_bs_column; /**< The column count. */
|     
| 	/* Whether to try to fill the input buffer when we reach the
| 	 * end of it.
| 	 */
| 	int yy_fill_buffer;
| 
| 	int yy_buffer_status;
| 
| #define YY_BUFFER_NEW 0
| #define YY_BUFFER_NORMAL 1
| 	/* When an EOF's been seen but there's still some text to process
| 	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
| 	 * shouldn't try reading from the input source any more.  We might
| 	 * still have a bunch of tokens to match, though, because of
| 	 * possible backing-up.
| 	 *
| 	 * When we actually see the EOF, we change the status to "new"
| 	 * (via yyrestart()), so that the user can continue scanning by
| 	 * just pointing yyin at a new input file.
| 	 */
| #define YY_BUFFER_EOF_PENDING 2
| 
| 	};
| #endif /* !YY_STRUCT_YY_BUFFER_STATE */
| 
| /* Stack of input buffers. */
| static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
| static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
| static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
| 
| /* We provide macros for accessing buffer states in case in the
|  * future we want to put the buffer states in a more general
|  * "scanner state".
|  *
|  * Returns the top of the stack, or NULL.
|  */
| #define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
|                           ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
|                           : NULL)
| 
| /* Same as previous macro, but useful when we know that the buffer stack is not
|  * NULL or when we need an lvalue. For internal use only.
|  */
| #define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
| 
| /* yy_hold_char holds the character lost when yytext is formed. */
| static char yy_hold_char;
| static yy_size_t yy_n_chars;		/* number of characters read into yy_ch_buf */
| yy_size_t yyleng;
| 
| /* Points to current character in buffer. */
| static char *yy_c_buf_p = (char *) 0;
| static int yy_init = 0;		/* whether we need to initialize */
| static int yy_start = 0;	/* start state number */
| 
| /* Flag which is used to allow yywrap()'s to do buffer switches
|  * instead of setting up a fresh yyin.  A bit of a hack ...
|  */
| static int yy_did_buffer_switch_on_eof;
| 
| void yyrestart (FILE *input_file  );
| void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
| YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
| void yy_delete_buffer (YY_BUFFER_STATE b  );
| void yy_flush_buffer (YY_BUFFER_STATE b  );
| void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
| void yypop_buffer_state (void );
| 
| static void yyensure_buffer_stack (void );
| static void yy_load_buffer_state (void );
| static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
| 
| #define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
| 
| YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
| YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
| YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,yy_size_t len  );
| 
| void *yyalloc (yy_size_t  );
| void *yyrealloc (void *,yy_size_t  );
| void yyfree (void *  );
| 
| #define yy_new_buffer yy_create_buffer
| 
| #define yy_set_interactive(is_interactive) \
| 	{ \
| 	if ( ! YY_CURRENT_BUFFER ){ \
|         yyensure_buffer_stack (); \
| 		YY_CURRENT_BUFFER_LVALUE =    \
|             yy_create_buffer(yyin,YY_BUF_SIZE ); \
| 	} \
| 	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
| 	}
| 
| #define yy_set_bol(at_bol) \
| 	{ \
| 	if ( ! YY_CURRENT_BUFFER ){\
|         yyensure_buffer_stack (); \
| 		YY_CURRENT_BUFFER_LVALUE =    \
|             yy_create_buffer(yyin,YY_BUF_SIZE ); \
| 	} \
| 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
| 	}
| 
| #define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
| 
| /* Begin user sect3 */
| 
| typedef unsigned char YY_CHAR;
| 
| FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
| 
| typedef int yy_state_type;
| 
| extern int yylineno;
| 
| int yylineno = 1;
| 
| extern char *yytext;
| #define yytext_ptr yytext
| 
| static yy_state_type yy_get_previous_state (void );
| static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
| static int yy_get_next_buffer (void );
| static void yy_fatal_error (yyconst char msg[]  );
| 
| /* Done after the current pattern has been matched and before the
|  * corresponding action - sets up yytext.
|  */
| #define YY_DO_BEFORE_ACTION \
| 	(yytext_ptr) = yy_bp; \
| 	(yytext_ptr) -= (yy_more_len); \
| 	yyleng = (size_t) (yy_cp - (yytext_ptr)); \
| 	(yy_hold_char) = *yy_cp; \
| 	*yy_cp = '\0'; \
| 	(yy_c_buf_p) = yy_cp;
| 
| #define YY_NUM_RULES 8
| #define YY_END_OF_BUFFER 9
| /* This struct is not used in this scanner,
|    but its presence is necessary. */
| struct yy_trans_info
| 	{
| 	flex_int32_t yy_verify;
| 	flex_int32_t yy_nxt;
| 	};
| static yyconst flex_int16_t yy_acclist[23] =
|     {   0,
|         9,    7,    8,    8,    1,    7,    8,    2,    7,    8,
|         3,    7,    8,    4,    7,    8,    5,    7,    8,    6,
|         7,    8
|     } ;
| 
| static yyconst flex_int16_t yy_accept[14] =
|     {   0,
|         1,    1,    1,    2,    4,    5,    8,   11,   14,   17,
|        20,   23,   23
|     } ;
| 
| static yyconst flex_int32_t yy_ec[256] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    3,    4,    5,    6,
| 
|         7,    8,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| 
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1
|     } ;
| 
| static yyconst flex_int32_t yy_meta[9] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1
|     } ;
| 
| static yyconst flex_int16_t yy_base[13] =
|     {   0,
|         0,    0,    9,   10,   10,   10,   10,   10,   10,   10,
|        10,   10
|     } ;
| 
| static yyconst flex_int16_t yy_def[13] =
|     {   0,
|        12,    1,   12,   12,   12,   12,   12,   12,   12,   12,
|        12,    0
|     } ;
| 
| static yyconst flex_int16_t yy_nxt[19] =
|     {   0,
|         4,    5,    6,    7,    8,    9,   10,   11,   12,    3,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| static yyconst flex_int16_t yy_chk[19] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    3,   12,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| extern int yy_flex_debug;
| int yy_flex_debug = 0;
| 
| static yy_state_type *yy_state_buf=0, *yy_state_ptr=0;
| static char *yy_full_match;
| static int yy_lp;
| #define REJECT \
| { \
| *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */ \
| yy_cp = (yy_full_match); /* restore poss. backed-over text */ \
| ++(yy_lp); \
| goto find_rule; \
| }
| 
| static int yy_more_flag = 0;
| static int yy_more_len = 0;
| #define yymore() ((yy_more_flag) = 1)
| #define YY_MORE_ADJ (yy_more_len)
| #define YY_RESTORE_YY_MORE_OFFSET
| char *yytext;
| #line 1 "conftest.l"
| #line 470 "lex.yy.c"
| 
| #define INITIAL 0
| 
| #ifndef YY_NO_UNISTD_H
| /* Special case for "unistd.h", since it is non-ANSI. We include it way
|  * down here because we want the user's section 1 to have been scanned first.
|  * The user has a chance to override it with an option.
|  */
| #include <unistd.h>
| #endif
| 
| #ifndef YY_EXTRA_TYPE
| #define YY_EXTRA_TYPE void *
| #endif
| 
| static int yy_init_globals (void );
| 
| /* Accessor methods to globals.
|    These are made visible to non-reentrant scanners for convenience. */
| 
| int yylex_destroy (void );
| 
| int yyget_debug (void );
| 
| void yyset_debug (int debug_flag  );
| 
| YY_EXTRA_TYPE yyget_extra (void );
| 
| void yyset_extra (YY_EXTRA_TYPE user_defined  );
| 
| FILE *yyget_in (void );
| 
| void yyset_in  (FILE * in_str  );
| 
| FILE *yyget_out (void );
| 
| void yyset_out  (FILE * out_str  );
| 
| yy_size_t yyget_leng (void );
| 
| char *yyget_text (void );
| 
| int yyget_lineno (void );
| 
| void yyset_lineno (int line_number  );
| 
| /* Macros after this point can all be overridden by user definitions in
|  * section 1.
|  */
| 
| #ifndef YY_SKIP_YYWRAP
| #ifdef __cplusplus
| extern "C" int yywrap (void );
| #else
| extern int yywrap (void );
| #endif
| #endif
| 
|     static void yyunput (int c,char *buf_ptr  );
|     
| #ifndef yytext_ptr
| static void yy_flex_strncpy (char *,yyconst char *,int );
| #endif
| 
| #ifdef YY_NEED_STRLEN
| static int yy_flex_strlen (yyconst char * );
| #endif
| 
| #ifndef YY_NO_INPUT
| 
| #ifdef __cplusplus
| static int yyinput (void );
| #else
| static int input (void );
| #endif
| 
| #endif
| 
| /* Amount of stuff to slurp up with each read. */
| #ifndef YY_READ_BUF_SIZE
| #define YY_READ_BUF_SIZE 8192
| #endif
| 
| /* Copy whatever the last rule matched to the standard output. */
| #ifndef ECHO
| /* This used to be an fputs(), but since the string might contain NUL's,
|  * we now use fwrite().
|  */
| #define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
| #endif
| 
| /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
|  * is returned in "result".
|  */
| #ifndef YY_INPUT
| #define YY_INPUT(buf,result,max_size) \
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
| 		{ \
| 		int c = '*'; \
| 		size_t n; \
| 		for ( n = 0; n < max_size && \
| 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
| 			buf[n] = (char) c; \
| 		if ( c == '\n' ) \
| 			buf[n++] = (char) c; \
| 		if ( c == EOF && ferror( yyin ) ) \
| 			YY_FATAL_ERROR( "input in flex scanner failed" ); \
| 		result = n; \
| 		} \
| 	else \
| 		{ \
| 		errno=0; \
| 		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
| 			{ \
| 			if( errno != EINTR) \
| 				{ \
| 				YY_FATAL_ERROR( "input in flex scanner failed" ); \
| 				break; \
| 				} \
| 			errno=0; \
| 			clearerr(yyin); \
| 			} \
| 		}\
| \
| 
| #endif
| 
| /* No semi-colon after return; correct usage is to write "yyterminate();" -
|  * we don't want an extra ';' after the "return" because that will cause
|  * some compilers to complain about unreachable statements.
|  */
| #ifndef yyterminate
| #define yyterminate() return YY_NULL
| #endif
| 
| /* Number of entries by which start-condition stack grows. */
| #ifndef YY_START_STACK_INCR
| #define YY_START_STACK_INCR 25
| #endif
| 
| /* Report a fatal error. */
| #ifndef YY_FATAL_ERROR
| #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
| #endif
| 
| /* end tables serialization structures and prototypes */
| 
| /* Default declaration of generated scanner - a define so the user can
|  * easily add parameters.
|  */
| #ifndef YY_DECL
| #define YY_DECL_IS_OURS 1
| 
| extern int yylex (void);
| 
| #define YY_DECL int yylex (void)
| #endif /* !YY_DECL */
| 
| /* Code executed at the beginning of each rule, after yytext and yyleng
|  * have been set up.
|  */
| #ifndef YY_USER_ACTION
| #define YY_USER_ACTION
| #endif
| 
| /* Code executed at the end of each rule. */
| #ifndef YY_BREAK
| #define YY_BREAK break;
| #endif
| 
| #define YY_RULE_SETUP \
| 	YY_USER_ACTION
| 
| /** The main scanner function which does all the work.
|  */
| YY_DECL
| {
| 	register yy_state_type yy_current_state;
| 	register char *yy_cp, *yy_bp;
| 	register int yy_act;
|     
| 	if ( !(yy_init) )
| 		{
| 		(yy_init) = 1;
| 
| #ifdef YY_USER_INIT
| 		YY_USER_INIT;
| #endif
| 
|         /* Create the reject buffer large enough to save one state per allowed character. */
|         if ( ! (yy_state_buf) )
|             (yy_state_buf) = (yy_state_type *)yyalloc(YY_STATE_BUF_SIZE  );
|             if ( ! (yy_state_buf) )
|                 YY_FATAL_ERROR( "out of dynamic memory in yylex()" );
| 
| 		if ( ! (yy_start) )
| 			(yy_start) = 1;	/* first start state */
| 
| 		if ( ! yyin )
| 			yyin = stdin;
| 
| 		if ( ! yyout )
| 			yyout = stdout;
| 
| 		if ( ! YY_CURRENT_BUFFER ) {
| 			yyensure_buffer_stack ();
| 			YY_CURRENT_BUFFER_LVALUE =
| 				yy_create_buffer(yyin,YY_BUF_SIZE );
| 		}
| 
| 		yy_load_buffer_state( );
| 		}
| 
| 	{
| #line 1 "conftest.l"
| 
| #line 687 "lex.yy.c"
| 
| 	while ( 1 )		/* loops until end-of-file is reached */
| 		{
| 		(yy_more_len) = 0;
| 		if ( (yy_more_flag) )
| 			{
| 			(yy_more_len) = (yy_c_buf_p) - (yytext_ptr);
| 			(yy_more_flag) = 0;
| 			}
| 		yy_cp = (yy_c_buf_p);
| 
| 		/* Support of yytext. */
| 		*yy_cp = (yy_hold_char);
| 
| 		/* yy_bp points to the position in yy_ch_buf of the start of
| 		 * the current run.
| 		 */
| 		yy_bp = yy_cp;
| 
| 		yy_current_state = (yy_start);
| 
| 		(yy_state_ptr) = (yy_state_buf);
| 		*(yy_state_ptr)++ = yy_current_state;
| 
| yy_match:
| 		do
| 			{
| 			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
| 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 				{
| 				yy_current_state = (int) yy_def[yy_current_state];
| 				if ( yy_current_state >= 13 )
| 					yy_c = yy_meta[(unsigned int) yy_c];
| 				}
| 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 			*(yy_state_ptr)++ = yy_current_state;
| 			++yy_cp;
| 			}
| 		while ( yy_base[yy_current_state] != 10 );
| 
| yy_find_action:
| 		yy_current_state = *--(yy_state_ptr);
| 		(yy_lp) = yy_accept[yy_current_state];
| find_rule: /* we branch to this label when backing up */
| 		for ( ; ; ) /* until we find what rule we matched */
| 			{
| 			if ( (yy_lp) && (yy_lp) < yy_accept[yy_current_state + 1] )
| 				{
| 				yy_act = yy_acclist[(yy_lp)];
| 					{
| 					(yy_full_match) = yy_cp;
| 					break;
| 					}
| 				}
| 			--yy_cp;
| 			yy_current_state = *--(yy_state_ptr);
| 			(yy_lp) = yy_accept[yy_current_state];
| 			}
| 
| 		YY_DO_BEFORE_ACTION;
| 
| do_action:	/* This label is used only to access EOF actions. */
| 
| 		switch ( yy_act )
| 	{ /* beginning of action switch */
| case 1:
| YY_RULE_SETUP
| #line 2 "conftest.l"
| { ECHO; }
| 	YY_BREAK
| case 2:
| YY_RULE_SETUP
| #line 3 "conftest.l"
| { REJECT; }
| 	YY_BREAK
| case 3:
| YY_RULE_SETUP
| #line 4 "conftest.l"
| { yymore (); }
| 	YY_BREAK
| case 4:
| YY_RULE_SETUP
| #line 5 "conftest.l"
| { yyless (1); }
| 	YY_BREAK
| case 5:
| YY_RULE_SETUP
| #line 6 "conftest.l"
| { yyless (input () != 0); }
| 	YY_BREAK
| case 6:
| YY_RULE_SETUP
| #line 7 "conftest.l"
| { unput (yytext[0]); }
| 	YY_BREAK
| case 7:
| YY_RULE_SETUP
| #line 8 "conftest.l"
| { BEGIN INITIAL; }
| 	YY_BREAK
| case 8:
| YY_RULE_SETUP
| #line 9 "conftest.l"
| ECHO;
| 	YY_BREAK
| #line 793 "lex.yy.c"
| 			case YY_STATE_EOF(INITIAL):
| 				yyterminate();
| 
| 	case YY_END_OF_BUFFER:
| 		{
| 		/* Amount of text matched not including the EOB char. */
| 		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
| 
| 		/* Undo the effects of YY_DO_BEFORE_ACTION. */
| 		*yy_cp = (yy_hold_char);
| 		YY_RESTORE_YY_MORE_OFFSET
| 
| 		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
| 			{
| 			/* We're scanning a new file or input source.  It's
| 			 * possible that this happened because the user
| 			 * just pointed yyin at a new source and called
| 			 * yylex().  If so, then we have to assure
| 			 * consistency between YY_CURRENT_BUFFER and our
| 			 * globals.  Here is the right place to do so, because
| 			 * this is the first action (other than possibly a
| 			 * back-up) that will match for the new input source.
| 			 */
| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
| 			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
| 			}
| 
| 		/* Note that here we test for yy_c_buf_p "<=" to the position
| 		 * of the first EOB in the buffer, since yy_c_buf_p will
| 		 * already have been incremented past the NUL character
| 		 * (since all states make transitions on EOB to the
| 		 * end-of-buffer state).  Contrast this with the test
| 		 * in input().
| 		 */
| 		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
| 			{ /* This was really a NUL. */
| 			yy_state_type yy_next_state;
| 
| 			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
| 
| 			yy_current_state = yy_get_previous_state(  );
| 
| 			/* Okay, we're now positioned to make the NUL
| 			 * transition.  We couldn't have
| 			 * yy_get_previous_state() go ahead and do it
| 			 * for us because it doesn't know how to deal
| 			 * with the possibility of jamming (and we don't
| 			 * want to build jamming into it because then it
| 			 * will run more slowly).
| 			 */
| 
| 			yy_next_state = yy_try_NUL_trans( yy_current_state );
| 
| 			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 
| 			if ( yy_next_state )
| 				{
| 				/* Consume the NUL. */
| 				yy_cp = ++(yy_c_buf_p);
| 				yy_current_state = yy_next_state;
| 				goto yy_match;
| 				}
| 
| 			else
| 				{
| 				yy_cp = (yy_c_buf_p);
| 				goto yy_find_action;
| 				}
| 			}
| 
| 		else switch ( yy_get_next_buffer(  ) )
| 			{
| 			case EOB_ACT_END_OF_FILE:
| 				{
| 				(yy_did_buffer_switch_on_eof) = 0;
| 
| 				if ( yywrap( ) )
| 					{
| 					/* Note: because we've taken care in
| 					 * yy_get_next_buffer() to have set up
| 					 * yytext, we can now set up
| 					 * yy_c_buf_p so that if some total
| 					 * hoser (like flex itself) wants to
| 					 * call the scanner after we return the
| 					 * YY_NULL, it'll still work - another
| 					 * YY_NULL will get returned.
| 					 */
| 					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
| 
| 					yy_act = YY_STATE_EOF(YY_START);
| 					goto do_action;
| 					}
| 
| 				else
| 					{
| 					if ( ! (yy_did_buffer_switch_on_eof) )
| 						YY_NEW_FILE;
| 					}
| 				break;
| 				}
| 
| 			case EOB_ACT_CONTINUE_SCAN:
| 				(yy_c_buf_p) =
| 					(yytext_ptr) + yy_amount_of_matched_text;
| 
| 				yy_current_state = yy_get_previous_state(  );
| 
| 				yy_cp = (yy_c_buf_p);
| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 				goto yy_match;
| 
| 			case EOB_ACT_LAST_MATCH:
| 				(yy_c_buf_p) =
| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
| 
| 				yy_current_state = yy_get_previous_state(  );
| 
| 				yy_cp = (yy_c_buf_p);
| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 				goto yy_find_action;
| 			}
| 		break;
| 		}
| 
| 	default:
| 		YY_FATAL_ERROR(
| 			"fatal flex scanner internal error--no action found" );
| 	} /* end of action switch */
| 		} /* end of scanning one token */
| 	} /* end of user's declarations */
| } /* end of yylex */
| 
| /* yy_get_next_buffer - try to read in a new buffer
|  *
|  * Returns a code representing an action:
|  *	EOB_ACT_LAST_MATCH -
|  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
|  *	EOB_ACT_END_OF_FILE - end of file
|  */
| static int yy_get_next_buffer (void)
| {
|     	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
| 	register char *source = (yytext_ptr);
| 	register int number_to_move, i;
| 	int ret_val;
| 
| 	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
| 		YY_FATAL_ERROR(
| 		"fatal flex scanner internal error--end of buffer missed" );
| 
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
| 		{ /* Don't try to fill the buffer, so this is an EOF. */
| 		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
| 			{
| 			/* We matched a single character, the EOB, so
| 			 * treat this as a final EOF.
| 			 */
| 			return EOB_ACT_END_OF_FILE;
| 			}
| 
| 		else
| 			{
| 			/* We matched some text prior to the EOB, first
| 			 * process it.
| 			 */
| 			return EOB_ACT_LAST_MATCH;
| 			}
| 		}
| 
| 	/* Try to read more data. */
| 
| 	/* First move last chars to start of buffer. */
| 	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
| 
| 	for ( i = 0; i < number_to_move; ++i )
| 		*(dest++) = *(source++);
| 
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
| 		/* don't do the read, it's not guaranteed to return an EOF,
| 		 * just force an EOF
| 		 */
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
| 
| 	else
| 		{
| 			yy_size_t num_to_read =
| 			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
| 
| 		while ( num_to_read <= 0 )
| 			{ /* Not enough room in the buffer - grow it. */
| 
| 			YY_FATAL_ERROR(
| "input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
| 
| 			}
| 
| 		if ( num_to_read > YY_READ_BUF_SIZE )
| 			num_to_read = YY_READ_BUF_SIZE;
| 
| 		/* Read in more data. */
| 		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
| 			(yy_n_chars), num_to_read );
| 
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	if ( (yy_n_chars) == 0 )
| 		{
| 		if ( number_to_move == YY_MORE_ADJ )
| 			{
| 			ret_val = EOB_ACT_END_OF_FILE;
| 			yyrestart(yyin  );
| 			}
| 
| 		else
| 			{
| 			ret_val = EOB_ACT_LAST_MATCH;
| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
| 				YY_BUFFER_EOF_PENDING;
| 			}
| 		}
| 
| 	else
| 		ret_val = EOB_ACT_CONTINUE_SCAN;
| 
| 	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
| 		/* Extend the array by 50%, plus the number we really need. */
| 		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
| 		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
| 		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
| 			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
| 	}
| 
| 	(yy_n_chars) += number_to_move;
| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
| 
| 	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
| 
| 	return ret_val;
| }
| 
| /* yy_get_previous_state - get the state just before the EOB char was reached */
| 
|     static yy_state_type yy_get_previous_state (void)
| {
| 	register yy_state_type yy_current_state;
| 	register char *yy_cp;
|     
| 	yy_current_state = (yy_start);
| 
| 	(yy_state_ptr) = (yy_state_buf);
| 	*(yy_state_ptr)++ = yy_current_state;
| 
| 	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
| 		{
| 		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
| 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 			{
| 			yy_current_state = (int) yy_def[yy_current_state];
| 			if ( yy_current_state >= 13 )
| 				yy_c = yy_meta[(unsigned int) yy_c];
| 			}
| 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 		*(yy_state_ptr)++ = yy_current_state;
| 		}
| 
| 	return yy_current_state;
| }
| 
| /* yy_try_NUL_trans - try to make a transition on the NUL character
|  *
|  * synopsis
|  *	next_state = yy_try_NUL_trans( current_state );
|  */
|     static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
| {
| 	register int yy_is_jam;
|     
| 	register YY_CHAR yy_c = 1;
| 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 		{
| 		yy_current_state = (int) yy_def[yy_current_state];
| 		if ( yy_current_state >= 13 )
| 			yy_c = yy_meta[(unsigned int) yy_c];
| 		}
| 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 	yy_is_jam = (yy_current_state == 12);
| 	if ( ! yy_is_jam )
| 		*(yy_state_ptr)++ = yy_current_state;
| 
| 		return yy_is_jam ? 0 : yy_current_state;
| }
| 
|     static void yyunput (int c, register char * yy_bp )
| {
| 	register char *yy_cp;
|     
|     yy_cp = (yy_c_buf_p);
| 
| 	/* undo effects of setting up yytext */
| 	*yy_cp = (yy_hold_char);
| 
| 	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
| 		{ /* need to shift things up to make room */
| 		/* +2 for EOB chars. */
| 		register yy_size_t number_to_move = (yy_n_chars) + 2;
| 		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
| 					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
| 		register char *source =
| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
| 
| 		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
| 			*--dest = *--source;
| 
| 		yy_cp += (int) (dest - source);
| 		yy_bp += (int) (dest - source);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
| 
| 		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
| 			YY_FATAL_ERROR( "flex scanner push-back overflow" );
| 		}
| 
| 	*--yy_cp = (char) c;
| 
| 	(yytext_ptr) = yy_bp;
| 	(yy_hold_char) = *yy_cp;
| 	(yy_c_buf_p) = yy_cp;
| }
| 
| #ifndef YY_NO_INPUT
| #ifdef __cplusplus
|     static int yyinput (void)
| #else
|     static int input  (void)
| #endif
| 
| {
| 	int c;
|     
| 	*(yy_c_buf_p) = (yy_hold_char);
| 
| 	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
| 		{
| 		/* yy_c_buf_p now points to the character we want to return.
| 		 * If this occurs *before* the EOB characters, then it's a
| 		 * valid NUL; if not, then we've hit the end of the buffer.
| 		 */
| 		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
| 			/* This was really a NUL. */
| 			*(yy_c_buf_p) = '\0';
| 
| 		else
| 			{ /* need more input */
| 			yy_size_t offset = (yy_c_buf_p) - (yytext_ptr);
| 			++(yy_c_buf_p);
| 
| 			switch ( yy_get_next_buffer(  ) )
| 				{
| 				case EOB_ACT_LAST_MATCH:
| 					/* This happens because yy_g_n_b()
| 					 * sees that we've accumulated a
| 					 * token and flags that we need to
| 					 * try matching the token before
| 					 * proceeding.  But for input(),
| 					 * there's no matching to consider.
| 					 * So convert the EOB_ACT_LAST_MATCH
| 					 * to EOB_ACT_END_OF_FILE.
| 					 */
| 
| 					/* Reset buffer status. */
| 					yyrestart(yyin );
| 
| 					/*FALLTHROUGH*/
| 
| 				case EOB_ACT_END_OF_FILE:
| 					{
| 					if ( yywrap( ) )
| 						return EOF;
| 
| 					if ( ! (yy_did_buffer_switch_on_eof) )
| 						YY_NEW_FILE;
| #ifdef __cplusplus
| 					return yyinput();
| #else
| 					return input();
| #endif
| 					}
| 
| 				case EOB_ACT_CONTINUE_SCAN:
| 					(yy_c_buf_p) = (yytext_ptr) + offset;
| 					break;
| 				}
| 			}
| 		}
| 
| 	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
| 	*(yy_c_buf_p) = '\0';	/* preserve yytext */
| 	(yy_hold_char) = *++(yy_c_buf_p);
| 
| 	return c;
| }
| #endif	/* ifndef YY_NO_INPUT */
| 
| /** Immediately switch to a different input stream.
|  * @param input_file A readable stream.
|  * 
|  * @note This function does not reset the start condition to @c INITIAL .
|  */
|     void yyrestart  (FILE * input_file )
| {
|     
| 	if ( ! YY_CURRENT_BUFFER ){
|         yyensure_buffer_stack ();
| 		YY_CURRENT_BUFFER_LVALUE =
|             yy_create_buffer(yyin,YY_BUF_SIZE );
| 	}
| 
| 	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
| 	yy_load_buffer_state( );
| }
| 
| /** Switch to a different input buffer.
|  * @param new_buffer The new input buffer.
|  * 
|  */
|     void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
| {
|     
| 	/* TODO. We should be able to replace this entire function body
| 	 * with
| 	 *		yypop_buffer_state();
| 	 *		yypush_buffer_state(new_buffer);
|      */
| 	yyensure_buffer_stack ();
| 	if ( YY_CURRENT_BUFFER == new_buffer )
| 		return;
| 
| 	if ( YY_CURRENT_BUFFER )
| 		{
| 		/* Flush out information for old buffer. */
| 		*(yy_c_buf_p) = (yy_hold_char);
| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
| 	yy_load_buffer_state( );
| 
| 	/* We don't actually know whether we did this switch during
| 	 * EOF (yywrap()) processing, but the only time this flag
| 	 * is looked at is after yywrap() is called, so it's safe
| 	 * to go ahead and always set it.
| 	 */
| 	(yy_did_buffer_switch_on_eof) = 1;
| }
| 
| static void yy_load_buffer_state  (void)
| {
|     	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
| 	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
| 	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
| 	(yy_hold_char) = *(yy_c_buf_p);
| }
| 
| /** Allocate and initialize an input buffer state.
|  * @param file A readable stream.
|  * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
|  * 
|  * @return the allocated buffer state.
|  */
|     YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
| {
| 	YY_BUFFER_STATE b;
|     
| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_buf_size = size;
| 
| 	/* yy_ch_buf has to be 2 characters longer than the size given because
| 	 * we need to put in 2 end-of-buffer characters.
| 	 */
| 	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
| 	if ( ! b->yy_ch_buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_is_our_buffer = 1;
| 
| 	yy_init_buffer(b,file );
| 
| 	return b;
| }
| 
| /** Destroy the buffer.
|  * @param b a buffer created with yy_create_buffer()
|  * 
|  */
|     void yy_delete_buffer (YY_BUFFER_STATE  b )
| {
|     
| 	if ( ! b )
| 		return;
| 
| 	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
| 		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
| 
| 	if ( b->yy_is_our_buffer )
| 		yyfree((void *) b->yy_ch_buf  );
| 
| 	yyfree((void *) b  );
| }
| 
| /* Initializes or reinitializes a buffer.
|  * This function is sometimes called more than once on the same buffer,
|  * such as during a yyrestart() or at EOF.
|  */
|     static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
| 
| {
| 	int oerrno = errno;
|     
| 	yy_flush_buffer(b );
| 
| 	b->yy_input_file = file;
| 	b->yy_fill_buffer = 1;
| 
|     /* If b is the current buffer, then yy_init_buffer was _probably_
|      * called from yyrestart() or through yy_get_next_buffer.
|      * In that case, we don't want to reset the lineno or column.
|      */
|     if (b != YY_CURRENT_BUFFER){
|         b->yy_bs_lineno = 1;
|         b->yy_bs_column = 0;
|     }
| 
|         b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
|     
| 	errno = oerrno;
| }
| 
| /** Discard all buffered characters. On the next scan, YY_INPUT will be called.
|  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
|  * 
|  */
|     void yy_flush_buffer (YY_BUFFER_STATE  b )
| {
|     	if ( ! b )
| 		return;
| 
| 	b->yy_n_chars = 0;
| 
| 	/* We always need two end-of-buffer characters.  The first causes
| 	 * a transition to the end-of-buffer state.  The second causes
| 	 * a jam in that state.
| 	 */
| 	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
| 	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b->yy_buf_pos = &b->yy_ch_buf[0];
| 
| 	b->yy_at_bol = 1;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	if ( b == YY_CURRENT_BUFFER )
| 		yy_load_buffer_state( );
| }
| 
| /** Pushes the new state onto the stack. The new state becomes
|  *  the current state. This function will allocate the stack
|  *  if necessary.
|  *  @param new_buffer The new state.
|  *  
|  */
| void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
| {
|     	if (new_buffer == NULL)
| 		return;
| 
| 	yyensure_buffer_stack();
| 
| 	/* This block is copied from yy_switch_to_buffer. */
| 	if ( YY_CURRENT_BUFFER )
| 		{
| 		/* Flush out information for old buffer. */
| 		*(yy_c_buf_p) = (yy_hold_char);
| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	/* Only push if top exists. Otherwise, replace top. */
| 	if (YY_CURRENT_BUFFER)
| 		(yy_buffer_stack_top)++;
| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
| 
| 	/* copied from yy_switch_to_buffer. */
| 	yy_load_buffer_state( );
| 	(yy_did_buffer_switch_on_eof) = 1;
| }
| 
| /** Removes and deletes the top of the stack, if present.
|  *  The next element becomes the new top.
|  *  
|  */
| void yypop_buffer_state (void)
| {
|     	if (!YY_CURRENT_BUFFER)
| 		return;
| 
| 	yy_delete_buffer(YY_CURRENT_BUFFER );
| 	YY_CURRENT_BUFFER_LVALUE = NULL;
| 	if ((yy_buffer_stack_top) > 0)
| 		--(yy_buffer_stack_top);
| 
| 	if (YY_CURRENT_BUFFER) {
| 		yy_load_buffer_state( );
| 		(yy_did_buffer_switch_on_eof) = 1;
| 	}
| }
| 
| /* Allocates the stack if it does not exist.
|  *  Guarantees space for at least one push.
|  */
| static void yyensure_buffer_stack (void)
| {
| 	yy_size_t num_to_alloc;
|     
| 	if (!(yy_buffer_stack)) {
| 
| 		/* First allocation is just for 2 elements, since we don't know if this
| 		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
| 		 * immediate realloc on the next call.
|          */
| 		num_to_alloc = 1;
| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
| 								(num_to_alloc * sizeof(struct yy_buffer_state*)
| 								);
| 		if ( ! (yy_buffer_stack) )
| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
| 								  
| 		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
| 				
| 		(yy_buffer_stack_max) = num_to_alloc;
| 		(yy_buffer_stack_top) = 0;
| 		return;
| 	}
| 
| 	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
| 
| 		/* Increase the buffer to prepare for a possible push. */
| 		int grow_size = 8 /* arbitrary grow size */;
| 
| 		num_to_alloc = (yy_buffer_stack_max) + grow_size;
| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
| 								((yy_buffer_stack),
| 								num_to_alloc * sizeof(struct yy_buffer_state*)
| 								);
| 		if ( ! (yy_buffer_stack) )
| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
| 
| 		/* zero only the new slots.*/
| 		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
| 		(yy_buffer_stack_max) = num_to_alloc;
| 	}
| }
| 
| /** Setup the input buffer state to scan directly from a user-specified character buffer.
|  * @param base the character buffer
|  * @param size the size in bytes of the character buffer
|  * 
|  * @return the newly allocated buffer state object. 
|  */
| YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
| {
| 	YY_BUFFER_STATE b;
|     
| 	if ( size < 2 ||
| 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
| 	     base[size-1] != YY_END_OF_BUFFER_CHAR )
| 		/* They forgot to leave room for the EOB's. */
| 		return 0;
| 
| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
| 
| 	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
| 	b->yy_buf_pos = b->yy_ch_buf = base;
| 	b->yy_is_our_buffer = 0;
| 	b->yy_input_file = 0;
| 	b->yy_n_chars = b->yy_buf_size;
| 	b->yy_is_interactive = 0;
| 	b->yy_at_bol = 1;
| 	b->yy_fill_buffer = 0;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	yy_switch_to_buffer(b  );
| 
| 	return b;
| }
| 
| /** Setup the input buffer state to scan a string. The next call to yylex() will
|  * scan from a @e copy of @a str.
|  * @param yystr a NUL-terminated string to scan
|  * 
|  * @return the newly allocated buffer state object.
|  * @note If you want to scan bytes that may contain NUL values, then use
|  *       yy_scan_bytes() instead.
|  */
| YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
| {
|     
| 	return yy_scan_bytes(yystr,strlen(yystr) );
| }
| 
| /** Setup the input buffer state to scan the given bytes. The next call to yylex() will
|  * scan from a @e copy of @a bytes.
|  * @param yybytes the byte buffer to scan
|  * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
|  * 
|  * @return the newly allocated buffer state object.
|  */
| YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len )
| {
| 	YY_BUFFER_STATE b;
| 	char *buf;
| 	yy_size_t n;
| 	yy_size_t i;
|     
| 	/* Get memory for full buffer, including space for trailing EOB's. */
| 	n = _yybytes_len + 2;
| 	buf = (char *) yyalloc(n  );
| 	if ( ! buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
| 
| 	for ( i = 0; i < _yybytes_len; ++i )
| 		buf[i] = yybytes[i];
| 
| 	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b = yy_scan_buffer(buf,n );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
| 
| 	/* It's okay to grow etc. this buffer, and we should throw it
| 	 * away when we're done.
| 	 */
| 	b->yy_is_our_buffer = 1;
| 
| 	return b;
| }
| 
| #ifndef YY_EXIT_FAILURE
| #define YY_EXIT_FAILURE 2
| #endif
| 
| static void yy_fatal_error (yyconst char* msg )
| {
|     	(void) fprintf( stderr, "%s\n", msg );
| 	exit( YY_EXIT_FAILURE );
| }
| 
| /* Redefine yyless() so it works in section 3 code. */
| 
| #undef yyless
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
|         int yyless_macro_arg = (n); \
|         YY_LESS_LINENO(yyless_macro_arg);\
| 		yytext[yyleng] = (yy_hold_char); \
| 		(yy_c_buf_p) = yytext + yyless_macro_arg; \
| 		(yy_hold_char) = *(yy_c_buf_p); \
| 		*(yy_c_buf_p) = '\0'; \
| 		yyleng = yyless_macro_arg; \
| 		} \
| 	while ( 0 )
| 
| /* Accessor  methods (get/set functions) to struct members. */
| 
| /** Get the current line number.
|  * 
|  */
| int yyget_lineno  (void)
| {
|         
|     return yylineno;
| }
| 
| /** Get the input stream.
|  * 
|  */
| FILE *yyget_in  (void)
| {
|         return yyin;
| }
| 
| /** Get the output stream.
|  * 
|  */
| FILE *yyget_out  (void)
| {
|         return yyout;
| }
| 
| /** Get the length of the current token.
|  * 
|  */
| yy_size_t yyget_leng  (void)
| {
|         return yyleng;
| }
| 
| /** Get the current token.
|  * 
|  */
| 
| char *yyget_text  (void)
| {
|         return yytext;
| }
| 
| /** Set the current line number.
|  * @param line_number
|  * 
|  */
| void yyset_lineno (int  line_number )
| {
|     
|     yylineno = line_number;
| }
| 
| /** Set the input stream. This does not discard the current
|  * input buffer.
|  * @param in_str A readable stream.
|  * 
|  * @see yy_switch_to_buffer
|  */
| void yyset_in (FILE *  in_str )
| {
|         yyin = in_str ;
| }
| 
| void yyset_out (FILE *  out_str )
| {
|         yyout = out_str ;
| }
| 
| int yyget_debug  (void)
| {
|         return yy_flex_debug;
| }
| 
| void yyset_debug (int  bdebug )
| {
|         yy_flex_debug = bdebug ;
| }
| 
| static int yy_init_globals (void)
| {
|         /* Initialization is the same as for the non-reentrant scanner.
|      * This function is called from yylex_destroy(), so don't allocate here.
|      */
| 
|     (yy_buffer_stack) = 0;
|     (yy_buffer_stack_top) = 0;
|     (yy_buffer_stack_max) = 0;
|     (yy_c_buf_p) = (char *) 0;
|     (yy_init) = 0;
|     (yy_start) = 0;
| 
|     (yy_state_buf) = 0;
|     (yy_state_ptr) = 0;
|     (yy_full_match) = 0;
|     (yy_lp) = 0;
| 
| /* Defined in main.c */
| #ifdef YY_STDINIT
|     yyin = stdin;
|     yyout = stdout;
| #else
|     yyin = (FILE *) 0;
|     yyout = (FILE *) 0;
| #endif
| 
|     /* For future reference: Set errno on error, since we are called by
|      * yylex_init()
|      */
|     return 0;
| }
| 
| /* yylex_destroy is for both reentrant and non-reentrant scanners. */
| int yylex_destroy  (void)
| {
|     
|     /* Pop the buffer stack, destroying each element. */
| 	while(YY_CURRENT_BUFFER){
| 		yy_delete_buffer(YY_CURRENT_BUFFER  );
| 		YY_CURRENT_BUFFER_LVALUE = NULL;
| 		yypop_buffer_state();
| 	}
| 
| 	/* Destroy the stack itself. */
| 	yyfree((yy_buffer_stack) );
| 	(yy_buffer_stack) = NULL;
| 
|     yyfree ( (yy_state_buf) );
|     (yy_state_buf)  = NULL;
| 
|     /* Reset the globals. This is important in a non-reentrant scanner so the next time
|      * yylex() is called, initialization will occur. */
|     yy_init_globals( );
| 
|     return 0;
| }
| 
| /*
|  * Internal utility routines.
|  */
| 
| #ifndef yytext_ptr
| static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
| {
| 	register int i;
| 	for ( i = 0; i < n; ++i )
| 		s1[i] = s2[i];
| }
| #endif
| 
| #ifdef YY_NEED_STRLEN
| static int yy_flex_strlen (yyconst char * s )
| {
| 	register int n;
| 	for ( n = 0; s[n]; ++n )
| 		;
| 
| 	return n;
| }
| #endif
| 
| void *yyalloc (yy_size_t  size )
| {
| 	return (void *) malloc( size );
| }
| 
| void *yyrealloc  (void * ptr, yy_size_t  size )
| {
| 	/* The cast to (char *) in the following accommodates both
| 	 * implementations that use char* generic pointers, and those
| 	 * that use void* generic pointers.  It works with the latter
| 	 * because both ANSI C and C++ allow castless assignment from
| 	 * any pointer type to void*, and deal with argument conversions
| 	 * as though doing an assignment.
| 	 */
| 	return (void *) realloc( (char *) ptr, size );
| }
| 
| void yyfree (void * ptr )
| {
| 	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
| }
| 
| #define YYTABLES_NAME "yytables"
| 
| #line 9 "conftest.l"
| 
| 
| #ifdef YYTEXT_POINTER
| extern char *yytext;
| #endif
| int
| main (void)
| {
|   return ! yylex () + ! yywrap ();
| }
configure:12177: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c -ll  >&5
/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld: error: cannot find -ll
/tmp/cca4pJvc.o:conftest.c:function yylex: error: undefined reference to 'yywrap'
/tmp/cca4pJvc.o:conftest.c:function input: error: undefined reference to 'yywrap'
/tmp/cca4pJvc.o:conftest.c:function main: error: undefined reference to 'yywrap'
collect2: error: ld returned 1 exit status
configure:12177: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "binutils"
| #define PACKAGE_TARNAME "binutils"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "binutils 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "binutils"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define DEFAULT_AR_DETERMINISTIC 0
| #define DEFAULT_STRINGS_ALL 1
| /* end confdefs.h.  */
| 
| #line 3 "lex.yy.c"
| 
| #define  YY_INT_ALIGNED short int
| 
| /* A lexical scanner generated by flex */
| 
| #define FLEX_SCANNER
| #define YY_FLEX_MAJOR_VERSION 2
| #define YY_FLEX_MINOR_VERSION 5
| #define YY_FLEX_SUBMINOR_VERSION 39
| #if YY_FLEX_SUBMINOR_VERSION > 0
| #define FLEX_BETA
| #endif
| 
| /* First, we deal with  platform-specific or compiler-specific issues. */
| 
| /* begin standard C headers. */
| #include <stdio.h>
| #include <string.h>
| #include <errno.h>
| #include <stdlib.h>
| 
| /* end standard C headers. */
| 
| /* flex integer type definitions */
| 
| #ifndef FLEXINT_H
| #define FLEXINT_H
| 
| /* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
| 
| #if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
| 
| /* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
|  * if you want the limit (max/min) macros for int types. 
|  */
| #ifndef __STDC_LIMIT_MACROS
| #define __STDC_LIMIT_MACROS 1
| #endif
| 
| #include <inttypes.h>
| typedef int8_t flex_int8_t;
| typedef uint8_t flex_uint8_t;
| typedef int16_t flex_int16_t;
| typedef uint16_t flex_uint16_t;
| typedef int32_t flex_int32_t;
| typedef uint32_t flex_uint32_t;
| #else
| typedef signed char flex_int8_t;
| typedef short int flex_int16_t;
| typedef int flex_int32_t;
| typedef unsigned char flex_uint8_t; 
| typedef unsigned short int flex_uint16_t;
| typedef unsigned int flex_uint32_t;
| 
| /* Limits of integral types. */
| #ifndef INT8_MIN
| #define INT8_MIN               (-128)
| #endif
| #ifndef INT16_MIN
| #define INT16_MIN              (-32767-1)
| #endif
| #ifndef INT32_MIN
| #define INT32_MIN              (-2147483647-1)
| #endif
| #ifndef INT8_MAX
| #define INT8_MAX               (127)
| #endif
| #ifndef INT16_MAX
| #define INT16_MAX              (32767)
| #endif
| #ifndef INT32_MAX
| #define INT32_MAX              (2147483647)
| #endif
| #ifndef UINT8_MAX
| #define UINT8_MAX              (255U)
| #endif
| #ifndef UINT16_MAX
| #define UINT16_MAX             (65535U)
| #endif
| #ifndef UINT32_MAX
| #define UINT32_MAX             (4294967295U)
| #endif
| 
| #endif /* ! C99 */
| 
| #endif /* ! FLEXINT_H */
| 
| #ifdef __cplusplus
| 
| /* The "const" storage-class-modifier is valid. */
| #define YY_USE_CONST
| 
| #else	/* ! __cplusplus */
| 
| /* C99 requires __STDC__ to be defined as 1. */
| #if defined (__STDC__)
| 
| #define YY_USE_CONST
| 
| #endif	/* defined (__STDC__) */
| #endif	/* ! __cplusplus */
| 
| #ifdef YY_USE_CONST
| #define yyconst const
| #else
| #define yyconst
| #endif
| 
| /* Returned upon end-of-file. */
| #define YY_NULL 0
| 
| /* Promotes a possibly negative, possibly signed char to an unsigned
|  * integer for use as an array index.  If the signed char is negative,
|  * we want to instead treat it as an 8-bit unsigned char, hence the
|  * double cast.
|  */
| #define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
| 
| /* Enter a start condition.  This macro really ought to take a parameter,
|  * but we do it the disgusting crufty way forced on us by the ()-less
|  * definition of BEGIN.
|  */
| #define BEGIN (yy_start) = 1 + 2 *
| 
| /* Translate the current start state into a value that can be later handed
|  * to BEGIN to return to the state.  The YYSTATE alias is for lex
|  * compatibility.
|  */
| #define YY_START (((yy_start) - 1) / 2)
| #define YYSTATE YY_START
| 
| /* Action number for EOF rule of a given start state. */
| #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
| 
| /* Special action meaning "start processing a new file". */
| #define YY_NEW_FILE yyrestart(yyin  )
| 
| #define YY_END_OF_BUFFER_CHAR 0
| 
| /* Size of default input buffer. */
| #ifndef YY_BUF_SIZE
| #define YY_BUF_SIZE 16384
| #endif
| 
| /* The state buf must be large enough to hold one state per character in the main buffer.
|  */
| #define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
| 
| #ifndef YY_TYPEDEF_YY_BUFFER_STATE
| #define YY_TYPEDEF_YY_BUFFER_STATE
| typedef struct yy_buffer_state *YY_BUFFER_STATE;
| #endif
| 
| #ifndef YY_TYPEDEF_YY_SIZE_T
| #define YY_TYPEDEF_YY_SIZE_T
| typedef size_t yy_size_t;
| #endif
| 
| extern yy_size_t yyleng;
| 
| extern FILE *yyin, *yyout;
| 
| #define EOB_ACT_CONTINUE_SCAN 0
| #define EOB_ACT_END_OF_FILE 1
| #define EOB_ACT_LAST_MATCH 2
| 
|     #define YY_LESS_LINENO(n)
|     #define YY_LINENO_REWIND_TO(ptr)
|     
| /* Return all but the first "n" matched characters back to the input stream. */
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
|         int yyless_macro_arg = (n); \
|         YY_LESS_LINENO(yyless_macro_arg);\
| 		*yy_cp = (yy_hold_char); \
| 		YY_RESTORE_YY_MORE_OFFSET \
| 		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
| 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
| 		} \
| 	while ( 0 )
| 
| #define unput(c) yyunput( c, (yytext_ptr)  )
| 
| #ifndef YY_STRUCT_YY_BUFFER_STATE
| #define YY_STRUCT_YY_BUFFER_STATE
| struct yy_buffer_state
| 	{
| 	FILE *yy_input_file;
| 
| 	char *yy_ch_buf;		/* input buffer */
| 	char *yy_buf_pos;		/* current position in input buffer */
| 
| 	/* Size of input buffer in bytes, not including room for EOB
| 	 * characters.
| 	 */
| 	yy_size_t yy_buf_size;
| 
| 	/* Number of characters read into yy_ch_buf, not including EOB
| 	 * characters.
| 	 */
| 	yy_size_t yy_n_chars;
| 
| 	/* Whether we "own" the buffer - i.e., we know we created it,
| 	 * and can realloc() it to grow it, and should free() it to
| 	 * delete it.
| 	 */
| 	int yy_is_our_buffer;
| 
| 	/* Whether this is an "interactive" input source; if so, and
| 	 * if we're using stdio for input, then we want to use getc()
| 	 * instead of fread(), to make sure we stop fetching input after
| 	 * each newline.
| 	 */
| 	int yy_is_interactive;
| 
| 	/* Whether we're considered to be at the beginning of a line.
| 	 * If so, '^' rules will be active on the next match, otherwise
| 	 * not.
| 	 */
| 	int yy_at_bol;
| 
|     int yy_bs_lineno; /**< The line count. */
|     int yy_bs_column; /**< The column count. */
|     
| 	/* Whether to try to fill the input buffer when we reach the
| 	 * end of it.
| 	 */
| 	int yy_fill_buffer;
| 
| 	int yy_buffer_status;
| 
| #define YY_BUFFER_NEW 0
| #define YY_BUFFER_NORMAL 1
| 	/* When an EOF's been seen but there's still some text to process
| 	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
| 	 * shouldn't try reading from the input source any more.  We might
| 	 * still have a bunch of tokens to match, though, because of
| 	 * possible backing-up.
| 	 *
| 	 * When we actually see the EOF, we change the status to "new"
| 	 * (via yyrestart()), so that the user can continue scanning by
| 	 * just pointing yyin at a new input file.
| 	 */
| #define YY_BUFFER_EOF_PENDING 2
| 
| 	};
| #endif /* !YY_STRUCT_YY_BUFFER_STATE */
| 
| /* Stack of input buffers. */
| static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
| static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
| static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
| 
| /* We provide macros for accessing buffer states in case in the
|  * future we want to put the buffer states in a more general
|  * "scanner state".
|  *
|  * Returns the top of the stack, or NULL.
|  */
| #define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
|                           ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
|                           : NULL)
| 
| /* Same as previous macro, but useful when we know that the buffer stack is not
|  * NULL or when we need an lvalue. For internal use only.
|  */
| #define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
| 
| /* yy_hold_char holds the character lost when yytext is formed. */
| static char yy_hold_char;
| static yy_size_t yy_n_chars;		/* number of characters read into yy_ch_buf */
| yy_size_t yyleng;
| 
| /* Points to current character in buffer. */
| static char *yy_c_buf_p = (char *) 0;
| static int yy_init = 0;		/* whether we need to initialize */
| static int yy_start = 0;	/* start state number */
| 
| /* Flag which is used to allow yywrap()'s to do buffer switches
|  * instead of setting up a fresh yyin.  A bit of a hack ...
|  */
| static int yy_did_buffer_switch_on_eof;
| 
| void yyrestart (FILE *input_file  );
| void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
| YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
| void yy_delete_buffer (YY_BUFFER_STATE b  );
| void yy_flush_buffer (YY_BUFFER_STATE b  );
| void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
| void yypop_buffer_state (void );
| 
| static void yyensure_buffer_stack (void );
| static void yy_load_buffer_state (void );
| static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
| 
| #define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
| 
| YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
| YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
| YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,yy_size_t len  );
| 
| void *yyalloc (yy_size_t  );
| void *yyrealloc (void *,yy_size_t  );
| void yyfree (void *  );
| 
| #define yy_new_buffer yy_create_buffer
| 
| #define yy_set_interactive(is_interactive) \
| 	{ \
| 	if ( ! YY_CURRENT_BUFFER ){ \
|         yyensure_buffer_stack (); \
| 		YY_CURRENT_BUFFER_LVALUE =    \
|             yy_create_buffer(yyin,YY_BUF_SIZE ); \
| 	} \
| 	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
| 	}
| 
| #define yy_set_bol(at_bol) \
| 	{ \
| 	if ( ! YY_CURRENT_BUFFER ){\
|         yyensure_buffer_stack (); \
| 		YY_CURRENT_BUFFER_LVALUE =    \
|             yy_create_buffer(yyin,YY_BUF_SIZE ); \
| 	} \
| 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
| 	}
| 
| #define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
| 
| /* Begin user sect3 */
| 
| typedef unsigned char YY_CHAR;
| 
| FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
| 
| typedef int yy_state_type;
| 
| extern int yylineno;
| 
| int yylineno = 1;
| 
| extern char *yytext;
| #define yytext_ptr yytext
| 
| static yy_state_type yy_get_previous_state (void );
| static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
| static int yy_get_next_buffer (void );
| static void yy_fatal_error (yyconst char msg[]  );
| 
| /* Done after the current pattern has been matched and before the
|  * corresponding action - sets up yytext.
|  */
| #define YY_DO_BEFORE_ACTION \
| 	(yytext_ptr) = yy_bp; \
| 	(yytext_ptr) -= (yy_more_len); \
| 	yyleng = (size_t) (yy_cp - (yytext_ptr)); \
| 	(yy_hold_char) = *yy_cp; \
| 	*yy_cp = '\0'; \
| 	(yy_c_buf_p) = yy_cp;
| 
| #define YY_NUM_RULES 8
| #define YY_END_OF_BUFFER 9
| /* This struct is not used in this scanner,
|    but its presence is necessary. */
| struct yy_trans_info
| 	{
| 	flex_int32_t yy_verify;
| 	flex_int32_t yy_nxt;
| 	};
| static yyconst flex_int16_t yy_acclist[23] =
|     {   0,
|         9,    7,    8,    8,    1,    7,    8,    2,    7,    8,
|         3,    7,    8,    4,    7,    8,    5,    7,    8,    6,
|         7,    8
|     } ;
| 
| static yyconst flex_int16_t yy_accept[14] =
|     {   0,
|         1,    1,    1,    2,    4,    5,    8,   11,   14,   17,
|        20,   23,   23
|     } ;
| 
| static yyconst flex_int32_t yy_ec[256] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    3,    4,    5,    6,
| 
|         7,    8,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| 
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1
|     } ;
| 
| static yyconst flex_int32_t yy_meta[9] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1
|     } ;
| 
| static yyconst flex_int16_t yy_base[13] =
|     {   0,
|         0,    0,    9,   10,   10,   10,   10,   10,   10,   10,
|        10,   10
|     } ;
| 
| static yyconst flex_int16_t yy_def[13] =
|     {   0,
|        12,    1,   12,   12,   12,   12,   12,   12,   12,   12,
|        12,    0
|     } ;
| 
| static yyconst flex_int16_t yy_nxt[19] =
|     {   0,
|         4,    5,    6,    7,    8,    9,   10,   11,   12,    3,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| static yyconst flex_int16_t yy_chk[19] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    3,   12,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| extern int yy_flex_debug;
| int yy_flex_debug = 0;
| 
| static yy_state_type *yy_state_buf=0, *yy_state_ptr=0;
| static char *yy_full_match;
| static int yy_lp;
| #define REJECT \
| { \
| *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */ \
| yy_cp = (yy_full_match); /* restore poss. backed-over text */ \
| ++(yy_lp); \
| goto find_rule; \
| }
| 
| static int yy_more_flag = 0;
| static int yy_more_len = 0;
| #define yymore() ((yy_more_flag) = 1)
| #define YY_MORE_ADJ (yy_more_len)
| #define YY_RESTORE_YY_MORE_OFFSET
| char *yytext;
| #line 1 "conftest.l"
| #line 470 "lex.yy.c"
| 
| #define INITIAL 0
| 
| #ifndef YY_NO_UNISTD_H
| /* Special case for "unistd.h", since it is non-ANSI. We include it way
|  * down here because we want the user's section 1 to have been scanned first.
|  * The user has a chance to override it with an option.
|  */
| #include <unistd.h>
| #endif
| 
| #ifndef YY_EXTRA_TYPE
| #define YY_EXTRA_TYPE void *
| #endif
| 
| static int yy_init_globals (void );
| 
| /* Accessor methods to globals.
|    These are made visible to non-reentrant scanners for convenience. */
| 
| int yylex_destroy (void );
| 
| int yyget_debug (void );
| 
| void yyset_debug (int debug_flag  );
| 
| YY_EXTRA_TYPE yyget_extra (void );
| 
| void yyset_extra (YY_EXTRA_TYPE user_defined  );
| 
| FILE *yyget_in (void );
| 
| void yyset_in  (FILE * in_str  );
| 
| FILE *yyget_out (void );
| 
| void yyset_out  (FILE * out_str  );
| 
| yy_size_t yyget_leng (void );
| 
| char *yyget_text (void );
| 
| int yyget_lineno (void );
| 
| void yyset_lineno (int line_number  );
| 
| /* Macros after this point can all be overridden by user definitions in
|  * section 1.
|  */
| 
| #ifndef YY_SKIP_YYWRAP
| #ifdef __cplusplus
| extern "C" int yywrap (void );
| #else
| extern int yywrap (void );
| #endif
| #endif
| 
|     static void yyunput (int c,char *buf_ptr  );
|     
| #ifndef yytext_ptr
| static void yy_flex_strncpy (char *,yyconst char *,int );
| #endif
| 
| #ifdef YY_NEED_STRLEN
| static int yy_flex_strlen (yyconst char * );
| #endif
| 
| #ifndef YY_NO_INPUT
| 
| #ifdef __cplusplus
| static int yyinput (void );
| #else
| static int input (void );
| #endif
| 
| #endif
| 
| /* Amount of stuff to slurp up with each read. */
| #ifndef YY_READ_BUF_SIZE
| #define YY_READ_BUF_SIZE 8192
| #endif
| 
| /* Copy whatever the last rule matched to the standard output. */
| #ifndef ECHO
| /* This used to be an fputs(), but since the string might contain NUL's,
|  * we now use fwrite().
|  */
| #define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
| #endif
| 
| /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
|  * is returned in "result".
|  */
| #ifndef YY_INPUT
| #define YY_INPUT(buf,result,max_size) \
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
| 		{ \
| 		int c = '*'; \
| 		size_t n; \
| 		for ( n = 0; n < max_size && \
| 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
| 			buf[n] = (char) c; \
| 		if ( c == '\n' ) \
| 			buf[n++] = (char) c; \
| 		if ( c == EOF && ferror( yyin ) ) \
| 			YY_FATAL_ERROR( "input in flex scanner failed" ); \
| 		result = n; \
| 		} \
| 	else \
| 		{ \
| 		errno=0; \
| 		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
| 			{ \
| 			if( errno != EINTR) \
| 				{ \
| 				YY_FATAL_ERROR( "input in flex scanner failed" ); \
| 				break; \
| 				} \
| 			errno=0; \
| 			clearerr(yyin); \
| 			} \
| 		}\
| \
| 
| #endif
| 
| /* No semi-colon after return; correct usage is to write "yyterminate();" -
|  * we don't want an extra ';' after the "return" because that will cause
|  * some compilers to complain about unreachable statements.
|  */
| #ifndef yyterminate
| #define yyterminate() return YY_NULL
| #endif
| 
| /* Number of entries by which start-condition stack grows. */
| #ifndef YY_START_STACK_INCR
| #define YY_START_STACK_INCR 25
| #endif
| 
| /* Report a fatal error. */
| #ifndef YY_FATAL_ERROR
| #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
| #endif
| 
| /* end tables serialization structures and prototypes */
| 
| /* Default declaration of generated scanner - a define so the user can
|  * easily add parameters.
|  */
| #ifndef YY_DECL
| #define YY_DECL_IS_OURS 1
| 
| extern int yylex (void);
| 
| #define YY_DECL int yylex (void)
| #endif /* !YY_DECL */
| 
| /* Code executed at the beginning of each rule, after yytext and yyleng
|  * have been set up.
|  */
| #ifndef YY_USER_ACTION
| #define YY_USER_ACTION
| #endif
| 
| /* Code executed at the end of each rule. */
| #ifndef YY_BREAK
| #define YY_BREAK break;
| #endif
| 
| #define YY_RULE_SETUP \
| 	YY_USER_ACTION
| 
| /** The main scanner function which does all the work.
|  */
| YY_DECL
| {
| 	register yy_state_type yy_current_state;
| 	register char *yy_cp, *yy_bp;
| 	register int yy_act;
|     
| 	if ( !(yy_init) )
| 		{
| 		(yy_init) = 1;
| 
| #ifdef YY_USER_INIT
| 		YY_USER_INIT;
| #endif
| 
|         /* Create the reject buffer large enough to save one state per allowed character. */
|         if ( ! (yy_state_buf) )
|             (yy_state_buf) = (yy_state_type *)yyalloc(YY_STATE_BUF_SIZE  );
|             if ( ! (yy_state_buf) )
|                 YY_FATAL_ERROR( "out of dynamic memory in yylex()" );
| 
| 		if ( ! (yy_start) )
| 			(yy_start) = 1;	/* first start state */
| 
| 		if ( ! yyin )
| 			yyin = stdin;
| 
| 		if ( ! yyout )
| 			yyout = stdout;
| 
| 		if ( ! YY_CURRENT_BUFFER ) {
| 			yyensure_buffer_stack ();
| 			YY_CURRENT_BUFFER_LVALUE =
| 				yy_create_buffer(yyin,YY_BUF_SIZE );
| 		}
| 
| 		yy_load_buffer_state( );
| 		}
| 
| 	{
| #line 1 "conftest.l"
| 
| #line 687 "lex.yy.c"
| 
| 	while ( 1 )		/* loops until end-of-file is reached */
| 		{
| 		(yy_more_len) = 0;
| 		if ( (yy_more_flag) )
| 			{
| 			(yy_more_len) = (yy_c_buf_p) - (yytext_ptr);
| 			(yy_more_flag) = 0;
| 			}
| 		yy_cp = (yy_c_buf_p);
| 
| 		/* Support of yytext. */
| 		*yy_cp = (yy_hold_char);
| 
| 		/* yy_bp points to the position in yy_ch_buf of the start of
| 		 * the current run.
| 		 */
| 		yy_bp = yy_cp;
| 
| 		yy_current_state = (yy_start);
| 
| 		(yy_state_ptr) = (yy_state_buf);
| 		*(yy_state_ptr)++ = yy_current_state;
| 
| yy_match:
| 		do
| 			{
| 			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
| 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 				{
| 				yy_current_state = (int) yy_def[yy_current_state];
| 				if ( yy_current_state >= 13 )
| 					yy_c = yy_meta[(unsigned int) yy_c];
| 				}
| 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 			*(yy_state_ptr)++ = yy_current_state;
| 			++yy_cp;
| 			}
| 		while ( yy_base[yy_current_state] != 10 );
| 
| yy_find_action:
| 		yy_current_state = *--(yy_state_ptr);
| 		(yy_lp) = yy_accept[yy_current_state];
| find_rule: /* we branch to this label when backing up */
| 		for ( ; ; ) /* until we find what rule we matched */
| 			{
| 			if ( (yy_lp) && (yy_lp) < yy_accept[yy_current_state + 1] )
| 				{
| 				yy_act = yy_acclist[(yy_lp)];
| 					{
| 					(yy_full_match) = yy_cp;
| 					break;
| 					}
| 				}
| 			--yy_cp;
| 			yy_current_state = *--(yy_state_ptr);
| 			(yy_lp) = yy_accept[yy_current_state];
| 			}
| 
| 		YY_DO_BEFORE_ACTION;
| 
| do_action:	/* This label is used only to access EOF actions. */
| 
| 		switch ( yy_act )
| 	{ /* beginning of action switch */
| case 1:
| YY_RULE_SETUP
| #line 2 "conftest.l"
| { ECHO; }
| 	YY_BREAK
| case 2:
| YY_RULE_SETUP
| #line 3 "conftest.l"
| { REJECT; }
| 	YY_BREAK
| case 3:
| YY_RULE_SETUP
| #line 4 "conftest.l"
| { yymore (); }
| 	YY_BREAK
| case 4:
| YY_RULE_SETUP
| #line 5 "conftest.l"
| { yyless (1); }
| 	YY_BREAK
| case 5:
| YY_RULE_SETUP
| #line 6 "conftest.l"
| { yyless (input () != 0); }
| 	YY_BREAK
| case 6:
| YY_RULE_SETUP
| #line 7 "conftest.l"
| { unput (yytext[0]); }
| 	YY_BREAK
| case 7:
| YY_RULE_SETUP
| #line 8 "conftest.l"
| { BEGIN INITIAL; }
| 	YY_BREAK
| case 8:
| YY_RULE_SETUP
| #line 9 "conftest.l"
| ECHO;
| 	YY_BREAK
| #line 793 "lex.yy.c"
| 			case YY_STATE_EOF(INITIAL):
| 				yyterminate();
| 
| 	case YY_END_OF_BUFFER:
| 		{
| 		/* Amount of text matched not including the EOB char. */
| 		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
| 
| 		/* Undo the effects of YY_DO_BEFORE_ACTION. */
| 		*yy_cp = (yy_hold_char);
| 		YY_RESTORE_YY_MORE_OFFSET
| 
| 		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
| 			{
| 			/* We're scanning a new file or input source.  It's
| 			 * possible that this happened because the user
| 			 * just pointed yyin at a new source and called
| 			 * yylex().  If so, then we have to assure
| 			 * consistency between YY_CURRENT_BUFFER and our
| 			 * globals.  Here is the right place to do so, because
| 			 * this is the first action (other than possibly a
| 			 * back-up) that will match for the new input source.
| 			 */
| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
| 			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
| 			}
| 
| 		/* Note that here we test for yy_c_buf_p "<=" to the position
| 		 * of the first EOB in the buffer, since yy_c_buf_p will
| 		 * already have been incremented past the NUL character
| 		 * (since all states make transitions on EOB to the
| 		 * end-of-buffer state).  Contrast this with the test
| 		 * in input().
| 		 */
| 		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
| 			{ /* This was really a NUL. */
| 			yy_state_type yy_next_state;
| 
| 			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
| 
| 			yy_current_state = yy_get_previous_state(  );
| 
| 			/* Okay, we're now positioned to make the NUL
| 			 * transition.  We couldn't have
| 			 * yy_get_previous_state() go ahead and do it
| 			 * for us because it doesn't know how to deal
| 			 * with the possibility of jamming (and we don't
| 			 * want to build jamming into it because then it
| 			 * will run more slowly).
| 			 */
| 
| 			yy_next_state = yy_try_NUL_trans( yy_current_state );
| 
| 			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 
| 			if ( yy_next_state )
| 				{
| 				/* Consume the NUL. */
| 				yy_cp = ++(yy_c_buf_p);
| 				yy_current_state = yy_next_state;
| 				goto yy_match;
| 				}
| 
| 			else
| 				{
| 				yy_cp = (yy_c_buf_p);
| 				goto yy_find_action;
| 				}
| 			}
| 
| 		else switch ( yy_get_next_buffer(  ) )
| 			{
| 			case EOB_ACT_END_OF_FILE:
| 				{
| 				(yy_did_buffer_switch_on_eof) = 0;
| 
| 				if ( yywrap( ) )
| 					{
| 					/* Note: because we've taken care in
| 					 * yy_get_next_buffer() to have set up
| 					 * yytext, we can now set up
| 					 * yy_c_buf_p so that if some total
| 					 * hoser (like flex itself) wants to
| 					 * call the scanner after we return the
| 					 * YY_NULL, it'll still work - another
| 					 * YY_NULL will get returned.
| 					 */
| 					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
| 
| 					yy_act = YY_STATE_EOF(YY_START);
| 					goto do_action;
| 					}
| 
| 				else
| 					{
| 					if ( ! (yy_did_buffer_switch_on_eof) )
| 						YY_NEW_FILE;
| 					}
| 				break;
| 				}
| 
| 			case EOB_ACT_CONTINUE_SCAN:
| 				(yy_c_buf_p) =
| 					(yytext_ptr) + yy_amount_of_matched_text;
| 
| 				yy_current_state = yy_get_previous_state(  );
| 
| 				yy_cp = (yy_c_buf_p);
| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 				goto yy_match;
| 
| 			case EOB_ACT_LAST_MATCH:
| 				(yy_c_buf_p) =
| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
| 
| 				yy_current_state = yy_get_previous_state(  );
| 
| 				yy_cp = (yy_c_buf_p);
| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 				goto yy_find_action;
| 			}
| 		break;
| 		}
| 
| 	default:
| 		YY_FATAL_ERROR(
| 			"fatal flex scanner internal error--no action found" );
| 	} /* end of action switch */
| 		} /* end of scanning one token */
| 	} /* end of user's declarations */
| } /* end of yylex */
| 
| /* yy_get_next_buffer - try to read in a new buffer
|  *
|  * Returns a code representing an action:
|  *	EOB_ACT_LAST_MATCH -
|  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
|  *	EOB_ACT_END_OF_FILE - end of file
|  */
| static int yy_get_next_buffer (void)
| {
|     	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
| 	register char *source = (yytext_ptr);
| 	register int number_to_move, i;
| 	int ret_val;
| 
| 	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
| 		YY_FATAL_ERROR(
| 		"fatal flex scanner internal error--end of buffer missed" );
| 
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
| 		{ /* Don't try to fill the buffer, so this is an EOF. */
| 		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
| 			{
| 			/* We matched a single character, the EOB, so
| 			 * treat this as a final EOF.
| 			 */
| 			return EOB_ACT_END_OF_FILE;
| 			}
| 
| 		else
| 			{
| 			/* We matched some text prior to the EOB, first
| 			 * process it.
| 			 */
| 			return EOB_ACT_LAST_MATCH;
| 			}
| 		}
| 
| 	/* Try to read more data. */
| 
| 	/* First move last chars to start of buffer. */
| 	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
| 
| 	for ( i = 0; i < number_to_move; ++i )
| 		*(dest++) = *(source++);
| 
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
| 		/* don't do the read, it's not guaranteed to return an EOF,
| 		 * just force an EOF
| 		 */
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
| 
| 	else
| 		{
| 			yy_size_t num_to_read =
| 			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
| 
| 		while ( num_to_read <= 0 )
| 			{ /* Not enough room in the buffer - grow it. */
| 
| 			YY_FATAL_ERROR(
| "input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
| 
| 			}
| 
| 		if ( num_to_read > YY_READ_BUF_SIZE )
| 			num_to_read = YY_READ_BUF_SIZE;
| 
| 		/* Read in more data. */
| 		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
| 			(yy_n_chars), num_to_read );
| 
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	if ( (yy_n_chars) == 0 )
| 		{
| 		if ( number_to_move == YY_MORE_ADJ )
| 			{
| 			ret_val = EOB_ACT_END_OF_FILE;
| 			yyrestart(yyin  );
| 			}
| 
| 		else
| 			{
| 			ret_val = EOB_ACT_LAST_MATCH;
| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
| 				YY_BUFFER_EOF_PENDING;
| 			}
| 		}
| 
| 	else
| 		ret_val = EOB_ACT_CONTINUE_SCAN;
| 
| 	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
| 		/* Extend the array by 50%, plus the number we really need. */
| 		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
| 		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
| 		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
| 			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
| 	}
| 
| 	(yy_n_chars) += number_to_move;
| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
| 
| 	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
| 
| 	return ret_val;
| }
| 
| /* yy_get_previous_state - get the state just before the EOB char was reached */
| 
|     static yy_state_type yy_get_previous_state (void)
| {
| 	register yy_state_type yy_current_state;
| 	register char *yy_cp;
|     
| 	yy_current_state = (yy_start);
| 
| 	(yy_state_ptr) = (yy_state_buf);
| 	*(yy_state_ptr)++ = yy_current_state;
| 
| 	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
| 		{
| 		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
| 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 			{
| 			yy_current_state = (int) yy_def[yy_current_state];
| 			if ( yy_current_state >= 13 )
| 				yy_c = yy_meta[(unsigned int) yy_c];
| 			}
| 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 		*(yy_state_ptr)++ = yy_current_state;
| 		}
| 
| 	return yy_current_state;
| }
| 
| /* yy_try_NUL_trans - try to make a transition on the NUL character
|  *
|  * synopsis
|  *	next_state = yy_try_NUL_trans( current_state );
|  */
|     static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
| {
| 	register int yy_is_jam;
|     
| 	register YY_CHAR yy_c = 1;
| 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 		{
| 		yy_current_state = (int) yy_def[yy_current_state];
| 		if ( yy_current_state >= 13 )
| 			yy_c = yy_meta[(unsigned int) yy_c];
| 		}
| 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 	yy_is_jam = (yy_current_state == 12);
| 	if ( ! yy_is_jam )
| 		*(yy_state_ptr)++ = yy_current_state;
| 
| 		return yy_is_jam ? 0 : yy_current_state;
| }
| 
|     static void yyunput (int c, register char * yy_bp )
| {
| 	register char *yy_cp;
|     
|     yy_cp = (yy_c_buf_p);
| 
| 	/* undo effects of setting up yytext */
| 	*yy_cp = (yy_hold_char);
| 
| 	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
| 		{ /* need to shift things up to make room */
| 		/* +2 for EOB chars. */
| 		register yy_size_t number_to_move = (yy_n_chars) + 2;
| 		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
| 					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
| 		register char *source =
| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
| 
| 		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
| 			*--dest = *--source;
| 
| 		yy_cp += (int) (dest - source);
| 		yy_bp += (int) (dest - source);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
| 
| 		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
| 			YY_FATAL_ERROR( "flex scanner push-back overflow" );
| 		}
| 
| 	*--yy_cp = (char) c;
| 
| 	(yytext_ptr) = yy_bp;
| 	(yy_hold_char) = *yy_cp;
| 	(yy_c_buf_p) = yy_cp;
| }
| 
| #ifndef YY_NO_INPUT
| #ifdef __cplusplus
|     static int yyinput (void)
| #else
|     static int input  (void)
| #endif
| 
| {
| 	int c;
|     
| 	*(yy_c_buf_p) = (yy_hold_char);
| 
| 	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
| 		{
| 		/* yy_c_buf_p now points to the character we want to return.
| 		 * If this occurs *before* the EOB characters, then it's a
| 		 * valid NUL; if not, then we've hit the end of the buffer.
| 		 */
| 		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
| 			/* This was really a NUL. */
| 			*(yy_c_buf_p) = '\0';
| 
| 		else
| 			{ /* need more input */
| 			yy_size_t offset = (yy_c_buf_p) - (yytext_ptr);
| 			++(yy_c_buf_p);
| 
| 			switch ( yy_get_next_buffer(  ) )
| 				{
| 				case EOB_ACT_LAST_MATCH:
| 					/* This happens because yy_g_n_b()
| 					 * sees that we've accumulated a
| 					 * token and flags that we need to
| 					 * try matching the token before
| 					 * proceeding.  But for input(),
| 					 * there's no matching to consider.
| 					 * So convert the EOB_ACT_LAST_MATCH
| 					 * to EOB_ACT_END_OF_FILE.
| 					 */
| 
| 					/* Reset buffer status. */
| 					yyrestart(yyin );
| 
| 					/*FALLTHROUGH*/
| 
| 				case EOB_ACT_END_OF_FILE:
| 					{
| 					if ( yywrap( ) )
| 						return EOF;
| 
| 					if ( ! (yy_did_buffer_switch_on_eof) )
| 						YY_NEW_FILE;
| #ifdef __cplusplus
| 					return yyinput();
| #else
| 					return input();
| #endif
| 					}
| 
| 				case EOB_ACT_CONTINUE_SCAN:
| 					(yy_c_buf_p) = (yytext_ptr) + offset;
| 					break;
| 				}
| 			}
| 		}
| 
| 	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
| 	*(yy_c_buf_p) = '\0';	/* preserve yytext */
| 	(yy_hold_char) = *++(yy_c_buf_p);
| 
| 	return c;
| }
| #endif	/* ifndef YY_NO_INPUT */
| 
| /** Immediately switch to a different input stream.
|  * @param input_file A readable stream.
|  * 
|  * @note This function does not reset the start condition to @c INITIAL .
|  */
|     void yyrestart  (FILE * input_file )
| {
|     
| 	if ( ! YY_CURRENT_BUFFER ){
|         yyensure_buffer_stack ();
| 		YY_CURRENT_BUFFER_LVALUE =
|             yy_create_buffer(yyin,YY_BUF_SIZE );
| 	}
| 
| 	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
| 	yy_load_buffer_state( );
| }
| 
| /** Switch to a different input buffer.
|  * @param new_buffer The new input buffer.
|  * 
|  */
|     void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
| {
|     
| 	/* TODO. We should be able to replace this entire function body
| 	 * with
| 	 *		yypop_buffer_state();
| 	 *		yypush_buffer_state(new_buffer);
|      */
| 	yyensure_buffer_stack ();
| 	if ( YY_CURRENT_BUFFER == new_buffer )
| 		return;
| 
| 	if ( YY_CURRENT_BUFFER )
| 		{
| 		/* Flush out information for old buffer. */
| 		*(yy_c_buf_p) = (yy_hold_char);
| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
| 	yy_load_buffer_state( );
| 
| 	/* We don't actually know whether we did this switch during
| 	 * EOF (yywrap()) processing, but the only time this flag
| 	 * is looked at is after yywrap() is called, so it's safe
| 	 * to go ahead and always set it.
| 	 */
| 	(yy_did_buffer_switch_on_eof) = 1;
| }
| 
| static void yy_load_buffer_state  (void)
| {
|     	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
| 	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
| 	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
| 	(yy_hold_char) = *(yy_c_buf_p);
| }
| 
| /** Allocate and initialize an input buffer state.
|  * @param file A readable stream.
|  * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
|  * 
|  * @return the allocated buffer state.
|  */
|     YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
| {
| 	YY_BUFFER_STATE b;
|     
| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_buf_size = size;
| 
| 	/* yy_ch_buf has to be 2 characters longer than the size given because
| 	 * we need to put in 2 end-of-buffer characters.
| 	 */
| 	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
| 	if ( ! b->yy_ch_buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_is_our_buffer = 1;
| 
| 	yy_init_buffer(b,file );
| 
| 	return b;
| }
| 
| /** Destroy the buffer.
|  * @param b a buffer created with yy_create_buffer()
|  * 
|  */
|     void yy_delete_buffer (YY_BUFFER_STATE  b )
| {
|     
| 	if ( ! b )
| 		return;
| 
| 	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
| 		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
| 
| 	if ( b->yy_is_our_buffer )
| 		yyfree((void *) b->yy_ch_buf  );
| 
| 	yyfree((void *) b  );
| }
| 
| /* Initializes or reinitializes a buffer.
|  * This function is sometimes called more than once on the same buffer,
|  * such as during a yyrestart() or at EOF.
|  */
|     static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
| 
| {
| 	int oerrno = errno;
|     
| 	yy_flush_buffer(b );
| 
| 	b->yy_input_file = file;
| 	b->yy_fill_buffer = 1;
| 
|     /* If b is the current buffer, then yy_init_buffer was _probably_
|      * called from yyrestart() or through yy_get_next_buffer.
|      * In that case, we don't want to reset the lineno or column.
|      */
|     if (b != YY_CURRENT_BUFFER){
|         b->yy_bs_lineno = 1;
|         b->yy_bs_column = 0;
|     }
| 
|         b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
|     
| 	errno = oerrno;
| }
| 
| /** Discard all buffered characters. On the next scan, YY_INPUT will be called.
|  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
|  * 
|  */
|     void yy_flush_buffer (YY_BUFFER_STATE  b )
| {
|     	if ( ! b )
| 		return;
| 
| 	b->yy_n_chars = 0;
| 
| 	/* We always need two end-of-buffer characters.  The first causes
| 	 * a transition to the end-of-buffer state.  The second causes
| 	 * a jam in that state.
| 	 */
| 	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
| 	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b->yy_buf_pos = &b->yy_ch_buf[0];
| 
| 	b->yy_at_bol = 1;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	if ( b == YY_CURRENT_BUFFER )
| 		yy_load_buffer_state( );
| }
| 
| /** Pushes the new state onto the stack. The new state becomes
|  *  the current state. This function will allocate the stack
|  *  if necessary.
|  *  @param new_buffer The new state.
|  *  
|  */
| void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
| {
|     	if (new_buffer == NULL)
| 		return;
| 
| 	yyensure_buffer_stack();
| 
| 	/* This block is copied from yy_switch_to_buffer. */
| 	if ( YY_CURRENT_BUFFER )
| 		{
| 		/* Flush out information for old buffer. */
| 		*(yy_c_buf_p) = (yy_hold_char);
| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	/* Only push if top exists. Otherwise, replace top. */
| 	if (YY_CURRENT_BUFFER)
| 		(yy_buffer_stack_top)++;
| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
| 
| 	/* copied from yy_switch_to_buffer. */
| 	yy_load_buffer_state( );
| 	(yy_did_buffer_switch_on_eof) = 1;
| }
| 
| /** Removes and deletes the top of the stack, if present.
|  *  The next element becomes the new top.
|  *  
|  */
| void yypop_buffer_state (void)
| {
|     	if (!YY_CURRENT_BUFFER)
| 		return;
| 
| 	yy_delete_buffer(YY_CURRENT_BUFFER );
| 	YY_CURRENT_BUFFER_LVALUE = NULL;
| 	if ((yy_buffer_stack_top) > 0)
| 		--(yy_buffer_stack_top);
| 
| 	if (YY_CURRENT_BUFFER) {
| 		yy_load_buffer_state( );
| 		(yy_did_buffer_switch_on_eof) = 1;
| 	}
| }
| 
| /* Allocates the stack if it does not exist.
|  *  Guarantees space for at least one push.
|  */
| static void yyensure_buffer_stack (void)
| {
| 	yy_size_t num_to_alloc;
|     
| 	if (!(yy_buffer_stack)) {
| 
| 		/* First allocation is just for 2 elements, since we don't know if this
| 		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
| 		 * immediate realloc on the next call.
|          */
| 		num_to_alloc = 1;
| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
| 								(num_to_alloc * sizeof(struct yy_buffer_state*)
| 								);
| 		if ( ! (yy_buffer_stack) )
| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
| 								  
| 		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
| 				
| 		(yy_buffer_stack_max) = num_to_alloc;
| 		(yy_buffer_stack_top) = 0;
| 		return;
| 	}
| 
| 	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
| 
| 		/* Increase the buffer to prepare for a possible push. */
| 		int grow_size = 8 /* arbitrary grow size */;
| 
| 		num_to_alloc = (yy_buffer_stack_max) + grow_size;
| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
| 								((yy_buffer_stack),
| 								num_to_alloc * sizeof(struct yy_buffer_state*)
| 								);
| 		if ( ! (yy_buffer_stack) )
| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
| 
| 		/* zero only the new slots.*/
| 		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
| 		(yy_buffer_stack_max) = num_to_alloc;
| 	}
| }
| 
| /** Setup the input buffer state to scan directly from a user-specified character buffer.
|  * @param base the character buffer
|  * @param size the size in bytes of the character buffer
|  * 
|  * @return the newly allocated buffer state object. 
|  */
| YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
| {
| 	YY_BUFFER_STATE b;
|     
| 	if ( size < 2 ||
| 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
| 	     base[size-1] != YY_END_OF_BUFFER_CHAR )
| 		/* They forgot to leave room for the EOB's. */
| 		return 0;
| 
| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
| 
| 	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
| 	b->yy_buf_pos = b->yy_ch_buf = base;
| 	b->yy_is_our_buffer = 0;
| 	b->yy_input_file = 0;
| 	b->yy_n_chars = b->yy_buf_size;
| 	b->yy_is_interactive = 0;
| 	b->yy_at_bol = 1;
| 	b->yy_fill_buffer = 0;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	yy_switch_to_buffer(b  );
| 
| 	return b;
| }
| 
| /** Setup the input buffer state to scan a string. The next call to yylex() will
|  * scan from a @e copy of @a str.
|  * @param yystr a NUL-terminated string to scan
|  * 
|  * @return the newly allocated buffer state object.
|  * @note If you want to scan bytes that may contain NUL values, then use
|  *       yy_scan_bytes() instead.
|  */
| YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
| {
|     
| 	return yy_scan_bytes(yystr,strlen(yystr) );
| }
| 
| /** Setup the input buffer state to scan the given bytes. The next call to yylex() will
|  * scan from a @e copy of @a bytes.
|  * @param yybytes the byte buffer to scan
|  * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
|  * 
|  * @return the newly allocated buffer state object.
|  */
| YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len )
| {
| 	YY_BUFFER_STATE b;
| 	char *buf;
| 	yy_size_t n;
| 	yy_size_t i;
|     
| 	/* Get memory for full buffer, including space for trailing EOB's. */
| 	n = _yybytes_len + 2;
| 	buf = (char *) yyalloc(n  );
| 	if ( ! buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
| 
| 	for ( i = 0; i < _yybytes_len; ++i )
| 		buf[i] = yybytes[i];
| 
| 	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b = yy_scan_buffer(buf,n );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
| 
| 	/* It's okay to grow etc. this buffer, and we should throw it
| 	 * away when we're done.
| 	 */
| 	b->yy_is_our_buffer = 1;
| 
| 	return b;
| }
| 
| #ifndef YY_EXIT_FAILURE
| #define YY_EXIT_FAILURE 2
| #endif
| 
| static void yy_fatal_error (yyconst char* msg )
| {
|     	(void) fprintf( stderr, "%s\n", msg );
| 	exit( YY_EXIT_FAILURE );
| }
| 
| /* Redefine yyless() so it works in section 3 code. */
| 
| #undef yyless
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
|         int yyless_macro_arg = (n); \
|         YY_LESS_LINENO(yyless_macro_arg);\
| 		yytext[yyleng] = (yy_hold_char); \
| 		(yy_c_buf_p) = yytext + yyless_macro_arg; \
| 		(yy_hold_char) = *(yy_c_buf_p); \
| 		*(yy_c_buf_p) = '\0'; \
| 		yyleng = yyless_macro_arg; \
| 		} \
| 	while ( 0 )
| 
| /* Accessor  methods (get/set functions) to struct members. */
| 
| /** Get the current line number.
|  * 
|  */
| int yyget_lineno  (void)
| {
|         
|     return yylineno;
| }
| 
| /** Get the input stream.
|  * 
|  */
| FILE *yyget_in  (void)
| {
|         return yyin;
| }
| 
| /** Get the output stream.
|  * 
|  */
| FILE *yyget_out  (void)
| {
|         return yyout;
| }
| 
| /** Get the length of the current token.
|  * 
|  */
| yy_size_t yyget_leng  (void)
| {
|         return yyleng;
| }
| 
| /** Get the current token.
|  * 
|  */
| 
| char *yyget_text  (void)
| {
|         return yytext;
| }
| 
| /** Set the current line number.
|  * @param line_number
|  * 
|  */
| void yyset_lineno (int  line_number )
| {
|     
|     yylineno = line_number;
| }
| 
| /** Set the input stream. This does not discard the current
|  * input buffer.
|  * @param in_str A readable stream.
|  * 
|  * @see yy_switch_to_buffer
|  */
| void yyset_in (FILE *  in_str )
| {
|         yyin = in_str ;
| }
| 
| void yyset_out (FILE *  out_str )
| {
|         yyout = out_str ;
| }
| 
| int yyget_debug  (void)
| {
|         return yy_flex_debug;
| }
| 
| void yyset_debug (int  bdebug )
| {
|         yy_flex_debug = bdebug ;
| }
| 
| static int yy_init_globals (void)
| {
|         /* Initialization is the same as for the non-reentrant scanner.
|      * This function is called from yylex_destroy(), so don't allocate here.
|      */
| 
|     (yy_buffer_stack) = 0;
|     (yy_buffer_stack_top) = 0;
|     (yy_buffer_stack_max) = 0;
|     (yy_c_buf_p) = (char *) 0;
|     (yy_init) = 0;
|     (yy_start) = 0;
| 
|     (yy_state_buf) = 0;
|     (yy_state_ptr) = 0;
|     (yy_full_match) = 0;
|     (yy_lp) = 0;
| 
| /* Defined in main.c */
| #ifdef YY_STDINIT
|     yyin = stdin;
|     yyout = stdout;
| #else
|     yyin = (FILE *) 0;
|     yyout = (FILE *) 0;
| #endif
| 
|     /* For future reference: Set errno on error, since we are called by
|      * yylex_init()
|      */
|     return 0;
| }
| 
| /* yylex_destroy is for both reentrant and non-reentrant scanners. */
| int yylex_destroy  (void)
| {
|     
|     /* Pop the buffer stack, destroying each element. */
| 	while(YY_CURRENT_BUFFER){
| 		yy_delete_buffer(YY_CURRENT_BUFFER  );
| 		YY_CURRENT_BUFFER_LVALUE = NULL;
| 		yypop_buffer_state();
| 	}
| 
| 	/* Destroy the stack itself. */
| 	yyfree((yy_buffer_stack) );
| 	(yy_buffer_stack) = NULL;
| 
|     yyfree ( (yy_state_buf) );
|     (yy_state_buf)  = NULL;
| 
|     /* Reset the globals. This is important in a non-reentrant scanner so the next time
|      * yylex() is called, initialization will occur. */
|     yy_init_globals( );
| 
|     return 0;
| }
| 
| /*
|  * Internal utility routines.
|  */
| 
| #ifndef yytext_ptr
| static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
| {
| 	register int i;
| 	for ( i = 0; i < n; ++i )
| 		s1[i] = s2[i];
| }
| #endif
| 
| #ifdef YY_NEED_STRLEN
| static int yy_flex_strlen (yyconst char * s )
| {
| 	register int n;
| 	for ( n = 0; s[n]; ++n )
| 		;
| 
| 	return n;
| }
| #endif
| 
| void *yyalloc (yy_size_t  size )
| {
| 	return (void *) malloc( size );
| }
| 
| void *yyrealloc  (void * ptr, yy_size_t  size )
| {
| 	/* The cast to (char *) in the following accommodates both
| 	 * implementations that use char* generic pointers, and those
| 	 * that use void* generic pointers.  It works with the latter
| 	 * because both ANSI C and C++ allow castless assignment from
| 	 * any pointer type to void*, and deal with argument conversions
| 	 * as though doing an assignment.
| 	 */
| 	return (void *) realloc( (char *) ptr, size );
| }
| 
| void yyfree (void * ptr )
| {
| 	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
| }
| 
| #define YYTABLES_NAME "yytables"
| 
| #line 9 "conftest.l"
| 
| 
| #ifdef YYTEXT_POINTER
| extern char *yytext;
| #endif
| int
| main (void)
| {
|   return ! yylex () + ! yywrap ();
| }
configure:12187: result: none needed
configure:12193: checking whether yytext is a pointer
configure:12209: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c   >&5
/tmp/cca9K5vh.o:conftest.c:function yylex: error: undefined reference to 'yywrap'
/tmp/cca9K5vh.o:conftest.c:function input: error: undefined reference to 'yywrap'
/tmp/cca9K5vh.o:conftest.c:function main: error: undefined reference to 'yywrap'
collect2: error: ld returned 1 exit status
configure:12209: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "binutils"
| #define PACKAGE_TARNAME "binutils"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "binutils 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "binutils"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define DEFAULT_AR_DETERMINISTIC 0
| #define DEFAULT_STRINGS_ALL 1
| /* end confdefs.h.  */
| #define YYTEXT_POINTER 1
| 
| #line 3 "lex.yy.c"
| 
| #define  YY_INT_ALIGNED short int
| 
| /* A lexical scanner generated by flex */
| 
| #define FLEX_SCANNER
| #define YY_FLEX_MAJOR_VERSION 2
| #define YY_FLEX_MINOR_VERSION 5
| #define YY_FLEX_SUBMINOR_VERSION 39
| #if YY_FLEX_SUBMINOR_VERSION > 0
| #define FLEX_BETA
| #endif
| 
| /* First, we deal with  platform-specific or compiler-specific issues. */
| 
| /* begin standard C headers. */
| #include <stdio.h>
| #include <string.h>
| #include <errno.h>
| #include <stdlib.h>
| 
| /* end standard C headers. */
| 
| /* flex integer type definitions */
| 
| #ifndef FLEXINT_H
| #define FLEXINT_H
| 
| /* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
| 
| #if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
| 
| /* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
|  * if you want the limit (max/min) macros for int types. 
|  */
| #ifndef __STDC_LIMIT_MACROS
| #define __STDC_LIMIT_MACROS 1
| #endif
| 
| #include <inttypes.h>
| typedef int8_t flex_int8_t;
| typedef uint8_t flex_uint8_t;
| typedef int16_t flex_int16_t;
| typedef uint16_t flex_uint16_t;
| typedef int32_t flex_int32_t;
| typedef uint32_t flex_uint32_t;
| #else
| typedef signed char flex_int8_t;
| typedef short int flex_int16_t;
| typedef int flex_int32_t;
| typedef unsigned char flex_uint8_t; 
| typedef unsigned short int flex_uint16_t;
| typedef unsigned int flex_uint32_t;
| 
| /* Limits of integral types. */
| #ifndef INT8_MIN
| #define INT8_MIN               (-128)
| #endif
| #ifndef INT16_MIN
| #define INT16_MIN              (-32767-1)
| #endif
| #ifndef INT32_MIN
| #define INT32_MIN              (-2147483647-1)
| #endif
| #ifndef INT8_MAX
| #define INT8_MAX               (127)
| #endif
| #ifndef INT16_MAX
| #define INT16_MAX              (32767)
| #endif
| #ifndef INT32_MAX
| #define INT32_MAX              (2147483647)
| #endif
| #ifndef UINT8_MAX
| #define UINT8_MAX              (255U)
| #endif
| #ifndef UINT16_MAX
| #define UINT16_MAX             (65535U)
| #endif
| #ifndef UINT32_MAX
| #define UINT32_MAX             (4294967295U)
| #endif
| 
| #endif /* ! C99 */
| 
| #endif /* ! FLEXINT_H */
| 
| #ifdef __cplusplus
| 
| /* The "const" storage-class-modifier is valid. */
| #define YY_USE_CONST
| 
| #else	/* ! __cplusplus */
| 
| /* C99 requires __STDC__ to be defined as 1. */
| #if defined (__STDC__)
| 
| #define YY_USE_CONST
| 
| #endif	/* defined (__STDC__) */
| #endif	/* ! __cplusplus */
| 
| #ifdef YY_USE_CONST
| #define yyconst const
| #else
| #define yyconst
| #endif
| 
| /* Returned upon end-of-file. */
| #define YY_NULL 0
| 
| /* Promotes a possibly negative, possibly signed char to an unsigned
|  * integer for use as an array index.  If the signed char is negative,
|  * we want to instead treat it as an 8-bit unsigned char, hence the
|  * double cast.
|  */
| #define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
| 
| /* Enter a start condition.  This macro really ought to take a parameter,
|  * but we do it the disgusting crufty way forced on us by the ()-less
|  * definition of BEGIN.
|  */
| #define BEGIN (yy_start) = 1 + 2 *
| 
| /* Translate the current start state into a value that can be later handed
|  * to BEGIN to return to the state.  The YYSTATE alias is for lex
|  * compatibility.
|  */
| #define YY_START (((yy_start) - 1) / 2)
| #define YYSTATE YY_START
| 
| /* Action number for EOF rule of a given start state. */
| #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
| 
| /* Special action meaning "start processing a new file". */
| #define YY_NEW_FILE yyrestart(yyin  )
| 
| #define YY_END_OF_BUFFER_CHAR 0
| 
| /* Size of default input buffer. */
| #ifndef YY_BUF_SIZE
| #define YY_BUF_SIZE 16384
| #endif
| 
| /* The state buf must be large enough to hold one state per character in the main buffer.
|  */
| #define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
| 
| #ifndef YY_TYPEDEF_YY_BUFFER_STATE
| #define YY_TYPEDEF_YY_BUFFER_STATE
| typedef struct yy_buffer_state *YY_BUFFER_STATE;
| #endif
| 
| #ifndef YY_TYPEDEF_YY_SIZE_T
| #define YY_TYPEDEF_YY_SIZE_T
| typedef size_t yy_size_t;
| #endif
| 
| extern yy_size_t yyleng;
| 
| extern FILE *yyin, *yyout;
| 
| #define EOB_ACT_CONTINUE_SCAN 0
| #define EOB_ACT_END_OF_FILE 1
| #define EOB_ACT_LAST_MATCH 2
| 
|     #define YY_LESS_LINENO(n)
|     #define YY_LINENO_REWIND_TO(ptr)
|     
| /* Return all but the first "n" matched characters back to the input stream. */
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
|         int yyless_macro_arg = (n); \
|         YY_LESS_LINENO(yyless_macro_arg);\
| 		*yy_cp = (yy_hold_char); \
| 		YY_RESTORE_YY_MORE_OFFSET \
| 		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
| 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
| 		} \
| 	while ( 0 )
| 
| #define unput(c) yyunput( c, (yytext_ptr)  )
| 
| #ifndef YY_STRUCT_YY_BUFFER_STATE
| #define YY_STRUCT_YY_BUFFER_STATE
| struct yy_buffer_state
| 	{
| 	FILE *yy_input_file;
| 
| 	char *yy_ch_buf;		/* input buffer */
| 	char *yy_buf_pos;		/* current position in input buffer */
| 
| 	/* Size of input buffer in bytes, not including room for EOB
| 	 * characters.
| 	 */
| 	yy_size_t yy_buf_size;
| 
| 	/* Number of characters read into yy_ch_buf, not including EOB
| 	 * characters.
| 	 */
| 	yy_size_t yy_n_chars;
| 
| 	/* Whether we "own" the buffer - i.e., we know we created it,
| 	 * and can realloc() it to grow it, and should free() it to
| 	 * delete it.
| 	 */
| 	int yy_is_our_buffer;
| 
| 	/* Whether this is an "interactive" input source; if so, and
| 	 * if we're using stdio for input, then we want to use getc()
| 	 * instead of fread(), to make sure we stop fetching input after
| 	 * each newline.
| 	 */
| 	int yy_is_interactive;
| 
| 	/* Whether we're considered to be at the beginning of a line.
| 	 * If so, '^' rules will be active on the next match, otherwise
| 	 * not.
| 	 */
| 	int yy_at_bol;
| 
|     int yy_bs_lineno; /**< The line count. */
|     int yy_bs_column; /**< The column count. */
|     
| 	/* Whether to try to fill the input buffer when we reach the
| 	 * end of it.
| 	 */
| 	int yy_fill_buffer;
| 
| 	int yy_buffer_status;
| 
| #define YY_BUFFER_NEW 0
| #define YY_BUFFER_NORMAL 1
| 	/* When an EOF's been seen but there's still some text to process
| 	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
| 	 * shouldn't try reading from the input source any more.  We might
| 	 * still have a bunch of tokens to match, though, because of
| 	 * possible backing-up.
| 	 *
| 	 * When we actually see the EOF, we change the status to "new"
| 	 * (via yyrestart()), so that the user can continue scanning by
| 	 * just pointing yyin at a new input file.
| 	 */
| #define YY_BUFFER_EOF_PENDING 2
| 
| 	};
| #endif /* !YY_STRUCT_YY_BUFFER_STATE */
| 
| /* Stack of input buffers. */
| static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
| static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
| static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
| 
| /* We provide macros for accessing buffer states in case in the
|  * future we want to put the buffer states in a more general
|  * "scanner state".
|  *
|  * Returns the top of the stack, or NULL.
|  */
| #define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
|                           ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
|                           : NULL)
| 
| /* Same as previous macro, but useful when we know that the buffer stack is not
|  * NULL or when we need an lvalue. For internal use only.
|  */
| #define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
| 
| /* yy_hold_char holds the character lost when yytext is formed. */
| static char yy_hold_char;
| static yy_size_t yy_n_chars;		/* number of characters read into yy_ch_buf */
| yy_size_t yyleng;
| 
| /* Points to current character in buffer. */
| static char *yy_c_buf_p = (char *) 0;
| static int yy_init = 0;		/* whether we need to initialize */
| static int yy_start = 0;	/* start state number */
| 
| /* Flag which is used to allow yywrap()'s to do buffer switches
|  * instead of setting up a fresh yyin.  A bit of a hack ...
|  */
| static int yy_did_buffer_switch_on_eof;
| 
| void yyrestart (FILE *input_file  );
| void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
| YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
| void yy_delete_buffer (YY_BUFFER_STATE b  );
| void yy_flush_buffer (YY_BUFFER_STATE b  );
| void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
| void yypop_buffer_state (void );
| 
| static void yyensure_buffer_stack (void );
| static void yy_load_buffer_state (void );
| static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
| 
| #define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
| 
| YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
| YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
| YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,yy_size_t len  );
| 
| void *yyalloc (yy_size_t  );
| void *yyrealloc (void *,yy_size_t  );
| void yyfree (void *  );
| 
| #define yy_new_buffer yy_create_buffer
| 
| #define yy_set_interactive(is_interactive) \
| 	{ \
| 	if ( ! YY_CURRENT_BUFFER ){ \
|         yyensure_buffer_stack (); \
| 		YY_CURRENT_BUFFER_LVALUE =    \
|             yy_create_buffer(yyin,YY_BUF_SIZE ); \
| 	} \
| 	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
| 	}
| 
| #define yy_set_bol(at_bol) \
| 	{ \
| 	if ( ! YY_CURRENT_BUFFER ){\
|         yyensure_buffer_stack (); \
| 		YY_CURRENT_BUFFER_LVALUE =    \
|             yy_create_buffer(yyin,YY_BUF_SIZE ); \
| 	} \
| 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
| 	}
| 
| #define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
| 
| /* Begin user sect3 */
| 
| typedef unsigned char YY_CHAR;
| 
| FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
| 
| typedef int yy_state_type;
| 
| extern int yylineno;
| 
| int yylineno = 1;
| 
| extern char *yytext;
| #define yytext_ptr yytext
| 
| static yy_state_type yy_get_previous_state (void );
| static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
| static int yy_get_next_buffer (void );
| static void yy_fatal_error (yyconst char msg[]  );
| 
| /* Done after the current pattern has been matched and before the
|  * corresponding action - sets up yytext.
|  */
| #define YY_DO_BEFORE_ACTION \
| 	(yytext_ptr) = yy_bp; \
| 	(yytext_ptr) -= (yy_more_len); \
| 	yyleng = (size_t) (yy_cp - (yytext_ptr)); \
| 	(yy_hold_char) = *yy_cp; \
| 	*yy_cp = '\0'; \
| 	(yy_c_buf_p) = yy_cp;
| 
| #define YY_NUM_RULES 8
| #define YY_END_OF_BUFFER 9
| /* This struct is not used in this scanner,
|    but its presence is necessary. */
| struct yy_trans_info
| 	{
| 	flex_int32_t yy_verify;
| 	flex_int32_t yy_nxt;
| 	};
| static yyconst flex_int16_t yy_acclist[23] =
|     {   0,
|         9,    7,    8,    8,    1,    7,    8,    2,    7,    8,
|         3,    7,    8,    4,    7,    8,    5,    7,    8,    6,
|         7,    8
|     } ;
| 
| static yyconst flex_int16_t yy_accept[14] =
|     {   0,
|         1,    1,    1,    2,    4,    5,    8,   11,   14,   17,
|        20,   23,   23
|     } ;
| 
| static yyconst flex_int32_t yy_ec[256] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    3,    4,    5,    6,
| 
|         7,    8,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
| 
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
|         1,    1,    1,    1,    1
|     } ;
| 
| static yyconst flex_int32_t yy_meta[9] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1
|     } ;
| 
| static yyconst flex_int16_t yy_base[13] =
|     {   0,
|         0,    0,    9,   10,   10,   10,   10,   10,   10,   10,
|        10,   10
|     } ;
| 
| static yyconst flex_int16_t yy_def[13] =
|     {   0,
|        12,    1,   12,   12,   12,   12,   12,   12,   12,   12,
|        12,    0
|     } ;
| 
| static yyconst flex_int16_t yy_nxt[19] =
|     {   0,
|         4,    5,    6,    7,    8,    9,   10,   11,   12,    3,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| static yyconst flex_int16_t yy_chk[19] =
|     {   0,
|         1,    1,    1,    1,    1,    1,    1,    1,    3,   12,
|        12,   12,   12,   12,   12,   12,   12,   12
|     } ;
| 
| extern int yy_flex_debug;
| int yy_flex_debug = 0;
| 
| static yy_state_type *yy_state_buf=0, *yy_state_ptr=0;
| static char *yy_full_match;
| static int yy_lp;
| #define REJECT \
| { \
| *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */ \
| yy_cp = (yy_full_match); /* restore poss. backed-over text */ \
| ++(yy_lp); \
| goto find_rule; \
| }
| 
| static int yy_more_flag = 0;
| static int yy_more_len = 0;
| #define yymore() ((yy_more_flag) = 1)
| #define YY_MORE_ADJ (yy_more_len)
| #define YY_RESTORE_YY_MORE_OFFSET
| char *yytext;
| #line 1 "conftest.l"
| #line 470 "lex.yy.c"
| 
| #define INITIAL 0
| 
| #ifndef YY_NO_UNISTD_H
| /* Special case for "unistd.h", since it is non-ANSI. We include it way
|  * down here because we want the user's section 1 to have been scanned first.
|  * The user has a chance to override it with an option.
|  */
| #include <unistd.h>
| #endif
| 
| #ifndef YY_EXTRA_TYPE
| #define YY_EXTRA_TYPE void *
| #endif
| 
| static int yy_init_globals (void );
| 
| /* Accessor methods to globals.
|    These are made visible to non-reentrant scanners for convenience. */
| 
| int yylex_destroy (void );
| 
| int yyget_debug (void );
| 
| void yyset_debug (int debug_flag  );
| 
| YY_EXTRA_TYPE yyget_extra (void );
| 
| void yyset_extra (YY_EXTRA_TYPE user_defined  );
| 
| FILE *yyget_in (void );
| 
| void yyset_in  (FILE * in_str  );
| 
| FILE *yyget_out (void );
| 
| void yyset_out  (FILE * out_str  );
| 
| yy_size_t yyget_leng (void );
| 
| char *yyget_text (void );
| 
| int yyget_lineno (void );
| 
| void yyset_lineno (int line_number  );
| 
| /* Macros after this point can all be overridden by user definitions in
|  * section 1.
|  */
| 
| #ifndef YY_SKIP_YYWRAP
| #ifdef __cplusplus
| extern "C" int yywrap (void );
| #else
| extern int yywrap (void );
| #endif
| #endif
| 
|     static void yyunput (int c,char *buf_ptr  );
|     
| #ifndef yytext_ptr
| static void yy_flex_strncpy (char *,yyconst char *,int );
| #endif
| 
| #ifdef YY_NEED_STRLEN
| static int yy_flex_strlen (yyconst char * );
| #endif
| 
| #ifndef YY_NO_INPUT
| 
| #ifdef __cplusplus
| static int yyinput (void );
| #else
| static int input (void );
| #endif
| 
| #endif
| 
| /* Amount of stuff to slurp up with each read. */
| #ifndef YY_READ_BUF_SIZE
| #define YY_READ_BUF_SIZE 8192
| #endif
| 
| /* Copy whatever the last rule matched to the standard output. */
| #ifndef ECHO
| /* This used to be an fputs(), but since the string might contain NUL's,
|  * we now use fwrite().
|  */
| #define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
| #endif
| 
| /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
|  * is returned in "result".
|  */
| #ifndef YY_INPUT
| #define YY_INPUT(buf,result,max_size) \
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
| 		{ \
| 		int c = '*'; \
| 		size_t n; \
| 		for ( n = 0; n < max_size && \
| 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
| 			buf[n] = (char) c; \
| 		if ( c == '\n' ) \
| 			buf[n++] = (char) c; \
| 		if ( c == EOF && ferror( yyin ) ) \
| 			YY_FATAL_ERROR( "input in flex scanner failed" ); \
| 		result = n; \
| 		} \
| 	else \
| 		{ \
| 		errno=0; \
| 		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
| 			{ \
| 			if( errno != EINTR) \
| 				{ \
| 				YY_FATAL_ERROR( "input in flex scanner failed" ); \
| 				break; \
| 				} \
| 			errno=0; \
| 			clearerr(yyin); \
| 			} \
| 		}\
| \
| 
| #endif
| 
| /* No semi-colon after return; correct usage is to write "yyterminate();" -
|  * we don't want an extra ';' after the "return" because that will cause
|  * some compilers to complain about unreachable statements.
|  */
| #ifndef yyterminate
| #define yyterminate() return YY_NULL
| #endif
| 
| /* Number of entries by which start-condition stack grows. */
| #ifndef YY_START_STACK_INCR
| #define YY_START_STACK_INCR 25
| #endif
| 
| /* Report a fatal error. */
| #ifndef YY_FATAL_ERROR
| #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
| #endif
| 
| /* end tables serialization structures and prototypes */
| 
| /* Default declaration of generated scanner - a define so the user can
|  * easily add parameters.
|  */
| #ifndef YY_DECL
| #define YY_DECL_IS_OURS 1
| 
| extern int yylex (void);
| 
| #define YY_DECL int yylex (void)
| #endif /* !YY_DECL */
| 
| /* Code executed at the beginning of each rule, after yytext and yyleng
|  * have been set up.
|  */
| #ifndef YY_USER_ACTION
| #define YY_USER_ACTION
| #endif
| 
| /* Code executed at the end of each rule. */
| #ifndef YY_BREAK
| #define YY_BREAK break;
| #endif
| 
| #define YY_RULE_SETUP \
| 	YY_USER_ACTION
| 
| /** The main scanner function which does all the work.
|  */
| YY_DECL
| {
| 	register yy_state_type yy_current_state;
| 	register char *yy_cp, *yy_bp;
| 	register int yy_act;
|     
| 	if ( !(yy_init) )
| 		{
| 		(yy_init) = 1;
| 
| #ifdef YY_USER_INIT
| 		YY_USER_INIT;
| #endif
| 
|         /* Create the reject buffer large enough to save one state per allowed character. */
|         if ( ! (yy_state_buf) )
|             (yy_state_buf) = (yy_state_type *)yyalloc(YY_STATE_BUF_SIZE  );
|             if ( ! (yy_state_buf) )
|                 YY_FATAL_ERROR( "out of dynamic memory in yylex()" );
| 
| 		if ( ! (yy_start) )
| 			(yy_start) = 1;	/* first start state */
| 
| 		if ( ! yyin )
| 			yyin = stdin;
| 
| 		if ( ! yyout )
| 			yyout = stdout;
| 
| 		if ( ! YY_CURRENT_BUFFER ) {
| 			yyensure_buffer_stack ();
| 			YY_CURRENT_BUFFER_LVALUE =
| 				yy_create_buffer(yyin,YY_BUF_SIZE );
| 		}
| 
| 		yy_load_buffer_state( );
| 		}
| 
| 	{
| #line 1 "conftest.l"
| 
| #line 687 "lex.yy.c"
| 
| 	while ( 1 )		/* loops until end-of-file is reached */
| 		{
| 		(yy_more_len) = 0;
| 		if ( (yy_more_flag) )
| 			{
| 			(yy_more_len) = (yy_c_buf_p) - (yytext_ptr);
| 			(yy_more_flag) = 0;
| 			}
| 		yy_cp = (yy_c_buf_p);
| 
| 		/* Support of yytext. */
| 		*yy_cp = (yy_hold_char);
| 
| 		/* yy_bp points to the position in yy_ch_buf of the start of
| 		 * the current run.
| 		 */
| 		yy_bp = yy_cp;
| 
| 		yy_current_state = (yy_start);
| 
| 		(yy_state_ptr) = (yy_state_buf);
| 		*(yy_state_ptr)++ = yy_current_state;
| 
| yy_match:
| 		do
| 			{
| 			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
| 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 				{
| 				yy_current_state = (int) yy_def[yy_current_state];
| 				if ( yy_current_state >= 13 )
| 					yy_c = yy_meta[(unsigned int) yy_c];
| 				}
| 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 			*(yy_state_ptr)++ = yy_current_state;
| 			++yy_cp;
| 			}
| 		while ( yy_base[yy_current_state] != 10 );
| 
| yy_find_action:
| 		yy_current_state = *--(yy_state_ptr);
| 		(yy_lp) = yy_accept[yy_current_state];
| find_rule: /* we branch to this label when backing up */
| 		for ( ; ; ) /* until we find what rule we matched */
| 			{
| 			if ( (yy_lp) && (yy_lp) < yy_accept[yy_current_state + 1] )
| 				{
| 				yy_act = yy_acclist[(yy_lp)];
| 					{
| 					(yy_full_match) = yy_cp;
| 					break;
| 					}
| 				}
| 			--yy_cp;
| 			yy_current_state = *--(yy_state_ptr);
| 			(yy_lp) = yy_accept[yy_current_state];
| 			}
| 
| 		YY_DO_BEFORE_ACTION;
| 
| do_action:	/* This label is used only to access EOF actions. */
| 
| 		switch ( yy_act )
| 	{ /* beginning of action switch */
| case 1:
| YY_RULE_SETUP
| #line 2 "conftest.l"
| { ECHO; }
| 	YY_BREAK
| case 2:
| YY_RULE_SETUP
| #line 3 "conftest.l"
| { REJECT; }
| 	YY_BREAK
| case 3:
| YY_RULE_SETUP
| #line 4 "conftest.l"
| { yymore (); }
| 	YY_BREAK
| case 4:
| YY_RULE_SETUP
| #line 5 "conftest.l"
| { yyless (1); }
| 	YY_BREAK
| case 5:
| YY_RULE_SETUP
| #line 6 "conftest.l"
| { yyless (input () != 0); }
| 	YY_BREAK
| case 6:
| YY_RULE_SETUP
| #line 7 "conftest.l"
| { unput (yytext[0]); }
| 	YY_BREAK
| case 7:
| YY_RULE_SETUP
| #line 8 "conftest.l"
| { BEGIN INITIAL; }
| 	YY_BREAK
| case 8:
| YY_RULE_SETUP
| #line 9 "conftest.l"
| ECHO;
| 	YY_BREAK
| #line 793 "lex.yy.c"
| 			case YY_STATE_EOF(INITIAL):
| 				yyterminate();
| 
| 	case YY_END_OF_BUFFER:
| 		{
| 		/* Amount of text matched not including the EOB char. */
| 		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
| 
| 		/* Undo the effects of YY_DO_BEFORE_ACTION. */
| 		*yy_cp = (yy_hold_char);
| 		YY_RESTORE_YY_MORE_OFFSET
| 
| 		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
| 			{
| 			/* We're scanning a new file or input source.  It's
| 			 * possible that this happened because the user
| 			 * just pointed yyin at a new source and called
| 			 * yylex().  If so, then we have to assure
| 			 * consistency between YY_CURRENT_BUFFER and our
| 			 * globals.  Here is the right place to do so, because
| 			 * this is the first action (other than possibly a
| 			 * back-up) that will match for the new input source.
| 			 */
| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
| 			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
| 			}
| 
| 		/* Note that here we test for yy_c_buf_p "<=" to the position
| 		 * of the first EOB in the buffer, since yy_c_buf_p will
| 		 * already have been incremented past the NUL character
| 		 * (since all states make transitions on EOB to the
| 		 * end-of-buffer state).  Contrast this with the test
| 		 * in input().
| 		 */
| 		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
| 			{ /* This was really a NUL. */
| 			yy_state_type yy_next_state;
| 
| 			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
| 
| 			yy_current_state = yy_get_previous_state(  );
| 
| 			/* Okay, we're now positioned to make the NUL
| 			 * transition.  We couldn't have
| 			 * yy_get_previous_state() go ahead and do it
| 			 * for us because it doesn't know how to deal
| 			 * with the possibility of jamming (and we don't
| 			 * want to build jamming into it because then it
| 			 * will run more slowly).
| 			 */
| 
| 			yy_next_state = yy_try_NUL_trans( yy_current_state );
| 
| 			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 
| 			if ( yy_next_state )
| 				{
| 				/* Consume the NUL. */
| 				yy_cp = ++(yy_c_buf_p);
| 				yy_current_state = yy_next_state;
| 				goto yy_match;
| 				}
| 
| 			else
| 				{
| 				yy_cp = (yy_c_buf_p);
| 				goto yy_find_action;
| 				}
| 			}
| 
| 		else switch ( yy_get_next_buffer(  ) )
| 			{
| 			case EOB_ACT_END_OF_FILE:
| 				{
| 				(yy_did_buffer_switch_on_eof) = 0;
| 
| 				if ( yywrap( ) )
| 					{
| 					/* Note: because we've taken care in
| 					 * yy_get_next_buffer() to have set up
| 					 * yytext, we can now set up
| 					 * yy_c_buf_p so that if some total
| 					 * hoser (like flex itself) wants to
| 					 * call the scanner after we return the
| 					 * YY_NULL, it'll still work - another
| 					 * YY_NULL will get returned.
| 					 */
| 					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
| 
| 					yy_act = YY_STATE_EOF(YY_START);
| 					goto do_action;
| 					}
| 
| 				else
| 					{
| 					if ( ! (yy_did_buffer_switch_on_eof) )
| 						YY_NEW_FILE;
| 					}
| 				break;
| 				}
| 
| 			case EOB_ACT_CONTINUE_SCAN:
| 				(yy_c_buf_p) =
| 					(yytext_ptr) + yy_amount_of_matched_text;
| 
| 				yy_current_state = yy_get_previous_state(  );
| 
| 				yy_cp = (yy_c_buf_p);
| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 				goto yy_match;
| 
| 			case EOB_ACT_LAST_MATCH:
| 				(yy_c_buf_p) =
| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
| 
| 				yy_current_state = yy_get_previous_state(  );
| 
| 				yy_cp = (yy_c_buf_p);
| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
| 				goto yy_find_action;
| 			}
| 		break;
| 		}
| 
| 	default:
| 		YY_FATAL_ERROR(
| 			"fatal flex scanner internal error--no action found" );
| 	} /* end of action switch */
| 		} /* end of scanning one token */
| 	} /* end of user's declarations */
| } /* end of yylex */
| 
| /* yy_get_next_buffer - try to read in a new buffer
|  *
|  * Returns a code representing an action:
|  *	EOB_ACT_LAST_MATCH -
|  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
|  *	EOB_ACT_END_OF_FILE - end of file
|  */
| static int yy_get_next_buffer (void)
| {
|     	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
| 	register char *source = (yytext_ptr);
| 	register int number_to_move, i;
| 	int ret_val;
| 
| 	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
| 		YY_FATAL_ERROR(
| 		"fatal flex scanner internal error--end of buffer missed" );
| 
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
| 		{ /* Don't try to fill the buffer, so this is an EOF. */
| 		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
| 			{
| 			/* We matched a single character, the EOB, so
| 			 * treat this as a final EOF.
| 			 */
| 			return EOB_ACT_END_OF_FILE;
| 			}
| 
| 		else
| 			{
| 			/* We matched some text prior to the EOB, first
| 			 * process it.
| 			 */
| 			return EOB_ACT_LAST_MATCH;
| 			}
| 		}
| 
| 	/* Try to read more data. */
| 
| 	/* First move last chars to start of buffer. */
| 	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
| 
| 	for ( i = 0; i < number_to_move; ++i )
| 		*(dest++) = *(source++);
| 
| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
| 		/* don't do the read, it's not guaranteed to return an EOF,
| 		 * just force an EOF
| 		 */
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
| 
| 	else
| 		{
| 			yy_size_t num_to_read =
| 			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
| 
| 		while ( num_to_read <= 0 )
| 			{ /* Not enough room in the buffer - grow it. */
| 
| 			YY_FATAL_ERROR(
| "input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
| 
| 			}
| 
| 		if ( num_to_read > YY_READ_BUF_SIZE )
| 			num_to_read = YY_READ_BUF_SIZE;
| 
| 		/* Read in more data. */
| 		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
| 			(yy_n_chars), num_to_read );
| 
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	if ( (yy_n_chars) == 0 )
| 		{
| 		if ( number_to_move == YY_MORE_ADJ )
| 			{
| 			ret_val = EOB_ACT_END_OF_FILE;
| 			yyrestart(yyin  );
| 			}
| 
| 		else
| 			{
| 			ret_val = EOB_ACT_LAST_MATCH;
| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
| 				YY_BUFFER_EOF_PENDING;
| 			}
| 		}
| 
| 	else
| 		ret_val = EOB_ACT_CONTINUE_SCAN;
| 
| 	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
| 		/* Extend the array by 50%, plus the number we really need. */
| 		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
| 		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
| 		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
| 			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
| 	}
| 
| 	(yy_n_chars) += number_to_move;
| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
| 
| 	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
| 
| 	return ret_val;
| }
| 
| /* yy_get_previous_state - get the state just before the EOB char was reached */
| 
|     static yy_state_type yy_get_previous_state (void)
| {
| 	register yy_state_type yy_current_state;
| 	register char *yy_cp;
|     
| 	yy_current_state = (yy_start);
| 
| 	(yy_state_ptr) = (yy_state_buf);
| 	*(yy_state_ptr)++ = yy_current_state;
| 
| 	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
| 		{
| 		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
| 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 			{
| 			yy_current_state = (int) yy_def[yy_current_state];
| 			if ( yy_current_state >= 13 )
| 				yy_c = yy_meta[(unsigned int) yy_c];
| 			}
| 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 		*(yy_state_ptr)++ = yy_current_state;
| 		}
| 
| 	return yy_current_state;
| }
| 
| /* yy_try_NUL_trans - try to make a transition on the NUL character
|  *
|  * synopsis
|  *	next_state = yy_try_NUL_trans( current_state );
|  */
|     static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
| {
| 	register int yy_is_jam;
|     
| 	register YY_CHAR yy_c = 1;
| 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
| 		{
| 		yy_current_state = (int) yy_def[yy_current_state];
| 		if ( yy_current_state >= 13 )
| 			yy_c = yy_meta[(unsigned int) yy_c];
| 		}
| 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
| 	yy_is_jam = (yy_current_state == 12);
| 	if ( ! yy_is_jam )
| 		*(yy_state_ptr)++ = yy_current_state;
| 
| 		return yy_is_jam ? 0 : yy_current_state;
| }
| 
|     static void yyunput (int c, register char * yy_bp )
| {
| 	register char *yy_cp;
|     
|     yy_cp = (yy_c_buf_p);
| 
| 	/* undo effects of setting up yytext */
| 	*yy_cp = (yy_hold_char);
| 
| 	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
| 		{ /* need to shift things up to make room */
| 		/* +2 for EOB chars. */
| 		register yy_size_t number_to_move = (yy_n_chars) + 2;
| 		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
| 					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
| 		register char *source =
| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
| 
| 		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
| 			*--dest = *--source;
| 
| 		yy_cp += (int) (dest - source);
| 		yy_bp += (int) (dest - source);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
| 
| 		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
| 			YY_FATAL_ERROR( "flex scanner push-back overflow" );
| 		}
| 
| 	*--yy_cp = (char) c;
| 
| 	(yytext_ptr) = yy_bp;
| 	(yy_hold_char) = *yy_cp;
| 	(yy_c_buf_p) = yy_cp;
| }
| 
| #ifndef YY_NO_INPUT
| #ifdef __cplusplus
|     static int yyinput (void)
| #else
|     static int input  (void)
| #endif
| 
| {
| 	int c;
|     
| 	*(yy_c_buf_p) = (yy_hold_char);
| 
| 	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
| 		{
| 		/* yy_c_buf_p now points to the character we want to return.
| 		 * If this occurs *before* the EOB characters, then it's a
| 		 * valid NUL; if not, then we've hit the end of the buffer.
| 		 */
| 		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
| 			/* This was really a NUL. */
| 			*(yy_c_buf_p) = '\0';
| 
| 		else
| 			{ /* need more input */
| 			yy_size_t offset = (yy_c_buf_p) - (yytext_ptr);
| 			++(yy_c_buf_p);
| 
| 			switch ( yy_get_next_buffer(  ) )
| 				{
| 				case EOB_ACT_LAST_MATCH:
| 					/* This happens because yy_g_n_b()
| 					 * sees that we've accumulated a
| 					 * token and flags that we need to
| 					 * try matching the token before
| 					 * proceeding.  But for input(),
| 					 * there's no matching to consider.
| 					 * So convert the EOB_ACT_LAST_MATCH
| 					 * to EOB_ACT_END_OF_FILE.
| 					 */
| 
| 					/* Reset buffer status. */
| 					yyrestart(yyin );
| 
| 					/*FALLTHROUGH*/
| 
| 				case EOB_ACT_END_OF_FILE:
| 					{
| 					if ( yywrap( ) )
| 						return EOF;
| 
| 					if ( ! (yy_did_buffer_switch_on_eof) )
| 						YY_NEW_FILE;
| #ifdef __cplusplus
| 					return yyinput();
| #else
| 					return input();
| #endif
| 					}
| 
| 				case EOB_ACT_CONTINUE_SCAN:
| 					(yy_c_buf_p) = (yytext_ptr) + offset;
| 					break;
| 				}
| 			}
| 		}
| 
| 	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
| 	*(yy_c_buf_p) = '\0';	/* preserve yytext */
| 	(yy_hold_char) = *++(yy_c_buf_p);
| 
| 	return c;
| }
| #endif	/* ifndef YY_NO_INPUT */
| 
| /** Immediately switch to a different input stream.
|  * @param input_file A readable stream.
|  * 
|  * @note This function does not reset the start condition to @c INITIAL .
|  */
|     void yyrestart  (FILE * input_file )
| {
|     
| 	if ( ! YY_CURRENT_BUFFER ){
|         yyensure_buffer_stack ();
| 		YY_CURRENT_BUFFER_LVALUE =
|             yy_create_buffer(yyin,YY_BUF_SIZE );
| 	}
| 
| 	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
| 	yy_load_buffer_state( );
| }
| 
| /** Switch to a different input buffer.
|  * @param new_buffer The new input buffer.
|  * 
|  */
|     void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
| {
|     
| 	/* TODO. We should be able to replace this entire function body
| 	 * with
| 	 *		yypop_buffer_state();
| 	 *		yypush_buffer_state(new_buffer);
|      */
| 	yyensure_buffer_stack ();
| 	if ( YY_CURRENT_BUFFER == new_buffer )
| 		return;
| 
| 	if ( YY_CURRENT_BUFFER )
| 		{
| 		/* Flush out information for old buffer. */
| 		*(yy_c_buf_p) = (yy_hold_char);
| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
| 	yy_load_buffer_state( );
| 
| 	/* We don't actually know whether we did this switch during
| 	 * EOF (yywrap()) processing, but the only time this flag
| 	 * is looked at is after yywrap() is called, so it's safe
| 	 * to go ahead and always set it.
| 	 */
| 	(yy_did_buffer_switch_on_eof) = 1;
| }
| 
| static void yy_load_buffer_state  (void)
| {
|     	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
| 	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
| 	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
| 	(yy_hold_char) = *(yy_c_buf_p);
| }
| 
| /** Allocate and initialize an input buffer state.
|  * @param file A readable stream.
|  * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
|  * 
|  * @return the allocated buffer state.
|  */
|     YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
| {
| 	YY_BUFFER_STATE b;
|     
| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_buf_size = size;
| 
| 	/* yy_ch_buf has to be 2 characters longer than the size given because
| 	 * we need to put in 2 end-of-buffer characters.
| 	 */
| 	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
| 	if ( ! b->yy_ch_buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
| 
| 	b->yy_is_our_buffer = 1;
| 
| 	yy_init_buffer(b,file );
| 
| 	return b;
| }
| 
| /** Destroy the buffer.
|  * @param b a buffer created with yy_create_buffer()
|  * 
|  */
|     void yy_delete_buffer (YY_BUFFER_STATE  b )
| {
|     
| 	if ( ! b )
| 		return;
| 
| 	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
| 		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
| 
| 	if ( b->yy_is_our_buffer )
| 		yyfree((void *) b->yy_ch_buf  );
| 
| 	yyfree((void *) b  );
| }
| 
| /* Initializes or reinitializes a buffer.
|  * This function is sometimes called more than once on the same buffer,
|  * such as during a yyrestart() or at EOF.
|  */
|     static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
| 
| {
| 	int oerrno = errno;
|     
| 	yy_flush_buffer(b );
| 
| 	b->yy_input_file = file;
| 	b->yy_fill_buffer = 1;
| 
|     /* If b is the current buffer, then yy_init_buffer was _probably_
|      * called from yyrestart() or through yy_get_next_buffer.
|      * In that case, we don't want to reset the lineno or column.
|      */
|     if (b != YY_CURRENT_BUFFER){
|         b->yy_bs_lineno = 1;
|         b->yy_bs_column = 0;
|     }
| 
|         b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
|     
| 	errno = oerrno;
| }
| 
| /** Discard all buffered characters. On the next scan, YY_INPUT will be called.
|  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
|  * 
|  */
|     void yy_flush_buffer (YY_BUFFER_STATE  b )
| {
|     	if ( ! b )
| 		return;
| 
| 	b->yy_n_chars = 0;
| 
| 	/* We always need two end-of-buffer characters.  The first causes
| 	 * a transition to the end-of-buffer state.  The second causes
| 	 * a jam in that state.
| 	 */
| 	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
| 	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b->yy_buf_pos = &b->yy_ch_buf[0];
| 
| 	b->yy_at_bol = 1;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	if ( b == YY_CURRENT_BUFFER )
| 		yy_load_buffer_state( );
| }
| 
| /** Pushes the new state onto the stack. The new state becomes
|  *  the current state. This function will allocate the stack
|  *  if necessary.
|  *  @param new_buffer The new state.
|  *  
|  */
| void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
| {
|     	if (new_buffer == NULL)
| 		return;
| 
| 	yyensure_buffer_stack();
| 
| 	/* This block is copied from yy_switch_to_buffer. */
| 	if ( YY_CURRENT_BUFFER )
| 		{
| 		/* Flush out information for old buffer. */
| 		*(yy_c_buf_p) = (yy_hold_char);
| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
| 		}
| 
| 	/* Only push if top exists. Otherwise, replace top. */
| 	if (YY_CURRENT_BUFFER)
| 		(yy_buffer_stack_top)++;
| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
| 
| 	/* copied from yy_switch_to_buffer. */
| 	yy_load_buffer_state( );
| 	(yy_did_buffer_switch_on_eof) = 1;
| }
| 
| /** Removes and deletes the top of the stack, if present.
|  *  The next element becomes the new top.
|  *  
|  */
| void yypop_buffer_state (void)
| {
|     	if (!YY_CURRENT_BUFFER)
| 		return;
| 
| 	yy_delete_buffer(YY_CURRENT_BUFFER );
| 	YY_CURRENT_BUFFER_LVALUE = NULL;
| 	if ((yy_buffer_stack_top) > 0)
| 		--(yy_buffer_stack_top);
| 
| 	if (YY_CURRENT_BUFFER) {
| 		yy_load_buffer_state( );
| 		(yy_did_buffer_switch_on_eof) = 1;
| 	}
| }
| 
| /* Allocates the stack if it does not exist.
|  *  Guarantees space for at least one push.
|  */
| static void yyensure_buffer_stack (void)
| {
| 	yy_size_t num_to_alloc;
|     
| 	if (!(yy_buffer_stack)) {
| 
| 		/* First allocation is just for 2 elements, since we don't know if this
| 		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
| 		 * immediate realloc on the next call.
|          */
| 		num_to_alloc = 1;
| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
| 								(num_to_alloc * sizeof(struct yy_buffer_state*)
| 								);
| 		if ( ! (yy_buffer_stack) )
| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
| 								  
| 		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
| 				
| 		(yy_buffer_stack_max) = num_to_alloc;
| 		(yy_buffer_stack_top) = 0;
| 		return;
| 	}
| 
| 	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
| 
| 		/* Increase the buffer to prepare for a possible push. */
| 		int grow_size = 8 /* arbitrary grow size */;
| 
| 		num_to_alloc = (yy_buffer_stack_max) + grow_size;
| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
| 								((yy_buffer_stack),
| 								num_to_alloc * sizeof(struct yy_buffer_state*)
| 								);
| 		if ( ! (yy_buffer_stack) )
| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
| 
| 		/* zero only the new slots.*/
| 		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
| 		(yy_buffer_stack_max) = num_to_alloc;
| 	}
| }
| 
| /** Setup the input buffer state to scan directly from a user-specified character buffer.
|  * @param base the character buffer
|  * @param size the size in bytes of the character buffer
|  * 
|  * @return the newly allocated buffer state object. 
|  */
| YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
| {
| 	YY_BUFFER_STATE b;
|     
| 	if ( size < 2 ||
| 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
| 	     base[size-1] != YY_END_OF_BUFFER_CHAR )
| 		/* They forgot to leave room for the EOB's. */
| 		return 0;
| 
| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
| 
| 	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
| 	b->yy_buf_pos = b->yy_ch_buf = base;
| 	b->yy_is_our_buffer = 0;
| 	b->yy_input_file = 0;
| 	b->yy_n_chars = b->yy_buf_size;
| 	b->yy_is_interactive = 0;
| 	b->yy_at_bol = 1;
| 	b->yy_fill_buffer = 0;
| 	b->yy_buffer_status = YY_BUFFER_NEW;
| 
| 	yy_switch_to_buffer(b  );
| 
| 	return b;
| }
| 
| /** Setup the input buffer state to scan a string. The next call to yylex() will
|  * scan from a @e copy of @a str.
|  * @param yystr a NUL-terminated string to scan
|  * 
|  * @return the newly allocated buffer state object.
|  * @note If you want to scan bytes that may contain NUL values, then use
|  *       yy_scan_bytes() instead.
|  */
| YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
| {
|     
| 	return yy_scan_bytes(yystr,strlen(yystr) );
| }
| 
| /** Setup the input buffer state to scan the given bytes. The next call to yylex() will
|  * scan from a @e copy of @a bytes.
|  * @param yybytes the byte buffer to scan
|  * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
|  * 
|  * @return the newly allocated buffer state object.
|  */
| YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len )
| {
| 	YY_BUFFER_STATE b;
| 	char *buf;
| 	yy_size_t n;
| 	yy_size_t i;
|     
| 	/* Get memory for full buffer, including space for trailing EOB's. */
| 	n = _yybytes_len + 2;
| 	buf = (char *) yyalloc(n  );
| 	if ( ! buf )
| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
| 
| 	for ( i = 0; i < _yybytes_len; ++i )
| 		buf[i] = yybytes[i];
| 
| 	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
| 
| 	b = yy_scan_buffer(buf,n );
| 	if ( ! b )
| 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
| 
| 	/* It's okay to grow etc. this buffer, and we should throw it
| 	 * away when we're done.
| 	 */
| 	b->yy_is_our_buffer = 1;
| 
| 	return b;
| }
| 
| #ifndef YY_EXIT_FAILURE
| #define YY_EXIT_FAILURE 2
| #endif
| 
| static void yy_fatal_error (yyconst char* msg )
| {
|     	(void) fprintf( stderr, "%s\n", msg );
| 	exit( YY_EXIT_FAILURE );
| }
| 
| /* Redefine yyless() so it works in section 3 code. */
| 
| #undef yyless
| #define yyless(n) \
| 	do \
| 		{ \
| 		/* Undo effects of setting up yytext. */ \
|         int yyless_macro_arg = (n); \
|         YY_LESS_LINENO(yyless_macro_arg);\
| 		yytext[yyleng] = (yy_hold_char); \
| 		(yy_c_buf_p) = yytext + yyless_macro_arg; \
| 		(yy_hold_char) = *(yy_c_buf_p); \
| 		*(yy_c_buf_p) = '\0'; \
| 		yyleng = yyless_macro_arg; \
| 		} \
| 	while ( 0 )
| 
| /* Accessor  methods (get/set functions) to struct members. */
| 
| /** Get the current line number.
|  * 
|  */
| int yyget_lineno  (void)
| {
|         
|     return yylineno;
| }
| 
| /** Get the input stream.
|  * 
|  */
| FILE *yyget_in  (void)
| {
|         return yyin;
| }
| 
| /** Get the output stream.
|  * 
|  */
| FILE *yyget_out  (void)
| {
|         return yyout;
| }
| 
| /** Get the length of the current token.
|  * 
|  */
| yy_size_t yyget_leng  (void)
| {
|         return yyleng;
| }
| 
| /** Get the current token.
|  * 
|  */
| 
| char *yyget_text  (void)
| {
|         return yytext;
| }
| 
| /** Set the current line number.
|  * @param line_number
|  * 
|  */
| void yyset_lineno (int  line_number )
| {
|     
|     yylineno = line_number;
| }
| 
| /** Set the input stream. This does not discard the current
|  * input buffer.
|  * @param in_str A readable stream.
|  * 
|  * @see yy_switch_to_buffer
|  */
| void yyset_in (FILE *  in_str )
| {
|         yyin = in_str ;
| }
| 
| void yyset_out (FILE *  out_str )
| {
|         yyout = out_str ;
| }
| 
| int yyget_debug  (void)
| {
|         return yy_flex_debug;
| }
| 
| void yyset_debug (int  bdebug )
| {
|         yy_flex_debug = bdebug ;
| }
| 
| static int yy_init_globals (void)
| {
|         /* Initialization is the same as for the non-reentrant scanner.
|      * This function is called from yylex_destroy(), so don't allocate here.
|      */
| 
|     (yy_buffer_stack) = 0;
|     (yy_buffer_stack_top) = 0;
|     (yy_buffer_stack_max) = 0;
|     (yy_c_buf_p) = (char *) 0;
|     (yy_init) = 0;
|     (yy_start) = 0;
| 
|     (yy_state_buf) = 0;
|     (yy_state_ptr) = 0;
|     (yy_full_match) = 0;
|     (yy_lp) = 0;
| 
| /* Defined in main.c */
| #ifdef YY_STDINIT
|     yyin = stdin;
|     yyout = stdout;
| #else
|     yyin = (FILE *) 0;
|     yyout = (FILE *) 0;
| #endif
| 
|     /* For future reference: Set errno on error, since we are called by
|      * yylex_init()
|      */
|     return 0;
| }
| 
| /* yylex_destroy is for both reentrant and non-reentrant scanners. */
| int yylex_destroy  (void)
| {
|     
|     /* Pop the buffer stack, destroying each element. */
| 	while(YY_CURRENT_BUFFER){
| 		yy_delete_buffer(YY_CURRENT_BUFFER  );
| 		YY_CURRENT_BUFFER_LVALUE = NULL;
| 		yypop_buffer_state();
| 	}
| 
| 	/* Destroy the stack itself. */
| 	yyfree((yy_buffer_stack) );
| 	(yy_buffer_stack) = NULL;
| 
|     yyfree ( (yy_state_buf) );
|     (yy_state_buf)  = NULL;
| 
|     /* Reset the globals. This is important in a non-reentrant scanner so the next time
|      * yylex() is called, initialization will occur. */
|     yy_init_globals( );
| 
|     return 0;
| }
| 
| /*
|  * Internal utility routines.
|  */
| 
| #ifndef yytext_ptr
| static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
| {
| 	register int i;
| 	for ( i = 0; i < n; ++i )
| 		s1[i] = s2[i];
| }
| #endif
| 
| #ifdef YY_NEED_STRLEN
| static int yy_flex_strlen (yyconst char * s )
| {
| 	register int n;
| 	for ( n = 0; s[n]; ++n )
| 		;
| 
| 	return n;
| }
| #endif
| 
| void *yyalloc (yy_size_t  size )
| {
| 	return (void *) malloc( size );
| }
| 
| void *yyrealloc  (void * ptr, yy_size_t  size )
| {
| 	/* The cast to (char *) in the following accommodates both
| 	 * implementations that use char* generic pointers, and those
| 	 * that use void* generic pointers.  It works with the latter
| 	 * because both ANSI C and C++ allow castless assignment from
| 	 * any pointer type to void*, and deal with argument conversions
| 	 * as though doing an assignment.
| 	 */
| 	return (void *) realloc( (char *) ptr, size );
| }
| 
| void yyfree (void * ptr )
| {
| 	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
| }
| 
| #define YYTABLES_NAME "yytables"
| 
| #line 9 "conftest.l"
| 
| 
| #ifdef YYTEXT_POINTER
| extern char *yytext;
| #endif
| int
| main (void)
| {
|   return ! yylex () + ! yywrap ();
| }
configure:12217: result: no
configure:12245: checking whether NLS is requested
configure:12248: result: no
configure:12316: checking whether NLS is requested
configure:12325: result: no
configure:12363: checking for msgfmt
configure:12394: result: /usr/sbin/msgfmt
configure:12403: checking for gmsgfmt
configure:12434: result: /usr/sbin/msgfmt
configure:12474: checking for xgettext
configure:12505: result: /usr/sbin/xgettext
configure:12545: checking for msgmerge
configure:12575: result: /usr/sbin/msgmerge
configure:12612: checking whether to enable maintainer-specific portions of Makefiles
configure:12621: result: no
configure:12666: checking for x86_64-unknown-linux-ranlib
configure:12693: result: ranlib
configure:12770: checking for build system executable suffix
configure:12788: result: no
configure:12806: checking size of long
configure:12811: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12811: $? = 0
configure:12811: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:68:12: error: size of array 'test_array' is negative
 static int test_array [1 - 2 * !(((long int) (sizeof (long))) <= 0)];
            ^
configure:12811: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "binutils"
| #define PACKAGE_TARNAME "binutils"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "binutils 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "binutils"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define DEFAULT_AR_DETERMINISTIC 0
| #define DEFAULT_STRINGS_ALL 1
| #define EXECUTABLE_SUFFIX ""
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static int test_array [1 - 2 * !(((long int) (sizeof (long))) <= 0)];
| test_array [0] = 0
| 
|   ;
|   return 0;
| }
configure:12811: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:68:12: error: size of array 'test_array' is negative
 static int test_array [1 - 2 * !(((long int) (sizeof (long))) <= 1)];
            ^
configure:12811: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "binutils"
| #define PACKAGE_TARNAME "binutils"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "binutils 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "binutils"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define DEFAULT_AR_DETERMINISTIC 0
| #define DEFAULT_STRINGS_ALL 1
| #define EXECUTABLE_SUFFIX ""
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static int test_array [1 - 2 * !(((long int) (sizeof (long))) <= 1)];
| test_array [0] = 0
| 
|   ;
|   return 0;
| }
configure:12811: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:68:12: error: size of array 'test_array' is negative
 static int test_array [1 - 2 * !(((long int) (sizeof (long))) <= 3)];
            ^
configure:12811: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "binutils"
| #define PACKAGE_TARNAME "binutils"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "binutils 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "binutils"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define DEFAULT_AR_DETERMINISTIC 0
| #define DEFAULT_STRINGS_ALL 1
| #define EXECUTABLE_SUFFIX ""
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static int test_array [1 - 2 * !(((long int) (sizeof (long))) <= 3)];
| test_array [0] = 0
| 
|   ;
|   return 0;
| }
configure:12811: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12811: $? = 0
configure:12811: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12811: $? = 0
configure:12811: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12811: $? = 0
configure:12826: result: 4
configure:12836: checking for long long
configure:12836: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12836: $? = 0
configure:12836: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:69:24: error: expected expression before ')' token
 if (sizeof ((long long)))
                        ^
configure:12836: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "binutils"
| #define PACKAGE_TARNAME "binutils"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "binutils 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "binutils"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define DEFAULT_AR_DETERMINISTIC 0
| #define DEFAULT_STRINGS_ALL 1
| #define EXECUTABLE_SUFFIX ""
| #define SIZEOF_LONG 4
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| if (sizeof ((long long)))
| 	    return 0;
|   ;
|   return 0;
| }
configure:12836: result: yes
configure:12847: checking size of long long
configure:12852: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12852: $? = 0
configure:12852: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:70:12: error: size of array 'test_array' is negative
 static int test_array [1 - 2 * !(((long int) (sizeof (long long))) <= 0)];
            ^
configure:12852: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "binutils"
| #define PACKAGE_TARNAME "binutils"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "binutils 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "binutils"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define DEFAULT_AR_DETERMINISTIC 0
| #define DEFAULT_STRINGS_ALL 1
| #define EXECUTABLE_SUFFIX ""
| #define SIZEOF_LONG 4
| #define HAVE_LONG_LONG 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static int test_array [1 - 2 * !(((long int) (sizeof (long long))) <= 0)];
| test_array [0] = 0
| 
|   ;
|   return 0;
| }
configure:12852: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:70:12: error: size of array 'test_array' is negative
 static int test_array [1 - 2 * !(((long int) (sizeof (long long))) <= 1)];
            ^
configure:12852: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "binutils"
| #define PACKAGE_TARNAME "binutils"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "binutils 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "binutils"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define DEFAULT_AR_DETERMINISTIC 0
| #define DEFAULT_STRINGS_ALL 1
| #define EXECUTABLE_SUFFIX ""
| #define SIZEOF_LONG 4
| #define HAVE_LONG_LONG 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static int test_array [1 - 2 * !(((long int) (sizeof (long long))) <= 1)];
| test_array [0] = 0
| 
|   ;
|   return 0;
| }
configure:12852: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:70:12: error: size of array 'test_array' is negative
 static int test_array [1 - 2 * !(((long int) (sizeof (long long))) <= 3)];
            ^
configure:12852: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "binutils"
| #define PACKAGE_TARNAME "binutils"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "binutils 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "binutils"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define DEFAULT_AR_DETERMINISTIC 0
| #define DEFAULT_STRINGS_ALL 1
| #define EXECUTABLE_SUFFIX ""
| #define SIZEOF_LONG 4
| #define HAVE_LONG_LONG 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static int test_array [1 - 2 * !(((long int) (sizeof (long long))) <= 3)];
| test_array [0] = 0
| 
|   ;
|   return 0;
| }
configure:12852: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c: In function 'main':
conftest.c:70:12: error: size of array 'test_array' is negative
 static int test_array [1 - 2 * !(((long int) (sizeof (long long))) <= 7)];
            ^
configure:12852: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "binutils"
| #define PACKAGE_TARNAME "binutils"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "binutils 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "binutils"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define DEFAULT_AR_DETERMINISTIC 0
| #define DEFAULT_STRINGS_ALL 1
| #define EXECUTABLE_SUFFIX ""
| #define SIZEOF_LONG 4
| #define HAVE_LONG_LONG 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static int test_array [1 - 2 * !(((long int) (sizeof (long long))) <= 7)];
| test_array [0] = 0
| 
|   ;
|   return 0;
| }
configure:12852: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12852: $? = 0
configure:12852: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12852: $? = 0
configure:12852: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12852: $? = 0
configure:12852: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12852: $? = 0
configure:12867: result: 8
configure:12883: checking for string.h
configure:12883: result: yes
configure:12883: checking for strings.h
configure:12883: result: yes
configure:12883: checking for stdlib.h
configure:12883: result: yes
configure:12883: checking for unistd.h
configure:12883: result: yes
configure:12883: checking fcntl.h usability
configure:12883: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12883: $? = 0
configure:12883: result: yes
configure:12883: checking fcntl.h presence
configure:12883: arm-linux-androideabi-gcc -E  conftest.c
configure:12883: $? = 0
configure:12883: result: yes
configure:12883: checking for fcntl.h
configure:12883: result: yes
configure:12883: checking sys/file.h usability
configure:12883: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12883: $? = 0
configure:12883: result: yes
configure:12883: checking sys/file.h presence
configure:12883: arm-linux-androideabi-gcc -E  conftest.c
configure:12883: $? = 0
configure:12883: result: yes
configure:12883: checking for sys/file.h
configure:12883: result: yes
configure:12883: checking limits.h usability
configure:12883: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12883: $? = 0
configure:12883: result: yes
configure:12883: checking limits.h presence
configure:12883: arm-linux-androideabi-gcc -E  conftest.c
configure:12883: $? = 0
configure:12883: result: yes
configure:12883: checking for limits.h
configure:12883: result: yes
configure:12883: checking locale.h usability
configure:12883: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12883: $? = 0
configure:12883: result: yes
configure:12883: checking locale.h presence
configure:12883: arm-linux-androideabi-gcc -E  conftest.c
configure:12883: $? = 0
configure:12883: result: yes
configure:12883: checking for locale.h
configure:12883: result: yes
configure:12883: checking sys/param.h usability
configure:12883: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12883: $? = 0
configure:12883: result: yes
configure:12883: checking sys/param.h presence
configure:12883: arm-linux-androideabi-gcc -E  conftest.c
configure:12883: $? = 0
configure:12883: result: yes
configure:12883: checking for sys/param.h
configure:12883: result: yes
configure:12883: checking wchar.h usability
configure:12883: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12883: $? = 0
configure:12883: result: yes
configure:12883: checking wchar.h presence
configure:12883: arm-linux-androideabi-gcc -E  conftest.c
configure:12883: $? = 0
configure:12883: result: yes
configure:12883: checking for wchar.h
configure:12883: result: yes
configure:12894: checking for sys/wait.h that is POSIX.1 compatible
configure:12920: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12920: $? = 0
configure:12927: result: yes
configure:12935: checking whether string.h and strings.h may both be included
configure:12952: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:12952: $? = 0
configure:12959: result: yes
configure:12969: checking for working alloca.h
configure:12986: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:12986: $? = 0
configure:12994: result: yes
configure:13002: checking for alloca
configure:13039: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:13039: $? = 0
configure:13047: result: yes
configure:13160: checking for sbrk
configure:13160: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:13160: $? = 0
configure:13160: result: yes
configure:13160: checking for utimes
configure:13160: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:13160: $? = 0
configure:13160: result: yes
configure:13160: checking for setmode
configure:13160: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
/tmp/cc2FSUxE.o:conftest.c:function main: error: undefined reference to 'setmode'
collect2: error: ld returned 1 exit status
configure:13160: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "binutils"
| #define PACKAGE_TARNAME "binutils"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "binutils 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "binutils"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define DEFAULT_AR_DETERMINISTIC 0
| #define DEFAULT_STRINGS_ALL 1
| #define EXECUTABLE_SUFFIX ""
| #define SIZEOF_LONG 4
| #define HAVE_LONG_LONG 1
| #define SIZEOF_LONG_LONG 8
| #define HAVE_STRING_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_SYS_WAIT_H 1
| #define STRING_WITH_STRINGS 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_ALLOCA 1
| #define HAVE_SBRK 1
| #define HAVE_UTIMES 1
| /* end confdefs.h.  */
| /* Define setmode to an innocuous variant, in case <limits.h> declares setmode.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define setmode innocuous_setmode
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char setmode (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef setmode
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char setmode ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_setmode || defined __stub___setmode
| choke me
| #endif
| 
| int
| main ()
| {
| return setmode ();
|   ;
|   return 0;
| }
configure:13160: result: no
configure:13160: checking for getc_unlocked
configure:13160: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:13160: $? = 0
configure:13160: result: yes
configure:13160: checking for strcoll
configure:13160: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:13160: $? = 0
configure:13160: result: yes
configure:13160: checking for setlocale
configure:13160: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:13160: $? = 0
configure:13160: result: yes
configure:13170: checking for mkstemp
configure:13170: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:13170: $? = 0
configure:13170: result: yes
configure:13177: checking for mkdtemp
configure:13177: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
configure:13177: $? = 0
configure:13177: result: yes
configure:13184: checking for mbstate_t
configure:13197: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13197: $? = 0
configure:13203: result: yes
configure:13212: checking for library containing frexp
configure:13243: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c  >&5
conftest.c:64:6: warning: conflicting types for built-in function 'frexp' [enabled by default]
 char frexp ();
      ^
/tmp/ccs0C8Ri.o:conftest.c:function main: error: undefined reference to 'frexp'
collect2: error: ld returned 1 exit status
configure:13243: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "binutils"
| #define PACKAGE_TARNAME "binutils"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "binutils 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "binutils"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define DEFAULT_AR_DETERMINISTIC 0
| #define DEFAULT_STRINGS_ALL 1
| #define EXECUTABLE_SUFFIX ""
| #define SIZEOF_LONG 4
| #define HAVE_LONG_LONG 1
| #define SIZEOF_LONG_LONG 8
| #define HAVE_STRING_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_SYS_WAIT_H 1
| #define STRING_WITH_STRINGS 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_ALLOCA 1
| #define HAVE_SBRK 1
| #define HAVE_UTIMES 1
| #define HAVE_GETC_UNLOCKED 1
| #define HAVE_STRCOLL 1
| #define HAVE_SETLOCALE 1
| #define HAVE_MKSTEMP 1
| #define HAVE_MKDTEMP 1
| #define HAVE_MBSTATE_T 1
| /* end confdefs.h.  */
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char frexp ();
| int
| main ()
| {
| return frexp ();
|   ;
|   return 0;
| }
configure:13243: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c -lm   >&5
conftest.c:64:6: warning: conflicting types for built-in function 'frexp' [enabled by default]
 char frexp ();
      ^
configure:13243: $? = 0
configure:13260: result: -lm
configure:13270: checking for LC_MESSAGES
configure:13286: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c -lm  >&5
configure:13286: $? = 0
configure:13294: result: yes
configure:13303: checking for time_t in time.h
configure:13319: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13319: $? = 0
configure:13327: result: yes
configure:13335: checking for time_t in sys/types.h
configure:13351: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13351: $? = 0
configure:13359: result: yes
configure:13367: checking for a known getopt prototype in unistd.h
configure:13383: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13383: $? = 0
configure:13391: result: yes
configure:13401: checking for utime.h
configure:13421: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13421: $? = 0
configure:13429: result: yes
configure:13437: checking whether environ is declared
configure:13437: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13437: $? = 0
configure:13437: result: yes
configure:13447: checking whether fprintf is declared
configure:13447: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13447: $? = 0
configure:13447: result: yes
configure:13457: checking whether getc_unlocked is declared
configure:13457: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13457: $? = 0
configure:13457: result: yes
configure:13467: checking whether getenv is declared
configure:13467: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13467: $? = 0
configure:13467: result: yes
configure:13477: checking whether sbrk is declared
configure:13477: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13477: $? = 0
configure:13477: result: yes
configure:13487: checking whether snprintf is declared
configure:13487: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13487: $? = 0
configure:13487: result: yes
configure:13497: checking whether stpcpy is declared
configure:13497: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13497: $? = 0
configure:13497: result: yes
configure:13507: checking whether strnlen is declared
configure:13507: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13507: $? = 0
configure:13507: result: yes
configure:13517: checking whether strstr is declared
configure:13517: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13517: $? = 0
configure:13517: result: yes
configure:13527: checking whether vsnprintf is declared
configure:13527: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13527: $? = 0
configure:13527: result: yes
configure:13554: checking for library containing zlibVersion
configure:13585: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c -lm  >&5
/tmp/ccAFeZiP.o:conftest.c:function main: error: undefined reference to 'zlibVersion'
collect2: error: ld returned 1 exit status
configure:13585: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "binutils"
| #define PACKAGE_TARNAME "binutils"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "binutils 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "binutils"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define DEFAULT_AR_DETERMINISTIC 0
| #define DEFAULT_STRINGS_ALL 1
| #define EXECUTABLE_SUFFIX ""
| #define SIZEOF_LONG 4
| #define HAVE_LONG_LONG 1
| #define SIZEOF_LONG_LONG 8
| #define HAVE_STRING_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_SYS_WAIT_H 1
| #define STRING_WITH_STRINGS 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_ALLOCA 1
| #define HAVE_SBRK 1
| #define HAVE_UTIMES 1
| #define HAVE_GETC_UNLOCKED 1
| #define HAVE_STRCOLL 1
| #define HAVE_SETLOCALE 1
| #define HAVE_MKSTEMP 1
| #define HAVE_MKDTEMP 1
| #define HAVE_MBSTATE_T 1
| #define HAVE_LC_MESSAGES 1
| #define HAVE_TIME_T_IN_TIME_H 1
| #define HAVE_TIME_T_IN_TYPES_H 1
| #define HAVE_DECL_GETOPT 1
| #define HAVE_GOOD_UTIME_H 1
| #define HAVE_DECL_ENVIRON 1
| #define HAVE_DECL_FPRINTF 1
| #define HAVE_DECL_GETC_UNLOCKED 1
| #define HAVE_DECL_GETENV 1
| #define HAVE_DECL_SBRK 1
| #define HAVE_DECL_SNPRINTF 1
| #define HAVE_DECL_STPCPY 1
| #define HAVE_DECL_STRNLEN 1
| #define HAVE_DECL_STRSTR 1
| #define HAVE_DECL_VSNPRINTF 1
| /* end confdefs.h.  */
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char zlibVersion ();
| int
| main ()
| {
| return zlibVersion ();
|   ;
|   return 0;
| }
configure:13585: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c -lz  -lm  >&5
configure:13585: $? = 0
configure:13602: result: -lz
configure:13609: checking zlib.h usability
configure:13609: arm-linux-androideabi-gcc -c   conftest.c >&5
configure:13609: $? = 0
configure:13609: result: yes
configure:13609: checking zlib.h presence
configure:13609: arm-linux-androideabi-gcc -E  conftest.c
configure:13609: $? = 0
configure:13609: result: yes
configure:13609: checking for zlib.h
configure:13609: result: yes
configure:13651: checking iconv.h usability
configure:13651: arm-linux-androideabi-gcc -c   conftest.c >&5
conftest.c:106:19: fatal error: iconv.h: No such file or directory
 #include <iconv.h>
                   ^
compilation terminated.
configure:13651: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "binutils"
| #define PACKAGE_TARNAME "binutils"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "binutils 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "binutils"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define DEFAULT_AR_DETERMINISTIC 0
| #define DEFAULT_STRINGS_ALL 1
| #define EXECUTABLE_SUFFIX ""
| #define SIZEOF_LONG 4
| #define HAVE_LONG_LONG 1
| #define SIZEOF_LONG_LONG 8
| #define HAVE_STRING_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_SYS_WAIT_H 1
| #define STRING_WITH_STRINGS 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_ALLOCA 1
| #define HAVE_SBRK 1
| #define HAVE_UTIMES 1
| #define HAVE_GETC_UNLOCKED 1
| #define HAVE_STRCOLL 1
| #define HAVE_SETLOCALE 1
| #define HAVE_MKSTEMP 1
| #define HAVE_MKDTEMP 1
| #define HAVE_MBSTATE_T 1
| #define HAVE_LC_MESSAGES 1
| #define HAVE_TIME_T_IN_TIME_H 1
| #define HAVE_TIME_T_IN_TYPES_H 1
| #define HAVE_DECL_GETOPT 1
| #define HAVE_GOOD_UTIME_H 1
| #define HAVE_DECL_ENVIRON 1
| #define HAVE_DECL_FPRINTF 1
| #define HAVE_DECL_GETC_UNLOCKED 1
| #define HAVE_DECL_GETENV 1
| #define HAVE_DECL_SBRK 1
| #define HAVE_DECL_SNPRINTF 1
| #define HAVE_DECL_STPCPY 1
| #define HAVE_DECL_STRNLEN 1
| #define HAVE_DECL_STRSTR 1
| #define HAVE_DECL_VSNPRINTF 1
| #define HAVE_ZLIB_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <iconv.h>
configure:13651: result: no
configure:13651: checking iconv.h presence
configure:13651: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:73:19: fatal error: iconv.h: No such file or directory
 #include <iconv.h>
                   ^
compilation terminated.
configure:13651: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "binutils"
| #define PACKAGE_TARNAME "binutils"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "binutils 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "binutils"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define DEFAULT_AR_DETERMINISTIC 0
| #define DEFAULT_STRINGS_ALL 1
| #define EXECUTABLE_SUFFIX ""
| #define SIZEOF_LONG 4
| #define HAVE_LONG_LONG 1
| #define SIZEOF_LONG_LONG 8
| #define HAVE_STRING_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_SYS_WAIT_H 1
| #define STRING_WITH_STRINGS 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_ALLOCA 1
| #define HAVE_SBRK 1
| #define HAVE_UTIMES 1
| #define HAVE_GETC_UNLOCKED 1
| #define HAVE_STRCOLL 1
| #define HAVE_SETLOCALE 1
| #define HAVE_MKSTEMP 1
| #define HAVE_MKDTEMP 1
| #define HAVE_MBSTATE_T 1
| #define HAVE_LC_MESSAGES 1
| #define HAVE_TIME_T_IN_TIME_H 1
| #define HAVE_TIME_T_IN_TYPES_H 1
| #define HAVE_DECL_GETOPT 1
| #define HAVE_GOOD_UTIME_H 1
| #define HAVE_DECL_ENVIRON 1
| #define HAVE_DECL_FPRINTF 1
| #define HAVE_DECL_GETC_UNLOCKED 1
| #define HAVE_DECL_GETENV 1
| #define HAVE_DECL_SBRK 1
| #define HAVE_DECL_SNPRINTF 1
| #define HAVE_DECL_STPCPY 1
| #define HAVE_DECL_STRNLEN 1
| #define HAVE_DECL_STRSTR 1
| #define HAVE_DECL_VSNPRINTF 1
| #define HAVE_ZLIB_H 1
| /* end confdefs.h.  */
| #include <iconv.h>
configure:13651: result: no
configure:13651: checking for iconv.h
configure:13651: result: no
configure:13697: checking for ld used by GCC
configure:13760: result: /tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld -m elf_i386
configure:13767: checking if the linker (/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld -m elf_i386) is GNU ld
GNU gold (GNU Binutils 2.24.90) 1.11
configure:13779: result: yes
configure:13785: checking for shared library run path origin
configure:13798: result: done
configure:14228: checking for iconv
configure:14250: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c -lz -lm  >&5
conftest.c:74:19: fatal error: iconv.h: No such file or directory
 #include <iconv.h>
                   ^
compilation terminated.
configure:14250: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "binutils"
| #define PACKAGE_TARNAME "binutils"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "binutils 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "binutils"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define DEFAULT_AR_DETERMINISTIC 0
| #define DEFAULT_STRINGS_ALL 1
| #define EXECUTABLE_SUFFIX ""
| #define SIZEOF_LONG 4
| #define HAVE_LONG_LONG 1
| #define SIZEOF_LONG_LONG 8
| #define HAVE_STRING_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_SYS_WAIT_H 1
| #define STRING_WITH_STRINGS 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_ALLOCA 1
| #define HAVE_SBRK 1
| #define HAVE_UTIMES 1
| #define HAVE_GETC_UNLOCKED 1
| #define HAVE_STRCOLL 1
| #define HAVE_SETLOCALE 1
| #define HAVE_MKSTEMP 1
| #define HAVE_MKDTEMP 1
| #define HAVE_MBSTATE_T 1
| #define HAVE_LC_MESSAGES 1
| #define HAVE_TIME_T_IN_TIME_H 1
| #define HAVE_TIME_T_IN_TYPES_H 1
| #define HAVE_DECL_GETOPT 1
| #define HAVE_GOOD_UTIME_H 1
| #define HAVE_DECL_ENVIRON 1
| #define HAVE_DECL_FPRINTF 1
| #define HAVE_DECL_GETC_UNLOCKED 1
| #define HAVE_DECL_GETENV 1
| #define HAVE_DECL_SBRK 1
| #define HAVE_DECL_SNPRINTF 1
| #define HAVE_DECL_STPCPY 1
| #define HAVE_DECL_STRNLEN 1
| #define HAVE_DECL_STRSTR 1
| #define HAVE_DECL_VSNPRINTF 1
| #define HAVE_ZLIB_H 1
| /* end confdefs.h.  */
| #include <stdlib.h>
| #include <iconv.h>
| int
| main ()
| {
| iconv_t cd = iconv_open("","");
|        iconv(cd,NULL,NULL,NULL,NULL);
|        iconv_close(cd);
|   ;
|   return 0;
| }
configure:14272: arm-linux-androideabi-gcc -o conftest   -static-libstdc++ -static-libgcc  conftest.c -lz -lm  -liconv >&5
conftest.c:74:19: fatal error: iconv.h: No such file or directory
 #include <iconv.h>
                   ^
compilation terminated.
configure:14272: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "binutils"
| #define PACKAGE_TARNAME "binutils"
| #define PACKAGE_VERSION "2.25.1"
| #define PACKAGE_STRING "binutils 2.25.1"
| #define PACKAGE_BUGREPORT ""
| #define PACKAGE_URL ""
| #define PACKAGE "binutils"
| #define VERSION "2.25.1"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DLFCN_H 1
| #define DEFAULT_AR_DETERMINISTIC 0
| #define DEFAULT_STRINGS_ALL 1
| #define EXECUTABLE_SUFFIX ""
| #define SIZEOF_LONG 4
| #define HAVE_LONG_LONG 1
| #define SIZEOF_LONG_LONG 8
| #define HAVE_STRING_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_SYS_FILE_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_SYS_WAIT_H 1
| #define STRING_WITH_STRINGS 1
| #define HAVE_ALLOCA_H 1
| #define HAVE_ALLOCA 1
| #define HAVE_SBRK 1
| #define HAVE_UTIMES 1
| #define HAVE_GETC_UNLOCKED 1
| #define HAVE_STRCOLL 1
| #define HAVE_SETLOCALE 1
| #define HAVE_MKSTEMP 1
| #define HAVE_MKDTEMP 1
| #define HAVE_MBSTATE_T 1
| #define HAVE_LC_MESSAGES 1
| #define HAVE_TIME_T_IN_TIME_H 1
| #define HAVE_TIME_T_IN_TYPES_H 1
| #define HAVE_DECL_GETOPT 1
| #define HAVE_GOOD_UTIME_H 1
| #define HAVE_DECL_ENVIRON 1
| #define HAVE_DECL_FPRINTF 1
| #define HAVE_DECL_GETC_UNLOCKED 1
| #define HAVE_DECL_GETENV 1
| #define HAVE_DECL_SBRK 1
| #define HAVE_DECL_SNPRINTF 1
| #define HAVE_DECL_STPCPY 1
| #define HAVE_DECL_STRNLEN 1
| #define HAVE_DECL_STRSTR 1
| #define HAVE_DECL_VSNPRINTF 1
| #define HAVE_ZLIB_H 1
| /* end confdefs.h.  */
| #include <stdlib.h>
| #include <iconv.h>
| int
| main ()
| {
| iconv_t cd = iconv_open("","");
|          iconv(cd,NULL,NULL,NULL,NULL);
|          iconv_close(cd);
|   ;
|   return 0;
| }
configure:14282: result: no, consider installing GNU libiconv
configure:14699: updating cache ./config.cache
configure:14760: creating ./config.status

## ---------------------- ##
## Running config.status. ##
## ---------------------- ##

This file was extended by binutils config.status 2.25.1, which was
generated by GNU Autoconf 2.64.  Invocation command line was

  CONFIG_FILES    = 
  CONFIG_HEADERS  = 
  CONFIG_LINKS    = 
  CONFIG_COMMANDS = 
  $ ./config.status 

on d5f3793a98c0

config.status:1175: creating Makefile
config.status:1175: creating doc/Makefile
config.status:1175: creating po/Makefile.in
config.status:1175: creating config.h
config.status:1388: executing depfiles commands
config.status:1388: executing libtool commands
config.status:1388: executing default-1 commands

## ---------------- ##
## Cache variables. ##
## ---------------- ##

ac_cv_build=x86_64-unknown-linux-gnu
ac_cv_c_compiler_gnu=yes
ac_cv_env_CC_set=set
ac_cv_env_CC_value=arm-linux-androideabi-gcc
ac_cv_env_CFLAGS_set=set
ac_cv_env_CFLAGS_value=
ac_cv_env_CPPFLAGS_set=set
ac_cv_env_CPPFLAGS_value=
ac_cv_env_CPP_set=
ac_cv_env_CPP_value=
ac_cv_env_LDFLAGS_set=set
ac_cv_env_LDFLAGS_value='-static-libstdc++ -static-libgcc '
ac_cv_env_LIBS_set=
ac_cv_env_LIBS_value=
ac_cv_env_YACC_set=set
ac_cv_env_YACC_value='bison -y'
ac_cv_env_YFLAGS_set=
ac_cv_env_YFLAGS_value=
ac_cv_env_build_alias_set=set
ac_cv_env_build_alias_value=x86_64-unknown-linux-gnu
ac_cv_env_host_alias_set=set
ac_cv_env_host_alias_value=x86_64-unknown-linux
ac_cv_env_target_alias_set=set
ac_cv_env_target_alias_value=i686-w64-mingw32
ac_cv_func_alloca_works=yes
ac_cv_func_getc_unlocked=yes
ac_cv_func_mkdtemp=yes
ac_cv_func_mkstemp=yes
ac_cv_func_sbrk=yes
ac_cv_func_setlocale=yes
ac_cv_func_setmode=no
ac_cv_func_strcoll=yes
ac_cv_func_utimes=yes
ac_cv_have_decl_environ=yes
ac_cv_have_decl_fprintf=yes
ac_cv_have_decl_getc_unlocked=yes
ac_cv_have_decl_getenv=yes
ac_cv_have_decl_sbrk=yes
ac_cv_have_decl_snprintf=yes
ac_cv_have_decl_stpcpy=yes
ac_cv_have_decl_strnlen=yes
ac_cv_have_decl_strstr=yes
ac_cv_have_decl_vsnprintf=yes
ac_cv_header_dlfcn_h=yes
ac_cv_header_fcntl_h=yes
ac_cv_header_iconv_h=no
ac_cv_header_inttypes_h=yes
ac_cv_header_limits_h=yes
ac_cv_header_locale_h=yes
ac_cv_header_memory_h=yes
ac_cv_header_minix_config_h=no
ac_cv_header_stdc=yes
ac_cv_header_stdint_h=yes
ac_cv_header_stdlib_h=yes
ac_cv_header_string_h=yes
ac_cv_header_strings_h=yes
ac_cv_header_sys_file_h=yes
ac_cv_header_sys_param_h=yes
ac_cv_header_sys_stat_h=yes
ac_cv_header_sys_types_h=yes
ac_cv_header_sys_wait_h=yes
ac_cv_header_unistd_h=yes
ac_cv_header_wchar_h=yes
ac_cv_header_windows_h=no
ac_cv_header_zlib_h=yes
ac_cv_host=x86_64-unknown-linux-gnu
ac_cv_lib_lex='none needed'
ac_cv_objext=o
ac_cv_path_EGREP='/usr/sbin/grep -E'
ac_cv_path_FGREP='/usr/sbin/grep -F'
ac_cv_path_GMSGFMT=/usr/sbin/msgfmt
ac_cv_path_GREP=/usr/sbin/grep
ac_cv_path_MSGFMT=/usr/sbin/msgfmt
ac_cv_path_MSGMERGE=/usr/sbin/msgmerge
ac_cv_path_SED=/usr/sbin/sed
ac_cv_path_XGETTEXT=/usr/sbin/xgettext
ac_cv_path_mkdir=/usr/sbin/mkdir
ac_cv_prog_AR=ar
ac_cv_prog_AWK=gawk
ac_cv_prog_CC=arm-linux-androideabi-gcc
ac_cv_prog_CPP='arm-linux-androideabi-gcc -E'
ac_cv_prog_LEX=flex
ac_cv_prog_OBJDUMP=objdump
ac_cv_prog_RANLIB=ranlib
ac_cv_prog_STRIP=strip
ac_cv_prog_YACC='bison -y'
ac_cv_prog_ac_ct_STRIP=strip
ac_cv_prog_cc_c89=
ac_cv_prog_cc_g=yes
ac_cv_prog_lex_root=lex.yy
ac_cv_prog_lex_yytext_pointer=no
ac_cv_prog_make_make_set=yes
ac_cv_safe_to_define___extensions__=yes
ac_cv_search_dlopen='none required'
ac_cv_search_frexp=-lm
ac_cv_search_strerror='none required'
ac_cv_search_zlibVersion=-lz
ac_cv_sizeof_long=4
ac_cv_sizeof_long_long=8
ac_cv_sys_file_offset_bits=unknown
ac_cv_sys_large_files=unknown
ac_cv_sys_largefile_CC=no
ac_cv_target=i686-w64-mingw32
ac_cv_type_long_long=yes
ac_cv_working_alloca_h=yes
acl_cv_hardcode_direct=no
acl_cv_hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
acl_cv_hardcode_libdir_separator=
acl_cv_hardcode_minus_L=no
acl_cv_libext=a
acl_cv_path_LD='/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld -m elf_i386'
acl_cv_prog_gnu_ld=yes
acl_cv_rpath=done
acl_cv_shlibext=so
acl_cv_wl=-Wl,
am_cv_CC_dependencies_compiler_type=gcc3
am_cv_func_iconv='no, consider installing GNU libiconv'
am_cv_lib_iconv=no
am_cv_val_LC_MESSAGES=yes
bfd_cv_build_exeext=no
bu_cv_decl_getopt_unistd_h=yes
bu_cv_decl_time_t_time_h=yes
bu_cv_decl_time_t_types_h=yes
bu_cv_header_utime_h=yes
gcc_cv_header_string=yes
lt_cv_archive_cmds_need_lc=no
lt_cv_deplibs_check_method=pass_all
lt_cv_file_magic_cmd='$MAGIC_CMD'
lt_cv_file_magic_test_file=
lt_cv_ld_reload_flag=-r
lt_cv_nm_interface='BSD nm'
lt_cv_objdir=.libs
lt_cv_path_LD=/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld
lt_cv_path_NM=nm
lt_cv_prog_compiler_c_o=yes
lt_cv_prog_compiler_pic_works=yes
lt_cv_prog_compiler_rtti_exceptions=no
lt_cv_prog_compiler_static_works=yes
lt_cv_prog_gnu_ld=yes
lt_cv_shlibpath_overrides_runpath=yes
lt_cv_sys_global_symbol_pipe='sed -n -e '\''s/^.*[	 ]\([ABCDGIRSTW][ABCDGIRSTW]*\)[	 ][	 ]*\([_A-Za-z][_A-Za-z0-9]*\)$/\1 \2 \2/p'\'''
lt_cv_sys_global_symbol_to_c_name_address='sed -n -e '\''s/^: \([^ ]*\) $/  {\"\1\", (void *) 0},/p'\'' -e '\''s/^[ABCDGIRSTW]* \([^ ]*\) \([^ ]*\)$/  {"\2", (void *) \&\2},/p'\'''
lt_cv_sys_global_symbol_to_c_name_address_lib_prefix='sed -n -e '\''s/^: \([^ ]*\) $/  {\"\1\", (void *) 0},/p'\'' -e '\''s/^[ABCDGIRSTW]* \([^ ]*\) \(lib[^ ]*\)$/  {"\2", (void *) \&\2},/p'\'' -e '\''s/^[ABCDGIRSTW]* \([^ ]*\) \([^ ]*\)$/  {"lib\2", (void *) \&\2},/p'\'''
lt_cv_sys_global_symbol_to_cdecl='sed -n -e '\''s/^T .* \(.*\)$/extern int \1();/p'\'' -e '\''s/^[ABCDGIRSTW]* .* \(.*\)$/extern char \1;/p'\'''
lt_cv_sys_max_cmd_len=1572864

## ----------------- ##
## Output variables. ##
## ----------------- ##

ACLOCAL='${SHELL} /tmp/mingw-w64-binutils/src/binutils-2.25.1/missing --run aclocal-1.11'
ALLOCA=''
AMDEPBACKSLASH='\'
AMDEP_FALSE='#'
AMDEP_TRUE=''
AMTAR='${SHELL} /tmp/mingw-w64-binutils/src/binutils-2.25.1/missing --run tar'
AR='ar'
AUTOCONF='${SHELL} /tmp/mingw-w64-binutils/src/binutils-2.25.1/missing --run autoconf'
AUTOHEADER='${SHELL} /tmp/mingw-w64-binutils/src/binutils-2.25.1/missing --run autoheader'
AUTOMAKE='${SHELL} /tmp/mingw-w64-binutils/src/binutils-2.25.1/missing --run automake-1.11'
AWK='gawk'
BUILD_DLLTOOL='$(DLLTOOL_PROG)$(EXEEXT)'
BUILD_DLLWRAP='$(DLLWRAP_PROG)$(EXEEXT)'
BUILD_INSTALL_MISC=''
BUILD_MISC=''
BUILD_NLMCONV=''
BUILD_SRCONV=''
BUILD_WINDMC='$(WINDMC_PROG)$(EXEEXT)'
BUILD_WINDRES='$(WINDRES_PROG)$(EXEEXT)'
CATALOGS=''
CATOBJEXT=''
CC='arm-linux-androideabi-gcc'
CCDEPMODE='depmode=gcc3'
CC_FOR_BUILD='arm-linux-androideabi-gcc'
CFLAGS=''
CPP='arm-linux-androideabi-gcc -E'
CPPFLAGS=''
CYGPATH_W='echo'
DATADIRNAME=''
DEFS='-DHAVE_CONFIG_H'
DEMANGLER_NAME='c++filt'
DEPDIR='.deps'
DLLTOOL_DEFS=' -DDLLTOOL_I386 -DDLLTOOL_DEFAULT_I386'
DSYMUTIL=''
DUMPBIN=''
ECHO_C=''
ECHO_N='-n'
ECHO_T=''
EGREP='/usr/sbin/grep -E'
EMULATION='vanilla'
EMULATION_VECTOR='bin_vanilla_emulation'
EXEEXT=''
EXEEXT_FOR_BUILD=''
FGREP='/usr/sbin/grep -F'
GENCAT=''
GENINSRC_NEVER_FALSE=''
GENINSRC_NEVER_TRUE='#'
GMSGFMT='/usr/sbin/msgfmt'
GREP='/usr/sbin/grep'
HDEFINES=''
INCINTL=''
INSTALL_DATA='/usr/bin/install -c -m 644'
INSTALL_PROGRAM='/usr/bin/install -c'
INSTALL_SCRIPT='/usr/bin/install -c'
INSTALL_STRIP_PROGRAM='$(install_sh) -c -s'
INSTOBJEXT=''
LD='/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld -m elf_i386'
LDFLAGS='-static-libstdc++ -static-libgcc '
LEX='flex'
LEXLIB=''
LEX_OUTPUT_ROOT='lex.yy'
LIBICONV=''
LIBINTL=''
LIBINTL_DEP=''
LIBOBJS=''
LIBS='-lz -lm '
LIBTOOL='$(SHELL) $(top_builddir)/libtool'
LIPO=''
LN_S='ln -s'
LTLIBICONV=''
LTLIBOBJS=''
MAINT='#'
MAINTAINER_MODE_FALSE=''
MAINTAINER_MODE_TRUE='#'
MAKEINFO='makeinfo --split-size=5000000'
MKDIR_P='/usr/sbin/mkdir -p'
MKINSTALLDIRS='/tmp/mingw-w64-binutils/src/binutils-2.25.1/binutils/../mkinstalldirs'
MSGFMT='/usr/sbin/msgfmt'
MSGMERGE='/usr/sbin/msgmerge'
NLMCONV_DEFS=''
NM='nm'
NMEDIT=''
NO_WERROR=''
OBJDUMP='objdump'
OBJDUMP_DEFS=' -DOBJDUMP_PRIVATE_VECTORS=""'
OBJDUMP_PRIVATE_OFILES=''
OBJEXT='o'
OTOOL64=''
OTOOL=''
PACKAGE='binutils'
PACKAGE_BUGREPORT=''
PACKAGE_NAME='binutils'
PACKAGE_STRING='binutils 2.25.1'
PACKAGE_TARNAME='binutils'
PACKAGE_URL=''
PACKAGE_VERSION='2.25.1'
PATH_SEPARATOR=':'
POSUB=''
RANLIB='ranlib'
SED='/usr/sbin/sed'
SET_MAKE=''
SHELL='/bin/sh'
STRIP='strip'
USE_NLS='no'
VERSION='2.25.1'
WARN_CFLAGS='-W -Wall -Wstrict-prototypes -Wmissing-prototypes -Wshadow'
XGETTEXT='/usr/sbin/xgettext'
YACC='bison -y'
YFLAGS=''
ac_ct_CC=''
ac_ct_DUMPBIN=''
am__EXEEXT_FALSE=''
am__EXEEXT_TRUE='#'
am__fastdepCC_FALSE='#'
am__fastdepCC_TRUE=''
am__include='include'
am__isrc=' -I$(srcdir)'
am__leading_dot='.'
am__quote=''
am__tar='${AMTAR} chof - "$$tardir"'
am__untar='${AMTAR} xf -'
bindir='${exec_prefix}/bin'
build='x86_64-unknown-linux-gnu'
build_alias='x86_64-unknown-linux-gnu'
build_cpu='x86_64'
build_os='linux-gnu'
build_vendor='unknown'
datadir='${datarootdir}'
datarootdir='${prefix}/share'
docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
dvidir='${docdir}'
exec_prefix='${prefix}'
host='x86_64-unknown-linux-gnu'
host_alias='x86_64-unknown-linux'
host_cpu='x86_64'
host_os='linux-gnu'
host_vendor='unknown'
htmldir='${docdir}'
includedir='${prefix}/include'
infodir='/usr/share/info/i686-w64-mingw32'
install_sh='${SHELL} /tmp/mingw-w64-binutils/src/binutils-2.25.1/install-sh'
libdir='${exec_prefix}/lib'
libexecdir='${exec_prefix}/libexec'
localedir='${datarootdir}/locale'
localstatedir='${prefix}/var'
mandir='${datarootdir}/man'
mkdir_p='/usr/sbin/mkdir -p'
oldincludedir='/usr/include'
pdfdir='${docdir}'
prefix='/usr'
program_transform_name='s&^&i686-w64-mingw32-&'
psdir='${docdir}'
sbindir='${exec_prefix}/sbin'
sharedstatedir='${prefix}/com'
sysconfdir='${prefix}/etc'
target='i686-w64-mingw32'
target_alias='i686-w64-mingw32'
target_cpu='i686'
target_os='mingw32'
target_vendor='w64'

## ----------- ##
## confdefs.h. ##
## ----------- ##

/* confdefs.h */
#define PACKAGE_NAME "binutils"
#define PACKAGE_TARNAME "binutils"
#define PACKAGE_VERSION "2.25.1"
#define PACKAGE_STRING "binutils 2.25.1"
#define PACKAGE_BUGREPORT ""
#define PACKAGE_URL ""
#define PACKAGE "binutils"
#define VERSION "2.25.1"
#define STDC_HEADERS 1
#define HAVE_SYS_TYPES_H 1
#define HAVE_SYS_STAT_H 1
#define HAVE_STDLIB_H 1
#define HAVE_STRING_H 1
#define HAVE_MEMORY_H 1
#define HAVE_STRINGS_H 1
#define HAVE_INTTYPES_H 1
#define HAVE_STDINT_H 1
#define HAVE_UNISTD_H 1
#define __EXTENSIONS__ 1
#define _ALL_SOURCE 1
#define _GNU_SOURCE 1
#define _POSIX_PTHREAD_SEMANTICS 1
#define _TANDEM_SOURCE 1
#define HAVE_DLFCN_H 1
#define LT_OBJDIR ".libs/"
#define HAVE_DLFCN_H 1
#define DEFAULT_AR_DETERMINISTIC 0
#define DEFAULT_STRINGS_ALL 1
#define EXECUTABLE_SUFFIX ""
#define SIZEOF_LONG 4
#define HAVE_LONG_LONG 1
#define SIZEOF_LONG_LONG 8
#define HAVE_STRING_H 1
#define HAVE_STRINGS_H 1
#define HAVE_STDLIB_H 1
#define HAVE_UNISTD_H 1
#define HAVE_FCNTL_H 1
#define HAVE_SYS_FILE_H 1
#define HAVE_LIMITS_H 1
#define HAVE_LOCALE_H 1
#define HAVE_SYS_PARAM_H 1
#define HAVE_WCHAR_H 1
#define HAVE_SYS_WAIT_H 1
#define STRING_WITH_STRINGS 1
#define HAVE_ALLOCA_H 1
#define HAVE_ALLOCA 1
#define HAVE_SBRK 1
#define HAVE_UTIMES 1
#define HAVE_GETC_UNLOCKED 1
#define HAVE_STRCOLL 1
#define HAVE_SETLOCALE 1
#define HAVE_MKSTEMP 1
#define HAVE_MKDTEMP 1
#define HAVE_MBSTATE_T 1
#define HAVE_LC_MESSAGES 1
#define HAVE_TIME_T_IN_TIME_H 1
#define HAVE_TIME_T_IN_TYPES_H 1
#define HAVE_DECL_GETOPT 1
#define HAVE_GOOD_UTIME_H 1
#define HAVE_DECL_ENVIRON 1
#define HAVE_DECL_FPRINTF 1
#define HAVE_DECL_GETC_UNLOCKED 1
#define HAVE_DECL_GETENV 1
#define HAVE_DECL_SBRK 1
#define HAVE_DECL_SNPRINTF 1
#define HAVE_DECL_STPCPY 1
#define HAVE_DECL_STRNLEN 1
#define HAVE_DECL_STRSTR 1
#define HAVE_DECL_VSNPRINTF 1
#define HAVE_ZLIB_H 1
#define TARGET "i686-w64-mingw32"
#define TARGET_PREPENDS_UNDERSCORE 1

configure: exit 0

===> Finished printing config.logs></pre></code>
        </body></html>
