<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>nickle</title>
		<link href='https://fonts.googleapis.com/css?family=Roboto:400,900'
          rel='stylesheet' type='text/css'>
    <link
    href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,700'
          rel='stylesheet' type='text/css'>

<style>
body{
  font-family: 'Roboto', 'sans-serif';
  background-color: #fff;
  color: #212121;
}
code{
  font-family: 'Source Code Pro', ;
  white-space: pre;
}
div{
  padding: 5px;
  border-radius: 5px;
  position: relative;
  float: left;
  min-width: 99%;
  clear: both;
}

/* Each log block */
.block{
  background-color: #e0e0e0;
  margin-bottom: 20px;
}

/* Different log block headers */
.die{
  background-color: #ff9800;
  color: #212121;
  font-weight: bold;
}
.command{
  background-color: #42a5f5;
  color: #212121;
  font-weight: bold;
}
.file{
  background-color: #4db6ac;
  color: #212121;
  font-weight: bold;
}
.info{
  background-color: #4db6ac;
  color: #212121;
  font-weight: bold;
}

a{
  color: #00bcd4;
  text-decoration: none;
}
a:visited {
  color: #e91e63;
  text-decoration: none;
}

/* Log block output */
.output{
  background-color: #fff;
  color: #212121;
}

/* The word CMD that indicates the header of a log block is a
 * command-line invocation
 */
.prompt{
  color: #212121;
  text-shadow: -2px -2px 0 #ffeb3b,
                2px -2px 0 #ffeb3b,
                2px  2px 0 #ffeb3b,
               -2px  2px 0 #ffeb3b;
}

/* Formats for lines in command output */
.none{

}
.error{
  background-color: #f44336;
  color: #212121;
  font-weight: bold;
  text-decoration: underline;
}

.warning{
  background-color: #ffeb3b;
  color: #212121;
  font-weight: bold;
  text-decoration: underline;
}

</style>
  </head>
  <body>
    <h1>Build of /var/abs/community/nickle
        with <a href="../index.html">android</a>
        toolchain</h1>
    <p>This PKGBUILD creates the following packages:</p>
    <ul>
      
    </ul>
    <p>The build took 00:03:29.</p>
    <p>The return code of the build was 5.</p>
    <h2>Log</h2>
    

      <div class="block">
        <div class="info">
          <code>Found permanent source directory in /sources/nickle</code>
        </div>
        
      </div>
      <br />
    

      <div class="block">
        <div class="info">
          <code>Removed vanilla repositories from pacman.conf and added:</code>
        </div>
        
          <div class="output">
            
            <span class="none">
            <code>[tuscan]</code><br />
            </span>
            
            <span class="none">
            <code>Server = file:///toolchain_repo</code><br />
            </span>
            
          </div>
        
      </div>
      <br />
    

      <div class="block">
        <div class="command">
          <code><span class="prompt">CMD: </span>pacman -Syy --noconfirm</code>
        </div>
        
          <div class="output">
            
            <span class="none">
            <code>:: Synchronizing package databases...</code><br />
            </span>
            
            <span class="none">
            <code>downloading tuscan.db...</code><br />
            </span>
            
          </div>
        
      </div>
      <br />
    

      <div class="block">
        <div class="command">
          <code><span class="prompt">CMD: </span>sudo -u tuscan PATH=/toolchain_root/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin CC=arm-linux-androideabi-gcc CXX=arm-linux-androideabi-g++ SYSROOT=/build/android-ndk-r10e/platforms/android-21/arch-arm LIBRARY_PATH=/toolchain_root/usr/lib CPATH=/toolchain_root/usr/include makepkg --noextract --syncdeps --skipinteg --skippgpcheck --skipchecksums --noconfirm --nocolor --log --noprogressbar --nocheck</code>
        </div>
        
          <div class="output">
            
            <span class="none">
            <code>==> Making package: nickle 2.70-3 (Thu Dec 17 00:43:03 UTC 2015)</code><br />
            </span>
            
            <span class="none">
            <code>==> Checking runtime dependencies...</code><br />
            </span>
            
            <span class="none">
            <code>==> Checking buildtime dependencies...</code><br />
            </span>
            
            <span class="none">
            <code>==> WARNING: Using existing $srcdir/ tree</code><br />
            </span>
            
            <span class="none">
            <code>==> Starting build()...</code><br />
            </span>
            
            <span class="none">
            <code>configure: WARNING: If you wanted to set the --build type, don't use --host.</code><br />
            </span>
            
            <span class="none">
            <code>    If a cross compiler is detected then cross compile mode will be used.</code><br />
            </span>
            
            <span class="none">
            <code>checking for a BSD-compatible install... /usr/bin/install -c</code><br />
            </span>
            
            <span class="none">
            <code>checking whether build environment is sane... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for x86_64-unknown-linux-strip... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for strip... strip</code><br />
            </span>
            
            <span class="none">
            <code>checking for a thread-safe mkdir -p... /usr/sbin/mkdir -p</code><br />
            </span>
            
            <span class="none">
            <code>checking for gawk... gawk</code><br />
            </span>
            
            <span class="none">
            <code>checking whether make sets $(MAKE)... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking whether to enable maintainer-specific portions of Makefiles... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for x86_64-unknown-linux-gcc... arm-linux-androideabi-gcc</code><br />
            </span>
            
            <span class="none">
            <code>checking whether the C compiler works... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for C compiler default output file name... a.out</code><br />
            </span>
            
            <span class="none">
            <code>checking for suffix of executables... </code><br />
            </span>
            
            <span class="none">
            <code>checking whether we are cross compiling... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for suffix of object files... o</code><br />
            </span>
            
            <span class="none">
            <code>checking whether we are using the GNU C compiler... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking whether arm-linux-androideabi-gcc accepts -g... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for arm-linux-androideabi-gcc option to accept ISO C89... none needed</code><br />
            </span>
            
            <span class="none">
            <code>checking for style of include used by make... GNU</code><br />
            </span>
            
            <span class="none">
            <code>checking dependency style of arm-linux-androideabi-gcc... gcc3</code><br />
            </span>
            
            <span class="none">
            <code>checking whether ln -s works... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for flex... flex</code><br />
            </span>
            
            <span class="none">
            <code>checking lex output file root... lex.yy</code><br />
            </span>
            
            <span class="none">
            <code>checking lex library... none needed</code><br />
            </span>
            
            <span class="none">
            <code>checking whether yytext is a pointer... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for byacc... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for yacc... yacc</code><br />
            </span>
            
            <span class="none">
            <code>checking for gawk... (cached) gawk</code><br />
            </span>
            
            <span class="none">
            <code>checking for date... date</code><br />
            </span>
            
            <span class="none">
            <code>checking for log... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for log in -lm... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for gethostbyname... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for socket... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for dlopen in -ldl... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking to see if compiler understands -Wl,-E... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking how to run the C preprocessor... arm-linux-androideabi-gcc -E</code><br />
            </span>
            
            <span class="none">
            <code>checking for grep that handles long lines and -e... /usr/sbin/grep</code><br />
            </span>
            
            <span class="none">
            <code>checking for egrep... /usr/sbin/grep -E</code><br />
            </span>
            
            <span class="none">
            <code>checking for ANSI C header files... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for sys/types.h... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for sys/stat.h... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for stdlib.h... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for string.h... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for memory.h... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for strings.h... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for inttypes.h... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for stdint.h... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for unistd.h... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking fcntl.h usability... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking fcntl.h presence... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for fcntl.h... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for strings.h... (cached) yes</code><br />
            </span>
            
            <span class="none">
            <code>checking time.h usability... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking time.h presence... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for time.h... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking sys/time.h usability... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking sys/time.h presence... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for sys/time.h... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for unistd.h... (cached) yes</code><br />
            </span>
            
            <span class="none">
            <code>checking sys/resource.h usability... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking sys/resource.h presence... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for sys/resource.h... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking stropts.h usability... no</code><br />
            </span>
            
            <span class="none">
            <code>checking stropts.h presence... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for stropts.h... no</code><br />
            </span>
            
            <span class="none">
            <code>checking dlfcn.h usability... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking dlfcn.h presence... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for dlfcn.h... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for inline... inline</code><br />
            </span>
            
            <span class="none">
            <code>checking for stdint.h... (cached) yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for uint64_t... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking return type of signal handlers... void</code><br />
            </span>
            
            <span class="none">
            <code>checking for vprintf... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for _doprnt... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for unsetenv... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for setenv... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for putenv... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for gettimeofday... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for hstrerror... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for select... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for sigaction... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for sigrelse... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for sigignore... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for setrlimit... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for getrlimit... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for dlopen... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for dlsym... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for dlerror... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for dlclose... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking whether getpgrp requires zero arguments... yes</code><br />
            </span>
            
            <span class="none">
            <code>checking for tparm in -lncurses... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for tgetent in -ltermcap... no</code><br />
            </span>
            
            <span class="none">
            <code>checking for readline in -lreadline... no</code><br />
            </span>
            
            <span class="none">
            <code>Cannot find readline.  Build with --without-readline or set the readline path appropriately.</code><br />
            </span>
            
            <span class="none">
            <code>==> ERROR: A failure occurred in build().</code><br />
            </span>
            
            <span class="none">
            <code>    Aborting...</code><br />
            </span>
            
          </div>
        
      </div>
      <br />
    

      <div class="block">
        <div class="info">
          <code>Printing config.logs</code>
        </div>
        
      </div>
      <br />
    

      <div class="block">
        <div class="command">
          <code><span class="prompt">CMD: </span>Config logfile '/tmp/nickle/src/nickle-2.70/config.log'</code>
        </div>
        
          <div class="output">
            
            <span class="none">
            <code>This file contains any messages produced by compilers while</code><br />
            </span>
            
            <span class="none">
            <code>running configure, to aid debugging if configure makes a mistake.</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>It was created by nickle configure 2.70, which was</code><br />
            </span>
            
            <span class="none">
            <code>generated by GNU Autoconf 2.65.  Invocation command line was</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>$ ./configure --host x86_64-unknown-linux --prefix=/usr</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>## --------- ##</code><br />
            </span>
            
            <span class="none">
            <code>## Platform. ##</code><br />
            </span>
            
            <span class="none">
            <code>## --------- ##</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>hostname = 03dc75548fe0</code><br />
            </span>
            
            <span class="none">
            <code>uname -m = x86_64</code><br />
            </span>
            
            <span class="none">
            <code>uname -r = 3.13.0-67-generic</code><br />
            </span>
            
            <span class="none">
            <code>uname -s = Linux</code><br />
            </span>
            
            <span class="none">
            <code>uname -v = #110-Ubuntu SMP Fri Oct 23 13:24:41 UTC 2015</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>/usr/bin/uname -p = unknown</code><br />
            </span>
            
            <span class="none">
            <code>/bin/uname -X     = unknown</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>/bin/arch              = unknown</code><br />
            </span>
            
            <span class="none">
            <code>/usr/bin/arch -k       = unknown</code><br />
            </span>
            
            <span class="none">
            <code>/usr/convex/getsysinfo = unknown</code><br />
            </span>
            
            <span class="none">
            <code>/usr/bin/hostinfo      = unknown</code><br />
            </span>
            
            <span class="none">
            <code>/bin/machine           = unknown</code><br />
            </span>
            
            <span class="none">
            <code>/usr/bin/oslevel       = unknown</code><br />
            </span>
            
            <span class="none">
            <code>/bin/universe          = unknown</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>PATH: /toolchain_root/bin</code><br />
            </span>
            
            <span class="none">
            <code>PATH: /usr/local/sbin</code><br />
            </span>
            
            <span class="none">
            <code>PATH: /usr/local/bin</code><br />
            </span>
            
            <span class="none">
            <code>PATH: /usr/sbin</code><br />
            </span>
            
            <span class="none">
            <code>PATH: /usr/bin</code><br />
            </span>
            
            <span class="none">
            <code>PATH: /sbin</code><br />
            </span>
            
            <span class="none">
            <code>PATH: /bin</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>## ----------- ##</code><br />
            </span>
            
            <span class="none">
            <code>## Core tests. ##</code><br />
            </span>
            
            <span class="none">
            <code>## ----------- ##</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>configure:2349: checking for a BSD-compatible install</code><br />
            </span>
            
            <span class="none">
            <code>configure:2417: result: /usr/bin/install -c</code><br />
            </span>
            
            <span class="none">
            <code>configure:2428: checking whether build environment is sane</code><br />
            </span>
            
            <span class="none">
            <code>configure:2478: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:2527: checking for x86_64-unknown-linux-strip</code><br />
            </span>
            
            <span class="none">
            <code>configure:2557: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:2567: checking for strip</code><br />
            </span>
            
            <span class="none">
            <code>configure:2583: found /usr/sbin/strip</code><br />
            </span>
            
            <span class="none">
            <code>configure:2594: result: strip</code><br />
            </span>
            
            <span class="none">
            <code>configure:2619: checking for a thread-safe mkdir -p</code><br />
            </span>
            
            <span class="none">
            <code>configure:2658: result: /usr/sbin/mkdir -p</code><br />
            </span>
            
            <span class="none">
            <code>configure:2671: checking for gawk</code><br />
            </span>
            
            <span class="none">
            <code>configure:2687: found /usr/sbin/gawk</code><br />
            </span>
            
            <span class="none">
            <code>configure:2698: result: gawk</code><br />
            </span>
            
            <span class="none">
            <code>configure:2709: checking whether make sets $(MAKE)</code><br />
            </span>
            
            <span class="none">
            <code>configure:2731: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:2813: checking whether to enable maintainer-specific portions of Makefiles</code><br />
            </span>
            
            <span class="none">
            <code>configure:2822: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:2844: checking for x86_64-unknown-linux-gcc</code><br />
            </span>
            
            <span class="none">
            <code>configure:2871: result: arm-linux-androideabi-gcc</code><br />
            </span>
            
            <span class="none">
            <code>configure:3140: checking for C compiler version</code><br />
            </span>
            
            <span class="none">
            <code>configure:3149: arm-linux-androideabi-gcc --version >&5</code><br />
            </span>
            
            <span class="none">
            <code>arm-linux-androideabi-gcc (GCC) 4.8</code><br />
            </span>
            
            <span class="none">
            <code>Copyright (C) 2013 Free Software Foundation, Inc.</code><br />
            </span>
            
            <span class="none">
            <code>This is free software; see the source for copying conditions.  There is NO</code><br />
            </span>
            
            <span class="none">
            <code>warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>configure:3160: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:3149: arm-linux-androideabi-gcc -v >&5</code><br />
            </span>
            
            <span class="none">
            <code>Using built-in specs.</code><br />
            </span>
            
            <span class="none">
            <code>COLLECT_GCC=arm-linux-androideabi-gcc</code><br />
            </span>
            
            <span class="none">
            <code>COLLECT_LTO_WRAPPER=/toolchain_root/bin/../libexec/gcc/arm-linux-androideabi/4.8/lto-wrapper</code><br />
            </span>
            
            <span class="none">
            <code>Target: arm-linux-androideabi</code><br />
            </span>
            
            <span class="none">
            <code>Configured with: /s/ndk-toolchain/src/build/../gcc/gcc-4.8/configure --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --target=arm-linux-androideabi --host=x86_64-linux-gnu --build=x86_64-linux-gnu --with-gnu-as --with-gnu-ld --enable-languages=c,c++ --with-gmp=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpfr=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpc=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-cloog=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-isl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-ppl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --disable-ppl-version-check --disable-cloog-version-check --disable-isl-version-check --enable-cloog-backend=isl --with-host-libstdcxx='-static-libgcc -Wl,-Bstatic,-lstdc++,-Bdynamic -lm' --disable-libssp --enable-threads --disable-nls --disable-libmudflap --disable-libgomp --disable-libstdc__-v3 --disable-sjlj-exceptions --disable-shared --disable-tls --disable-libitm --with-float=soft --with-fpu=vfp --with-arch=armv5te --enable-target-optspace --enable-initfini-array --disable-nls --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --with-sysroot=/tmp/ndk-andrewhsieh/build/toolchain/prefix/sysroot --with-binutils-version=2.25 --with-mpfr-version=3.1.1 --with-mpc-version=1.0.1 --with-gmp-version=5.0.5 --with-gcc-version=4.8 --with-gdb-version=7.7 --with-python=/usr/local/google/home/andrewhsieh/mydroid/ndk/prebuilt/linux-x86_64/bin/python-config.sh --with-gxx-include-dir=/tmp/ndk-andrewhsieh/build/toolchain/prefix/include/c++/4.8 --with-bugurl=http://source.android.com/source/report-bugs.html --enable-languages=c,c++ --disable-bootstrap --enable-plugins --enable-libgomp --enable-gnu-indirect-function --disable-libsanitizer --enable-gold --enable-threads --enable-graphite=yes --with-cloog-version=0.18.0 --with-isl-version=0.11.1 --enable-eh-frame-hdr-for-static --with-arch=armv5te --program-transform-name='s&^&arm-linux-androideabi-&' --enable-gold=default</code><br />
            </span>
            
            <span class="none">
            <code>Thread model: posix</code><br />
            </span>
            
            <span class="none">
            <code>gcc version 4.8 (GCC)</code><br />
            </span>
            
            <span class="none">
            <code>configure:3160: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:3149: arm-linux-androideabi-gcc -V >&5</code><br />
            </span>
            
            <span class="error">
            <code>arm-linux-androideabi-gcc: error: unrecognized command line option '-V'</code><br />
            </span>
            
            <span class="none">
            <code>arm-linux-androideabi-gcc: fatal error: no input files</code><br />
            </span>
            
            <span class="none">
            <code>compilation terminated.</code><br />
            </span>
            
            <span class="none">
            <code>configure:3160: $? = 1</code><br />
            </span>
            
            <span class="none">
            <code>configure:3149: arm-linux-androideabi-gcc -qversion >&5</code><br />
            </span>
            
            <span class="error">
            <code>arm-linux-androideabi-gcc: error: unrecognized command line option '-qversion'</code><br />
            </span>
            
            <span class="none">
            <code>arm-linux-androideabi-gcc: fatal error: no input files</code><br />
            </span>
            
            <span class="none">
            <code>compilation terminated.</code><br />
            </span>
            
            <span class="none">
            <code>configure:3160: $? = 1</code><br />
            </span>
            
            <span class="none">
            <code>configure:3180: checking whether the C compiler works</code><br />
            </span>
            
            <span class="none">
            <code>configure:3202: arm-linux-androideabi-gcc    conftest.c  >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:3206: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:3255: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:3258: checking for C compiler default output file name</code><br />
            </span>
            
            <span class="none">
            <code>configure:3260: result: a.out</code><br />
            </span>
            
            <span class="none">
            <code>configure:3266: checking for suffix of executables</code><br />
            </span>
            
            <span class="none">
            <code>configure:3273: arm-linux-androideabi-gcc -o conftest    conftest.c  >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:3277: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:3299: result:</code><br />
            </span>
            
            <span class="none">
            <code>configure:3321: checking whether we are cross compiling</code><br />
            </span>
            
            <span class="none">
            <code>configure:3329: arm-linux-androideabi-gcc -o conftest    conftest.c  >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:3333: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:3340: ./conftest</code><br />
            </span>
            
            <span class="error">
            <code>./configure: line 3342: ./conftest: cannot execute binary file: Exec format error</code><br />
            </span>
            
            <span class="none">
            <code>configure:3344: $? = 126</code><br />
            </span>
            
            <span class="none">
            <code>configure:3359: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:3364: checking for suffix of object files</code><br />
            </span>
            
            <span class="none">
            <code>configure:3386: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:3390: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:3411: result: o</code><br />
            </span>
            
            <span class="none">
            <code>configure:3415: checking whether we are using the GNU C compiler</code><br />
            </span>
            
            <span class="none">
            <code>configure:3434: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:3434: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:3443: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:3452: checking whether arm-linux-androideabi-gcc accepts -g</code><br />
            </span>
            
            <span class="none">
            <code>configure:3472: arm-linux-androideabi-gcc -c -g  conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:3472: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:3513: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:3530: checking for arm-linux-androideabi-gcc option to accept ISO C89</code><br />
            </span>
            
            <span class="none">
            <code>configure:3594: arm-linux-androideabi-gcc  -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:3594: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:3607: result: none needed</code><br />
            </span>
            
            <span class="none">
            <code>configure:3638: checking for style of include used by make</code><br />
            </span>
            
            <span class="none">
            <code>configure:3666: result: GNU</code><br />
            </span>
            
            <span class="none">
            <code>configure:3691: checking dependency style of arm-linux-androideabi-gcc</code><br />
            </span>
            
            <span class="none">
            <code>configure:3801: result: gcc3</code><br />
            </span>
            
            <span class="none">
            <code>configure:3817: checking whether ln -s works</code><br />
            </span>
            
            <span class="none">
            <code>configure:3821: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:3833: checking for flex</code><br />
            </span>
            
            <span class="none">
            <code>configure:3849: found /usr/sbin/flex</code><br />
            </span>
            
            <span class="none">
            <code>configure:3860: result: flex</code><br />
            </span>
            
            <span class="none">
            <code>configure:3897: flex conftest.l</code><br />
            </span>
            
            <span class="none">
            <code>configure:3901: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:3903: checking lex output file root</code><br />
            </span>
            
            <span class="none">
            <code>configure:3917: result: lex.yy</code><br />
            </span>
            
            <span class="none">
            <code>configure:3922: checking lex library</code><br />
            </span>
            
            <span class="none">
            <code>configure:3936: arm-linux-androideabi-gcc -o conftest    conftest.c   >&5</code><br />
            </span>
            
            <span class="error">
            <code>/tmp/cckTJA9k.o:conftest.c:function yylex: error: undefined reference to 'yywrap'</code><br />
            </span>
            
            <span class="error">
            <code>/tmp/cckTJA9k.o:conftest.c:function input: error: undefined reference to 'yywrap'</code><br />
            </span>
            
            <span class="error">
            <code>/tmp/cckTJA9k.o:conftest.c:function main: error: undefined reference to 'yywrap'</code><br />
            </span>
            
            <span class="none">
            <code>collect2: error: ld returned 1 exit status</code><br />
            </span>
            
            <span class="none">
            <code>configure:3936: $? = 1</code><br />
            </span>
            
            <span class="none">
            <code>configure: failed program was:</code><br />
            </span>
            
            <span class="none">
            <code>| /* confdefs.h */</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_NAME "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_TARNAME "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_VERSION "2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_STRING "nickle 2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_BUGREPORT "http://nickle.org"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_URL ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define VERSION "2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| /* end confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #line 3 "lex.yy.c"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define  YY_INT_ALIGNED short int</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* A lexical scanner generated by flex */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define FLEX_SCANNER</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FLEX_MAJOR_VERSION 2</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FLEX_MINOR_VERSION 5</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FLEX_SUBMINOR_VERSION 39</code><br />
            </span>
            
            <span class="none">
            <code>| #if YY_FLEX_SUBMINOR_VERSION > 0</code><br />
            </span>
            
            <span class="none">
            <code>| #define FLEX_BETA</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* First, we deal with  platform-specific or compiler-specific issues. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* begin standard C headers. */</code><br />
            </span>
            
            <span class="none">
            <code>| #include <stdio.h></code><br />
            </span>
            
            <span class="none">
            <code>| #include <string.h></code><br />
            </span>
            
            <span class="none">
            <code>| #include <errno.h></code><br />
            </span>
            
            <span class="none">
            <code>| #include <stdlib.h></code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* end standard C headers. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* flex integer type definitions */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef FLEXINT_H</code><br />
            </span>
            
            <span class="none">
            <code>| #define FLEXINT_H</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,</code><br />
            </span>
            
            <span class="none">
            <code>|  * if you want the limit (max/min) macros for int types.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef __STDC_LIMIT_MACROS</code><br />
            </span>
            
            <span class="none">
            <code>| #define __STDC_LIMIT_MACROS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #include <inttypes.h></code><br />
            </span>
            
            <span class="none">
            <code>| typedef int8_t flex_int8_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef uint8_t flex_uint8_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef int16_t flex_int16_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef uint16_t flex_uint16_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef int32_t flex_int32_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef uint32_t flex_uint32_t;</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| typedef signed char flex_int8_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef short int flex_int16_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef int flex_int32_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef unsigned char flex_uint8_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef unsigned short int flex_uint16_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef unsigned int flex_uint32_t;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Limits of integral types. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT8_MIN</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT8_MIN               (-128)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT16_MIN</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT16_MIN              (-32767-1)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT32_MIN</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT32_MIN              (-2147483647-1)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT8_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT8_MAX               (127)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT16_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT16_MAX              (32767)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT32_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT32_MAX              (2147483647)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef UINT8_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define UINT8_MAX              (255U)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef UINT16_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define UINT16_MAX             (65535U)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef UINT32_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define UINT32_MAX             (4294967295U)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif /* ! C99 */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif /* ! FLEXINT_H */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* The "const" storage-class-modifier is valid. */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_USE_CONST</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #else	/* ! __cplusplus */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* C99 requires __STDC__ to be defined as 1. */</code><br />
            </span>
            
            <span class="none">
            <code>| #if defined (__STDC__)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_USE_CONST</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif	/* defined (__STDC__) */</code><br />
            </span>
            
            <span class="none">
            <code>| #endif	/* ! __cplusplus */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_USE_CONST</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyconst const</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyconst</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Returned upon end-of-file. */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_NULL 0</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Promotes a possibly negative, possibly signed char to an unsigned</code><br />
            </span>
            
            <span class="none">
            <code>|  * integer for use as an array index.  If the signed char is negative,</code><br />
            </span>
            
            <span class="none">
            <code>|  * we want to instead treat it as an 8-bit unsigned char, hence the</code><br />
            </span>
            
            <span class="none">
            <code>|  * double cast.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Enter a start condition.  This macro really ought to take a parameter,</code><br />
            </span>
            
            <span class="none">
            <code>|  * but we do it the disgusting crufty way forced on us by the ()-less</code><br />
            </span>
            
            <span class="none">
            <code>|  * definition of BEGIN.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define BEGIN (yy_start) = 1 + 2 *</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Translate the current start state into a value that can be later handed</code><br />
            </span>
            
            <span class="none">
            <code>|  * to BEGIN to return to the state.  The YYSTATE alias is for lex</code><br />
            </span>
            
            <span class="none">
            <code>|  * compatibility.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_START (((yy_start) - 1) / 2)</code><br />
            </span>
            
            <span class="none">
            <code>| #define YYSTATE YY_START</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Action number for EOF rule of a given start state. */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Special action meaning "start processing a new file". */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_NEW_FILE yyrestart(yyin  )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_END_OF_BUFFER_CHAR 0</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Size of default input buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_BUF_SIZE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BUF_SIZE 16384</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* The state buf must be large enough to hold one state per character in the main buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_TYPEDEF_YY_BUFFER_STATE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_TYPEDEF_YY_BUFFER_STATE</code><br />
            </span>
            
            <span class="none">
            <code>| typedef struct yy_buffer_state *YY_BUFFER_STATE;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_TYPEDEF_YY_SIZE_T</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_TYPEDEF_YY_SIZE_T</code><br />
            </span>
            
            <span class="none">
            <code>| typedef size_t yy_size_t;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern yy_size_t yyleng;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern FILE *yyin, *yyout;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define EOB_ACT_CONTINUE_SCAN 0</code><br />
            </span>
            
            <span class="none">
            <code>| #define EOB_ACT_END_OF_FILE 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define EOB_ACT_LAST_MATCH 2</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     #define YY_LESS_LINENO(n)</code><br />
            </span>
            
            <span class="none">
            <code>|     #define YY_LINENO_REWIND_TO(ptr)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Return all but the first "n" matched characters back to the input stream. */</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyless(n) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	do \</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Undo effects of setting up yytext. */ \</code><br />
            </span>
            
            <span class="none">
            <code>|         int yyless_macro_arg = (n); \</code><br />
            </span>
            
            <span class="none">
            <code>|         YY_LESS_LINENO(yyless_macro_arg);\</code><br />
            </span>
            
            <span class="none">
            <code>| 		*yy_cp = (yy_hold_char); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_RESTORE_YY_MORE_OFFSET \</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	while ( 0 )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define unput(c) yyunput( c, (yytext_ptr)  )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_STRUCT_YY_BUFFER_STATE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_STRUCT_YY_BUFFER_STATE</code><br />
            </span>
            
            <span class="none">
            <code>| struct yy_buffer_state</code><br />
            </span>
            
            <span class="none">
            <code>| 	{</code><br />
            </span>
            
            <span class="none">
            <code>| 	FILE *yy_input_file;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	char *yy_ch_buf;		/* input buffer */</code><br />
            </span>
            
            <span class="none">
            <code>| 	char *yy_buf_pos;		/* current position in input buffer */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Size of input buffer in bytes, not including room for EOB</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * characters.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t yy_buf_size;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Number of characters read into yy_ch_buf, not including EOB</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * characters.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t yy_n_chars;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Whether we "own" the buffer - i.e., we know we created it,</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * and can realloc() it to grow it, and should free() it to</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * delete it.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_is_our_buffer;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Whether this is an "interactive" input source; if so, and</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * if we're using stdio for input, then we want to use getc()</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * instead of fread(), to make sure we stop fetching input after</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * each newline.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_is_interactive;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Whether we're considered to be at the beginning of a line.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * If so, '^' rules will be active on the next match, otherwise</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * not.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_at_bol;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     int yy_bs_lineno; /**< The line count. */</code><br />
            </span>
            
            <span class="none">
            <code>|     int yy_bs_column; /**< The column count. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Whether to try to fill the input buffer when we reach the</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * end of it.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_fill_buffer;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_buffer_status;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BUFFER_NEW 0</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BUFFER_NORMAL 1</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* When an EOF's been seen but there's still some text to process</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * shouldn't try reading from the input source any more.  We might</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * still have a bunch of tokens to match, though, because of</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * possible backing-up.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 *</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * When we actually see the EOF, we change the status to "new"</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * (via yyrestart()), so that the user can continue scanning by</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * just pointing yyin at a new input file.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BUFFER_EOF_PENDING 2</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	};</code><br />
            </span>
            
            <span class="none">
            <code>| #endif /* !YY_STRUCT_YY_BUFFER_STATE */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Stack of input buffers. */</code><br />
            </span>
            
            <span class="none">
            <code>| static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */</code><br />
            </span>
            
            <span class="none">
            <code>| static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */</code><br />
            </span>
            
            <span class="none">
            <code>| static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* We provide macros for accessing buffer states in case in the</code><br />
            </span>
            
            <span class="none">
            <code>|  * future we want to put the buffer states in a more general</code><br />
            </span>
            
            <span class="none">
            <code>|  * "scanner state".</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * Returns the top of the stack, or NULL.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_CURRENT_BUFFER ( (yy_buffer_stack) \</code><br />
            </span>
            
            <span class="none">
            <code>|                           ? (yy_buffer_stack)[(yy_buffer_stack_top)] \</code><br />
            </span>
            
            <span class="none">
            <code>|                           : NULL)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Same as previous macro, but useful when we know that the buffer stack is not</code><br />
            </span>
            
            <span class="none">
            <code>|  * NULL or when we need an lvalue. For internal use only.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yy_hold_char holds the character lost when yytext is formed. */</code><br />
            </span>
            
            <span class="none">
            <code>| static char yy_hold_char;</code><br />
            </span>
            
            <span class="none">
            <code>| static yy_size_t yy_n_chars;		/* number of characters read into yy_ch_buf */</code><br />
            </span>
            
            <span class="none">
            <code>| yy_size_t yyleng;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Points to current character in buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| static char *yy_c_buf_p = (char *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_init = 0;		/* whether we need to initialize */</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_start = 0;	/* start state number */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Flag which is used to allow yywrap()'s to do buffer switches</code><br />
            </span>
            
            <span class="none">
            <code>|  * instead of setting up a fresh yyin.  A bit of a hack ...</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_did_buffer_switch_on_eof;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyrestart (FILE *input_file  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yy_delete_buffer (YY_BUFFER_STATE b  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yy_flush_buffer (YY_BUFFER_STATE b  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yypop_buffer_state (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static void yyensure_buffer_stack (void );</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_load_buffer_state (void );</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,yy_size_t len  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void *yyalloc (yy_size_t  );</code><br />
            </span>
            
            <span class="none">
            <code>| void *yyrealloc (void *,yy_size_t  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yyfree (void *  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define yy_new_buffer yy_create_buffer</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define yy_set_interactive(is_interactive) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! YY_CURRENT_BUFFER ){ \</code><br />
            </span>
            
            <span class="none">
            <code>|         yyensure_buffer_stack (); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE =    \</code><br />
            </span>
            
            <span class="none">
            <code>|             yy_create_buffer(yyin,YY_BUF_SIZE ); \</code><br />
            </span>
            
            <span class="none">
            <code>| 	} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define yy_set_bol(at_bol) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! YY_CURRENT_BUFFER ){\</code><br />
            </span>
            
            <span class="none">
            <code>|         yyensure_buffer_stack (); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE =    \</code><br />
            </span>
            
            <span class="none">
            <code>|             yy_create_buffer(yyin,YY_BUF_SIZE ); \</code><br />
            </span>
            
            <span class="none">
            <code>| 	} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Begin user sect3 */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| typedef unsigned char YY_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| typedef int yy_state_type;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern int yylineno;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yylineno = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern char *yytext;</code><br />
            </span>
            
            <span class="none">
            <code>| #define yytext_ptr yytext</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yy_state_type yy_get_previous_state (void );</code><br />
            </span>
            
            <span class="none">
            <code>| static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_get_next_buffer (void );</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_fatal_error (yyconst char msg[]  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Done after the current pattern has been matched and before the</code><br />
            </span>
            
            <span class="none">
            <code>|  * corresponding action - sets up yytext.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_DO_BEFORE_ACTION \</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) = yy_bp; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) -= (yy_more_len); \</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyleng = (size_t) (yy_cp - (yytext_ptr)); \</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_hold_char) = *yy_cp; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	*yy_cp = '\0'; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_c_buf_p) = yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_NUM_RULES 8</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_END_OF_BUFFER 9</code><br />
            </span>
            
            <span class="none">
            <code>| /* This struct is not used in this scanner,</code><br />
            </span>
            
            <span class="none">
            <code>|    but its presence is necessary. */</code><br />
            </span>
            
            <span class="none">
            <code>| struct yy_trans_info</code><br />
            </span>
            
            <span class="none">
            <code>| 	{</code><br />
            </span>
            
            <span class="none">
            <code>| 	flex_int32_t yy_verify;</code><br />
            </span>
            
            <span class="none">
            <code>| 	flex_int32_t yy_nxt;</code><br />
            </span>
            
            <span class="none">
            <code>| 	};</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_acclist[23] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         9,    7,    8,    8,    1,    7,    8,    2,    7,    8,</code><br />
            </span>
            
            <span class="none">
            <code>|         3,    7,    8,    4,    7,    8,    5,    7,    8,    6,</code><br />
            </span>
            
            <span class="none">
            <code>|         7,    8</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_accept[14] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    2,    4,    5,    8,   11,   14,   17,</code><br />
            </span>
            
            <span class="none">
            <code>|        20,   23,   23</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int32_t yy_ec[256] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    2,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    3,    4,    5,    6,</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|         7,    8,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int32_t yy_meta[9] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_base[13] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         0,    0,    9,   10,   10,   10,   10,   10,   10,   10,</code><br />
            </span>
            
            <span class="none">
            <code>|        10,   10</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_def[13] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|        12,    1,   12,   12,   12,   12,   12,   12,   12,   12,</code><br />
            </span>
            
            <span class="none">
            <code>|        12,    0</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_nxt[19] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         4,    5,    6,    7,    8,    9,   10,   11,   12,    3,</code><br />
            </span>
            
            <span class="none">
            <code>|        12,   12,   12,   12,   12,   12,   12,   12</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_chk[19] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    3,   12,</code><br />
            </span>
            
            <span class="none">
            <code>|        12,   12,   12,   12,   12,   12,   12,   12</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern int yy_flex_debug;</code><br />
            </span>
            
            <span class="none">
            <code>| int yy_flex_debug = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yy_state_type *yy_state_buf=0, *yy_state_ptr=0;</code><br />
            </span>
            
            <span class="none">
            <code>| static char *yy_full_match;</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_lp;</code><br />
            </span>
            
            <span class="none">
            <code>| #define REJECT \</code><br />
            </span>
            
            <span class="none">
            <code>| { \</code><br />
            </span>
            
            <span class="none">
            <code>| *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */ \</code><br />
            </span>
            
            <span class="none">
            <code>| yy_cp = (yy_full_match); /* restore poss. backed-over text */ \</code><br />
            </span>
            
            <span class="none">
            <code>| ++(yy_lp); \</code><br />
            </span>
            
            <span class="none">
            <code>| goto find_rule; \</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_more_flag = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_more_len = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| #define yymore() ((yy_more_flag) = 1)</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_MORE_ADJ (yy_more_len)</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_RESTORE_YY_MORE_OFFSET</code><br />
            </span>
            
            <span class="none">
            <code>| char *yytext;</code><br />
            </span>
            
            <span class="none">
            <code>| #line 1 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| #line 470 "lex.yy.c"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define INITIAL 0</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_NO_UNISTD_H</code><br />
            </span>
            
            <span class="none">
            <code>| /* Special case for "unistd.h", since it is non-ANSI. We include it way</code><br />
            </span>
            
            <span class="none">
            <code>|  * down here because we want the user's section 1 to have been scanned first.</code><br />
            </span>
            
            <span class="none">
            <code>|  * The user has a chance to override it with an option.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #include <unistd.h></code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_EXTRA_TYPE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_EXTRA_TYPE void *</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_init_globals (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Accessor methods to globals.</code><br />
            </span>
            
            <span class="none">
            <code>|    These are made visible to non-reentrant scanners for convenience. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yylex_destroy (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yyget_debug (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_debug (int debug_flag  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| YY_EXTRA_TYPE yyget_extra (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_extra (YY_EXTRA_TYPE user_defined  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyget_in (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_in  (FILE * in_str  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyget_out (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_out  (FILE * out_str  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| yy_size_t yyget_leng (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| char *yyget_text (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yyget_lineno (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_lineno (int line_number  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Macros after this point can all be overridden by user definitions in</code><br />
            </span>
            
            <span class="none">
            <code>|  * section 1.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_SKIP_YYWRAP</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>| extern "C" int yywrap (void );</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| extern int yywrap (void );</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     static void yyunput (int c,char *buf_ptr  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef yytext_ptr</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_flex_strncpy (char *,yyconst char *,int );</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_NEED_STRLEN</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_flex_strlen (yyconst char * );</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_NO_INPUT</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>| static int yyinput (void );</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| static int input (void );</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Amount of stuff to slurp up with each read. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_READ_BUF_SIZE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_READ_BUF_SIZE 8192</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Copy whatever the last rule matched to the standard output. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef ECHO</code><br />
            </span>
            
            <span class="none">
            <code>| /* This used to be an fputs(), but since the string might contain NUL's,</code><br />
            </span>
            
            <span class="none">
            <code>|  * we now use fwrite().</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,</code><br />
            </span>
            
            <span class="none">
            <code>|  * is returned in "result".</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_INPUT</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_INPUT(buf,result,max_size) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		int c = '*'; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		size_t n; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		for ( n = 0; n < max_size && \</code><br />
            </span>
            
            <span class="none">
            <code>| 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \</code><br />
            </span>
            
            <span class="none">
            <code>| 			buf[n] = (char) c; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( c == '\n' ) \</code><br />
            </span>
            
            <span class="none">
            <code>| 			buf[n++] = (char) c; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( c == EOF && ferror( yyin ) ) \</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "input in flex scanner failed" ); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		result = n; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	else \</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		errno=0; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \</code><br />
            </span>
            
            <span class="none">
            <code>| 			{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 			if( errno != EINTR) \</code><br />
            </span>
            
            <span class="none">
            <code>| 				{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 				YY_FATAL_ERROR( "input in flex scanner failed" ); \</code><br />
            </span>
            
            <span class="none">
            <code>| 				break; \</code><br />
            </span>
            
            <span class="none">
            <code>| 				} \</code><br />
            </span>
            
            <span class="none">
            <code>| 			errno=0; \</code><br />
            </span>
            
            <span class="none">
            <code>| 			clearerr(yyin); \</code><br />
            </span>
            
            <span class="none">
            <code>| 			} \</code><br />
            </span>
            
            <span class="none">
            <code>| 		}\</code><br />
            </span>
            
            <span class="none">
            <code>| \</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* No semi-colon after return; correct usage is to write "yyterminate();" -</code><br />
            </span>
            
            <span class="none">
            <code>|  * we don't want an extra ';' after the "return" because that will cause</code><br />
            </span>
            
            <span class="none">
            <code>|  * some compilers to complain about unreachable statements.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef yyterminate</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyterminate() return YY_NULL</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Number of entries by which start-condition stack grows. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_START_STACK_INCR</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_START_STACK_INCR 25</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Report a fatal error. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_FATAL_ERROR</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* end tables serialization structures and prototypes */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Default declaration of generated scanner - a define so the user can</code><br />
            </span>
            
            <span class="none">
            <code>|  * easily add parameters.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_DECL</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_DECL_IS_OURS 1</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern int yylex (void);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_DECL int yylex (void)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif /* !YY_DECL */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Code executed at the beginning of each rule, after yytext and yyleng</code><br />
            </span>
            
            <span class="none">
            <code>|  * have been set up.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_USER_ACTION</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_USER_ACTION</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Code executed at the end of each rule. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BREAK break;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_RULE_SETUP \</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_USER_ACTION</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** The main scanner function which does all the work.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| YY_DECL</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register yy_state_type yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 	register char *yy_cp, *yy_bp;</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int yy_act;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( !(yy_init) )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_init) = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_USER_INIT</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_USER_INIT;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|         /* Create the reject buffer large enough to save one state per allowed character. */</code><br />
            </span>
            
            <span class="none">
            <code>|         if ( ! (yy_state_buf) )</code><br />
            </span>
            
            <span class="none">
            <code>|             (yy_state_buf) = (yy_state_type *)yyalloc(YY_STATE_BUF_SIZE  );</code><br />
            </span>
            
            <span class="none">
            <code>|             if ( ! (yy_state_buf) )</code><br />
            </span>
            
            <span class="none">
            <code>|                 YY_FATAL_ERROR( "out of dynamic memory in yylex()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! (yy_start) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_start) = 1;	/* first start state */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! yyin )</code><br />
            </span>
            
            <span class="none">
            <code>| 			yyin = stdin;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! yyout )</code><br />
            </span>
            
            <span class="none">
            <code>| 			yyout = stdout;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! YY_CURRENT_BUFFER ) {</code><br />
            </span>
            
            <span class="none">
            <code>| 			yyensure_buffer_stack ();</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE =</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_create_buffer(yyin,YY_BUF_SIZE );</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	{</code><br />
            </span>
            
            <span class="none">
            <code>| #line 1 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #line 687 "lex.yy.c"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	while ( 1 )		/* loops until end-of-file is reached */</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_more_len) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( (yy_more_flag) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_more_len) = (yy_c_buf_p) - (yytext_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_more_flag) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Support of yytext. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		*yy_cp = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* yy_bp points to the position in yy_ch_buf of the start of</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * the current run.</code><br />
            </span>
            
            <span class="none">
            <code>| 		 */</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_bp = yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_current_state = (yy_start);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_state_ptr) = (yy_state_buf);</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| yy_match:</code><br />
            </span>
            
            <span class="none">
            <code>| 		do</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;</code><br />
            </span>
            
            <span class="none">
            <code>| 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_current_state = (int) yy_def[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| 				if ( yy_current_state >= 13 )</code><br />
            </span>
            
            <span class="none">
            <code>| 					yy_c = yy_meta[(unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 			*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 			++yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( yy_base[yy_current_state] != 10 );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| yy_find_action:</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_current_state = *--(yy_state_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_lp) = yy_accept[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| find_rule: /* we branch to this label when backing up */</code><br />
            </span>
            
            <span class="none">
            <code>| 		for ( ; ; ) /* until we find what rule we matched */</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			if ( (yy_lp) && (yy_lp) < yy_accept[yy_current_state + 1] )</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_act = yy_acclist[(yy_lp)];</code><br />
            </span>
            
            <span class="none">
            <code>| 					{</code><br />
            </span>
            
            <span class="none">
            <code>| 					(yy_full_match) = yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| 					break;</code><br />
            </span>
            
            <span class="none">
            <code>| 					}</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>| 			--yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_current_state = *--(yy_state_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_lp) = yy_accept[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_DO_BEFORE_ACTION;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| do_action:	/* This label is used only to access EOF actions. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		switch ( yy_act )</code><br />
            </span>
            
            <span class="none">
            <code>| 	{ /* beginning of action switch */</code><br />
            </span>
            
            <span class="none">
            <code>| case 1:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 2 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { ECHO; }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 2:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 3 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { REJECT; }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 3:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 4 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { yymore (); }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 4:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 5 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { yyless (1); }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 5:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 6 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { yyless (input () != 0); }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 6:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 7 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { unput (yytext[0]); }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 7:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 8 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { BEGIN INITIAL; }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 8:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 9 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| ECHO;</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| #line 793 "lex.yy.c"</code><br />
            </span>
            
            <span class="none">
            <code>| 			case YY_STATE_EOF(INITIAL):</code><br />
            </span>
            
            <span class="none">
            <code>| 				yyterminate();</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	case YY_END_OF_BUFFER:</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Amount of text matched not including the EOB char. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Undo the effects of YY_DO_BEFORE_ACTION. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		*yy_cp = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_RESTORE_YY_MORE_OFFSET</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* We're scanning a new file or input source.  It's</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * possible that this happened because the user</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * just pointed yyin at a new source and called</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * yylex().  If so, then we have to assure</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * consistency between YY_CURRENT_BUFFER and our</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * globals.  Here is the right place to do so, because</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * this is the first action (other than possibly a</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * back-up) that will match for the new input source.</code><br />
            </span>
            
            <span class="none">
            <code>| 			 */</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Note that here we test for yy_c_buf_p "<=" to the position</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * of the first EOB in the buffer, since yy_c_buf_p will</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * already have been incremented past the NUL character</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * (since all states make transitions on EOB to the</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * end-of-buffer state).  Contrast this with the test</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * in input().</code><br />
            </span>
            
            <span class="none">
            <code>| 		 */</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{ /* This was really a NUL. */</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_state_type yy_next_state;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_current_state = yy_get_previous_state(  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* Okay, we're now positioned to make the NUL</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * transition.  We couldn't have</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * yy_get_previous_state() go ahead and do it</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * for us because it doesn't know how to deal</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * with the possibility of jamming (and we don't</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * want to build jamming into it because then it</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * will run more slowly).</code><br />
            </span>
            
            <span class="none">
            <code>| 			 */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_next_state = yy_try_NUL_trans( yy_current_state );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_bp = (yytext_ptr) + YY_MORE_ADJ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			if ( yy_next_state )</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				/* Consume the NUL. */</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_cp = ++(yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_current_state = yy_next_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 				goto yy_match;</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			else</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 				goto yy_find_action;</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		else switch ( yy_get_next_buffer(  ) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			case EOB_ACT_END_OF_FILE:</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				(yy_did_buffer_switch_on_eof) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				if ( yywrap( ) )</code><br />
            </span>
            
            <span class="none">
            <code>| 					{</code><br />
            </span>
            
            <span class="none">
            <code>| 					/* Note: because we've taken care in</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * yy_get_next_buffer() to have set up</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * yytext, we can now set up</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * yy_c_buf_p so that if some total</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * hoser (like flex itself) wants to</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * call the scanner after we return the</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * YY_NULL, it'll still work - another</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * YY_NULL will get returned.</code><br />
            </span>
            
            <span class="none">
            <code>| 					 */</code><br />
            </span>
            
            <span class="none">
            <code>| 					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 					yy_act = YY_STATE_EOF(YY_START);</code><br />
            </span>
            
            <span class="none">
            <code>| 					goto do_action;</code><br />
            </span>
            
            <span class="none">
            <code>| 					}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				else</code><br />
            </span>
            
            <span class="none">
            <code>| 					{</code><br />
            </span>
            
            <span class="none">
            <code>| 					if ( ! (yy_did_buffer_switch_on_eof) )</code><br />
            </span>
            
            <span class="none">
            <code>| 						YY_NEW_FILE;</code><br />
            </span>
            
            <span class="none">
            <code>| 					}</code><br />
            </span>
            
            <span class="none">
            <code>| 				break;</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			case EOB_ACT_CONTINUE_SCAN:</code><br />
            </span>
            
            <span class="none">
            <code>| 				(yy_c_buf_p) =</code><br />
            </span>
            
            <span class="none">
            <code>| 					(yytext_ptr) + yy_amount_of_matched_text;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_current_state = yy_get_previous_state(  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;</code><br />
            </span>
            
            <span class="none">
            <code>| 				goto yy_match;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			case EOB_ACT_LAST_MATCH:</code><br />
            </span>
            
            <span class="none">
            <code>| 				(yy_c_buf_p) =</code><br />
            </span>
            
            <span class="none">
            <code>| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_current_state = yy_get_previous_state(  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;</code><br />
            </span>
            
            <span class="none">
            <code>| 				goto yy_find_action;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		break;</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	default:</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR(</code><br />
            </span>
            
            <span class="none">
            <code>| 			"fatal flex scanner internal error--no action found" );</code><br />
            </span>
            
            <span class="none">
            <code>| 	} /* end of action switch */</code><br />
            </span>
            
            <span class="none">
            <code>| 		} /* end of scanning one token */</code><br />
            </span>
            
            <span class="none">
            <code>| 	} /* end of user's declarations */</code><br />
            </span>
            
            <span class="none">
            <code>| } /* end of yylex */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yy_get_next_buffer - try to read in a new buffer</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * Returns a code representing an action:</code><br />
            </span>
            
            <span class="none">
            <code>|  *	EOB_ACT_LAST_MATCH -</code><br />
            </span>
            
            <span class="none">
            <code>|  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position</code><br />
            </span>
            
            <span class="none">
            <code>|  *	EOB_ACT_END_OF_FILE - end of file</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_get_next_buffer (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;</code><br />
            </span>
            
            <span class="none">
            <code>| 	register char *source = (yytext_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int number_to_move, i;</code><br />
            </span>
            
            <span class="none">
            <code>| 	int ret_val;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR(</code><br />
            </span>
            
            <span class="none">
            <code>| 		"fatal flex scanner internal error--end of buffer missed" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ /* Don't try to fill the buffer, so this is an EOF. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* We matched a single character, the EOB, so</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * treat this as a final EOF.</code><br />
            </span>
            
            <span class="none">
            <code>| 			 */</code><br />
            </span>
            
            <span class="none">
            <code>| 			return EOB_ACT_END_OF_FILE;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		else</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* We matched some text prior to the EOB, first</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * process it.</code><br />
            </span>
            
            <span class="none">
            <code>| 			 */</code><br />
            </span>
            
            <span class="none">
            <code>| 			return EOB_ACT_LAST_MATCH;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Try to read more data. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* First move last chars to start of buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( i = 0; i < number_to_move; ++i )</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(dest++) = *(source++);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* don't do the read, it's not guaranteed to return an EOF,</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * just force an EOF</code><br />
            </span>
            
            <span class="none">
            <code>| 		 */</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	else</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_size_t num_to_read =</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( num_to_read <= 0 )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{ /* Not enough room in the buffer - grow it. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR(</code><br />
            </span>
            
            <span class="none">
            <code>| "input buffer overflow, can't enlarge buffer because scanner uses REJECT" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( num_to_read > YY_READ_BUF_SIZE )</code><br />
            </span>
            
            <span class="none">
            <code>| 			num_to_read = YY_READ_BUF_SIZE;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Read in more data. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_n_chars), num_to_read );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( (yy_n_chars) == 0 )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( number_to_move == YY_MORE_ADJ )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			ret_val = EOB_ACT_END_OF_FILE;</code><br />
            </span>
            
            <span class="none">
            <code>| 			yyrestart(yyin  );</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		else</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			ret_val = EOB_ACT_LAST_MATCH;</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =</code><br />
            </span>
            
            <span class="none">
            <code>| 				YY_BUFFER_EOF_PENDING;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	else</code><br />
            </span>
            
            <span class="none">
            <code>| 		ret_val = EOB_ACT_CONTINUE_SCAN;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Extend the array by 50%, plus the number we really need. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_n_chars) += number_to_move;</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return ret_val;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yy_get_previous_state - get the state just before the EOB char was reached */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     static yy_state_type yy_get_previous_state (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register yy_state_type yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 	register char *yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_current_state = (yy_start);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_state_ptr) = (yy_state_buf);</code><br />
            </span>
            
            <span class="none">
            <code>| 	*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_current_state = (int) yy_def[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| 			if ( yy_current_state >= 13 )</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_c = yy_meta[(unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yy_try_NUL_trans - try to make a transition on the NUL character</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * synopsis</code><br />
            </span>
            
            <span class="none">
            <code>|  *	next_state = yy_try_NUL_trans( current_state );</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int yy_is_jam;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	register YY_CHAR yy_c = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_current_state = (int) yy_def[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( yy_current_state >= 13 )</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_c = yy_meta[(unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_is_jam = (yy_current_state == 12);</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! yy_is_jam )</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		return yy_is_jam ? 0 : yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     static void yyunput (int c, register char * yy_bp )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register char *yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* undo effects of setting up yytext */</code><br />
            </span>
            
            <span class="none">
            <code>| 	*yy_cp = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ /* need to shift things up to make room */</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* +2 for EOB chars. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		register yy_size_t number_to_move = (yy_n_chars) + 2;</code><br />
            </span>
            
            <span class="none">
            <code>| 		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[</code><br />
            </span>
            
            <span class="none">
            <code>| 					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];</code><br />
            </span>
            
            <span class="none">
            <code>| 		register char *source =</code><br />
            </span>
            
            <span class="none">
            <code>| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )</code><br />
            </span>
            
            <span class="none">
            <code>| 			*--dest = *--source;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_cp += (int) (dest - source);</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_bp += (int) (dest - source);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "flex scanner push-back overflow" );</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	*--yy_cp = (char) c;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) = yy_bp;</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_hold_char) = *yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_c_buf_p) = yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_NO_INPUT</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>|     static int yyinput (void)</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>|     static int input  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	int c;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	*(yy_c_buf_p) = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* yy_c_buf_p now points to the character we want to return.</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * If this occurs *before* the EOB characters, then it's a</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * valid NUL; if not, then we've hit the end of the buffer.</code><br />
            </span>
            
            <span class="none">
            <code>| 		 */</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* This was really a NUL. */</code><br />
            </span>
            
            <span class="none">
            <code>| 			*(yy_c_buf_p) = '\0';</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		else</code><br />
            </span>
            
            <span class="none">
            <code>| 			{ /* need more input */</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_size_t offset = (yy_c_buf_p) - (yytext_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 			++(yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			switch ( yy_get_next_buffer(  ) )</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				case EOB_ACT_LAST_MATCH:</code><br />
            </span>
            
            <span class="none">
            <code>| 					/* This happens because yy_g_n_b()</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * sees that we've accumulated a</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * token and flags that we need to</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * try matching the token before</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * proceeding.  But for input(),</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * there's no matching to consider.</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * So convert the EOB_ACT_LAST_MATCH</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * to EOB_ACT_END_OF_FILE.</code><br />
            </span>
            
            <span class="none">
            <code>| 					 */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 					/* Reset buffer status. */</code><br />
            </span>
            
            <span class="none">
            <code>| 					yyrestart(yyin );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 					/*FALLTHROUGH*/</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				case EOB_ACT_END_OF_FILE:</code><br />
            </span>
            
            <span class="none">
            <code>| 					{</code><br />
            </span>
            
            <span class="none">
            <code>| 					if ( yywrap( ) )</code><br />
            </span>
            
            <span class="none">
            <code>| 						return EOF;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 					if ( ! (yy_did_buffer_switch_on_eof) )</code><br />
            </span>
            
            <span class="none">
            <code>| 						YY_NEW_FILE;</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>| 					return yyinput();</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| 					return input();</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| 					}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				case EOB_ACT_CONTINUE_SCAN:</code><br />
            </span>
            
            <span class="none">
            <code>| 					(yy_c_buf_p) = (yytext_ptr) + offset;</code><br />
            </span>
            
            <span class="none">
            <code>| 					break;</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */</code><br />
            </span>
            
            <span class="none">
            <code>| 	*(yy_c_buf_p) = '\0';	/* preserve yytext */</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_hold_char) = *++(yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return c;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>| #endif	/* ifndef YY_NO_INPUT */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Immediately switch to a different input stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param input_file A readable stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @note This function does not reset the start condition to @c INITIAL .</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     void yyrestart  (FILE * input_file )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! YY_CURRENT_BUFFER ){</code><br />
            </span>
            
            <span class="none">
            <code>|         yyensure_buffer_stack ();</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE =</code><br />
            </span>
            
            <span class="none">
            <code>|             yy_create_buffer(yyin,YY_BUF_SIZE );</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_init_buffer(YY_CURRENT_BUFFER,input_file );</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Switch to a different input buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param new_buffer The new input buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* TODO. We should be able to replace this entire function body</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * with</code><br />
            </span>
            
            <span class="none">
            <code>| 	 *		yypop_buffer_state();</code><br />
            </span>
            
            <span class="none">
            <code>| 	 *		yypush_buffer_state(new_buffer);</code><br />
            </span>
            
            <span class="none">
            <code>|      */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyensure_buffer_stack ();</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER == new_buffer )</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Flush out information for old buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_c_buf_p) = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* We don't actually know whether we did this switch during</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * EOF (yywrap()) processing, but the only time this flag</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * is looked at is after yywrap() is called, so it's safe</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * to go ahead and always set it.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_did_buffer_switch_on_eof) = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_load_buffer_state  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_hold_char) = *(yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Allocate and initialize an input buffer state.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param file A readable stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @return the allocated buffer state.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BUFFER_STATE b;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buf_size = size;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* yy_ch_buf has to be 2 characters longer than the size given because</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * we need to put in 2 end-of-buffer characters.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b->yy_ch_buf )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_is_our_buffer = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_init_buffer(b,file );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return b;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Destroy the buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param b a buffer created with yy_create_buffer()</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     void yy_delete_buffer (YY_BUFFER_STATE  b )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( b->yy_is_our_buffer )</code><br />
            </span>
            
            <span class="none">
            <code>| 		yyfree((void *) b->yy_ch_buf  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyfree((void *) b  );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Initializes or reinitializes a buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * This function is sometimes called more than once on the same buffer,</code><br />
            </span>
            
            <span class="none">
            <code>|  * such as during a yyrestart() or at EOF.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	int oerrno = errno;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_flush_buffer(b );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_input_file = file;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_fill_buffer = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     /* If b is the current buffer, then yy_init_buffer was _probably_</code><br />
            </span>
            
            <span class="none">
            <code>|      * called from yyrestart() or through yy_get_next_buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|      * In that case, we don't want to reset the lineno or column.</code><br />
            </span>
            
            <span class="none">
            <code>|      */</code><br />
            </span>
            
            <span class="none">
            <code>|     if (b != YY_CURRENT_BUFFER){</code><br />
            </span>
            
            <span class="none">
            <code>|         b->yy_bs_lineno = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|         b->yy_bs_column = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|         b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	errno = oerrno;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Discard all buffered characters. On the next scan, YY_INPUT will be called.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     void yy_flush_buffer (YY_BUFFER_STATE  b )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_n_chars = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* We always need two end-of-buffer characters.  The first causes</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * a transition to the end-of-buffer state.  The second causes</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * a jam in that state.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buf_pos = &b->yy_ch_buf[0];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_at_bol = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buffer_status = YY_BUFFER_NEW;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( b == YY_CURRENT_BUFFER )</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Pushes the new state onto the stack. The new state becomes</code><br />
            </span>
            
            <span class="none">
            <code>|  *  the current state. This function will allocate the stack</code><br />
            </span>
            
            <span class="none">
            <code>|  *  if necessary.</code><br />
            </span>
            
            <span class="none">
            <code>|  *  @param new_buffer The new state.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| void yypush_buffer_state (YY_BUFFER_STATE new_buffer )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	if (new_buffer == NULL)</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyensure_buffer_stack();</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* This block is copied from yy_switch_to_buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Flush out information for old buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_c_buf_p) = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Only push if top exists. Otherwise, replace top. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	if (YY_CURRENT_BUFFER)</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack_top)++;</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* copied from yy_switch_to_buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_did_buffer_switch_on_eof) = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Removes and deletes the top of the stack, if present.</code><br />
            </span>
            
            <span class="none">
            <code>|  *  The next element becomes the new top.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| void yypop_buffer_state (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	if (!YY_CURRENT_BUFFER)</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_delete_buffer(YY_CURRENT_BUFFER );</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE = NULL;</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ((yy_buffer_stack_top) > 0)</code><br />
            </span>
            
            <span class="none">
            <code>| 		--(yy_buffer_stack_top);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if (YY_CURRENT_BUFFER) {</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_did_buffer_switch_on_eof) = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Allocates the stack if it does not exist.</code><br />
            </span>
            
            <span class="none">
            <code>|  *  Guarantees space for at least one push.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| static void yyensure_buffer_stack (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t num_to_alloc;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if (!(yy_buffer_stack)) {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* First allocation is just for 2 elements, since we don't know if this</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * scanner will even need a stack. We use 2 instead of 1 to avoid an</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * immediate realloc on the next call.</code><br />
            </span>
            
            <span class="none">
            <code>|          */</code><br />
            </span>
            
            <span class="none">
            <code>| 		num_to_alloc = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc</code><br />
            </span>
            
            <span class="none">
            <code>| 								(num_to_alloc * sizeof(struct yy_buffer_state*)</code><br />
            </span>
            
            <span class="none">
            <code>| 								);</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! (yy_buffer_stack) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack_max) = num_to_alloc;</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack_top) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Increase the buffer to prepare for a possible push. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		int grow_size = 8 /* arbitrary grow size */;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		num_to_alloc = (yy_buffer_stack_max) + grow_size;</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc</code><br />
            </span>
            
            <span class="none">
            <code>| 								((yy_buffer_stack),</code><br />
            </span>
            
            <span class="none">
            <code>| 								num_to_alloc * sizeof(struct yy_buffer_state*)</code><br />
            </span>
            
            <span class="none">
            <code>| 								);</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! (yy_buffer_stack) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* zero only the new slots.*/</code><br />
            </span>
            
            <span class="none">
            <code>| 		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack_max) = num_to_alloc;</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Setup the input buffer state to scan directly from a user-specified character buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param base the character buffer</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param size the size in bytes of the character buffer</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @return the newly allocated buffer state object.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BUFFER_STATE b;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( size < 2 ||</code><br />
            </span>
            
            <span class="none">
            <code>| 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||</code><br />
            </span>
            
            <span class="none">
            <code>| 	     base[size-1] != YY_END_OF_BUFFER_CHAR )</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* They forgot to leave room for the EOB's. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		return 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buf_pos = b->yy_ch_buf = base;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_is_our_buffer = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_input_file = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_n_chars = b->yy_buf_size;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_is_interactive = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_at_bol = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_fill_buffer = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buffer_status = YY_BUFFER_NEW;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_switch_to_buffer(b  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return b;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Setup the input buffer state to scan a string. The next call to yylex() will</code><br />
            </span>
            
            <span class="none">
            <code>|  * scan from a @e copy of @a str.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param yystr a NUL-terminated string to scan</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @return the newly allocated buffer state object.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @note If you want to scan bytes that may contain NUL values, then use</code><br />
            </span>
            
            <span class="none">
            <code>|  *       yy_scan_bytes() instead.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return yy_scan_bytes(yystr,strlen(yystr) );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Setup the input buffer state to scan the given bytes. The next call to yylex() will</code><br />
            </span>
            
            <span class="none">
            <code>|  * scan from a @e copy of @a bytes.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param yybytes the byte buffer to scan</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @return the newly allocated buffer state object.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BUFFER_STATE b;</code><br />
            </span>
            
            <span class="none">
            <code>| 	char *buf;</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t n;</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t i;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Get memory for full buffer, including space for trailing EOB's. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	n = _yybytes_len + 2;</code><br />
            </span>
            
            <span class="none">
            <code>| 	buf = (char *) yyalloc(n  );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! buf )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( i = 0; i < _yybytes_len; ++i )</code><br />
            </span>
            
            <span class="none">
            <code>| 		buf[i] = yybytes[i];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b = yy_scan_buffer(buf,n );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* It's okay to grow etc. this buffer, and we should throw it</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * away when we're done.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_is_our_buffer = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return b;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_EXIT_FAILURE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_EXIT_FAILURE 2</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_fatal_error (yyconst char* msg )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	(void) fprintf( stderr, "%s\n", msg );</code><br />
            </span>
            
            <span class="none">
            <code>| 	exit( YY_EXIT_FAILURE );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Redefine yyless() so it works in section 3 code. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #undef yyless</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyless(n) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	do \</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Undo effects of setting up yytext. */ \</code><br />
            </span>
            
            <span class="none">
            <code>|         int yyless_macro_arg = (n); \</code><br />
            </span>
            
            <span class="none">
            <code>|         YY_LESS_LINENO(yyless_macro_arg);\</code><br />
            </span>
            
            <span class="none">
            <code>| 		yytext[yyleng] = (yy_hold_char); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_c_buf_p) = yytext + yyless_macro_arg; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_hold_char) = *(yy_c_buf_p); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_c_buf_p) = '\0'; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		yyleng = yyless_macro_arg; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	while ( 0 )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Accessor  methods (get/set functions) to struct members. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the current line number.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| int yyget_lineno  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     return yylineno;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the input stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyget_in  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yyin;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the output stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyget_out  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yyout;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the length of the current token.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| yy_size_t yyget_leng  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yyleng;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the current token.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| char *yyget_text  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yytext;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Set the current line number.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param line_number</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_lineno (int  line_number )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     yylineno = line_number;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Set the input stream. This does not discard the current</code><br />
            </span>
            
            <span class="none">
            <code>|  * input buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param in_str A readable stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @see yy_switch_to_buffer</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_in (FILE *  in_str )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         yyin = in_str ;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_out (FILE *  out_str )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         yyout = out_str ;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yyget_debug  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yy_flex_debug;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_debug (int  bdebug )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         yy_flex_debug = bdebug ;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_init_globals (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         /* Initialization is the same as for the non-reentrant scanner.</code><br />
            </span>
            
            <span class="none">
            <code>|      * This function is called from yylex_destroy(), so don't allocate here.</code><br />
            </span>
            
            <span class="none">
            <code>|      */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_buffer_stack) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_buffer_stack_top) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_buffer_stack_max) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_c_buf_p) = (char *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_init) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_start) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_state_buf) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_state_ptr) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_full_match) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_lp) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Defined in main.c */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_STDINIT</code><br />
            </span>
            
            <span class="none">
            <code>|     yyin = stdin;</code><br />
            </span>
            
            <span class="none">
            <code>|     yyout = stdout;</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>|     yyin = (FILE *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     yyout = (FILE *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     /* For future reference: Set errno on error, since we are called by</code><br />
            </span>
            
            <span class="none">
            <code>|      * yylex_init()</code><br />
            </span>
            
            <span class="none">
            <code>|      */</code><br />
            </span>
            
            <span class="none">
            <code>|     return 0;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yylex_destroy is for both reentrant and non-reentrant scanners. */</code><br />
            </span>
            
            <span class="none">
            <code>| int yylex_destroy  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     /* Pop the buffer stack, destroying each element. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	while(YY_CURRENT_BUFFER){</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_delete_buffer(YY_CURRENT_BUFFER  );</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE = NULL;</code><br />
            </span>
            
            <span class="none">
            <code>| 		yypop_buffer_state();</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Destroy the stack itself. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyfree((yy_buffer_stack) );</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_buffer_stack) = NULL;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     yyfree ( (yy_state_buf) );</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_state_buf)  = NULL;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     /* Reset the globals. This is important in a non-reentrant scanner so the next time</code><br />
            </span>
            
            <span class="none">
            <code>|      * yylex() is called, initialization will occur. */</code><br />
            </span>
            
            <span class="none">
            <code>|     yy_init_globals( );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     return 0;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /*</code><br />
            </span>
            
            <span class="none">
            <code>|  * Internal utility routines.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef yytext_ptr</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int i;</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( i = 0; i < n; ++i )</code><br />
            </span>
            
            <span class="none">
            <code>| 		s1[i] = s2[i];</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_NEED_STRLEN</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_flex_strlen (yyconst char * s )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int n;</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( n = 0; s[n]; ++n )</code><br />
            </span>
            
            <span class="none">
            <code>| 		;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return n;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void *yyalloc (yy_size_t  size )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	return (void *) malloc( size );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void *yyrealloc  (void * ptr, yy_size_t  size )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* The cast to (char *) in the following accommodates both</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * implementations that use char* generic pointers, and those</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * that use void* generic pointers.  It works with the latter</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * because both ANSI C and C++ allow castless assignment from</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * any pointer type to void*, and deal with argument conversions</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * as though doing an assignment.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	return (void *) realloc( (char *) ptr, size );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyfree (void * ptr )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YYTABLES_NAME "yytables"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #line 9 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YYTEXT_POINTER</code><br />
            </span>
            
            <span class="none">
            <code>| extern char *yytext;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| int</code><br />
            </span>
            
            <span class="none">
            <code>| main (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|   return ! yylex () + ! yywrap ();</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>configure:3936: arm-linux-androideabi-gcc -o conftest    conftest.c -lfl  >&5</code><br />
            </span>
            
            <span class="error">
            <code>/toolchain_root/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld: error: cannot find -lfl</code><br />
            </span>
            
            <span class="error">
            <code>/tmp/ccMu4I1S.o:conftest.c:function yylex: error: undefined reference to 'yywrap'</code><br />
            </span>
            
            <span class="error">
            <code>/tmp/ccMu4I1S.o:conftest.c:function input: error: undefined reference to 'yywrap'</code><br />
            </span>
            
            <span class="error">
            <code>/tmp/ccMu4I1S.o:conftest.c:function main: error: undefined reference to 'yywrap'</code><br />
            </span>
            
            <span class="none">
            <code>collect2: error: ld returned 1 exit status</code><br />
            </span>
            
            <span class="none">
            <code>configure:3936: $? = 1</code><br />
            </span>
            
            <span class="none">
            <code>configure: failed program was:</code><br />
            </span>
            
            <span class="none">
            <code>| /* confdefs.h */</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_NAME "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_TARNAME "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_VERSION "2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_STRING "nickle 2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_BUGREPORT "http://nickle.org"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_URL ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define VERSION "2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| /* end confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #line 3 "lex.yy.c"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define  YY_INT_ALIGNED short int</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* A lexical scanner generated by flex */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define FLEX_SCANNER</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FLEX_MAJOR_VERSION 2</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FLEX_MINOR_VERSION 5</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FLEX_SUBMINOR_VERSION 39</code><br />
            </span>
            
            <span class="none">
            <code>| #if YY_FLEX_SUBMINOR_VERSION > 0</code><br />
            </span>
            
            <span class="none">
            <code>| #define FLEX_BETA</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* First, we deal with  platform-specific or compiler-specific issues. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* begin standard C headers. */</code><br />
            </span>
            
            <span class="none">
            <code>| #include <stdio.h></code><br />
            </span>
            
            <span class="none">
            <code>| #include <string.h></code><br />
            </span>
            
            <span class="none">
            <code>| #include <errno.h></code><br />
            </span>
            
            <span class="none">
            <code>| #include <stdlib.h></code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* end standard C headers. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* flex integer type definitions */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef FLEXINT_H</code><br />
            </span>
            
            <span class="none">
            <code>| #define FLEXINT_H</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,</code><br />
            </span>
            
            <span class="none">
            <code>|  * if you want the limit (max/min) macros for int types.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef __STDC_LIMIT_MACROS</code><br />
            </span>
            
            <span class="none">
            <code>| #define __STDC_LIMIT_MACROS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #include <inttypes.h></code><br />
            </span>
            
            <span class="none">
            <code>| typedef int8_t flex_int8_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef uint8_t flex_uint8_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef int16_t flex_int16_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef uint16_t flex_uint16_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef int32_t flex_int32_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef uint32_t flex_uint32_t;</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| typedef signed char flex_int8_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef short int flex_int16_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef int flex_int32_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef unsigned char flex_uint8_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef unsigned short int flex_uint16_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef unsigned int flex_uint32_t;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Limits of integral types. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT8_MIN</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT8_MIN               (-128)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT16_MIN</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT16_MIN              (-32767-1)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT32_MIN</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT32_MIN              (-2147483647-1)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT8_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT8_MAX               (127)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT16_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT16_MAX              (32767)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT32_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT32_MAX              (2147483647)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef UINT8_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define UINT8_MAX              (255U)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef UINT16_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define UINT16_MAX             (65535U)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef UINT32_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define UINT32_MAX             (4294967295U)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif /* ! C99 */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif /* ! FLEXINT_H */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* The "const" storage-class-modifier is valid. */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_USE_CONST</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #else	/* ! __cplusplus */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* C99 requires __STDC__ to be defined as 1. */</code><br />
            </span>
            
            <span class="none">
            <code>| #if defined (__STDC__)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_USE_CONST</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif	/* defined (__STDC__) */</code><br />
            </span>
            
            <span class="none">
            <code>| #endif	/* ! __cplusplus */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_USE_CONST</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyconst const</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyconst</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Returned upon end-of-file. */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_NULL 0</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Promotes a possibly negative, possibly signed char to an unsigned</code><br />
            </span>
            
            <span class="none">
            <code>|  * integer for use as an array index.  If the signed char is negative,</code><br />
            </span>
            
            <span class="none">
            <code>|  * we want to instead treat it as an 8-bit unsigned char, hence the</code><br />
            </span>
            
            <span class="none">
            <code>|  * double cast.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Enter a start condition.  This macro really ought to take a parameter,</code><br />
            </span>
            
            <span class="none">
            <code>|  * but we do it the disgusting crufty way forced on us by the ()-less</code><br />
            </span>
            
            <span class="none">
            <code>|  * definition of BEGIN.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define BEGIN (yy_start) = 1 + 2 *</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Translate the current start state into a value that can be later handed</code><br />
            </span>
            
            <span class="none">
            <code>|  * to BEGIN to return to the state.  The YYSTATE alias is for lex</code><br />
            </span>
            
            <span class="none">
            <code>|  * compatibility.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_START (((yy_start) - 1) / 2)</code><br />
            </span>
            
            <span class="none">
            <code>| #define YYSTATE YY_START</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Action number for EOF rule of a given start state. */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Special action meaning "start processing a new file". */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_NEW_FILE yyrestart(yyin  )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_END_OF_BUFFER_CHAR 0</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Size of default input buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_BUF_SIZE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BUF_SIZE 16384</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* The state buf must be large enough to hold one state per character in the main buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_TYPEDEF_YY_BUFFER_STATE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_TYPEDEF_YY_BUFFER_STATE</code><br />
            </span>
            
            <span class="none">
            <code>| typedef struct yy_buffer_state *YY_BUFFER_STATE;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_TYPEDEF_YY_SIZE_T</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_TYPEDEF_YY_SIZE_T</code><br />
            </span>
            
            <span class="none">
            <code>| typedef size_t yy_size_t;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern yy_size_t yyleng;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern FILE *yyin, *yyout;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define EOB_ACT_CONTINUE_SCAN 0</code><br />
            </span>
            
            <span class="none">
            <code>| #define EOB_ACT_END_OF_FILE 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define EOB_ACT_LAST_MATCH 2</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     #define YY_LESS_LINENO(n)</code><br />
            </span>
            
            <span class="none">
            <code>|     #define YY_LINENO_REWIND_TO(ptr)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Return all but the first "n" matched characters back to the input stream. */</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyless(n) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	do \</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Undo effects of setting up yytext. */ \</code><br />
            </span>
            
            <span class="none">
            <code>|         int yyless_macro_arg = (n); \</code><br />
            </span>
            
            <span class="none">
            <code>|         YY_LESS_LINENO(yyless_macro_arg);\</code><br />
            </span>
            
            <span class="none">
            <code>| 		*yy_cp = (yy_hold_char); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_RESTORE_YY_MORE_OFFSET \</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	while ( 0 )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define unput(c) yyunput( c, (yytext_ptr)  )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_STRUCT_YY_BUFFER_STATE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_STRUCT_YY_BUFFER_STATE</code><br />
            </span>
            
            <span class="none">
            <code>| struct yy_buffer_state</code><br />
            </span>
            
            <span class="none">
            <code>| 	{</code><br />
            </span>
            
            <span class="none">
            <code>| 	FILE *yy_input_file;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	char *yy_ch_buf;		/* input buffer */</code><br />
            </span>
            
            <span class="none">
            <code>| 	char *yy_buf_pos;		/* current position in input buffer */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Size of input buffer in bytes, not including room for EOB</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * characters.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t yy_buf_size;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Number of characters read into yy_ch_buf, not including EOB</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * characters.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t yy_n_chars;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Whether we "own" the buffer - i.e., we know we created it,</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * and can realloc() it to grow it, and should free() it to</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * delete it.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_is_our_buffer;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Whether this is an "interactive" input source; if so, and</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * if we're using stdio for input, then we want to use getc()</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * instead of fread(), to make sure we stop fetching input after</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * each newline.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_is_interactive;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Whether we're considered to be at the beginning of a line.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * If so, '^' rules will be active on the next match, otherwise</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * not.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_at_bol;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     int yy_bs_lineno; /**< The line count. */</code><br />
            </span>
            
            <span class="none">
            <code>|     int yy_bs_column; /**< The column count. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Whether to try to fill the input buffer when we reach the</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * end of it.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_fill_buffer;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_buffer_status;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BUFFER_NEW 0</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BUFFER_NORMAL 1</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* When an EOF's been seen but there's still some text to process</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * shouldn't try reading from the input source any more.  We might</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * still have a bunch of tokens to match, though, because of</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * possible backing-up.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 *</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * When we actually see the EOF, we change the status to "new"</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * (via yyrestart()), so that the user can continue scanning by</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * just pointing yyin at a new input file.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BUFFER_EOF_PENDING 2</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	};</code><br />
            </span>
            
            <span class="none">
            <code>| #endif /* !YY_STRUCT_YY_BUFFER_STATE */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Stack of input buffers. */</code><br />
            </span>
            
            <span class="none">
            <code>| static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */</code><br />
            </span>
            
            <span class="none">
            <code>| static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */</code><br />
            </span>
            
            <span class="none">
            <code>| static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* We provide macros for accessing buffer states in case in the</code><br />
            </span>
            
            <span class="none">
            <code>|  * future we want to put the buffer states in a more general</code><br />
            </span>
            
            <span class="none">
            <code>|  * "scanner state".</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * Returns the top of the stack, or NULL.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_CURRENT_BUFFER ( (yy_buffer_stack) \</code><br />
            </span>
            
            <span class="none">
            <code>|                           ? (yy_buffer_stack)[(yy_buffer_stack_top)] \</code><br />
            </span>
            
            <span class="none">
            <code>|                           : NULL)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Same as previous macro, but useful when we know that the buffer stack is not</code><br />
            </span>
            
            <span class="none">
            <code>|  * NULL or when we need an lvalue. For internal use only.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yy_hold_char holds the character lost when yytext is formed. */</code><br />
            </span>
            
            <span class="none">
            <code>| static char yy_hold_char;</code><br />
            </span>
            
            <span class="none">
            <code>| static yy_size_t yy_n_chars;		/* number of characters read into yy_ch_buf */</code><br />
            </span>
            
            <span class="none">
            <code>| yy_size_t yyleng;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Points to current character in buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| static char *yy_c_buf_p = (char *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_init = 0;		/* whether we need to initialize */</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_start = 0;	/* start state number */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Flag which is used to allow yywrap()'s to do buffer switches</code><br />
            </span>
            
            <span class="none">
            <code>|  * instead of setting up a fresh yyin.  A bit of a hack ...</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_did_buffer_switch_on_eof;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyrestart (FILE *input_file  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yy_delete_buffer (YY_BUFFER_STATE b  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yy_flush_buffer (YY_BUFFER_STATE b  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yypop_buffer_state (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static void yyensure_buffer_stack (void );</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_load_buffer_state (void );</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,yy_size_t len  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void *yyalloc (yy_size_t  );</code><br />
            </span>
            
            <span class="none">
            <code>| void *yyrealloc (void *,yy_size_t  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yyfree (void *  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define yy_new_buffer yy_create_buffer</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define yy_set_interactive(is_interactive) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! YY_CURRENT_BUFFER ){ \</code><br />
            </span>
            
            <span class="none">
            <code>|         yyensure_buffer_stack (); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE =    \</code><br />
            </span>
            
            <span class="none">
            <code>|             yy_create_buffer(yyin,YY_BUF_SIZE ); \</code><br />
            </span>
            
            <span class="none">
            <code>| 	} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define yy_set_bol(at_bol) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! YY_CURRENT_BUFFER ){\</code><br />
            </span>
            
            <span class="none">
            <code>|         yyensure_buffer_stack (); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE =    \</code><br />
            </span>
            
            <span class="none">
            <code>|             yy_create_buffer(yyin,YY_BUF_SIZE ); \</code><br />
            </span>
            
            <span class="none">
            <code>| 	} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Begin user sect3 */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| typedef unsigned char YY_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| typedef int yy_state_type;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern int yylineno;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yylineno = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern char *yytext;</code><br />
            </span>
            
            <span class="none">
            <code>| #define yytext_ptr yytext</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yy_state_type yy_get_previous_state (void );</code><br />
            </span>
            
            <span class="none">
            <code>| static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_get_next_buffer (void );</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_fatal_error (yyconst char msg[]  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Done after the current pattern has been matched and before the</code><br />
            </span>
            
            <span class="none">
            <code>|  * corresponding action - sets up yytext.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_DO_BEFORE_ACTION \</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) = yy_bp; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) -= (yy_more_len); \</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyleng = (size_t) (yy_cp - (yytext_ptr)); \</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_hold_char) = *yy_cp; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	*yy_cp = '\0'; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_c_buf_p) = yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_NUM_RULES 8</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_END_OF_BUFFER 9</code><br />
            </span>
            
            <span class="none">
            <code>| /* This struct is not used in this scanner,</code><br />
            </span>
            
            <span class="none">
            <code>|    but its presence is necessary. */</code><br />
            </span>
            
            <span class="none">
            <code>| struct yy_trans_info</code><br />
            </span>
            
            <span class="none">
            <code>| 	{</code><br />
            </span>
            
            <span class="none">
            <code>| 	flex_int32_t yy_verify;</code><br />
            </span>
            
            <span class="none">
            <code>| 	flex_int32_t yy_nxt;</code><br />
            </span>
            
            <span class="none">
            <code>| 	};</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_acclist[23] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         9,    7,    8,    8,    1,    7,    8,    2,    7,    8,</code><br />
            </span>
            
            <span class="none">
            <code>|         3,    7,    8,    4,    7,    8,    5,    7,    8,    6,</code><br />
            </span>
            
            <span class="none">
            <code>|         7,    8</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_accept[14] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    2,    4,    5,    8,   11,   14,   17,</code><br />
            </span>
            
            <span class="none">
            <code>|        20,   23,   23</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int32_t yy_ec[256] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    2,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    3,    4,    5,    6,</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|         7,    8,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int32_t yy_meta[9] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_base[13] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         0,    0,    9,   10,   10,   10,   10,   10,   10,   10,</code><br />
            </span>
            
            <span class="none">
            <code>|        10,   10</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_def[13] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|        12,    1,   12,   12,   12,   12,   12,   12,   12,   12,</code><br />
            </span>
            
            <span class="none">
            <code>|        12,    0</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_nxt[19] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         4,    5,    6,    7,    8,    9,   10,   11,   12,    3,</code><br />
            </span>
            
            <span class="none">
            <code>|        12,   12,   12,   12,   12,   12,   12,   12</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_chk[19] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    3,   12,</code><br />
            </span>
            
            <span class="none">
            <code>|        12,   12,   12,   12,   12,   12,   12,   12</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern int yy_flex_debug;</code><br />
            </span>
            
            <span class="none">
            <code>| int yy_flex_debug = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yy_state_type *yy_state_buf=0, *yy_state_ptr=0;</code><br />
            </span>
            
            <span class="none">
            <code>| static char *yy_full_match;</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_lp;</code><br />
            </span>
            
            <span class="none">
            <code>| #define REJECT \</code><br />
            </span>
            
            <span class="none">
            <code>| { \</code><br />
            </span>
            
            <span class="none">
            <code>| *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */ \</code><br />
            </span>
            
            <span class="none">
            <code>| yy_cp = (yy_full_match); /* restore poss. backed-over text */ \</code><br />
            </span>
            
            <span class="none">
            <code>| ++(yy_lp); \</code><br />
            </span>
            
            <span class="none">
            <code>| goto find_rule; \</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_more_flag = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_more_len = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| #define yymore() ((yy_more_flag) = 1)</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_MORE_ADJ (yy_more_len)</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_RESTORE_YY_MORE_OFFSET</code><br />
            </span>
            
            <span class="none">
            <code>| char *yytext;</code><br />
            </span>
            
            <span class="none">
            <code>| #line 1 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| #line 470 "lex.yy.c"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define INITIAL 0</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_NO_UNISTD_H</code><br />
            </span>
            
            <span class="none">
            <code>| /* Special case for "unistd.h", since it is non-ANSI. We include it way</code><br />
            </span>
            
            <span class="none">
            <code>|  * down here because we want the user's section 1 to have been scanned first.</code><br />
            </span>
            
            <span class="none">
            <code>|  * The user has a chance to override it with an option.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #include <unistd.h></code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_EXTRA_TYPE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_EXTRA_TYPE void *</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_init_globals (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Accessor methods to globals.</code><br />
            </span>
            
            <span class="none">
            <code>|    These are made visible to non-reentrant scanners for convenience. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yylex_destroy (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yyget_debug (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_debug (int debug_flag  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| YY_EXTRA_TYPE yyget_extra (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_extra (YY_EXTRA_TYPE user_defined  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyget_in (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_in  (FILE * in_str  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyget_out (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_out  (FILE * out_str  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| yy_size_t yyget_leng (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| char *yyget_text (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yyget_lineno (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_lineno (int line_number  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Macros after this point can all be overridden by user definitions in</code><br />
            </span>
            
            <span class="none">
            <code>|  * section 1.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_SKIP_YYWRAP</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>| extern "C" int yywrap (void );</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| extern int yywrap (void );</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     static void yyunput (int c,char *buf_ptr  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef yytext_ptr</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_flex_strncpy (char *,yyconst char *,int );</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_NEED_STRLEN</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_flex_strlen (yyconst char * );</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_NO_INPUT</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>| static int yyinput (void );</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| static int input (void );</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Amount of stuff to slurp up with each read. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_READ_BUF_SIZE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_READ_BUF_SIZE 8192</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Copy whatever the last rule matched to the standard output. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef ECHO</code><br />
            </span>
            
            <span class="none">
            <code>| /* This used to be an fputs(), but since the string might contain NUL's,</code><br />
            </span>
            
            <span class="none">
            <code>|  * we now use fwrite().</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,</code><br />
            </span>
            
            <span class="none">
            <code>|  * is returned in "result".</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_INPUT</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_INPUT(buf,result,max_size) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		int c = '*'; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		size_t n; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		for ( n = 0; n < max_size && \</code><br />
            </span>
            
            <span class="none">
            <code>| 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \</code><br />
            </span>
            
            <span class="none">
            <code>| 			buf[n] = (char) c; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( c == '\n' ) \</code><br />
            </span>
            
            <span class="none">
            <code>| 			buf[n++] = (char) c; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( c == EOF && ferror( yyin ) ) \</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "input in flex scanner failed" ); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		result = n; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	else \</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		errno=0; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \</code><br />
            </span>
            
            <span class="none">
            <code>| 			{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 			if( errno != EINTR) \</code><br />
            </span>
            
            <span class="none">
            <code>| 				{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 				YY_FATAL_ERROR( "input in flex scanner failed" ); \</code><br />
            </span>
            
            <span class="none">
            <code>| 				break; \</code><br />
            </span>
            
            <span class="none">
            <code>| 				} \</code><br />
            </span>
            
            <span class="none">
            <code>| 			errno=0; \</code><br />
            </span>
            
            <span class="none">
            <code>| 			clearerr(yyin); \</code><br />
            </span>
            
            <span class="none">
            <code>| 			} \</code><br />
            </span>
            
            <span class="none">
            <code>| 		}\</code><br />
            </span>
            
            <span class="none">
            <code>| \</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* No semi-colon after return; correct usage is to write "yyterminate();" -</code><br />
            </span>
            
            <span class="none">
            <code>|  * we don't want an extra ';' after the "return" because that will cause</code><br />
            </span>
            
            <span class="none">
            <code>|  * some compilers to complain about unreachable statements.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef yyterminate</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyterminate() return YY_NULL</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Number of entries by which start-condition stack grows. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_START_STACK_INCR</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_START_STACK_INCR 25</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Report a fatal error. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_FATAL_ERROR</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* end tables serialization structures and prototypes */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Default declaration of generated scanner - a define so the user can</code><br />
            </span>
            
            <span class="none">
            <code>|  * easily add parameters.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_DECL</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_DECL_IS_OURS 1</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern int yylex (void);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_DECL int yylex (void)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif /* !YY_DECL */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Code executed at the beginning of each rule, after yytext and yyleng</code><br />
            </span>
            
            <span class="none">
            <code>|  * have been set up.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_USER_ACTION</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_USER_ACTION</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Code executed at the end of each rule. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BREAK break;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_RULE_SETUP \</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_USER_ACTION</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** The main scanner function which does all the work.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| YY_DECL</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register yy_state_type yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 	register char *yy_cp, *yy_bp;</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int yy_act;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( !(yy_init) )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_init) = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_USER_INIT</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_USER_INIT;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|         /* Create the reject buffer large enough to save one state per allowed character. */</code><br />
            </span>
            
            <span class="none">
            <code>|         if ( ! (yy_state_buf) )</code><br />
            </span>
            
            <span class="none">
            <code>|             (yy_state_buf) = (yy_state_type *)yyalloc(YY_STATE_BUF_SIZE  );</code><br />
            </span>
            
            <span class="none">
            <code>|             if ( ! (yy_state_buf) )</code><br />
            </span>
            
            <span class="none">
            <code>|                 YY_FATAL_ERROR( "out of dynamic memory in yylex()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! (yy_start) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_start) = 1;	/* first start state */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! yyin )</code><br />
            </span>
            
            <span class="none">
            <code>| 			yyin = stdin;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! yyout )</code><br />
            </span>
            
            <span class="none">
            <code>| 			yyout = stdout;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! YY_CURRENT_BUFFER ) {</code><br />
            </span>
            
            <span class="none">
            <code>| 			yyensure_buffer_stack ();</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE =</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_create_buffer(yyin,YY_BUF_SIZE );</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	{</code><br />
            </span>
            
            <span class="none">
            <code>| #line 1 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #line 687 "lex.yy.c"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	while ( 1 )		/* loops until end-of-file is reached */</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_more_len) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( (yy_more_flag) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_more_len) = (yy_c_buf_p) - (yytext_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_more_flag) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Support of yytext. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		*yy_cp = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* yy_bp points to the position in yy_ch_buf of the start of</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * the current run.</code><br />
            </span>
            
            <span class="none">
            <code>| 		 */</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_bp = yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_current_state = (yy_start);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_state_ptr) = (yy_state_buf);</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| yy_match:</code><br />
            </span>
            
            <span class="none">
            <code>| 		do</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;</code><br />
            </span>
            
            <span class="none">
            <code>| 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_current_state = (int) yy_def[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| 				if ( yy_current_state >= 13 )</code><br />
            </span>
            
            <span class="none">
            <code>| 					yy_c = yy_meta[(unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 			*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 			++yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( yy_base[yy_current_state] != 10 );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| yy_find_action:</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_current_state = *--(yy_state_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_lp) = yy_accept[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| find_rule: /* we branch to this label when backing up */</code><br />
            </span>
            
            <span class="none">
            <code>| 		for ( ; ; ) /* until we find what rule we matched */</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			if ( (yy_lp) && (yy_lp) < yy_accept[yy_current_state + 1] )</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_act = yy_acclist[(yy_lp)];</code><br />
            </span>
            
            <span class="none">
            <code>| 					{</code><br />
            </span>
            
            <span class="none">
            <code>| 					(yy_full_match) = yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| 					break;</code><br />
            </span>
            
            <span class="none">
            <code>| 					}</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>| 			--yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_current_state = *--(yy_state_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_lp) = yy_accept[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_DO_BEFORE_ACTION;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| do_action:	/* This label is used only to access EOF actions. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		switch ( yy_act )</code><br />
            </span>
            
            <span class="none">
            <code>| 	{ /* beginning of action switch */</code><br />
            </span>
            
            <span class="none">
            <code>| case 1:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 2 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { ECHO; }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 2:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 3 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { REJECT; }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 3:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 4 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { yymore (); }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 4:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 5 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { yyless (1); }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 5:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 6 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { yyless (input () != 0); }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 6:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 7 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { unput (yytext[0]); }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 7:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 8 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { BEGIN INITIAL; }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 8:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 9 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| ECHO;</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| #line 793 "lex.yy.c"</code><br />
            </span>
            
            <span class="none">
            <code>| 			case YY_STATE_EOF(INITIAL):</code><br />
            </span>
            
            <span class="none">
            <code>| 				yyterminate();</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	case YY_END_OF_BUFFER:</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Amount of text matched not including the EOB char. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Undo the effects of YY_DO_BEFORE_ACTION. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		*yy_cp = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_RESTORE_YY_MORE_OFFSET</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* We're scanning a new file or input source.  It's</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * possible that this happened because the user</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * just pointed yyin at a new source and called</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * yylex().  If so, then we have to assure</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * consistency between YY_CURRENT_BUFFER and our</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * globals.  Here is the right place to do so, because</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * this is the first action (other than possibly a</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * back-up) that will match for the new input source.</code><br />
            </span>
            
            <span class="none">
            <code>| 			 */</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Note that here we test for yy_c_buf_p "<=" to the position</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * of the first EOB in the buffer, since yy_c_buf_p will</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * already have been incremented past the NUL character</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * (since all states make transitions on EOB to the</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * end-of-buffer state).  Contrast this with the test</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * in input().</code><br />
            </span>
            
            <span class="none">
            <code>| 		 */</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{ /* This was really a NUL. */</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_state_type yy_next_state;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_current_state = yy_get_previous_state(  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* Okay, we're now positioned to make the NUL</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * transition.  We couldn't have</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * yy_get_previous_state() go ahead and do it</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * for us because it doesn't know how to deal</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * with the possibility of jamming (and we don't</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * want to build jamming into it because then it</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * will run more slowly).</code><br />
            </span>
            
            <span class="none">
            <code>| 			 */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_next_state = yy_try_NUL_trans( yy_current_state );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_bp = (yytext_ptr) + YY_MORE_ADJ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			if ( yy_next_state )</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				/* Consume the NUL. */</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_cp = ++(yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_current_state = yy_next_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 				goto yy_match;</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			else</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 				goto yy_find_action;</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		else switch ( yy_get_next_buffer(  ) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			case EOB_ACT_END_OF_FILE:</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				(yy_did_buffer_switch_on_eof) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				if ( yywrap( ) )</code><br />
            </span>
            
            <span class="none">
            <code>| 					{</code><br />
            </span>
            
            <span class="none">
            <code>| 					/* Note: because we've taken care in</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * yy_get_next_buffer() to have set up</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * yytext, we can now set up</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * yy_c_buf_p so that if some total</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * hoser (like flex itself) wants to</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * call the scanner after we return the</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * YY_NULL, it'll still work - another</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * YY_NULL will get returned.</code><br />
            </span>
            
            <span class="none">
            <code>| 					 */</code><br />
            </span>
            
            <span class="none">
            <code>| 					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 					yy_act = YY_STATE_EOF(YY_START);</code><br />
            </span>
            
            <span class="none">
            <code>| 					goto do_action;</code><br />
            </span>
            
            <span class="none">
            <code>| 					}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				else</code><br />
            </span>
            
            <span class="none">
            <code>| 					{</code><br />
            </span>
            
            <span class="none">
            <code>| 					if ( ! (yy_did_buffer_switch_on_eof) )</code><br />
            </span>
            
            <span class="none">
            <code>| 						YY_NEW_FILE;</code><br />
            </span>
            
            <span class="none">
            <code>| 					}</code><br />
            </span>
            
            <span class="none">
            <code>| 				break;</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			case EOB_ACT_CONTINUE_SCAN:</code><br />
            </span>
            
            <span class="none">
            <code>| 				(yy_c_buf_p) =</code><br />
            </span>
            
            <span class="none">
            <code>| 					(yytext_ptr) + yy_amount_of_matched_text;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_current_state = yy_get_previous_state(  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;</code><br />
            </span>
            
            <span class="none">
            <code>| 				goto yy_match;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			case EOB_ACT_LAST_MATCH:</code><br />
            </span>
            
            <span class="none">
            <code>| 				(yy_c_buf_p) =</code><br />
            </span>
            
            <span class="none">
            <code>| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_current_state = yy_get_previous_state(  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;</code><br />
            </span>
            
            <span class="none">
            <code>| 				goto yy_find_action;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		break;</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	default:</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR(</code><br />
            </span>
            
            <span class="none">
            <code>| 			"fatal flex scanner internal error--no action found" );</code><br />
            </span>
            
            <span class="none">
            <code>| 	} /* end of action switch */</code><br />
            </span>
            
            <span class="none">
            <code>| 		} /* end of scanning one token */</code><br />
            </span>
            
            <span class="none">
            <code>| 	} /* end of user's declarations */</code><br />
            </span>
            
            <span class="none">
            <code>| } /* end of yylex */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yy_get_next_buffer - try to read in a new buffer</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * Returns a code representing an action:</code><br />
            </span>
            
            <span class="none">
            <code>|  *	EOB_ACT_LAST_MATCH -</code><br />
            </span>
            
            <span class="none">
            <code>|  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position</code><br />
            </span>
            
            <span class="none">
            <code>|  *	EOB_ACT_END_OF_FILE - end of file</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_get_next_buffer (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;</code><br />
            </span>
            
            <span class="none">
            <code>| 	register char *source = (yytext_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int number_to_move, i;</code><br />
            </span>
            
            <span class="none">
            <code>| 	int ret_val;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR(</code><br />
            </span>
            
            <span class="none">
            <code>| 		"fatal flex scanner internal error--end of buffer missed" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ /* Don't try to fill the buffer, so this is an EOF. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* We matched a single character, the EOB, so</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * treat this as a final EOF.</code><br />
            </span>
            
            <span class="none">
            <code>| 			 */</code><br />
            </span>
            
            <span class="none">
            <code>| 			return EOB_ACT_END_OF_FILE;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		else</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* We matched some text prior to the EOB, first</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * process it.</code><br />
            </span>
            
            <span class="none">
            <code>| 			 */</code><br />
            </span>
            
            <span class="none">
            <code>| 			return EOB_ACT_LAST_MATCH;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Try to read more data. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* First move last chars to start of buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( i = 0; i < number_to_move; ++i )</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(dest++) = *(source++);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* don't do the read, it's not guaranteed to return an EOF,</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * just force an EOF</code><br />
            </span>
            
            <span class="none">
            <code>| 		 */</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	else</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_size_t num_to_read =</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( num_to_read <= 0 )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{ /* Not enough room in the buffer - grow it. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR(</code><br />
            </span>
            
            <span class="none">
            <code>| "input buffer overflow, can't enlarge buffer because scanner uses REJECT" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( num_to_read > YY_READ_BUF_SIZE )</code><br />
            </span>
            
            <span class="none">
            <code>| 			num_to_read = YY_READ_BUF_SIZE;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Read in more data. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_n_chars), num_to_read );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( (yy_n_chars) == 0 )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( number_to_move == YY_MORE_ADJ )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			ret_val = EOB_ACT_END_OF_FILE;</code><br />
            </span>
            
            <span class="none">
            <code>| 			yyrestart(yyin  );</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		else</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			ret_val = EOB_ACT_LAST_MATCH;</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =</code><br />
            </span>
            
            <span class="none">
            <code>| 				YY_BUFFER_EOF_PENDING;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	else</code><br />
            </span>
            
            <span class="none">
            <code>| 		ret_val = EOB_ACT_CONTINUE_SCAN;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Extend the array by 50%, plus the number we really need. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_n_chars) += number_to_move;</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return ret_val;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yy_get_previous_state - get the state just before the EOB char was reached */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     static yy_state_type yy_get_previous_state (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register yy_state_type yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 	register char *yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_current_state = (yy_start);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_state_ptr) = (yy_state_buf);</code><br />
            </span>
            
            <span class="none">
            <code>| 	*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_current_state = (int) yy_def[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| 			if ( yy_current_state >= 13 )</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_c = yy_meta[(unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yy_try_NUL_trans - try to make a transition on the NUL character</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * synopsis</code><br />
            </span>
            
            <span class="none">
            <code>|  *	next_state = yy_try_NUL_trans( current_state );</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int yy_is_jam;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	register YY_CHAR yy_c = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_current_state = (int) yy_def[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( yy_current_state >= 13 )</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_c = yy_meta[(unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_is_jam = (yy_current_state == 12);</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! yy_is_jam )</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		return yy_is_jam ? 0 : yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     static void yyunput (int c, register char * yy_bp )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register char *yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* undo effects of setting up yytext */</code><br />
            </span>
            
            <span class="none">
            <code>| 	*yy_cp = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ /* need to shift things up to make room */</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* +2 for EOB chars. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		register yy_size_t number_to_move = (yy_n_chars) + 2;</code><br />
            </span>
            
            <span class="none">
            <code>| 		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[</code><br />
            </span>
            
            <span class="none">
            <code>| 					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];</code><br />
            </span>
            
            <span class="none">
            <code>| 		register char *source =</code><br />
            </span>
            
            <span class="none">
            <code>| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )</code><br />
            </span>
            
            <span class="none">
            <code>| 			*--dest = *--source;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_cp += (int) (dest - source);</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_bp += (int) (dest - source);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "flex scanner push-back overflow" );</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	*--yy_cp = (char) c;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) = yy_bp;</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_hold_char) = *yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_c_buf_p) = yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_NO_INPUT</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>|     static int yyinput (void)</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>|     static int input  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	int c;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	*(yy_c_buf_p) = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* yy_c_buf_p now points to the character we want to return.</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * If this occurs *before* the EOB characters, then it's a</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * valid NUL; if not, then we've hit the end of the buffer.</code><br />
            </span>
            
            <span class="none">
            <code>| 		 */</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* This was really a NUL. */</code><br />
            </span>
            
            <span class="none">
            <code>| 			*(yy_c_buf_p) = '\0';</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		else</code><br />
            </span>
            
            <span class="none">
            <code>| 			{ /* need more input */</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_size_t offset = (yy_c_buf_p) - (yytext_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 			++(yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			switch ( yy_get_next_buffer(  ) )</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				case EOB_ACT_LAST_MATCH:</code><br />
            </span>
            
            <span class="none">
            <code>| 					/* This happens because yy_g_n_b()</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * sees that we've accumulated a</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * token and flags that we need to</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * try matching the token before</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * proceeding.  But for input(),</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * there's no matching to consider.</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * So convert the EOB_ACT_LAST_MATCH</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * to EOB_ACT_END_OF_FILE.</code><br />
            </span>
            
            <span class="none">
            <code>| 					 */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 					/* Reset buffer status. */</code><br />
            </span>
            
            <span class="none">
            <code>| 					yyrestart(yyin );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 					/*FALLTHROUGH*/</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				case EOB_ACT_END_OF_FILE:</code><br />
            </span>
            
            <span class="none">
            <code>| 					{</code><br />
            </span>
            
            <span class="none">
            <code>| 					if ( yywrap( ) )</code><br />
            </span>
            
            <span class="none">
            <code>| 						return EOF;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 					if ( ! (yy_did_buffer_switch_on_eof) )</code><br />
            </span>
            
            <span class="none">
            <code>| 						YY_NEW_FILE;</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>| 					return yyinput();</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| 					return input();</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| 					}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				case EOB_ACT_CONTINUE_SCAN:</code><br />
            </span>
            
            <span class="none">
            <code>| 					(yy_c_buf_p) = (yytext_ptr) + offset;</code><br />
            </span>
            
            <span class="none">
            <code>| 					break;</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */</code><br />
            </span>
            
            <span class="none">
            <code>| 	*(yy_c_buf_p) = '\0';	/* preserve yytext */</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_hold_char) = *++(yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return c;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>| #endif	/* ifndef YY_NO_INPUT */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Immediately switch to a different input stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param input_file A readable stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @note This function does not reset the start condition to @c INITIAL .</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     void yyrestart  (FILE * input_file )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! YY_CURRENT_BUFFER ){</code><br />
            </span>
            
            <span class="none">
            <code>|         yyensure_buffer_stack ();</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE =</code><br />
            </span>
            
            <span class="none">
            <code>|             yy_create_buffer(yyin,YY_BUF_SIZE );</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_init_buffer(YY_CURRENT_BUFFER,input_file );</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Switch to a different input buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param new_buffer The new input buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* TODO. We should be able to replace this entire function body</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * with</code><br />
            </span>
            
            <span class="none">
            <code>| 	 *		yypop_buffer_state();</code><br />
            </span>
            
            <span class="none">
            <code>| 	 *		yypush_buffer_state(new_buffer);</code><br />
            </span>
            
            <span class="none">
            <code>|      */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyensure_buffer_stack ();</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER == new_buffer )</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Flush out information for old buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_c_buf_p) = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* We don't actually know whether we did this switch during</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * EOF (yywrap()) processing, but the only time this flag</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * is looked at is after yywrap() is called, so it's safe</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * to go ahead and always set it.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_did_buffer_switch_on_eof) = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_load_buffer_state  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_hold_char) = *(yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Allocate and initialize an input buffer state.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param file A readable stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @return the allocated buffer state.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BUFFER_STATE b;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buf_size = size;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* yy_ch_buf has to be 2 characters longer than the size given because</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * we need to put in 2 end-of-buffer characters.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b->yy_ch_buf )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_is_our_buffer = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_init_buffer(b,file );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return b;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Destroy the buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param b a buffer created with yy_create_buffer()</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     void yy_delete_buffer (YY_BUFFER_STATE  b )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( b->yy_is_our_buffer )</code><br />
            </span>
            
            <span class="none">
            <code>| 		yyfree((void *) b->yy_ch_buf  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyfree((void *) b  );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Initializes or reinitializes a buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * This function is sometimes called more than once on the same buffer,</code><br />
            </span>
            
            <span class="none">
            <code>|  * such as during a yyrestart() or at EOF.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	int oerrno = errno;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_flush_buffer(b );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_input_file = file;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_fill_buffer = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     /* If b is the current buffer, then yy_init_buffer was _probably_</code><br />
            </span>
            
            <span class="none">
            <code>|      * called from yyrestart() or through yy_get_next_buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|      * In that case, we don't want to reset the lineno or column.</code><br />
            </span>
            
            <span class="none">
            <code>|      */</code><br />
            </span>
            
            <span class="none">
            <code>|     if (b != YY_CURRENT_BUFFER){</code><br />
            </span>
            
            <span class="none">
            <code>|         b->yy_bs_lineno = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|         b->yy_bs_column = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|         b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	errno = oerrno;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Discard all buffered characters. On the next scan, YY_INPUT will be called.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     void yy_flush_buffer (YY_BUFFER_STATE  b )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_n_chars = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* We always need two end-of-buffer characters.  The first causes</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * a transition to the end-of-buffer state.  The second causes</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * a jam in that state.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buf_pos = &b->yy_ch_buf[0];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_at_bol = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buffer_status = YY_BUFFER_NEW;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( b == YY_CURRENT_BUFFER )</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Pushes the new state onto the stack. The new state becomes</code><br />
            </span>
            
            <span class="none">
            <code>|  *  the current state. This function will allocate the stack</code><br />
            </span>
            
            <span class="none">
            <code>|  *  if necessary.</code><br />
            </span>
            
            <span class="none">
            <code>|  *  @param new_buffer The new state.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| void yypush_buffer_state (YY_BUFFER_STATE new_buffer )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	if (new_buffer == NULL)</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyensure_buffer_stack();</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* This block is copied from yy_switch_to_buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Flush out information for old buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_c_buf_p) = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Only push if top exists. Otherwise, replace top. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	if (YY_CURRENT_BUFFER)</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack_top)++;</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* copied from yy_switch_to_buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_did_buffer_switch_on_eof) = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Removes and deletes the top of the stack, if present.</code><br />
            </span>
            
            <span class="none">
            <code>|  *  The next element becomes the new top.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| void yypop_buffer_state (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	if (!YY_CURRENT_BUFFER)</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_delete_buffer(YY_CURRENT_BUFFER );</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE = NULL;</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ((yy_buffer_stack_top) > 0)</code><br />
            </span>
            
            <span class="none">
            <code>| 		--(yy_buffer_stack_top);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if (YY_CURRENT_BUFFER) {</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_did_buffer_switch_on_eof) = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Allocates the stack if it does not exist.</code><br />
            </span>
            
            <span class="none">
            <code>|  *  Guarantees space for at least one push.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| static void yyensure_buffer_stack (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t num_to_alloc;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if (!(yy_buffer_stack)) {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* First allocation is just for 2 elements, since we don't know if this</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * scanner will even need a stack. We use 2 instead of 1 to avoid an</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * immediate realloc on the next call.</code><br />
            </span>
            
            <span class="none">
            <code>|          */</code><br />
            </span>
            
            <span class="none">
            <code>| 		num_to_alloc = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc</code><br />
            </span>
            
            <span class="none">
            <code>| 								(num_to_alloc * sizeof(struct yy_buffer_state*)</code><br />
            </span>
            
            <span class="none">
            <code>| 								);</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! (yy_buffer_stack) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack_max) = num_to_alloc;</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack_top) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Increase the buffer to prepare for a possible push. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		int grow_size = 8 /* arbitrary grow size */;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		num_to_alloc = (yy_buffer_stack_max) + grow_size;</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc</code><br />
            </span>
            
            <span class="none">
            <code>| 								((yy_buffer_stack),</code><br />
            </span>
            
            <span class="none">
            <code>| 								num_to_alloc * sizeof(struct yy_buffer_state*)</code><br />
            </span>
            
            <span class="none">
            <code>| 								);</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! (yy_buffer_stack) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* zero only the new slots.*/</code><br />
            </span>
            
            <span class="none">
            <code>| 		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack_max) = num_to_alloc;</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Setup the input buffer state to scan directly from a user-specified character buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param base the character buffer</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param size the size in bytes of the character buffer</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @return the newly allocated buffer state object.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BUFFER_STATE b;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( size < 2 ||</code><br />
            </span>
            
            <span class="none">
            <code>| 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||</code><br />
            </span>
            
            <span class="none">
            <code>| 	     base[size-1] != YY_END_OF_BUFFER_CHAR )</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* They forgot to leave room for the EOB's. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		return 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buf_pos = b->yy_ch_buf = base;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_is_our_buffer = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_input_file = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_n_chars = b->yy_buf_size;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_is_interactive = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_at_bol = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_fill_buffer = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buffer_status = YY_BUFFER_NEW;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_switch_to_buffer(b  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return b;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Setup the input buffer state to scan a string. The next call to yylex() will</code><br />
            </span>
            
            <span class="none">
            <code>|  * scan from a @e copy of @a str.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param yystr a NUL-terminated string to scan</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @return the newly allocated buffer state object.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @note If you want to scan bytes that may contain NUL values, then use</code><br />
            </span>
            
            <span class="none">
            <code>|  *       yy_scan_bytes() instead.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return yy_scan_bytes(yystr,strlen(yystr) );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Setup the input buffer state to scan the given bytes. The next call to yylex() will</code><br />
            </span>
            
            <span class="none">
            <code>|  * scan from a @e copy of @a bytes.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param yybytes the byte buffer to scan</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @return the newly allocated buffer state object.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BUFFER_STATE b;</code><br />
            </span>
            
            <span class="none">
            <code>| 	char *buf;</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t n;</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t i;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Get memory for full buffer, including space for trailing EOB's. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	n = _yybytes_len + 2;</code><br />
            </span>
            
            <span class="none">
            <code>| 	buf = (char *) yyalloc(n  );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! buf )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( i = 0; i < _yybytes_len; ++i )</code><br />
            </span>
            
            <span class="none">
            <code>| 		buf[i] = yybytes[i];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b = yy_scan_buffer(buf,n );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* It's okay to grow etc. this buffer, and we should throw it</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * away when we're done.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_is_our_buffer = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return b;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_EXIT_FAILURE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_EXIT_FAILURE 2</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_fatal_error (yyconst char* msg )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	(void) fprintf( stderr, "%s\n", msg );</code><br />
            </span>
            
            <span class="none">
            <code>| 	exit( YY_EXIT_FAILURE );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Redefine yyless() so it works in section 3 code. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #undef yyless</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyless(n) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	do \</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Undo effects of setting up yytext. */ \</code><br />
            </span>
            
            <span class="none">
            <code>|         int yyless_macro_arg = (n); \</code><br />
            </span>
            
            <span class="none">
            <code>|         YY_LESS_LINENO(yyless_macro_arg);\</code><br />
            </span>
            
            <span class="none">
            <code>| 		yytext[yyleng] = (yy_hold_char); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_c_buf_p) = yytext + yyless_macro_arg; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_hold_char) = *(yy_c_buf_p); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_c_buf_p) = '\0'; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		yyleng = yyless_macro_arg; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	while ( 0 )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Accessor  methods (get/set functions) to struct members. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the current line number.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| int yyget_lineno  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     return yylineno;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the input stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyget_in  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yyin;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the output stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyget_out  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yyout;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the length of the current token.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| yy_size_t yyget_leng  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yyleng;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the current token.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| char *yyget_text  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yytext;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Set the current line number.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param line_number</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_lineno (int  line_number )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     yylineno = line_number;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Set the input stream. This does not discard the current</code><br />
            </span>
            
            <span class="none">
            <code>|  * input buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param in_str A readable stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @see yy_switch_to_buffer</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_in (FILE *  in_str )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         yyin = in_str ;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_out (FILE *  out_str )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         yyout = out_str ;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yyget_debug  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yy_flex_debug;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_debug (int  bdebug )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         yy_flex_debug = bdebug ;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_init_globals (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         /* Initialization is the same as for the non-reentrant scanner.</code><br />
            </span>
            
            <span class="none">
            <code>|      * This function is called from yylex_destroy(), so don't allocate here.</code><br />
            </span>
            
            <span class="none">
            <code>|      */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_buffer_stack) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_buffer_stack_top) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_buffer_stack_max) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_c_buf_p) = (char *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_init) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_start) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_state_buf) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_state_ptr) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_full_match) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_lp) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Defined in main.c */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_STDINIT</code><br />
            </span>
            
            <span class="none">
            <code>|     yyin = stdin;</code><br />
            </span>
            
            <span class="none">
            <code>|     yyout = stdout;</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>|     yyin = (FILE *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     yyout = (FILE *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     /* For future reference: Set errno on error, since we are called by</code><br />
            </span>
            
            <span class="none">
            <code>|      * yylex_init()</code><br />
            </span>
            
            <span class="none">
            <code>|      */</code><br />
            </span>
            
            <span class="none">
            <code>|     return 0;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yylex_destroy is for both reentrant and non-reentrant scanners. */</code><br />
            </span>
            
            <span class="none">
            <code>| int yylex_destroy  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     /* Pop the buffer stack, destroying each element. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	while(YY_CURRENT_BUFFER){</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_delete_buffer(YY_CURRENT_BUFFER  );</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE = NULL;</code><br />
            </span>
            
            <span class="none">
            <code>| 		yypop_buffer_state();</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Destroy the stack itself. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyfree((yy_buffer_stack) );</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_buffer_stack) = NULL;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     yyfree ( (yy_state_buf) );</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_state_buf)  = NULL;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     /* Reset the globals. This is important in a non-reentrant scanner so the next time</code><br />
            </span>
            
            <span class="none">
            <code>|      * yylex() is called, initialization will occur. */</code><br />
            </span>
            
            <span class="none">
            <code>|     yy_init_globals( );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     return 0;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /*</code><br />
            </span>
            
            <span class="none">
            <code>|  * Internal utility routines.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef yytext_ptr</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int i;</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( i = 0; i < n; ++i )</code><br />
            </span>
            
            <span class="none">
            <code>| 		s1[i] = s2[i];</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_NEED_STRLEN</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_flex_strlen (yyconst char * s )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int n;</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( n = 0; s[n]; ++n )</code><br />
            </span>
            
            <span class="none">
            <code>| 		;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return n;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void *yyalloc (yy_size_t  size )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	return (void *) malloc( size );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void *yyrealloc  (void * ptr, yy_size_t  size )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* The cast to (char *) in the following accommodates both</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * implementations that use char* generic pointers, and those</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * that use void* generic pointers.  It works with the latter</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * because both ANSI C and C++ allow castless assignment from</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * any pointer type to void*, and deal with argument conversions</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * as though doing an assignment.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	return (void *) realloc( (char *) ptr, size );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyfree (void * ptr )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YYTABLES_NAME "yytables"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #line 9 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YYTEXT_POINTER</code><br />
            </span>
            
            <span class="none">
            <code>| extern char *yytext;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| int</code><br />
            </span>
            
            <span class="none">
            <code>| main (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|   return ! yylex () + ! yywrap ();</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>configure:3936: arm-linux-androideabi-gcc -o conftest    conftest.c -ll  >&5</code><br />
            </span>
            
            <span class="error">
            <code>/toolchain_root/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld: error: cannot find -ll</code><br />
            </span>
            
            <span class="error">
            <code>/tmp/ccw7Fl55.o:conftest.c:function yylex: error: undefined reference to 'yywrap'</code><br />
            </span>
            
            <span class="error">
            <code>/tmp/ccw7Fl55.o:conftest.c:function input: error: undefined reference to 'yywrap'</code><br />
            </span>
            
            <span class="error">
            <code>/tmp/ccw7Fl55.o:conftest.c:function main: error: undefined reference to 'yywrap'</code><br />
            </span>
            
            <span class="none">
            <code>collect2: error: ld returned 1 exit status</code><br />
            </span>
            
            <span class="none">
            <code>configure:3936: $? = 1</code><br />
            </span>
            
            <span class="none">
            <code>configure: failed program was:</code><br />
            </span>
            
            <span class="none">
            <code>| /* confdefs.h */</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_NAME "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_TARNAME "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_VERSION "2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_STRING "nickle 2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_BUGREPORT "http://nickle.org"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_URL ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define VERSION "2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| /* end confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #line 3 "lex.yy.c"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define  YY_INT_ALIGNED short int</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* A lexical scanner generated by flex */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define FLEX_SCANNER</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FLEX_MAJOR_VERSION 2</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FLEX_MINOR_VERSION 5</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FLEX_SUBMINOR_VERSION 39</code><br />
            </span>
            
            <span class="none">
            <code>| #if YY_FLEX_SUBMINOR_VERSION > 0</code><br />
            </span>
            
            <span class="none">
            <code>| #define FLEX_BETA</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* First, we deal with  platform-specific or compiler-specific issues. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* begin standard C headers. */</code><br />
            </span>
            
            <span class="none">
            <code>| #include <stdio.h></code><br />
            </span>
            
            <span class="none">
            <code>| #include <string.h></code><br />
            </span>
            
            <span class="none">
            <code>| #include <errno.h></code><br />
            </span>
            
            <span class="none">
            <code>| #include <stdlib.h></code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* end standard C headers. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* flex integer type definitions */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef FLEXINT_H</code><br />
            </span>
            
            <span class="none">
            <code>| #define FLEXINT_H</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,</code><br />
            </span>
            
            <span class="none">
            <code>|  * if you want the limit (max/min) macros for int types.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef __STDC_LIMIT_MACROS</code><br />
            </span>
            
            <span class="none">
            <code>| #define __STDC_LIMIT_MACROS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #include <inttypes.h></code><br />
            </span>
            
            <span class="none">
            <code>| typedef int8_t flex_int8_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef uint8_t flex_uint8_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef int16_t flex_int16_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef uint16_t flex_uint16_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef int32_t flex_int32_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef uint32_t flex_uint32_t;</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| typedef signed char flex_int8_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef short int flex_int16_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef int flex_int32_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef unsigned char flex_uint8_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef unsigned short int flex_uint16_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef unsigned int flex_uint32_t;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Limits of integral types. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT8_MIN</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT8_MIN               (-128)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT16_MIN</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT16_MIN              (-32767-1)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT32_MIN</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT32_MIN              (-2147483647-1)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT8_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT8_MAX               (127)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT16_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT16_MAX              (32767)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT32_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT32_MAX              (2147483647)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef UINT8_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define UINT8_MAX              (255U)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef UINT16_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define UINT16_MAX             (65535U)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef UINT32_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define UINT32_MAX             (4294967295U)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif /* ! C99 */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif /* ! FLEXINT_H */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* The "const" storage-class-modifier is valid. */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_USE_CONST</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #else	/* ! __cplusplus */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* C99 requires __STDC__ to be defined as 1. */</code><br />
            </span>
            
            <span class="none">
            <code>| #if defined (__STDC__)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_USE_CONST</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif	/* defined (__STDC__) */</code><br />
            </span>
            
            <span class="none">
            <code>| #endif	/* ! __cplusplus */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_USE_CONST</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyconst const</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyconst</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Returned upon end-of-file. */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_NULL 0</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Promotes a possibly negative, possibly signed char to an unsigned</code><br />
            </span>
            
            <span class="none">
            <code>|  * integer for use as an array index.  If the signed char is negative,</code><br />
            </span>
            
            <span class="none">
            <code>|  * we want to instead treat it as an 8-bit unsigned char, hence the</code><br />
            </span>
            
            <span class="none">
            <code>|  * double cast.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Enter a start condition.  This macro really ought to take a parameter,</code><br />
            </span>
            
            <span class="none">
            <code>|  * but we do it the disgusting crufty way forced on us by the ()-less</code><br />
            </span>
            
            <span class="none">
            <code>|  * definition of BEGIN.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define BEGIN (yy_start) = 1 + 2 *</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Translate the current start state into a value that can be later handed</code><br />
            </span>
            
            <span class="none">
            <code>|  * to BEGIN to return to the state.  The YYSTATE alias is for lex</code><br />
            </span>
            
            <span class="none">
            <code>|  * compatibility.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_START (((yy_start) - 1) / 2)</code><br />
            </span>
            
            <span class="none">
            <code>| #define YYSTATE YY_START</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Action number for EOF rule of a given start state. */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Special action meaning "start processing a new file". */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_NEW_FILE yyrestart(yyin  )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_END_OF_BUFFER_CHAR 0</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Size of default input buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_BUF_SIZE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BUF_SIZE 16384</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* The state buf must be large enough to hold one state per character in the main buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_TYPEDEF_YY_BUFFER_STATE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_TYPEDEF_YY_BUFFER_STATE</code><br />
            </span>
            
            <span class="none">
            <code>| typedef struct yy_buffer_state *YY_BUFFER_STATE;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_TYPEDEF_YY_SIZE_T</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_TYPEDEF_YY_SIZE_T</code><br />
            </span>
            
            <span class="none">
            <code>| typedef size_t yy_size_t;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern yy_size_t yyleng;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern FILE *yyin, *yyout;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define EOB_ACT_CONTINUE_SCAN 0</code><br />
            </span>
            
            <span class="none">
            <code>| #define EOB_ACT_END_OF_FILE 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define EOB_ACT_LAST_MATCH 2</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     #define YY_LESS_LINENO(n)</code><br />
            </span>
            
            <span class="none">
            <code>|     #define YY_LINENO_REWIND_TO(ptr)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Return all but the first "n" matched characters back to the input stream. */</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyless(n) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	do \</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Undo effects of setting up yytext. */ \</code><br />
            </span>
            
            <span class="none">
            <code>|         int yyless_macro_arg = (n); \</code><br />
            </span>
            
            <span class="none">
            <code>|         YY_LESS_LINENO(yyless_macro_arg);\</code><br />
            </span>
            
            <span class="none">
            <code>| 		*yy_cp = (yy_hold_char); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_RESTORE_YY_MORE_OFFSET \</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	while ( 0 )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define unput(c) yyunput( c, (yytext_ptr)  )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_STRUCT_YY_BUFFER_STATE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_STRUCT_YY_BUFFER_STATE</code><br />
            </span>
            
            <span class="none">
            <code>| struct yy_buffer_state</code><br />
            </span>
            
            <span class="none">
            <code>| 	{</code><br />
            </span>
            
            <span class="none">
            <code>| 	FILE *yy_input_file;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	char *yy_ch_buf;		/* input buffer */</code><br />
            </span>
            
            <span class="none">
            <code>| 	char *yy_buf_pos;		/* current position in input buffer */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Size of input buffer in bytes, not including room for EOB</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * characters.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t yy_buf_size;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Number of characters read into yy_ch_buf, not including EOB</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * characters.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t yy_n_chars;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Whether we "own" the buffer - i.e., we know we created it,</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * and can realloc() it to grow it, and should free() it to</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * delete it.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_is_our_buffer;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Whether this is an "interactive" input source; if so, and</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * if we're using stdio for input, then we want to use getc()</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * instead of fread(), to make sure we stop fetching input after</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * each newline.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_is_interactive;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Whether we're considered to be at the beginning of a line.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * If so, '^' rules will be active on the next match, otherwise</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * not.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_at_bol;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     int yy_bs_lineno; /**< The line count. */</code><br />
            </span>
            
            <span class="none">
            <code>|     int yy_bs_column; /**< The column count. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Whether to try to fill the input buffer when we reach the</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * end of it.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_fill_buffer;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_buffer_status;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BUFFER_NEW 0</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BUFFER_NORMAL 1</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* When an EOF's been seen but there's still some text to process</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * shouldn't try reading from the input source any more.  We might</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * still have a bunch of tokens to match, though, because of</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * possible backing-up.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 *</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * When we actually see the EOF, we change the status to "new"</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * (via yyrestart()), so that the user can continue scanning by</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * just pointing yyin at a new input file.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BUFFER_EOF_PENDING 2</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	};</code><br />
            </span>
            
            <span class="none">
            <code>| #endif /* !YY_STRUCT_YY_BUFFER_STATE */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Stack of input buffers. */</code><br />
            </span>
            
            <span class="none">
            <code>| static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */</code><br />
            </span>
            
            <span class="none">
            <code>| static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */</code><br />
            </span>
            
            <span class="none">
            <code>| static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* We provide macros for accessing buffer states in case in the</code><br />
            </span>
            
            <span class="none">
            <code>|  * future we want to put the buffer states in a more general</code><br />
            </span>
            
            <span class="none">
            <code>|  * "scanner state".</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * Returns the top of the stack, or NULL.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_CURRENT_BUFFER ( (yy_buffer_stack) \</code><br />
            </span>
            
            <span class="none">
            <code>|                           ? (yy_buffer_stack)[(yy_buffer_stack_top)] \</code><br />
            </span>
            
            <span class="none">
            <code>|                           : NULL)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Same as previous macro, but useful when we know that the buffer stack is not</code><br />
            </span>
            
            <span class="none">
            <code>|  * NULL or when we need an lvalue. For internal use only.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yy_hold_char holds the character lost when yytext is formed. */</code><br />
            </span>
            
            <span class="none">
            <code>| static char yy_hold_char;</code><br />
            </span>
            
            <span class="none">
            <code>| static yy_size_t yy_n_chars;		/* number of characters read into yy_ch_buf */</code><br />
            </span>
            
            <span class="none">
            <code>| yy_size_t yyleng;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Points to current character in buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| static char *yy_c_buf_p = (char *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_init = 0;		/* whether we need to initialize */</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_start = 0;	/* start state number */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Flag which is used to allow yywrap()'s to do buffer switches</code><br />
            </span>
            
            <span class="none">
            <code>|  * instead of setting up a fresh yyin.  A bit of a hack ...</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_did_buffer_switch_on_eof;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyrestart (FILE *input_file  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yy_delete_buffer (YY_BUFFER_STATE b  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yy_flush_buffer (YY_BUFFER_STATE b  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yypop_buffer_state (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static void yyensure_buffer_stack (void );</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_load_buffer_state (void );</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,yy_size_t len  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void *yyalloc (yy_size_t  );</code><br />
            </span>
            
            <span class="none">
            <code>| void *yyrealloc (void *,yy_size_t  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yyfree (void *  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define yy_new_buffer yy_create_buffer</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define yy_set_interactive(is_interactive) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! YY_CURRENT_BUFFER ){ \</code><br />
            </span>
            
            <span class="none">
            <code>|         yyensure_buffer_stack (); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE =    \</code><br />
            </span>
            
            <span class="none">
            <code>|             yy_create_buffer(yyin,YY_BUF_SIZE ); \</code><br />
            </span>
            
            <span class="none">
            <code>| 	} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define yy_set_bol(at_bol) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! YY_CURRENT_BUFFER ){\</code><br />
            </span>
            
            <span class="none">
            <code>|         yyensure_buffer_stack (); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE =    \</code><br />
            </span>
            
            <span class="none">
            <code>|             yy_create_buffer(yyin,YY_BUF_SIZE ); \</code><br />
            </span>
            
            <span class="none">
            <code>| 	} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Begin user sect3 */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| typedef unsigned char YY_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| typedef int yy_state_type;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern int yylineno;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yylineno = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern char *yytext;</code><br />
            </span>
            
            <span class="none">
            <code>| #define yytext_ptr yytext</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yy_state_type yy_get_previous_state (void );</code><br />
            </span>
            
            <span class="none">
            <code>| static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_get_next_buffer (void );</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_fatal_error (yyconst char msg[]  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Done after the current pattern has been matched and before the</code><br />
            </span>
            
            <span class="none">
            <code>|  * corresponding action - sets up yytext.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_DO_BEFORE_ACTION \</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) = yy_bp; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) -= (yy_more_len); \</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyleng = (size_t) (yy_cp - (yytext_ptr)); \</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_hold_char) = *yy_cp; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	*yy_cp = '\0'; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_c_buf_p) = yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_NUM_RULES 8</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_END_OF_BUFFER 9</code><br />
            </span>
            
            <span class="none">
            <code>| /* This struct is not used in this scanner,</code><br />
            </span>
            
            <span class="none">
            <code>|    but its presence is necessary. */</code><br />
            </span>
            
            <span class="none">
            <code>| struct yy_trans_info</code><br />
            </span>
            
            <span class="none">
            <code>| 	{</code><br />
            </span>
            
            <span class="none">
            <code>| 	flex_int32_t yy_verify;</code><br />
            </span>
            
            <span class="none">
            <code>| 	flex_int32_t yy_nxt;</code><br />
            </span>
            
            <span class="none">
            <code>| 	};</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_acclist[23] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         9,    7,    8,    8,    1,    7,    8,    2,    7,    8,</code><br />
            </span>
            
            <span class="none">
            <code>|         3,    7,    8,    4,    7,    8,    5,    7,    8,    6,</code><br />
            </span>
            
            <span class="none">
            <code>|         7,    8</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_accept[14] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    2,    4,    5,    8,   11,   14,   17,</code><br />
            </span>
            
            <span class="none">
            <code>|        20,   23,   23</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int32_t yy_ec[256] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    2,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    3,    4,    5,    6,</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|         7,    8,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int32_t yy_meta[9] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_base[13] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         0,    0,    9,   10,   10,   10,   10,   10,   10,   10,</code><br />
            </span>
            
            <span class="none">
            <code>|        10,   10</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_def[13] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|        12,    1,   12,   12,   12,   12,   12,   12,   12,   12,</code><br />
            </span>
            
            <span class="none">
            <code>|        12,    0</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_nxt[19] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         4,    5,    6,    7,    8,    9,   10,   11,   12,    3,</code><br />
            </span>
            
            <span class="none">
            <code>|        12,   12,   12,   12,   12,   12,   12,   12</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_chk[19] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    3,   12,</code><br />
            </span>
            
            <span class="none">
            <code>|        12,   12,   12,   12,   12,   12,   12,   12</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern int yy_flex_debug;</code><br />
            </span>
            
            <span class="none">
            <code>| int yy_flex_debug = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yy_state_type *yy_state_buf=0, *yy_state_ptr=0;</code><br />
            </span>
            
            <span class="none">
            <code>| static char *yy_full_match;</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_lp;</code><br />
            </span>
            
            <span class="none">
            <code>| #define REJECT \</code><br />
            </span>
            
            <span class="none">
            <code>| { \</code><br />
            </span>
            
            <span class="none">
            <code>| *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */ \</code><br />
            </span>
            
            <span class="none">
            <code>| yy_cp = (yy_full_match); /* restore poss. backed-over text */ \</code><br />
            </span>
            
            <span class="none">
            <code>| ++(yy_lp); \</code><br />
            </span>
            
            <span class="none">
            <code>| goto find_rule; \</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_more_flag = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_more_len = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| #define yymore() ((yy_more_flag) = 1)</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_MORE_ADJ (yy_more_len)</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_RESTORE_YY_MORE_OFFSET</code><br />
            </span>
            
            <span class="none">
            <code>| char *yytext;</code><br />
            </span>
            
            <span class="none">
            <code>| #line 1 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| #line 470 "lex.yy.c"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define INITIAL 0</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_NO_UNISTD_H</code><br />
            </span>
            
            <span class="none">
            <code>| /* Special case for "unistd.h", since it is non-ANSI. We include it way</code><br />
            </span>
            
            <span class="none">
            <code>|  * down here because we want the user's section 1 to have been scanned first.</code><br />
            </span>
            
            <span class="none">
            <code>|  * The user has a chance to override it with an option.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #include <unistd.h></code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_EXTRA_TYPE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_EXTRA_TYPE void *</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_init_globals (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Accessor methods to globals.</code><br />
            </span>
            
            <span class="none">
            <code>|    These are made visible to non-reentrant scanners for convenience. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yylex_destroy (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yyget_debug (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_debug (int debug_flag  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| YY_EXTRA_TYPE yyget_extra (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_extra (YY_EXTRA_TYPE user_defined  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyget_in (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_in  (FILE * in_str  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyget_out (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_out  (FILE * out_str  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| yy_size_t yyget_leng (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| char *yyget_text (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yyget_lineno (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_lineno (int line_number  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Macros after this point can all be overridden by user definitions in</code><br />
            </span>
            
            <span class="none">
            <code>|  * section 1.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_SKIP_YYWRAP</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>| extern "C" int yywrap (void );</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| extern int yywrap (void );</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     static void yyunput (int c,char *buf_ptr  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef yytext_ptr</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_flex_strncpy (char *,yyconst char *,int );</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_NEED_STRLEN</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_flex_strlen (yyconst char * );</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_NO_INPUT</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>| static int yyinput (void );</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| static int input (void );</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Amount of stuff to slurp up with each read. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_READ_BUF_SIZE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_READ_BUF_SIZE 8192</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Copy whatever the last rule matched to the standard output. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef ECHO</code><br />
            </span>
            
            <span class="none">
            <code>| /* This used to be an fputs(), but since the string might contain NUL's,</code><br />
            </span>
            
            <span class="none">
            <code>|  * we now use fwrite().</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,</code><br />
            </span>
            
            <span class="none">
            <code>|  * is returned in "result".</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_INPUT</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_INPUT(buf,result,max_size) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		int c = '*'; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		size_t n; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		for ( n = 0; n < max_size && \</code><br />
            </span>
            
            <span class="none">
            <code>| 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \</code><br />
            </span>
            
            <span class="none">
            <code>| 			buf[n] = (char) c; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( c == '\n' ) \</code><br />
            </span>
            
            <span class="none">
            <code>| 			buf[n++] = (char) c; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( c == EOF && ferror( yyin ) ) \</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "input in flex scanner failed" ); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		result = n; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	else \</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		errno=0; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \</code><br />
            </span>
            
            <span class="none">
            <code>| 			{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 			if( errno != EINTR) \</code><br />
            </span>
            
            <span class="none">
            <code>| 				{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 				YY_FATAL_ERROR( "input in flex scanner failed" ); \</code><br />
            </span>
            
            <span class="none">
            <code>| 				break; \</code><br />
            </span>
            
            <span class="none">
            <code>| 				} \</code><br />
            </span>
            
            <span class="none">
            <code>| 			errno=0; \</code><br />
            </span>
            
            <span class="none">
            <code>| 			clearerr(yyin); \</code><br />
            </span>
            
            <span class="none">
            <code>| 			} \</code><br />
            </span>
            
            <span class="none">
            <code>| 		}\</code><br />
            </span>
            
            <span class="none">
            <code>| \</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* No semi-colon after return; correct usage is to write "yyterminate();" -</code><br />
            </span>
            
            <span class="none">
            <code>|  * we don't want an extra ';' after the "return" because that will cause</code><br />
            </span>
            
            <span class="none">
            <code>|  * some compilers to complain about unreachable statements.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef yyterminate</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyterminate() return YY_NULL</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Number of entries by which start-condition stack grows. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_START_STACK_INCR</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_START_STACK_INCR 25</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Report a fatal error. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_FATAL_ERROR</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* end tables serialization structures and prototypes */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Default declaration of generated scanner - a define so the user can</code><br />
            </span>
            
            <span class="none">
            <code>|  * easily add parameters.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_DECL</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_DECL_IS_OURS 1</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern int yylex (void);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_DECL int yylex (void)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif /* !YY_DECL */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Code executed at the beginning of each rule, after yytext and yyleng</code><br />
            </span>
            
            <span class="none">
            <code>|  * have been set up.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_USER_ACTION</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_USER_ACTION</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Code executed at the end of each rule. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BREAK break;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_RULE_SETUP \</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_USER_ACTION</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** The main scanner function which does all the work.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| YY_DECL</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register yy_state_type yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 	register char *yy_cp, *yy_bp;</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int yy_act;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( !(yy_init) )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_init) = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_USER_INIT</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_USER_INIT;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|         /* Create the reject buffer large enough to save one state per allowed character. */</code><br />
            </span>
            
            <span class="none">
            <code>|         if ( ! (yy_state_buf) )</code><br />
            </span>
            
            <span class="none">
            <code>|             (yy_state_buf) = (yy_state_type *)yyalloc(YY_STATE_BUF_SIZE  );</code><br />
            </span>
            
            <span class="none">
            <code>|             if ( ! (yy_state_buf) )</code><br />
            </span>
            
            <span class="none">
            <code>|                 YY_FATAL_ERROR( "out of dynamic memory in yylex()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! (yy_start) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_start) = 1;	/* first start state */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! yyin )</code><br />
            </span>
            
            <span class="none">
            <code>| 			yyin = stdin;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! yyout )</code><br />
            </span>
            
            <span class="none">
            <code>| 			yyout = stdout;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! YY_CURRENT_BUFFER ) {</code><br />
            </span>
            
            <span class="none">
            <code>| 			yyensure_buffer_stack ();</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE =</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_create_buffer(yyin,YY_BUF_SIZE );</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	{</code><br />
            </span>
            
            <span class="none">
            <code>| #line 1 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #line 687 "lex.yy.c"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	while ( 1 )		/* loops until end-of-file is reached */</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_more_len) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( (yy_more_flag) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_more_len) = (yy_c_buf_p) - (yytext_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_more_flag) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Support of yytext. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		*yy_cp = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* yy_bp points to the position in yy_ch_buf of the start of</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * the current run.</code><br />
            </span>
            
            <span class="none">
            <code>| 		 */</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_bp = yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_current_state = (yy_start);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_state_ptr) = (yy_state_buf);</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| yy_match:</code><br />
            </span>
            
            <span class="none">
            <code>| 		do</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;</code><br />
            </span>
            
            <span class="none">
            <code>| 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_current_state = (int) yy_def[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| 				if ( yy_current_state >= 13 )</code><br />
            </span>
            
            <span class="none">
            <code>| 					yy_c = yy_meta[(unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 			*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 			++yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( yy_base[yy_current_state] != 10 );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| yy_find_action:</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_current_state = *--(yy_state_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_lp) = yy_accept[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| find_rule: /* we branch to this label when backing up */</code><br />
            </span>
            
            <span class="none">
            <code>| 		for ( ; ; ) /* until we find what rule we matched */</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			if ( (yy_lp) && (yy_lp) < yy_accept[yy_current_state + 1] )</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_act = yy_acclist[(yy_lp)];</code><br />
            </span>
            
            <span class="none">
            <code>| 					{</code><br />
            </span>
            
            <span class="none">
            <code>| 					(yy_full_match) = yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| 					break;</code><br />
            </span>
            
            <span class="none">
            <code>| 					}</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>| 			--yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_current_state = *--(yy_state_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_lp) = yy_accept[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_DO_BEFORE_ACTION;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| do_action:	/* This label is used only to access EOF actions. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		switch ( yy_act )</code><br />
            </span>
            
            <span class="none">
            <code>| 	{ /* beginning of action switch */</code><br />
            </span>
            
            <span class="none">
            <code>| case 1:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 2 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { ECHO; }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 2:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 3 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { REJECT; }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 3:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 4 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { yymore (); }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 4:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 5 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { yyless (1); }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 5:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 6 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { yyless (input () != 0); }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 6:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 7 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { unput (yytext[0]); }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 7:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 8 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { BEGIN INITIAL; }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 8:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 9 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| ECHO;</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| #line 793 "lex.yy.c"</code><br />
            </span>
            
            <span class="none">
            <code>| 			case YY_STATE_EOF(INITIAL):</code><br />
            </span>
            
            <span class="none">
            <code>| 				yyterminate();</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	case YY_END_OF_BUFFER:</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Amount of text matched not including the EOB char. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Undo the effects of YY_DO_BEFORE_ACTION. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		*yy_cp = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_RESTORE_YY_MORE_OFFSET</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* We're scanning a new file or input source.  It's</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * possible that this happened because the user</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * just pointed yyin at a new source and called</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * yylex().  If so, then we have to assure</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * consistency between YY_CURRENT_BUFFER and our</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * globals.  Here is the right place to do so, because</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * this is the first action (other than possibly a</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * back-up) that will match for the new input source.</code><br />
            </span>
            
            <span class="none">
            <code>| 			 */</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Note that here we test for yy_c_buf_p "<=" to the position</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * of the first EOB in the buffer, since yy_c_buf_p will</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * already have been incremented past the NUL character</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * (since all states make transitions on EOB to the</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * end-of-buffer state).  Contrast this with the test</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * in input().</code><br />
            </span>
            
            <span class="none">
            <code>| 		 */</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{ /* This was really a NUL. */</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_state_type yy_next_state;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_current_state = yy_get_previous_state(  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* Okay, we're now positioned to make the NUL</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * transition.  We couldn't have</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * yy_get_previous_state() go ahead and do it</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * for us because it doesn't know how to deal</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * with the possibility of jamming (and we don't</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * want to build jamming into it because then it</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * will run more slowly).</code><br />
            </span>
            
            <span class="none">
            <code>| 			 */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_next_state = yy_try_NUL_trans( yy_current_state );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_bp = (yytext_ptr) + YY_MORE_ADJ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			if ( yy_next_state )</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				/* Consume the NUL. */</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_cp = ++(yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_current_state = yy_next_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 				goto yy_match;</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			else</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 				goto yy_find_action;</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		else switch ( yy_get_next_buffer(  ) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			case EOB_ACT_END_OF_FILE:</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				(yy_did_buffer_switch_on_eof) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				if ( yywrap( ) )</code><br />
            </span>
            
            <span class="none">
            <code>| 					{</code><br />
            </span>
            
            <span class="none">
            <code>| 					/* Note: because we've taken care in</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * yy_get_next_buffer() to have set up</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * yytext, we can now set up</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * yy_c_buf_p so that if some total</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * hoser (like flex itself) wants to</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * call the scanner after we return the</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * YY_NULL, it'll still work - another</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * YY_NULL will get returned.</code><br />
            </span>
            
            <span class="none">
            <code>| 					 */</code><br />
            </span>
            
            <span class="none">
            <code>| 					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 					yy_act = YY_STATE_EOF(YY_START);</code><br />
            </span>
            
            <span class="none">
            <code>| 					goto do_action;</code><br />
            </span>
            
            <span class="none">
            <code>| 					}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				else</code><br />
            </span>
            
            <span class="none">
            <code>| 					{</code><br />
            </span>
            
            <span class="none">
            <code>| 					if ( ! (yy_did_buffer_switch_on_eof) )</code><br />
            </span>
            
            <span class="none">
            <code>| 						YY_NEW_FILE;</code><br />
            </span>
            
            <span class="none">
            <code>| 					}</code><br />
            </span>
            
            <span class="none">
            <code>| 				break;</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			case EOB_ACT_CONTINUE_SCAN:</code><br />
            </span>
            
            <span class="none">
            <code>| 				(yy_c_buf_p) =</code><br />
            </span>
            
            <span class="none">
            <code>| 					(yytext_ptr) + yy_amount_of_matched_text;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_current_state = yy_get_previous_state(  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;</code><br />
            </span>
            
            <span class="none">
            <code>| 				goto yy_match;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			case EOB_ACT_LAST_MATCH:</code><br />
            </span>
            
            <span class="none">
            <code>| 				(yy_c_buf_p) =</code><br />
            </span>
            
            <span class="none">
            <code>| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_current_state = yy_get_previous_state(  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;</code><br />
            </span>
            
            <span class="none">
            <code>| 				goto yy_find_action;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		break;</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	default:</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR(</code><br />
            </span>
            
            <span class="none">
            <code>| 			"fatal flex scanner internal error--no action found" );</code><br />
            </span>
            
            <span class="none">
            <code>| 	} /* end of action switch */</code><br />
            </span>
            
            <span class="none">
            <code>| 		} /* end of scanning one token */</code><br />
            </span>
            
            <span class="none">
            <code>| 	} /* end of user's declarations */</code><br />
            </span>
            
            <span class="none">
            <code>| } /* end of yylex */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yy_get_next_buffer - try to read in a new buffer</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * Returns a code representing an action:</code><br />
            </span>
            
            <span class="none">
            <code>|  *	EOB_ACT_LAST_MATCH -</code><br />
            </span>
            
            <span class="none">
            <code>|  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position</code><br />
            </span>
            
            <span class="none">
            <code>|  *	EOB_ACT_END_OF_FILE - end of file</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_get_next_buffer (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;</code><br />
            </span>
            
            <span class="none">
            <code>| 	register char *source = (yytext_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int number_to_move, i;</code><br />
            </span>
            
            <span class="none">
            <code>| 	int ret_val;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR(</code><br />
            </span>
            
            <span class="none">
            <code>| 		"fatal flex scanner internal error--end of buffer missed" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ /* Don't try to fill the buffer, so this is an EOF. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* We matched a single character, the EOB, so</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * treat this as a final EOF.</code><br />
            </span>
            
            <span class="none">
            <code>| 			 */</code><br />
            </span>
            
            <span class="none">
            <code>| 			return EOB_ACT_END_OF_FILE;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		else</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* We matched some text prior to the EOB, first</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * process it.</code><br />
            </span>
            
            <span class="none">
            <code>| 			 */</code><br />
            </span>
            
            <span class="none">
            <code>| 			return EOB_ACT_LAST_MATCH;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Try to read more data. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* First move last chars to start of buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( i = 0; i < number_to_move; ++i )</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(dest++) = *(source++);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* don't do the read, it's not guaranteed to return an EOF,</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * just force an EOF</code><br />
            </span>
            
            <span class="none">
            <code>| 		 */</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	else</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_size_t num_to_read =</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( num_to_read <= 0 )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{ /* Not enough room in the buffer - grow it. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR(</code><br />
            </span>
            
            <span class="none">
            <code>| "input buffer overflow, can't enlarge buffer because scanner uses REJECT" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( num_to_read > YY_READ_BUF_SIZE )</code><br />
            </span>
            
            <span class="none">
            <code>| 			num_to_read = YY_READ_BUF_SIZE;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Read in more data. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_n_chars), num_to_read );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( (yy_n_chars) == 0 )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( number_to_move == YY_MORE_ADJ )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			ret_val = EOB_ACT_END_OF_FILE;</code><br />
            </span>
            
            <span class="none">
            <code>| 			yyrestart(yyin  );</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		else</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			ret_val = EOB_ACT_LAST_MATCH;</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =</code><br />
            </span>
            
            <span class="none">
            <code>| 				YY_BUFFER_EOF_PENDING;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	else</code><br />
            </span>
            
            <span class="none">
            <code>| 		ret_val = EOB_ACT_CONTINUE_SCAN;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Extend the array by 50%, plus the number we really need. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_n_chars) += number_to_move;</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return ret_val;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yy_get_previous_state - get the state just before the EOB char was reached */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     static yy_state_type yy_get_previous_state (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register yy_state_type yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 	register char *yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_current_state = (yy_start);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_state_ptr) = (yy_state_buf);</code><br />
            </span>
            
            <span class="none">
            <code>| 	*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_current_state = (int) yy_def[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| 			if ( yy_current_state >= 13 )</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_c = yy_meta[(unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yy_try_NUL_trans - try to make a transition on the NUL character</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * synopsis</code><br />
            </span>
            
            <span class="none">
            <code>|  *	next_state = yy_try_NUL_trans( current_state );</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int yy_is_jam;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	register YY_CHAR yy_c = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_current_state = (int) yy_def[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( yy_current_state >= 13 )</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_c = yy_meta[(unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_is_jam = (yy_current_state == 12);</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! yy_is_jam )</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		return yy_is_jam ? 0 : yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     static void yyunput (int c, register char * yy_bp )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register char *yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* undo effects of setting up yytext */</code><br />
            </span>
            
            <span class="none">
            <code>| 	*yy_cp = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ /* need to shift things up to make room */</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* +2 for EOB chars. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		register yy_size_t number_to_move = (yy_n_chars) + 2;</code><br />
            </span>
            
            <span class="none">
            <code>| 		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[</code><br />
            </span>
            
            <span class="none">
            <code>| 					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];</code><br />
            </span>
            
            <span class="none">
            <code>| 		register char *source =</code><br />
            </span>
            
            <span class="none">
            <code>| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )</code><br />
            </span>
            
            <span class="none">
            <code>| 			*--dest = *--source;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_cp += (int) (dest - source);</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_bp += (int) (dest - source);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "flex scanner push-back overflow" );</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	*--yy_cp = (char) c;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) = yy_bp;</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_hold_char) = *yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_c_buf_p) = yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_NO_INPUT</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>|     static int yyinput (void)</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>|     static int input  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	int c;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	*(yy_c_buf_p) = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* yy_c_buf_p now points to the character we want to return.</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * If this occurs *before* the EOB characters, then it's a</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * valid NUL; if not, then we've hit the end of the buffer.</code><br />
            </span>
            
            <span class="none">
            <code>| 		 */</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* This was really a NUL. */</code><br />
            </span>
            
            <span class="none">
            <code>| 			*(yy_c_buf_p) = '\0';</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		else</code><br />
            </span>
            
            <span class="none">
            <code>| 			{ /* need more input */</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_size_t offset = (yy_c_buf_p) - (yytext_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 			++(yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			switch ( yy_get_next_buffer(  ) )</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				case EOB_ACT_LAST_MATCH:</code><br />
            </span>
            
            <span class="none">
            <code>| 					/* This happens because yy_g_n_b()</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * sees that we've accumulated a</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * token and flags that we need to</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * try matching the token before</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * proceeding.  But for input(),</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * there's no matching to consider.</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * So convert the EOB_ACT_LAST_MATCH</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * to EOB_ACT_END_OF_FILE.</code><br />
            </span>
            
            <span class="none">
            <code>| 					 */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 					/* Reset buffer status. */</code><br />
            </span>
            
            <span class="none">
            <code>| 					yyrestart(yyin );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 					/*FALLTHROUGH*/</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				case EOB_ACT_END_OF_FILE:</code><br />
            </span>
            
            <span class="none">
            <code>| 					{</code><br />
            </span>
            
            <span class="none">
            <code>| 					if ( yywrap( ) )</code><br />
            </span>
            
            <span class="none">
            <code>| 						return EOF;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 					if ( ! (yy_did_buffer_switch_on_eof) )</code><br />
            </span>
            
            <span class="none">
            <code>| 						YY_NEW_FILE;</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>| 					return yyinput();</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| 					return input();</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| 					}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				case EOB_ACT_CONTINUE_SCAN:</code><br />
            </span>
            
            <span class="none">
            <code>| 					(yy_c_buf_p) = (yytext_ptr) + offset;</code><br />
            </span>
            
            <span class="none">
            <code>| 					break;</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */</code><br />
            </span>
            
            <span class="none">
            <code>| 	*(yy_c_buf_p) = '\0';	/* preserve yytext */</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_hold_char) = *++(yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return c;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>| #endif	/* ifndef YY_NO_INPUT */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Immediately switch to a different input stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param input_file A readable stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @note This function does not reset the start condition to @c INITIAL .</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     void yyrestart  (FILE * input_file )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! YY_CURRENT_BUFFER ){</code><br />
            </span>
            
            <span class="none">
            <code>|         yyensure_buffer_stack ();</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE =</code><br />
            </span>
            
            <span class="none">
            <code>|             yy_create_buffer(yyin,YY_BUF_SIZE );</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_init_buffer(YY_CURRENT_BUFFER,input_file );</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Switch to a different input buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param new_buffer The new input buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* TODO. We should be able to replace this entire function body</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * with</code><br />
            </span>
            
            <span class="none">
            <code>| 	 *		yypop_buffer_state();</code><br />
            </span>
            
            <span class="none">
            <code>| 	 *		yypush_buffer_state(new_buffer);</code><br />
            </span>
            
            <span class="none">
            <code>|      */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyensure_buffer_stack ();</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER == new_buffer )</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Flush out information for old buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_c_buf_p) = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* We don't actually know whether we did this switch during</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * EOF (yywrap()) processing, but the only time this flag</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * is looked at is after yywrap() is called, so it's safe</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * to go ahead and always set it.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_did_buffer_switch_on_eof) = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_load_buffer_state  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_hold_char) = *(yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Allocate and initialize an input buffer state.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param file A readable stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @return the allocated buffer state.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BUFFER_STATE b;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buf_size = size;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* yy_ch_buf has to be 2 characters longer than the size given because</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * we need to put in 2 end-of-buffer characters.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b->yy_ch_buf )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_is_our_buffer = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_init_buffer(b,file );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return b;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Destroy the buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param b a buffer created with yy_create_buffer()</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     void yy_delete_buffer (YY_BUFFER_STATE  b )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( b->yy_is_our_buffer )</code><br />
            </span>
            
            <span class="none">
            <code>| 		yyfree((void *) b->yy_ch_buf  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyfree((void *) b  );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Initializes or reinitializes a buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * This function is sometimes called more than once on the same buffer,</code><br />
            </span>
            
            <span class="none">
            <code>|  * such as during a yyrestart() or at EOF.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	int oerrno = errno;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_flush_buffer(b );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_input_file = file;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_fill_buffer = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     /* If b is the current buffer, then yy_init_buffer was _probably_</code><br />
            </span>
            
            <span class="none">
            <code>|      * called from yyrestart() or through yy_get_next_buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|      * In that case, we don't want to reset the lineno or column.</code><br />
            </span>
            
            <span class="none">
            <code>|      */</code><br />
            </span>
            
            <span class="none">
            <code>|     if (b != YY_CURRENT_BUFFER){</code><br />
            </span>
            
            <span class="none">
            <code>|         b->yy_bs_lineno = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|         b->yy_bs_column = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|         b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	errno = oerrno;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Discard all buffered characters. On the next scan, YY_INPUT will be called.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     void yy_flush_buffer (YY_BUFFER_STATE  b )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_n_chars = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* We always need two end-of-buffer characters.  The first causes</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * a transition to the end-of-buffer state.  The second causes</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * a jam in that state.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buf_pos = &b->yy_ch_buf[0];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_at_bol = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buffer_status = YY_BUFFER_NEW;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( b == YY_CURRENT_BUFFER )</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Pushes the new state onto the stack. The new state becomes</code><br />
            </span>
            
            <span class="none">
            <code>|  *  the current state. This function will allocate the stack</code><br />
            </span>
            
            <span class="none">
            <code>|  *  if necessary.</code><br />
            </span>
            
            <span class="none">
            <code>|  *  @param new_buffer The new state.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| void yypush_buffer_state (YY_BUFFER_STATE new_buffer )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	if (new_buffer == NULL)</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyensure_buffer_stack();</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* This block is copied from yy_switch_to_buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Flush out information for old buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_c_buf_p) = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Only push if top exists. Otherwise, replace top. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	if (YY_CURRENT_BUFFER)</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack_top)++;</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* copied from yy_switch_to_buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_did_buffer_switch_on_eof) = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Removes and deletes the top of the stack, if present.</code><br />
            </span>
            
            <span class="none">
            <code>|  *  The next element becomes the new top.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| void yypop_buffer_state (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	if (!YY_CURRENT_BUFFER)</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_delete_buffer(YY_CURRENT_BUFFER );</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE = NULL;</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ((yy_buffer_stack_top) > 0)</code><br />
            </span>
            
            <span class="none">
            <code>| 		--(yy_buffer_stack_top);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if (YY_CURRENT_BUFFER) {</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_did_buffer_switch_on_eof) = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Allocates the stack if it does not exist.</code><br />
            </span>
            
            <span class="none">
            <code>|  *  Guarantees space for at least one push.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| static void yyensure_buffer_stack (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t num_to_alloc;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if (!(yy_buffer_stack)) {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* First allocation is just for 2 elements, since we don't know if this</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * scanner will even need a stack. We use 2 instead of 1 to avoid an</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * immediate realloc on the next call.</code><br />
            </span>
            
            <span class="none">
            <code>|          */</code><br />
            </span>
            
            <span class="none">
            <code>| 		num_to_alloc = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc</code><br />
            </span>
            
            <span class="none">
            <code>| 								(num_to_alloc * sizeof(struct yy_buffer_state*)</code><br />
            </span>
            
            <span class="none">
            <code>| 								);</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! (yy_buffer_stack) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack_max) = num_to_alloc;</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack_top) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Increase the buffer to prepare for a possible push. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		int grow_size = 8 /* arbitrary grow size */;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		num_to_alloc = (yy_buffer_stack_max) + grow_size;</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc</code><br />
            </span>
            
            <span class="none">
            <code>| 								((yy_buffer_stack),</code><br />
            </span>
            
            <span class="none">
            <code>| 								num_to_alloc * sizeof(struct yy_buffer_state*)</code><br />
            </span>
            
            <span class="none">
            <code>| 								);</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! (yy_buffer_stack) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* zero only the new slots.*/</code><br />
            </span>
            
            <span class="none">
            <code>| 		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack_max) = num_to_alloc;</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Setup the input buffer state to scan directly from a user-specified character buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param base the character buffer</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param size the size in bytes of the character buffer</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @return the newly allocated buffer state object.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BUFFER_STATE b;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( size < 2 ||</code><br />
            </span>
            
            <span class="none">
            <code>| 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||</code><br />
            </span>
            
            <span class="none">
            <code>| 	     base[size-1] != YY_END_OF_BUFFER_CHAR )</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* They forgot to leave room for the EOB's. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		return 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buf_pos = b->yy_ch_buf = base;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_is_our_buffer = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_input_file = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_n_chars = b->yy_buf_size;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_is_interactive = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_at_bol = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_fill_buffer = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buffer_status = YY_BUFFER_NEW;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_switch_to_buffer(b  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return b;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Setup the input buffer state to scan a string. The next call to yylex() will</code><br />
            </span>
            
            <span class="none">
            <code>|  * scan from a @e copy of @a str.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param yystr a NUL-terminated string to scan</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @return the newly allocated buffer state object.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @note If you want to scan bytes that may contain NUL values, then use</code><br />
            </span>
            
            <span class="none">
            <code>|  *       yy_scan_bytes() instead.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return yy_scan_bytes(yystr,strlen(yystr) );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Setup the input buffer state to scan the given bytes. The next call to yylex() will</code><br />
            </span>
            
            <span class="none">
            <code>|  * scan from a @e copy of @a bytes.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param yybytes the byte buffer to scan</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @return the newly allocated buffer state object.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BUFFER_STATE b;</code><br />
            </span>
            
            <span class="none">
            <code>| 	char *buf;</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t n;</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t i;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Get memory for full buffer, including space for trailing EOB's. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	n = _yybytes_len + 2;</code><br />
            </span>
            
            <span class="none">
            <code>| 	buf = (char *) yyalloc(n  );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! buf )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( i = 0; i < _yybytes_len; ++i )</code><br />
            </span>
            
            <span class="none">
            <code>| 		buf[i] = yybytes[i];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b = yy_scan_buffer(buf,n );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* It's okay to grow etc. this buffer, and we should throw it</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * away when we're done.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_is_our_buffer = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return b;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_EXIT_FAILURE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_EXIT_FAILURE 2</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_fatal_error (yyconst char* msg )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	(void) fprintf( stderr, "%s\n", msg );</code><br />
            </span>
            
            <span class="none">
            <code>| 	exit( YY_EXIT_FAILURE );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Redefine yyless() so it works in section 3 code. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #undef yyless</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyless(n) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	do \</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Undo effects of setting up yytext. */ \</code><br />
            </span>
            
            <span class="none">
            <code>|         int yyless_macro_arg = (n); \</code><br />
            </span>
            
            <span class="none">
            <code>|         YY_LESS_LINENO(yyless_macro_arg);\</code><br />
            </span>
            
            <span class="none">
            <code>| 		yytext[yyleng] = (yy_hold_char); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_c_buf_p) = yytext + yyless_macro_arg; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_hold_char) = *(yy_c_buf_p); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_c_buf_p) = '\0'; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		yyleng = yyless_macro_arg; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	while ( 0 )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Accessor  methods (get/set functions) to struct members. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the current line number.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| int yyget_lineno  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     return yylineno;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the input stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyget_in  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yyin;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the output stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyget_out  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yyout;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the length of the current token.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| yy_size_t yyget_leng  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yyleng;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the current token.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| char *yyget_text  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yytext;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Set the current line number.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param line_number</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_lineno (int  line_number )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     yylineno = line_number;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Set the input stream. This does not discard the current</code><br />
            </span>
            
            <span class="none">
            <code>|  * input buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param in_str A readable stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @see yy_switch_to_buffer</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_in (FILE *  in_str )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         yyin = in_str ;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_out (FILE *  out_str )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         yyout = out_str ;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yyget_debug  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yy_flex_debug;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_debug (int  bdebug )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         yy_flex_debug = bdebug ;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_init_globals (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         /* Initialization is the same as for the non-reentrant scanner.</code><br />
            </span>
            
            <span class="none">
            <code>|      * This function is called from yylex_destroy(), so don't allocate here.</code><br />
            </span>
            
            <span class="none">
            <code>|      */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_buffer_stack) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_buffer_stack_top) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_buffer_stack_max) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_c_buf_p) = (char *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_init) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_start) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_state_buf) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_state_ptr) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_full_match) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_lp) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Defined in main.c */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_STDINIT</code><br />
            </span>
            
            <span class="none">
            <code>|     yyin = stdin;</code><br />
            </span>
            
            <span class="none">
            <code>|     yyout = stdout;</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>|     yyin = (FILE *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     yyout = (FILE *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     /* For future reference: Set errno on error, since we are called by</code><br />
            </span>
            
            <span class="none">
            <code>|      * yylex_init()</code><br />
            </span>
            
            <span class="none">
            <code>|      */</code><br />
            </span>
            
            <span class="none">
            <code>|     return 0;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yylex_destroy is for both reentrant and non-reentrant scanners. */</code><br />
            </span>
            
            <span class="none">
            <code>| int yylex_destroy  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     /* Pop the buffer stack, destroying each element. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	while(YY_CURRENT_BUFFER){</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_delete_buffer(YY_CURRENT_BUFFER  );</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE = NULL;</code><br />
            </span>
            
            <span class="none">
            <code>| 		yypop_buffer_state();</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Destroy the stack itself. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyfree((yy_buffer_stack) );</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_buffer_stack) = NULL;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     yyfree ( (yy_state_buf) );</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_state_buf)  = NULL;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     /* Reset the globals. This is important in a non-reentrant scanner so the next time</code><br />
            </span>
            
            <span class="none">
            <code>|      * yylex() is called, initialization will occur. */</code><br />
            </span>
            
            <span class="none">
            <code>|     yy_init_globals( );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     return 0;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /*</code><br />
            </span>
            
            <span class="none">
            <code>|  * Internal utility routines.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef yytext_ptr</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int i;</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( i = 0; i < n; ++i )</code><br />
            </span>
            
            <span class="none">
            <code>| 		s1[i] = s2[i];</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_NEED_STRLEN</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_flex_strlen (yyconst char * s )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int n;</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( n = 0; s[n]; ++n )</code><br />
            </span>
            
            <span class="none">
            <code>| 		;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return n;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void *yyalloc (yy_size_t  size )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	return (void *) malloc( size );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void *yyrealloc  (void * ptr, yy_size_t  size )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* The cast to (char *) in the following accommodates both</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * implementations that use char* generic pointers, and those</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * that use void* generic pointers.  It works with the latter</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * because both ANSI C and C++ allow castless assignment from</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * any pointer type to void*, and deal with argument conversions</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * as though doing an assignment.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	return (void *) realloc( (char *) ptr, size );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyfree (void * ptr )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YYTABLES_NAME "yytables"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #line 9 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YYTEXT_POINTER</code><br />
            </span>
            
            <span class="none">
            <code>| extern char *yytext;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| int</code><br />
            </span>
            
            <span class="none">
            <code>| main (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|   return ! yylex () + ! yywrap ();</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>configure:3946: result: none needed</code><br />
            </span>
            
            <span class="none">
            <code>configure:3952: checking whether yytext is a pointer</code><br />
            </span>
            
            <span class="none">
            <code>configure:3968: arm-linux-androideabi-gcc -o conftest    conftest.c   >&5</code><br />
            </span>
            
            <span class="error">
            <code>/tmp/ccs3srmt.o:conftest.c:function yylex: error: undefined reference to 'yywrap'</code><br />
            </span>
            
            <span class="error">
            <code>/tmp/ccs3srmt.o:conftest.c:function input: error: undefined reference to 'yywrap'</code><br />
            </span>
            
            <span class="error">
            <code>/tmp/ccs3srmt.o:conftest.c:function main: error: undefined reference to 'yywrap'</code><br />
            </span>
            
            <span class="none">
            <code>collect2: error: ld returned 1 exit status</code><br />
            </span>
            
            <span class="none">
            <code>configure:3968: $? = 1</code><br />
            </span>
            
            <span class="none">
            <code>configure: failed program was:</code><br />
            </span>
            
            <span class="none">
            <code>| /* confdefs.h */</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_NAME "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_TARNAME "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_VERSION "2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_STRING "nickle 2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_BUGREPORT "http://nickle.org"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_URL ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define VERSION "2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| /* end confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YYTEXT_POINTER 1</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #line 3 "lex.yy.c"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define  YY_INT_ALIGNED short int</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* A lexical scanner generated by flex */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define FLEX_SCANNER</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FLEX_MAJOR_VERSION 2</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FLEX_MINOR_VERSION 5</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FLEX_SUBMINOR_VERSION 39</code><br />
            </span>
            
            <span class="none">
            <code>| #if YY_FLEX_SUBMINOR_VERSION > 0</code><br />
            </span>
            
            <span class="none">
            <code>| #define FLEX_BETA</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* First, we deal with  platform-specific or compiler-specific issues. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* begin standard C headers. */</code><br />
            </span>
            
            <span class="none">
            <code>| #include <stdio.h></code><br />
            </span>
            
            <span class="none">
            <code>| #include <string.h></code><br />
            </span>
            
            <span class="none">
            <code>| #include <errno.h></code><br />
            </span>
            
            <span class="none">
            <code>| #include <stdlib.h></code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* end standard C headers. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* flex integer type definitions */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef FLEXINT_H</code><br />
            </span>
            
            <span class="none">
            <code>| #define FLEXINT_H</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,</code><br />
            </span>
            
            <span class="none">
            <code>|  * if you want the limit (max/min) macros for int types.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef __STDC_LIMIT_MACROS</code><br />
            </span>
            
            <span class="none">
            <code>| #define __STDC_LIMIT_MACROS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #include <inttypes.h></code><br />
            </span>
            
            <span class="none">
            <code>| typedef int8_t flex_int8_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef uint8_t flex_uint8_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef int16_t flex_int16_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef uint16_t flex_uint16_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef int32_t flex_int32_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef uint32_t flex_uint32_t;</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| typedef signed char flex_int8_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef short int flex_int16_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef int flex_int32_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef unsigned char flex_uint8_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef unsigned short int flex_uint16_t;</code><br />
            </span>
            
            <span class="none">
            <code>| typedef unsigned int flex_uint32_t;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Limits of integral types. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT8_MIN</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT8_MIN               (-128)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT16_MIN</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT16_MIN              (-32767-1)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT32_MIN</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT32_MIN              (-2147483647-1)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT8_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT8_MAX               (127)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT16_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT16_MAX              (32767)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef INT32_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define INT32_MAX              (2147483647)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef UINT8_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define UINT8_MAX              (255U)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef UINT16_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define UINT16_MAX             (65535U)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef UINT32_MAX</code><br />
            </span>
            
            <span class="none">
            <code>| #define UINT32_MAX             (4294967295U)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif /* ! C99 */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif /* ! FLEXINT_H */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* The "const" storage-class-modifier is valid. */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_USE_CONST</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #else	/* ! __cplusplus */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* C99 requires __STDC__ to be defined as 1. */</code><br />
            </span>
            
            <span class="none">
            <code>| #if defined (__STDC__)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_USE_CONST</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif	/* defined (__STDC__) */</code><br />
            </span>
            
            <span class="none">
            <code>| #endif	/* ! __cplusplus */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_USE_CONST</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyconst const</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyconst</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Returned upon end-of-file. */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_NULL 0</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Promotes a possibly negative, possibly signed char to an unsigned</code><br />
            </span>
            
            <span class="none">
            <code>|  * integer for use as an array index.  If the signed char is negative,</code><br />
            </span>
            
            <span class="none">
            <code>|  * we want to instead treat it as an 8-bit unsigned char, hence the</code><br />
            </span>
            
            <span class="none">
            <code>|  * double cast.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Enter a start condition.  This macro really ought to take a parameter,</code><br />
            </span>
            
            <span class="none">
            <code>|  * but we do it the disgusting crufty way forced on us by the ()-less</code><br />
            </span>
            
            <span class="none">
            <code>|  * definition of BEGIN.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define BEGIN (yy_start) = 1 + 2 *</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Translate the current start state into a value that can be later handed</code><br />
            </span>
            
            <span class="none">
            <code>|  * to BEGIN to return to the state.  The YYSTATE alias is for lex</code><br />
            </span>
            
            <span class="none">
            <code>|  * compatibility.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_START (((yy_start) - 1) / 2)</code><br />
            </span>
            
            <span class="none">
            <code>| #define YYSTATE YY_START</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Action number for EOF rule of a given start state. */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Special action meaning "start processing a new file". */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_NEW_FILE yyrestart(yyin  )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_END_OF_BUFFER_CHAR 0</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Size of default input buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_BUF_SIZE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BUF_SIZE 16384</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* The state buf must be large enough to hold one state per character in the main buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_TYPEDEF_YY_BUFFER_STATE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_TYPEDEF_YY_BUFFER_STATE</code><br />
            </span>
            
            <span class="none">
            <code>| typedef struct yy_buffer_state *YY_BUFFER_STATE;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_TYPEDEF_YY_SIZE_T</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_TYPEDEF_YY_SIZE_T</code><br />
            </span>
            
            <span class="none">
            <code>| typedef size_t yy_size_t;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern yy_size_t yyleng;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern FILE *yyin, *yyout;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define EOB_ACT_CONTINUE_SCAN 0</code><br />
            </span>
            
            <span class="none">
            <code>| #define EOB_ACT_END_OF_FILE 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define EOB_ACT_LAST_MATCH 2</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     #define YY_LESS_LINENO(n)</code><br />
            </span>
            
            <span class="none">
            <code>|     #define YY_LINENO_REWIND_TO(ptr)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Return all but the first "n" matched characters back to the input stream. */</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyless(n) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	do \</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Undo effects of setting up yytext. */ \</code><br />
            </span>
            
            <span class="none">
            <code>|         int yyless_macro_arg = (n); \</code><br />
            </span>
            
            <span class="none">
            <code>|         YY_LESS_LINENO(yyless_macro_arg);\</code><br />
            </span>
            
            <span class="none">
            <code>| 		*yy_cp = (yy_hold_char); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_RESTORE_YY_MORE_OFFSET \</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	while ( 0 )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define unput(c) yyunput( c, (yytext_ptr)  )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_STRUCT_YY_BUFFER_STATE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_STRUCT_YY_BUFFER_STATE</code><br />
            </span>
            
            <span class="none">
            <code>| struct yy_buffer_state</code><br />
            </span>
            
            <span class="none">
            <code>| 	{</code><br />
            </span>
            
            <span class="none">
            <code>| 	FILE *yy_input_file;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	char *yy_ch_buf;		/* input buffer */</code><br />
            </span>
            
            <span class="none">
            <code>| 	char *yy_buf_pos;		/* current position in input buffer */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Size of input buffer in bytes, not including room for EOB</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * characters.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t yy_buf_size;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Number of characters read into yy_ch_buf, not including EOB</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * characters.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t yy_n_chars;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Whether we "own" the buffer - i.e., we know we created it,</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * and can realloc() it to grow it, and should free() it to</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * delete it.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_is_our_buffer;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Whether this is an "interactive" input source; if so, and</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * if we're using stdio for input, then we want to use getc()</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * instead of fread(), to make sure we stop fetching input after</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * each newline.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_is_interactive;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Whether we're considered to be at the beginning of a line.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * If so, '^' rules will be active on the next match, otherwise</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * not.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_at_bol;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     int yy_bs_lineno; /**< The line count. */</code><br />
            </span>
            
            <span class="none">
            <code>|     int yy_bs_column; /**< The column count. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Whether to try to fill the input buffer when we reach the</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * end of it.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_fill_buffer;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	int yy_buffer_status;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BUFFER_NEW 0</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BUFFER_NORMAL 1</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* When an EOF's been seen but there's still some text to process</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * shouldn't try reading from the input source any more.  We might</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * still have a bunch of tokens to match, though, because of</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * possible backing-up.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 *</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * When we actually see the EOF, we change the status to "new"</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * (via yyrestart()), so that the user can continue scanning by</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * just pointing yyin at a new input file.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BUFFER_EOF_PENDING 2</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	};</code><br />
            </span>
            
            <span class="none">
            <code>| #endif /* !YY_STRUCT_YY_BUFFER_STATE */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Stack of input buffers. */</code><br />
            </span>
            
            <span class="none">
            <code>| static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */</code><br />
            </span>
            
            <span class="none">
            <code>| static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */</code><br />
            </span>
            
            <span class="none">
            <code>| static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* We provide macros for accessing buffer states in case in the</code><br />
            </span>
            
            <span class="none">
            <code>|  * future we want to put the buffer states in a more general</code><br />
            </span>
            
            <span class="none">
            <code>|  * "scanner state".</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * Returns the top of the stack, or NULL.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_CURRENT_BUFFER ( (yy_buffer_stack) \</code><br />
            </span>
            
            <span class="none">
            <code>|                           ? (yy_buffer_stack)[(yy_buffer_stack_top)] \</code><br />
            </span>
            
            <span class="none">
            <code>|                           : NULL)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Same as previous macro, but useful when we know that the buffer stack is not</code><br />
            </span>
            
            <span class="none">
            <code>|  * NULL or when we need an lvalue. For internal use only.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yy_hold_char holds the character lost when yytext is formed. */</code><br />
            </span>
            
            <span class="none">
            <code>| static char yy_hold_char;</code><br />
            </span>
            
            <span class="none">
            <code>| static yy_size_t yy_n_chars;		/* number of characters read into yy_ch_buf */</code><br />
            </span>
            
            <span class="none">
            <code>| yy_size_t yyleng;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Points to current character in buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| static char *yy_c_buf_p = (char *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_init = 0;		/* whether we need to initialize */</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_start = 0;	/* start state number */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Flag which is used to allow yywrap()'s to do buffer switches</code><br />
            </span>
            
            <span class="none">
            <code>|  * instead of setting up a fresh yyin.  A bit of a hack ...</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_did_buffer_switch_on_eof;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyrestart (FILE *input_file  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yy_delete_buffer (YY_BUFFER_STATE b  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yy_flush_buffer (YY_BUFFER_STATE b  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yypop_buffer_state (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static void yyensure_buffer_stack (void );</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_load_buffer_state (void );</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,yy_size_t len  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void *yyalloc (yy_size_t  );</code><br />
            </span>
            
            <span class="none">
            <code>| void *yyrealloc (void *,yy_size_t  );</code><br />
            </span>
            
            <span class="none">
            <code>| void yyfree (void *  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define yy_new_buffer yy_create_buffer</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define yy_set_interactive(is_interactive) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! YY_CURRENT_BUFFER ){ \</code><br />
            </span>
            
            <span class="none">
            <code>|         yyensure_buffer_stack (); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE =    \</code><br />
            </span>
            
            <span class="none">
            <code>|             yy_create_buffer(yyin,YY_BUF_SIZE ); \</code><br />
            </span>
            
            <span class="none">
            <code>| 	} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define yy_set_bol(at_bol) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! YY_CURRENT_BUFFER ){\</code><br />
            </span>
            
            <span class="none">
            <code>|         yyensure_buffer_stack (); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE =    \</code><br />
            </span>
            
            <span class="none">
            <code>|             yy_create_buffer(yyin,YY_BUF_SIZE ); \</code><br />
            </span>
            
            <span class="none">
            <code>| 	} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Begin user sect3 */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| typedef unsigned char YY_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| typedef int yy_state_type;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern int yylineno;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yylineno = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern char *yytext;</code><br />
            </span>
            
            <span class="none">
            <code>| #define yytext_ptr yytext</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yy_state_type yy_get_previous_state (void );</code><br />
            </span>
            
            <span class="none">
            <code>| static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_get_next_buffer (void );</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_fatal_error (yyconst char msg[]  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Done after the current pattern has been matched and before the</code><br />
            </span>
            
            <span class="none">
            <code>|  * corresponding action - sets up yytext.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_DO_BEFORE_ACTION \</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) = yy_bp; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) -= (yy_more_len); \</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyleng = (size_t) (yy_cp - (yytext_ptr)); \</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_hold_char) = *yy_cp; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	*yy_cp = '\0'; \</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_c_buf_p) = yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_NUM_RULES 8</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_END_OF_BUFFER 9</code><br />
            </span>
            
            <span class="none">
            <code>| /* This struct is not used in this scanner,</code><br />
            </span>
            
            <span class="none">
            <code>|    but its presence is necessary. */</code><br />
            </span>
            
            <span class="none">
            <code>| struct yy_trans_info</code><br />
            </span>
            
            <span class="none">
            <code>| 	{</code><br />
            </span>
            
            <span class="none">
            <code>| 	flex_int32_t yy_verify;</code><br />
            </span>
            
            <span class="none">
            <code>| 	flex_int32_t yy_nxt;</code><br />
            </span>
            
            <span class="none">
            <code>| 	};</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_acclist[23] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         9,    7,    8,    8,    1,    7,    8,    2,    7,    8,</code><br />
            </span>
            
            <span class="none">
            <code>|         3,    7,    8,    4,    7,    8,    5,    7,    8,    6,</code><br />
            </span>
            
            <span class="none">
            <code>|         7,    8</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_accept[14] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    2,    4,    5,    8,   11,   14,   17,</code><br />
            </span>
            
            <span class="none">
            <code>|        20,   23,   23</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int32_t yy_ec[256] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    2,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    3,    4,    5,    6,</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|         7,    8,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int32_t yy_meta[9] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_base[13] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         0,    0,    9,   10,   10,   10,   10,   10,   10,   10,</code><br />
            </span>
            
            <span class="none">
            <code>|        10,   10</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_def[13] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|        12,    1,   12,   12,   12,   12,   12,   12,   12,   12,</code><br />
            </span>
            
            <span class="none">
            <code>|        12,    0</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_nxt[19] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         4,    5,    6,    7,    8,    9,   10,   11,   12,    3,</code><br />
            </span>
            
            <span class="none">
            <code>|        12,   12,   12,   12,   12,   12,   12,   12</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yyconst flex_int16_t yy_chk[19] =</code><br />
            </span>
            
            <span class="none">
            <code>|     {   0,</code><br />
            </span>
            
            <span class="none">
            <code>|         1,    1,    1,    1,    1,    1,    1,    1,    3,   12,</code><br />
            </span>
            
            <span class="none">
            <code>|        12,   12,   12,   12,   12,   12,   12,   12</code><br />
            </span>
            
            <span class="none">
            <code>|     } ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern int yy_flex_debug;</code><br />
            </span>
            
            <span class="none">
            <code>| int yy_flex_debug = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static yy_state_type *yy_state_buf=0, *yy_state_ptr=0;</code><br />
            </span>
            
            <span class="none">
            <code>| static char *yy_full_match;</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_lp;</code><br />
            </span>
            
            <span class="none">
            <code>| #define REJECT \</code><br />
            </span>
            
            <span class="none">
            <code>| { \</code><br />
            </span>
            
            <span class="none">
            <code>| *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */ \</code><br />
            </span>
            
            <span class="none">
            <code>| yy_cp = (yy_full_match); /* restore poss. backed-over text */ \</code><br />
            </span>
            
            <span class="none">
            <code>| ++(yy_lp); \</code><br />
            </span>
            
            <span class="none">
            <code>| goto find_rule; \</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_more_flag = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_more_len = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| #define yymore() ((yy_more_flag) = 1)</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_MORE_ADJ (yy_more_len)</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_RESTORE_YY_MORE_OFFSET</code><br />
            </span>
            
            <span class="none">
            <code>| char *yytext;</code><br />
            </span>
            
            <span class="none">
            <code>| #line 1 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| #line 470 "lex.yy.c"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define INITIAL 0</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_NO_UNISTD_H</code><br />
            </span>
            
            <span class="none">
            <code>| /* Special case for "unistd.h", since it is non-ANSI. We include it way</code><br />
            </span>
            
            <span class="none">
            <code>|  * down here because we want the user's section 1 to have been scanned first.</code><br />
            </span>
            
            <span class="none">
            <code>|  * The user has a chance to override it with an option.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #include <unistd.h></code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_EXTRA_TYPE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_EXTRA_TYPE void *</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_init_globals (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Accessor methods to globals.</code><br />
            </span>
            
            <span class="none">
            <code>|    These are made visible to non-reentrant scanners for convenience. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yylex_destroy (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yyget_debug (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_debug (int debug_flag  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| YY_EXTRA_TYPE yyget_extra (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_extra (YY_EXTRA_TYPE user_defined  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyget_in (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_in  (FILE * in_str  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyget_out (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_out  (FILE * out_str  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| yy_size_t yyget_leng (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| char *yyget_text (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yyget_lineno (void );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_lineno (int line_number  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Macros after this point can all be overridden by user definitions in</code><br />
            </span>
            
            <span class="none">
            <code>|  * section 1.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_SKIP_YYWRAP</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>| extern "C" int yywrap (void );</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| extern int yywrap (void );</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     static void yyunput (int c,char *buf_ptr  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef yytext_ptr</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_flex_strncpy (char *,yyconst char *,int );</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_NEED_STRLEN</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_flex_strlen (yyconst char * );</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_NO_INPUT</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>| static int yyinput (void );</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| static int input (void );</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Amount of stuff to slurp up with each read. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_READ_BUF_SIZE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_READ_BUF_SIZE 8192</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Copy whatever the last rule matched to the standard output. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef ECHO</code><br />
            </span>
            
            <span class="none">
            <code>| /* This used to be an fputs(), but since the string might contain NUL's,</code><br />
            </span>
            
            <span class="none">
            <code>|  * we now use fwrite().</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,</code><br />
            </span>
            
            <span class="none">
            <code>|  * is returned in "result".</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_INPUT</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_INPUT(buf,result,max_size) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		int c = '*'; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		size_t n; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		for ( n = 0; n < max_size && \</code><br />
            </span>
            
            <span class="none">
            <code>| 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \</code><br />
            </span>
            
            <span class="none">
            <code>| 			buf[n] = (char) c; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( c == '\n' ) \</code><br />
            </span>
            
            <span class="none">
            <code>| 			buf[n++] = (char) c; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( c == EOF && ferror( yyin ) ) \</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "input in flex scanner failed" ); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		result = n; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	else \</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		errno=0; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \</code><br />
            </span>
            
            <span class="none">
            <code>| 			{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 			if( errno != EINTR) \</code><br />
            </span>
            
            <span class="none">
            <code>| 				{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 				YY_FATAL_ERROR( "input in flex scanner failed" ); \</code><br />
            </span>
            
            <span class="none">
            <code>| 				break; \</code><br />
            </span>
            
            <span class="none">
            <code>| 				} \</code><br />
            </span>
            
            <span class="none">
            <code>| 			errno=0; \</code><br />
            </span>
            
            <span class="none">
            <code>| 			clearerr(yyin); \</code><br />
            </span>
            
            <span class="none">
            <code>| 			} \</code><br />
            </span>
            
            <span class="none">
            <code>| 		}\</code><br />
            </span>
            
            <span class="none">
            <code>| \</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* No semi-colon after return; correct usage is to write "yyterminate();" -</code><br />
            </span>
            
            <span class="none">
            <code>|  * we don't want an extra ';' after the "return" because that will cause</code><br />
            </span>
            
            <span class="none">
            <code>|  * some compilers to complain about unreachable statements.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef yyterminate</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyterminate() return YY_NULL</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Number of entries by which start-condition stack grows. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_START_STACK_INCR</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_START_STACK_INCR 25</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Report a fatal error. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_FATAL_ERROR</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* end tables serialization structures and prototypes */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Default declaration of generated scanner - a define so the user can</code><br />
            </span>
            
            <span class="none">
            <code>|  * easily add parameters.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_DECL</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_DECL_IS_OURS 1</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| extern int yylex (void);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_DECL int yylex (void)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif /* !YY_DECL */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Code executed at the beginning of each rule, after yytext and yyleng</code><br />
            </span>
            
            <span class="none">
            <code>|  * have been set up.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_USER_ACTION</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_USER_ACTION</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Code executed at the end of each rule. */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_BREAK break;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_RULE_SETUP \</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_USER_ACTION</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** The main scanner function which does all the work.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| YY_DECL</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register yy_state_type yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 	register char *yy_cp, *yy_bp;</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int yy_act;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( !(yy_init) )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_init) = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_USER_INIT</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_USER_INIT;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|         /* Create the reject buffer large enough to save one state per allowed character. */</code><br />
            </span>
            
            <span class="none">
            <code>|         if ( ! (yy_state_buf) )</code><br />
            </span>
            
            <span class="none">
            <code>|             (yy_state_buf) = (yy_state_type *)yyalloc(YY_STATE_BUF_SIZE  );</code><br />
            </span>
            
            <span class="none">
            <code>|             if ( ! (yy_state_buf) )</code><br />
            </span>
            
            <span class="none">
            <code>|                 YY_FATAL_ERROR( "out of dynamic memory in yylex()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! (yy_start) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_start) = 1;	/* first start state */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! yyin )</code><br />
            </span>
            
            <span class="none">
            <code>| 			yyin = stdin;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! yyout )</code><br />
            </span>
            
            <span class="none">
            <code>| 			yyout = stdout;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! YY_CURRENT_BUFFER ) {</code><br />
            </span>
            
            <span class="none">
            <code>| 			yyensure_buffer_stack ();</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE =</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_create_buffer(yyin,YY_BUF_SIZE );</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	{</code><br />
            </span>
            
            <span class="none">
            <code>| #line 1 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #line 687 "lex.yy.c"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	while ( 1 )		/* loops until end-of-file is reached */</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_more_len) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( (yy_more_flag) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_more_len) = (yy_c_buf_p) - (yytext_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_more_flag) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Support of yytext. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		*yy_cp = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* yy_bp points to the position in yy_ch_buf of the start of</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * the current run.</code><br />
            </span>
            
            <span class="none">
            <code>| 		 */</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_bp = yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_current_state = (yy_start);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_state_ptr) = (yy_state_buf);</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| yy_match:</code><br />
            </span>
            
            <span class="none">
            <code>| 		do</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;</code><br />
            </span>
            
            <span class="none">
            <code>| 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_current_state = (int) yy_def[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| 				if ( yy_current_state >= 13 )</code><br />
            </span>
            
            <span class="none">
            <code>| 					yy_c = yy_meta[(unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 			*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 			++yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( yy_base[yy_current_state] != 10 );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| yy_find_action:</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_current_state = *--(yy_state_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_lp) = yy_accept[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| find_rule: /* we branch to this label when backing up */</code><br />
            </span>
            
            <span class="none">
            <code>| 		for ( ; ; ) /* until we find what rule we matched */</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			if ( (yy_lp) && (yy_lp) < yy_accept[yy_current_state + 1] )</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_act = yy_acclist[(yy_lp)];</code><br />
            </span>
            
            <span class="none">
            <code>| 					{</code><br />
            </span>
            
            <span class="none">
            <code>| 					(yy_full_match) = yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| 					break;</code><br />
            </span>
            
            <span class="none">
            <code>| 					}</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>| 			--yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_current_state = *--(yy_state_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_lp) = yy_accept[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_DO_BEFORE_ACTION;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| do_action:	/* This label is used only to access EOF actions. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		switch ( yy_act )</code><br />
            </span>
            
            <span class="none">
            <code>| 	{ /* beginning of action switch */</code><br />
            </span>
            
            <span class="none">
            <code>| case 1:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 2 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { ECHO; }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 2:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 3 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { REJECT; }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 3:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 4 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { yymore (); }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 4:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 5 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { yyless (1); }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 5:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 6 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { yyless (input () != 0); }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 6:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 7 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { unput (yytext[0]); }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 7:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 8 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| { BEGIN INITIAL; }</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| case 8:</code><br />
            </span>
            
            <span class="none">
            <code>| YY_RULE_SETUP</code><br />
            </span>
            
            <span class="none">
            <code>| #line 9 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>| ECHO;</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BREAK</code><br />
            </span>
            
            <span class="none">
            <code>| #line 793 "lex.yy.c"</code><br />
            </span>
            
            <span class="none">
            <code>| 			case YY_STATE_EOF(INITIAL):</code><br />
            </span>
            
            <span class="none">
            <code>| 				yyterminate();</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	case YY_END_OF_BUFFER:</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Amount of text matched not including the EOB char. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Undo the effects of YY_DO_BEFORE_ACTION. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		*yy_cp = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_RESTORE_YY_MORE_OFFSET</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* We're scanning a new file or input source.  It's</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * possible that this happened because the user</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * just pointed yyin at a new source and called</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * yylex().  If so, then we have to assure</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * consistency between YY_CURRENT_BUFFER and our</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * globals.  Here is the right place to do so, because</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * this is the first action (other than possibly a</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * back-up) that will match for the new input source.</code><br />
            </span>
            
            <span class="none">
            <code>| 			 */</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Note that here we test for yy_c_buf_p "<=" to the position</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * of the first EOB in the buffer, since yy_c_buf_p will</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * already have been incremented past the NUL character</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * (since all states make transitions on EOB to the</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * end-of-buffer state).  Contrast this with the test</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * in input().</code><br />
            </span>
            
            <span class="none">
            <code>| 		 */</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{ /* This was really a NUL. */</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_state_type yy_next_state;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_current_state = yy_get_previous_state(  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* Okay, we're now positioned to make the NUL</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * transition.  We couldn't have</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * yy_get_previous_state() go ahead and do it</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * for us because it doesn't know how to deal</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * with the possibility of jamming (and we don't</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * want to build jamming into it because then it</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * will run more slowly).</code><br />
            </span>
            
            <span class="none">
            <code>| 			 */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_next_state = yy_try_NUL_trans( yy_current_state );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_bp = (yytext_ptr) + YY_MORE_ADJ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			if ( yy_next_state )</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				/* Consume the NUL. */</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_cp = ++(yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_current_state = yy_next_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 				goto yy_match;</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			else</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 				goto yy_find_action;</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		else switch ( yy_get_next_buffer(  ) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			case EOB_ACT_END_OF_FILE:</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				(yy_did_buffer_switch_on_eof) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				if ( yywrap( ) )</code><br />
            </span>
            
            <span class="none">
            <code>| 					{</code><br />
            </span>
            
            <span class="none">
            <code>| 					/* Note: because we've taken care in</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * yy_get_next_buffer() to have set up</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * yytext, we can now set up</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * yy_c_buf_p so that if some total</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * hoser (like flex itself) wants to</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * call the scanner after we return the</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * YY_NULL, it'll still work - another</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * YY_NULL will get returned.</code><br />
            </span>
            
            <span class="none">
            <code>| 					 */</code><br />
            </span>
            
            <span class="none">
            <code>| 					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 					yy_act = YY_STATE_EOF(YY_START);</code><br />
            </span>
            
            <span class="none">
            <code>| 					goto do_action;</code><br />
            </span>
            
            <span class="none">
            <code>| 					}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				else</code><br />
            </span>
            
            <span class="none">
            <code>| 					{</code><br />
            </span>
            
            <span class="none">
            <code>| 					if ( ! (yy_did_buffer_switch_on_eof) )</code><br />
            </span>
            
            <span class="none">
            <code>| 						YY_NEW_FILE;</code><br />
            </span>
            
            <span class="none">
            <code>| 					}</code><br />
            </span>
            
            <span class="none">
            <code>| 				break;</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			case EOB_ACT_CONTINUE_SCAN:</code><br />
            </span>
            
            <span class="none">
            <code>| 				(yy_c_buf_p) =</code><br />
            </span>
            
            <span class="none">
            <code>| 					(yytext_ptr) + yy_amount_of_matched_text;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_current_state = yy_get_previous_state(  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;</code><br />
            </span>
            
            <span class="none">
            <code>| 				goto yy_match;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			case EOB_ACT_LAST_MATCH:</code><br />
            </span>
            
            <span class="none">
            <code>| 				(yy_c_buf_p) =</code><br />
            </span>
            
            <span class="none">
            <code>| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_current_state = yy_get_previous_state(  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;</code><br />
            </span>
            
            <span class="none">
            <code>| 				goto yy_find_action;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		break;</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	default:</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR(</code><br />
            </span>
            
            <span class="none">
            <code>| 			"fatal flex scanner internal error--no action found" );</code><br />
            </span>
            
            <span class="none">
            <code>| 	} /* end of action switch */</code><br />
            </span>
            
            <span class="none">
            <code>| 		} /* end of scanning one token */</code><br />
            </span>
            
            <span class="none">
            <code>| 	} /* end of user's declarations */</code><br />
            </span>
            
            <span class="none">
            <code>| } /* end of yylex */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yy_get_next_buffer - try to read in a new buffer</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * Returns a code representing an action:</code><br />
            </span>
            
            <span class="none">
            <code>|  *	EOB_ACT_LAST_MATCH -</code><br />
            </span>
            
            <span class="none">
            <code>|  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position</code><br />
            </span>
            
            <span class="none">
            <code>|  *	EOB_ACT_END_OF_FILE - end of file</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_get_next_buffer (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;</code><br />
            </span>
            
            <span class="none">
            <code>| 	register char *source = (yytext_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int number_to_move, i;</code><br />
            </span>
            
            <span class="none">
            <code>| 	int ret_val;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR(</code><br />
            </span>
            
            <span class="none">
            <code>| 		"fatal flex scanner internal error--end of buffer missed" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ /* Don't try to fill the buffer, so this is an EOF. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* We matched a single character, the EOB, so</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * treat this as a final EOF.</code><br />
            </span>
            
            <span class="none">
            <code>| 			 */</code><br />
            </span>
            
            <span class="none">
            <code>| 			return EOB_ACT_END_OF_FILE;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		else</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* We matched some text prior to the EOB, first</code><br />
            </span>
            
            <span class="none">
            <code>| 			 * process it.</code><br />
            </span>
            
            <span class="none">
            <code>| 			 */</code><br />
            </span>
            
            <span class="none">
            <code>| 			return EOB_ACT_LAST_MATCH;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Try to read more data. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* First move last chars to start of buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( i = 0; i < number_to_move; ++i )</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(dest++) = *(source++);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* don't do the read, it's not guaranteed to return an EOF,</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * just force an EOF</code><br />
            </span>
            
            <span class="none">
            <code>| 		 */</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	else</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_size_t num_to_read =</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( num_to_read <= 0 )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{ /* Not enough room in the buffer - grow it. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR(</code><br />
            </span>
            
            <span class="none">
            <code>| "input buffer overflow, can't enlarge buffer because scanner uses REJECT" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( num_to_read > YY_READ_BUF_SIZE )</code><br />
            </span>
            
            <span class="none">
            <code>| 			num_to_read = YY_READ_BUF_SIZE;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Read in more data. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_n_chars), num_to_read );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( (yy_n_chars) == 0 )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( number_to_move == YY_MORE_ADJ )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			ret_val = EOB_ACT_END_OF_FILE;</code><br />
            </span>
            
            <span class="none">
            <code>| 			yyrestart(yyin  );</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		else</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			ret_val = EOB_ACT_LAST_MATCH;</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =</code><br />
            </span>
            
            <span class="none">
            <code>| 				YY_BUFFER_EOF_PENDING;</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	else</code><br />
            </span>
            
            <span class="none">
            <code>| 		ret_val = EOB_ACT_CONTINUE_SCAN;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Extend the array by 50%, plus the number we really need. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_n_chars) += number_to_move;</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return ret_val;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yy_get_previous_state - get the state just before the EOB char was reached */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     static yy_state_type yy_get_previous_state (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register yy_state_type yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 	register char *yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_current_state = (yy_start);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_state_ptr) = (yy_state_buf);</code><br />
            </span>
            
            <span class="none">
            <code>| 	*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )</code><br />
            </span>
            
            <span class="none">
            <code>| 			{</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_current_state = (int) yy_def[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| 			if ( yy_current_state >= 13 )</code><br />
            </span>
            
            <span class="none">
            <code>| 				yy_c = yy_meta[(unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yy_try_NUL_trans - try to make a transition on the NUL character</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * synopsis</code><br />
            </span>
            
            <span class="none">
            <code>|  *	next_state = yy_try_NUL_trans( current_state );</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int yy_is_jam;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	register YY_CHAR yy_c = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_current_state = (int) yy_def[yy_current_state];</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( yy_current_state >= 13 )</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_c = yy_meta[(unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_is_jam = (yy_current_state == 12);</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! yy_is_jam )</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_state_ptr)++ = yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		return yy_is_jam ? 0 : yy_current_state;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     static void yyunput (int c, register char * yy_bp )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register char *yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     yy_cp = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* undo effects of setting up yytext */</code><br />
            </span>
            
            <span class="none">
            <code>| 	*yy_cp = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ /* need to shift things up to make room */</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* +2 for EOB chars. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		register yy_size_t number_to_move = (yy_n_chars) + 2;</code><br />
            </span>
            
            <span class="none">
            <code>| 		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[</code><br />
            </span>
            
            <span class="none">
            <code>| 					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];</code><br />
            </span>
            
            <span class="none">
            <code>| 		register char *source =</code><br />
            </span>
            
            <span class="none">
            <code>| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )</code><br />
            </span>
            
            <span class="none">
            <code>| 			*--dest = *--source;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_cp += (int) (dest - source);</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_bp += (int) (dest - source);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =</code><br />
            </span>
            
            <span class="none">
            <code>| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "flex scanner push-back overflow" );</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	*--yy_cp = (char) c;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) = yy_bp;</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_hold_char) = *yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_c_buf_p) = yy_cp;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_NO_INPUT</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>|     static int yyinput (void)</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>|     static int input  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	int c;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	*(yy_c_buf_p) = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* yy_c_buf_p now points to the character we want to return.</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * If this occurs *before* the EOB characters, then it's a</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * valid NUL; if not, then we've hit the end of the buffer.</code><br />
            </span>
            
            <span class="none">
            <code>| 		 */</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )</code><br />
            </span>
            
            <span class="none">
            <code>| 			/* This was really a NUL. */</code><br />
            </span>
            
            <span class="none">
            <code>| 			*(yy_c_buf_p) = '\0';</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		else</code><br />
            </span>
            
            <span class="none">
            <code>| 			{ /* need more input */</code><br />
            </span>
            
            <span class="none">
            <code>| 			yy_size_t offset = (yy_c_buf_p) - (yytext_ptr);</code><br />
            </span>
            
            <span class="none">
            <code>| 			++(yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 			switch ( yy_get_next_buffer(  ) )</code><br />
            </span>
            
            <span class="none">
            <code>| 				{</code><br />
            </span>
            
            <span class="none">
            <code>| 				case EOB_ACT_LAST_MATCH:</code><br />
            </span>
            
            <span class="none">
            <code>| 					/* This happens because yy_g_n_b()</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * sees that we've accumulated a</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * token and flags that we need to</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * try matching the token before</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * proceeding.  But for input(),</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * there's no matching to consider.</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * So convert the EOB_ACT_LAST_MATCH</code><br />
            </span>
            
            <span class="none">
            <code>| 					 * to EOB_ACT_END_OF_FILE.</code><br />
            </span>
            
            <span class="none">
            <code>| 					 */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 					/* Reset buffer status. */</code><br />
            </span>
            
            <span class="none">
            <code>| 					yyrestart(yyin );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 					/*FALLTHROUGH*/</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				case EOB_ACT_END_OF_FILE:</code><br />
            </span>
            
            <span class="none">
            <code>| 					{</code><br />
            </span>
            
            <span class="none">
            <code>| 					if ( yywrap( ) )</code><br />
            </span>
            
            <span class="none">
            <code>| 						return EOF;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 					if ( ! (yy_did_buffer_switch_on_eof) )</code><br />
            </span>
            
            <span class="none">
            <code>| 						YY_NEW_FILE;</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>| 					return yyinput();</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| 					return input();</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| 					}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 				case EOB_ACT_CONTINUE_SCAN:</code><br />
            </span>
            
            <span class="none">
            <code>| 					(yy_c_buf_p) = (yytext_ptr) + offset;</code><br />
            </span>
            
            <span class="none">
            <code>| 					break;</code><br />
            </span>
            
            <span class="none">
            <code>| 				}</code><br />
            </span>
            
            <span class="none">
            <code>| 			}</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */</code><br />
            </span>
            
            <span class="none">
            <code>| 	*(yy_c_buf_p) = '\0';	/* preserve yytext */</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_hold_char) = *++(yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return c;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>| #endif	/* ifndef YY_NO_INPUT */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Immediately switch to a different input stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param input_file A readable stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @note This function does not reset the start condition to @c INITIAL .</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     void yyrestart  (FILE * input_file )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! YY_CURRENT_BUFFER ){</code><br />
            </span>
            
            <span class="none">
            <code>|         yyensure_buffer_stack ();</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE =</code><br />
            </span>
            
            <span class="none">
            <code>|             yy_create_buffer(yyin,YY_BUF_SIZE );</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_init_buffer(YY_CURRENT_BUFFER,input_file );</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Switch to a different input buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param new_buffer The new input buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* TODO. We should be able to replace this entire function body</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * with</code><br />
            </span>
            
            <span class="none">
            <code>| 	 *		yypop_buffer_state();</code><br />
            </span>
            
            <span class="none">
            <code>| 	 *		yypush_buffer_state(new_buffer);</code><br />
            </span>
            
            <span class="none">
            <code>|      */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyensure_buffer_stack ();</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER == new_buffer )</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Flush out information for old buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_c_buf_p) = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* We don't actually know whether we did this switch during</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * EOF (yywrap()) processing, but the only time this flag</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * is looked at is after yywrap() is called, so it's safe</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * to go ahead and always set it.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_did_buffer_switch_on_eof) = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_load_buffer_state  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_hold_char) = *(yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Allocate and initialize an input buffer state.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param file A readable stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @return the allocated buffer state.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BUFFER_STATE b;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buf_size = size;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* yy_ch_buf has to be 2 characters longer than the size given because</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * we need to put in 2 end-of-buffer characters.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b->yy_ch_buf )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_is_our_buffer = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_init_buffer(b,file );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return b;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Destroy the buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param b a buffer created with yy_create_buffer()</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     void yy_delete_buffer (YY_BUFFER_STATE  b )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( b->yy_is_our_buffer )</code><br />
            </span>
            
            <span class="none">
            <code>| 		yyfree((void *) b->yy_ch_buf  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyfree((void *) b  );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Initializes or reinitializes a buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * This function is sometimes called more than once on the same buffer,</code><br />
            </span>
            
            <span class="none">
            <code>|  * such as during a yyrestart() or at EOF.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	int oerrno = errno;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_flush_buffer(b );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_input_file = file;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_fill_buffer = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     /* If b is the current buffer, then yy_init_buffer was _probably_</code><br />
            </span>
            
            <span class="none">
            <code>|      * called from yyrestart() or through yy_get_next_buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|      * In that case, we don't want to reset the lineno or column.</code><br />
            </span>
            
            <span class="none">
            <code>|      */</code><br />
            </span>
            
            <span class="none">
            <code>|     if (b != YY_CURRENT_BUFFER){</code><br />
            </span>
            
            <span class="none">
            <code>|         b->yy_bs_lineno = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|         b->yy_bs_column = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|         b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	errno = oerrno;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Discard all buffered characters. On the next scan, YY_INPUT will be called.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|     void yy_flush_buffer (YY_BUFFER_STATE  b )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_n_chars = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* We always need two end-of-buffer characters.  The first causes</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * a transition to the end-of-buffer state.  The second causes</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * a jam in that state.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buf_pos = &b->yy_ch_buf[0];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_at_bol = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buffer_status = YY_BUFFER_NEW;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( b == YY_CURRENT_BUFFER )</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Pushes the new state onto the stack. The new state becomes</code><br />
            </span>
            
            <span class="none">
            <code>|  *  the current state. This function will allocate the stack</code><br />
            </span>
            
            <span class="none">
            <code>|  *  if necessary.</code><br />
            </span>
            
            <span class="none">
            <code>|  *  @param new_buffer The new state.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| void yypush_buffer_state (YY_BUFFER_STATE new_buffer )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	if (new_buffer == NULL)</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyensure_buffer_stack();</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* This block is copied from yy_switch_to_buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( YY_CURRENT_BUFFER )</code><br />
            </span>
            
            <span class="none">
            <code>| 		{</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Flush out information for old buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_c_buf_p) = (yy_hold_char);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);</code><br />
            </span>
            
            <span class="none">
            <code>| 		}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Only push if top exists. Otherwise, replace top. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	if (YY_CURRENT_BUFFER)</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack_top)++;</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* copied from yy_switch_to_buffer. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_did_buffer_switch_on_eof) = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Removes and deletes the top of the stack, if present.</code><br />
            </span>
            
            <span class="none">
            <code>|  *  The next element becomes the new top.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| void yypop_buffer_state (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	if (!YY_CURRENT_BUFFER)</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_delete_buffer(YY_CURRENT_BUFFER );</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_CURRENT_BUFFER_LVALUE = NULL;</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ((yy_buffer_stack_top) > 0)</code><br />
            </span>
            
            <span class="none">
            <code>| 		--(yy_buffer_stack_top);</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if (YY_CURRENT_BUFFER) {</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_load_buffer_state( );</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_did_buffer_switch_on_eof) = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Allocates the stack if it does not exist.</code><br />
            </span>
            
            <span class="none">
            <code>|  *  Guarantees space for at least one push.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| static void yyensure_buffer_stack (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t num_to_alloc;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if (!(yy_buffer_stack)) {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* First allocation is just for 2 elements, since we don't know if this</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * scanner will even need a stack. We use 2 instead of 1 to avoid an</code><br />
            </span>
            
            <span class="none">
            <code>| 		 * immediate realloc on the next call.</code><br />
            </span>
            
            <span class="none">
            <code>|          */</code><br />
            </span>
            
            <span class="none">
            <code>| 		num_to_alloc = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc</code><br />
            </span>
            
            <span class="none">
            <code>| 								(num_to_alloc * sizeof(struct yy_buffer_state*)</code><br />
            </span>
            
            <span class="none">
            <code>| 								);</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! (yy_buffer_stack) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack_max) = num_to_alloc;</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack_top) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 		return;</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Increase the buffer to prepare for a possible push. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		int grow_size = 8 /* arbitrary grow size */;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		num_to_alloc = (yy_buffer_stack_max) + grow_size;</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc</code><br />
            </span>
            
            <span class="none">
            <code>| 								((yy_buffer_stack),</code><br />
            </span>
            
            <span class="none">
            <code>| 								num_to_alloc * sizeof(struct yy_buffer_state*)</code><br />
            </span>
            
            <span class="none">
            <code>| 								);</code><br />
            </span>
            
            <span class="none">
            <code>| 		if ( ! (yy_buffer_stack) )</code><br />
            </span>
            
            <span class="none">
            <code>| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* zero only the new slots.*/</code><br />
            </span>
            
            <span class="none">
            <code>| 		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_buffer_stack_max) = num_to_alloc;</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Setup the input buffer state to scan directly from a user-specified character buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param base the character buffer</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param size the size in bytes of the character buffer</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @return the newly allocated buffer state object.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BUFFER_STATE b;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( size < 2 ||</code><br />
            </span>
            
            <span class="none">
            <code>| 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||</code><br />
            </span>
            
            <span class="none">
            <code>| 	     base[size-1] != YY_END_OF_BUFFER_CHAR )</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* They forgot to leave room for the EOB's. */</code><br />
            </span>
            
            <span class="none">
            <code>| 		return 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buf_pos = b->yy_ch_buf = base;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_is_our_buffer = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_input_file = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_n_chars = b->yy_buf_size;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_is_interactive = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_at_bol = 1;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_fill_buffer = 0;</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_buffer_status = YY_BUFFER_NEW;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_switch_to_buffer(b  );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return b;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Setup the input buffer state to scan a string. The next call to yylex() will</code><br />
            </span>
            
            <span class="none">
            <code>|  * scan from a @e copy of @a str.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param yystr a NUL-terminated string to scan</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @return the newly allocated buffer state object.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @note If you want to scan bytes that may contain NUL values, then use</code><br />
            </span>
            
            <span class="none">
            <code>|  *       yy_scan_bytes() instead.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return yy_scan_bytes(yystr,strlen(yystr) );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Setup the input buffer state to scan the given bytes. The next call to yylex() will</code><br />
            </span>
            
            <span class="none">
            <code>|  * scan from a @e copy of @a bytes.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param yybytes the byte buffer to scan</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @return the newly allocated buffer state object.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	YY_BUFFER_STATE b;</code><br />
            </span>
            
            <span class="none">
            <code>| 	char *buf;</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t n;</code><br />
            </span>
            
            <span class="none">
            <code>| 	yy_size_t i;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Get memory for full buffer, including space for trailing EOB's. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	n = _yybytes_len + 2;</code><br />
            </span>
            
            <span class="none">
            <code>| 	buf = (char *) yyalloc(n  );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! buf )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( i = 0; i < _yybytes_len; ++i )</code><br />
            </span>
            
            <span class="none">
            <code>| 		buf[i] = yybytes[i];</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	b = yy_scan_buffer(buf,n );</code><br />
            </span>
            
            <span class="none">
            <code>| 	if ( ! b )</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* It's okay to grow etc. this buffer, and we should throw it</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * away when we're done.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	b->yy_is_our_buffer = 1;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return b;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef YY_EXIT_FAILURE</code><br />
            </span>
            
            <span class="none">
            <code>| #define YY_EXIT_FAILURE 2</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_fatal_error (yyconst char* msg )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|     	(void) fprintf( stderr, "%s\n", msg );</code><br />
            </span>
            
            <span class="none">
            <code>| 	exit( YY_EXIT_FAILURE );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Redefine yyless() so it works in section 3 code. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #undef yyless</code><br />
            </span>
            
            <span class="none">
            <code>| #define yyless(n) \</code><br />
            </span>
            
            <span class="none">
            <code>| 	do \</code><br />
            </span>
            
            <span class="none">
            <code>| 		{ \</code><br />
            </span>
            
            <span class="none">
            <code>| 		/* Undo effects of setting up yytext. */ \</code><br />
            </span>
            
            <span class="none">
            <code>|         int yyless_macro_arg = (n); \</code><br />
            </span>
            
            <span class="none">
            <code>|         YY_LESS_LINENO(yyless_macro_arg);\</code><br />
            </span>
            
            <span class="none">
            <code>| 		yytext[yyleng] = (yy_hold_char); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_c_buf_p) = yytext + yyless_macro_arg; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		(yy_hold_char) = *(yy_c_buf_p); \</code><br />
            </span>
            
            <span class="none">
            <code>| 		*(yy_c_buf_p) = '\0'; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		yyleng = yyless_macro_arg; \</code><br />
            </span>
            
            <span class="none">
            <code>| 		} \</code><br />
            </span>
            
            <span class="none">
            <code>| 	while ( 0 )</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Accessor  methods (get/set functions) to struct members. */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the current line number.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| int yyget_lineno  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     return yylineno;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the input stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyget_in  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yyin;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the output stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| FILE *yyget_out  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yyout;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the length of the current token.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| yy_size_t yyget_leng  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yyleng;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Get the current token.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| char *yyget_text  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yytext;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Set the current line number.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param line_number</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_lineno (int  line_number )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     yylineno = line_number;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /** Set the input stream. This does not discard the current</code><br />
            </span>
            
            <span class="none">
            <code>|  * input buffer.</code><br />
            </span>
            
            <span class="none">
            <code>|  * @param in_str A readable stream.</code><br />
            </span>
            
            <span class="none">
            <code>|  *</code><br />
            </span>
            
            <span class="none">
            <code>|  * @see yy_switch_to_buffer</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_in (FILE *  in_str )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         yyin = in_str ;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_out (FILE *  out_str )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         yyout = out_str ;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int yyget_debug  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         return yy_flex_debug;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyset_debug (int  bdebug )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         yy_flex_debug = bdebug ;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_init_globals (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|         /* Initialization is the same as for the non-reentrant scanner.</code><br />
            </span>
            
            <span class="none">
            <code>|      * This function is called from yylex_destroy(), so don't allocate here.</code><br />
            </span>
            
            <span class="none">
            <code>|      */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_buffer_stack) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_buffer_stack_top) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_buffer_stack_max) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_c_buf_p) = (char *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_init) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_start) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_state_buf) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_state_ptr) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_full_match) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_lp) = 0;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Defined in main.c */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_STDINIT</code><br />
            </span>
            
            <span class="none">
            <code>|     yyin = stdin;</code><br />
            </span>
            
            <span class="none">
            <code>|     yyout = stdout;</code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>|     yyin = (FILE *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>|     yyout = (FILE *) 0;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     /* For future reference: Set errno on error, since we are called by</code><br />
            </span>
            
            <span class="none">
            <code>|      * yylex_init()</code><br />
            </span>
            
            <span class="none">
            <code>|      */</code><br />
            </span>
            
            <span class="none">
            <code>|     return 0;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* yylex_destroy is for both reentrant and non-reentrant scanners. */</code><br />
            </span>
            
            <span class="none">
            <code>| int yylex_destroy  (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     /* Pop the buffer stack, destroying each element. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	while(YY_CURRENT_BUFFER){</code><br />
            </span>
            
            <span class="none">
            <code>| 		yy_delete_buffer(YY_CURRENT_BUFFER  );</code><br />
            </span>
            
            <span class="none">
            <code>| 		YY_CURRENT_BUFFER_LVALUE = NULL;</code><br />
            </span>
            
            <span class="none">
            <code>| 		yypop_buffer_state();</code><br />
            </span>
            
            <span class="none">
            <code>| 	}</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* Destroy the stack itself. */</code><br />
            </span>
            
            <span class="none">
            <code>| 	yyfree((yy_buffer_stack) );</code><br />
            </span>
            
            <span class="none">
            <code>| 	(yy_buffer_stack) = NULL;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     yyfree ( (yy_state_buf) );</code><br />
            </span>
            
            <span class="none">
            <code>|     (yy_state_buf)  = NULL;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     /* Reset the globals. This is important in a non-reentrant scanner so the next time</code><br />
            </span>
            
            <span class="none">
            <code>|      * yylex() is called, initialization will occur. */</code><br />
            </span>
            
            <span class="none">
            <code>|     yy_init_globals( );</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|     return 0;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /*</code><br />
            </span>
            
            <span class="none">
            <code>|  * Internal utility routines.</code><br />
            </span>
            
            <span class="none">
            <code>|  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifndef yytext_ptr</code><br />
            </span>
            
            <span class="none">
            <code>| static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int i;</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( i = 0; i < n; ++i )</code><br />
            </span>
            
            <span class="none">
            <code>| 		s1[i] = s2[i];</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YY_NEED_STRLEN</code><br />
            </span>
            
            <span class="none">
            <code>| static int yy_flex_strlen (yyconst char * s )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	register int n;</code><br />
            </span>
            
            <span class="none">
            <code>| 	for ( n = 0; s[n]; ++n )</code><br />
            </span>
            
            <span class="none">
            <code>| 		;</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| 	return n;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void *yyalloc (yy_size_t  size )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	return (void *) malloc( size );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void *yyrealloc  (void * ptr, yy_size_t  size )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	/* The cast to (char *) in the following accommodates both</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * implementations that use char* generic pointers, and those</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * that use void* generic pointers.  It works with the latter</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * because both ANSI C and C++ allow castless assignment from</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * any pointer type to void*, and deal with argument conversions</code><br />
            </span>
            
            <span class="none">
            <code>| 	 * as though doing an assignment.</code><br />
            </span>
            
            <span class="none">
            <code>| 	 */</code><br />
            </span>
            
            <span class="none">
            <code>| 	return (void *) realloc( (char *) ptr, size );</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| void yyfree (void * ptr )</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| 	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #define YYTABLES_NAME "yytables"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #line 9 "conftest.l"</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef YYTEXT_POINTER</code><br />
            </span>
            
            <span class="none">
            <code>| extern char *yytext;</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| int</code><br />
            </span>
            
            <span class="none">
            <code>| main (void)</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>|   return ! yylex () + ! yywrap ();</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>configure:3976: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:3993: checking for byacc</code><br />
            </span>
            
            <span class="none">
            <code>configure:4023: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:3993: checking for yacc</code><br />
            </span>
            
            <span class="none">
            <code>configure:4009: found /usr/sbin/yacc</code><br />
            </span>
            
            <span class="none">
            <code>configure:4020: result: yacc</code><br />
            </span>
            
            <span class="none">
            <code>configure:4039: checking for gawk</code><br />
            </span>
            
            <span class="none">
            <code>configure:4066: result: gawk</code><br />
            </span>
            
            <span class="none">
            <code>configure:4081: checking for date</code><br />
            </span>
            
            <span class="none">
            <code>configure:4097: found /usr/sbin/date</code><br />
            </span>
            
            <span class="none">
            <code>configure:4108: result: date</code><br />
            </span>
            
            <span class="none">
            <code>configure:4120: checking for log</code><br />
            </span>
            
            <span class="none">
            <code>configure:4120: arm-linux-androideabi-gcc -o conftest    conftest.c  >&5</code><br />
            </span>
            
            <span class="none">
            <code>conftest.c:34:6: warning: conflicting types for built-in function 'log' [enabled by default]</code><br />
            </span>
            
            <span class="none">
            <code>char log ();</code><br />
            </span>
            
            <span class="none">
            <code>^</code><br />
            </span>
            
            <span class="error">
            <code>/tmp/ccwIcDnj.o:conftest.c:function main: error: undefined reference to 'log'</code><br />
            </span>
            
            <span class="none">
            <code>collect2: error: ld returned 1 exit status</code><br />
            </span>
            
            <span class="none">
            <code>configure:4120: $? = 1</code><br />
            </span>
            
            <span class="none">
            <code>configure: failed program was:</code><br />
            </span>
            
            <span class="none">
            <code>| /* confdefs.h */</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_NAME "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_TARNAME "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_VERSION "2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_STRING "nickle 2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_BUGREPORT "http://nickle.org"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_URL ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define VERSION "2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| /* end confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>| /* Define log to an innocuous variant, in case <limits.h> declares log.</code><br />
            </span>
            
            <span class="none">
            <code>|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define log innocuous_log</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* System header to define __stub macros and hopefully few prototypes,</code><br />
            </span>
            
            <span class="none">
            <code>|     which can conflict with char log (); below.</code><br />
            </span>
            
            <span class="none">
            <code>|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since</code><br />
            </span>
            
            <span class="none">
            <code>|     <limits.h> exists even on freestanding compilers.  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __STDC__</code><br />
            </span>
            
            <span class="none">
            <code>| # include <limits.h></code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| # include <assert.h></code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #undef log</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Override any GCC internal prototype to avoid an error.</code><br />
            </span>
            
            <span class="none">
            <code>|    Use char because int might match the return type of a GCC</code><br />
            </span>
            
            <span class="none">
            <code>|    builtin and then its argument prototype would still apply.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>| extern "C"</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| char log ();</code><br />
            </span>
            
            <span class="none">
            <code>| /* The GNU C library defines this for functions which it implements</code><br />
            </span>
            
            <span class="none">
            <code>|     to always fail with ENOSYS.  Some functions are actually named</code><br />
            </span>
            
            <span class="none">
            <code>|     something starting with __ and the normal name is an alias.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #if defined __stub_log || defined __stub___log</code><br />
            </span>
            
            <span class="none">
            <code>| choke me</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int</code><br />
            </span>
            
            <span class="none">
            <code>| main ()</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| return log ();</code><br />
            </span>
            
            <span class="none">
            <code>|   ;</code><br />
            </span>
            
            <span class="none">
            <code>|   return 0;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>configure:4120: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:4124: checking for log in -lm</code><br />
            </span>
            
            <span class="none">
            <code>configure:4149: arm-linux-androideabi-gcc -o conftest    conftest.c -lm   >&5</code><br />
            </span>
            
            <span class="none">
            <code>conftest.c:18:6: warning: conflicting types for built-in function 'log' [enabled by default]</code><br />
            </span>
            
            <span class="none">
            <code>char log ();</code><br />
            </span>
            
            <span class="none">
            <code>^</code><br />
            </span>
            
            <span class="none">
            <code>configure:4149: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4158: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4171: checking for gethostbyname</code><br />
            </span>
            
            <span class="none">
            <code>configure:4171: arm-linux-androideabi-gcc -o conftest    conftest.c -lm  >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:4171: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4171: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4222: checking for socket</code><br />
            </span>
            
            <span class="none">
            <code>configure:4222: arm-linux-androideabi-gcc -o conftest    conftest.c -lm  >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:4222: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4222: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4318: checking for dlopen in -ldl</code><br />
            </span>
            
            <span class="none">
            <code>configure:4343: arm-linux-androideabi-gcc -o conftest    conftest.c -ldl  -lm  >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:4343: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4352: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4368: checking to see if compiler understands -Wl,-E</code><br />
            </span>
            
            <span class="none">
            <code>configure:4385: arm-linux-androideabi-gcc -o conftest  -Wl,-E   conftest.c -ldl -lm  >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:4385: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4401: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4419: checking how to run the C preprocessor</code><br />
            </span>
            
            <span class="none">
            <code>configure:4450: arm-linux-androideabi-gcc -E  conftest.c</code><br />
            </span>
            
            <span class="none">
            <code>configure:4450: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4464: arm-linux-androideabi-gcc -E  conftest.c</code><br />
            </span>
            
            <span class="error">
            <code>conftest.c:14:28: fatal error: ac_nonexistent.h: No such file or directory</code><br />
            </span>
            
            <span class="none">
            <code>#include <ac_nonexistent.h></code><br />
            </span>
            
            <span class="none">
            <code>^</code><br />
            </span>
            
            <span class="none">
            <code>compilation terminated.</code><br />
            </span>
            
            <span class="none">
            <code>configure:4464: $? = 1</code><br />
            </span>
            
            <span class="none">
            <code>configure: failed program was:</code><br />
            </span>
            
            <span class="none">
            <code>| /* confdefs.h */</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_NAME "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_TARNAME "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_VERSION "2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_STRING "nickle 2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_BUGREPORT "http://nickle.org"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_URL ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define VERSION "2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_LIBM 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_LIBDL 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_EXTERN_SYMS 1</code><br />
            </span>
            
            <span class="none">
            <code>| /* end confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #include <ac_nonexistent.h></code><br />
            </span>
            
            <span class="none">
            <code>configure:4489: result: arm-linux-androideabi-gcc -E</code><br />
            </span>
            
            <span class="none">
            <code>configure:4509: arm-linux-androideabi-gcc -E  conftest.c</code><br />
            </span>
            
            <span class="none">
            <code>configure:4509: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4523: arm-linux-androideabi-gcc -E  conftest.c</code><br />
            </span>
            
            <span class="error">
            <code>conftest.c:14:28: fatal error: ac_nonexistent.h: No such file or directory</code><br />
            </span>
            
            <span class="none">
            <code>#include <ac_nonexistent.h></code><br />
            </span>
            
            <span class="none">
            <code>^</code><br />
            </span>
            
            <span class="none">
            <code>compilation terminated.</code><br />
            </span>
            
            <span class="none">
            <code>configure:4523: $? = 1</code><br />
            </span>
            
            <span class="none">
            <code>configure: failed program was:</code><br />
            </span>
            
            <span class="none">
            <code>| /* confdefs.h */</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_NAME "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_TARNAME "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_VERSION "2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_STRING "nickle 2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_BUGREPORT "http://nickle.org"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_URL ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define VERSION "2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_LIBM 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_LIBDL 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_EXTERN_SYMS 1</code><br />
            </span>
            
            <span class="none">
            <code>| /* end confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #include <ac_nonexistent.h></code><br />
            </span>
            
            <span class="none">
            <code>configure:4552: checking for grep that handles long lines and -e</code><br />
            </span>
            
            <span class="none">
            <code>configure:4610: result: /usr/sbin/grep</code><br />
            </span>
            
            <span class="none">
            <code>configure:4615: checking for egrep</code><br />
            </span>
            
            <span class="none">
            <code>configure:4677: result: /usr/sbin/grep -E</code><br />
            </span>
            
            <span class="none">
            <code>configure:4682: checking for ANSI C header files</code><br />
            </span>
            
            <span class="none">
            <code>configure:4702: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:4702: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4786: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4799: checking for sys/types.h</code><br />
            </span>
            
            <span class="none">
            <code>configure:4799: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:4799: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4799: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4799: checking for sys/stat.h</code><br />
            </span>
            
            <span class="none">
            <code>configure:4799: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:4799: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4799: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4799: checking for stdlib.h</code><br />
            </span>
            
            <span class="none">
            <code>configure:4799: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:4799: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4799: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4799: checking for string.h</code><br />
            </span>
            
            <span class="none">
            <code>configure:4799: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:4799: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4799: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4799: checking for memory.h</code><br />
            </span>
            
            <span class="none">
            <code>configure:4799: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:4799: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4799: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4799: checking for strings.h</code><br />
            </span>
            
            <span class="none">
            <code>configure:4799: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:4799: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4799: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4799: checking for inttypes.h</code><br />
            </span>
            
            <span class="none">
            <code>configure:4799: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:4799: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4799: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4799: checking for stdint.h</code><br />
            </span>
            
            <span class="none">
            <code>configure:4799: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:4799: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4799: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4799: checking for unistd.h</code><br />
            </span>
            
            <span class="none">
            <code>configure:4799: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:4799: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4799: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: checking fcntl.h usability</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: checking fcntl.h presence</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: arm-linux-androideabi-gcc -E  conftest.c</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: checking for fcntl.h</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: checking for strings.h</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: checking time.h usability</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: checking time.h presence</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: arm-linux-androideabi-gcc -E  conftest.c</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: checking for time.h</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: checking sys/time.h usability</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: checking sys/time.h presence</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: arm-linux-androideabi-gcc -E  conftest.c</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: checking for sys/time.h</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: checking for unistd.h</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: checking sys/resource.h usability</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: checking sys/resource.h presence</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: arm-linux-androideabi-gcc -E  conftest.c</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: checking for sys/resource.h</code><br />
            </span>
            
            <span class="none">
            <code>configure:4815: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4828: checking stropts.h usability</code><br />
            </span>
            
            <span class="none">
            <code>configure:4828: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="error">
            <code>conftest.c:63:21: fatal error: stropts.h: No such file or directory</code><br />
            </span>
            
            <span class="none">
            <code>#include <stropts.h></code><br />
            </span>
            
            <span class="none">
            <code>^</code><br />
            </span>
            
            <span class="none">
            <code>compilation terminated.</code><br />
            </span>
            
            <span class="none">
            <code>configure:4828: $? = 1</code><br />
            </span>
            
            <span class="none">
            <code>configure: failed program was:</code><br />
            </span>
            
            <span class="none">
            <code>| /* confdefs.h */</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_NAME "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_TARNAME "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_VERSION "2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_STRING "nickle 2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_BUGREPORT "http://nickle.org"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_URL ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define VERSION "2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_LIBM 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_LIBDL 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_EXTERN_SYMS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define STDC_HEADERS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_TYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_STAT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDLIB_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRING_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_MEMORY_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRINGS_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_INTTYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDINT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_FCNTL_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRINGS_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_TIME_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_TIME_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_RESOURCE_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| /* end confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #include <stdio.h></code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef HAVE_SYS_TYPES_H</code><br />
            </span>
            
            <span class="none">
            <code>| # include <sys/types.h></code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef HAVE_SYS_STAT_H</code><br />
            </span>
            
            <span class="none">
            <code>| # include <sys/stat.h></code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef STDC_HEADERS</code><br />
            </span>
            
            <span class="none">
            <code>| # include <stdlib.h></code><br />
            </span>
            
            <span class="none">
            <code>| # include <stddef.h></code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| # ifdef HAVE_STDLIB_H</code><br />
            </span>
            
            <span class="none">
            <code>| #  include <stdlib.h></code><br />
            </span>
            
            <span class="none">
            <code>| # endif</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef HAVE_STRING_H</code><br />
            </span>
            
            <span class="none">
            <code>| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H</code><br />
            </span>
            
            <span class="none">
            <code>| #  include <memory.h></code><br />
            </span>
            
            <span class="none">
            <code>| # endif</code><br />
            </span>
            
            <span class="none">
            <code>| # include <string.h></code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef HAVE_STRINGS_H</code><br />
            </span>
            
            <span class="none">
            <code>| # include <strings.h></code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef HAVE_INTTYPES_H</code><br />
            </span>
            
            <span class="none">
            <code>| # include <inttypes.h></code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef HAVE_STDINT_H</code><br />
            </span>
            
            <span class="none">
            <code>| # include <stdint.h></code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef HAVE_UNISTD_H</code><br />
            </span>
            
            <span class="none">
            <code>| # include <unistd.h></code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #include <stropts.h></code><br />
            </span>
            
            <span class="none">
            <code>configure:4828: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:4828: checking stropts.h presence</code><br />
            </span>
            
            <span class="none">
            <code>configure:4828: arm-linux-androideabi-gcc -E  conftest.c</code><br />
            </span>
            
            <span class="error">
            <code>conftest.c:30:21: fatal error: stropts.h: No such file or directory</code><br />
            </span>
            
            <span class="none">
            <code>#include <stropts.h></code><br />
            </span>
            
            <span class="none">
            <code>^</code><br />
            </span>
            
            <span class="none">
            <code>compilation terminated.</code><br />
            </span>
            
            <span class="none">
            <code>configure:4828: $? = 1</code><br />
            </span>
            
            <span class="none">
            <code>configure: failed program was:</code><br />
            </span>
            
            <span class="none">
            <code>| /* confdefs.h */</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_NAME "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_TARNAME "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_VERSION "2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_STRING "nickle 2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_BUGREPORT "http://nickle.org"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_URL ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define VERSION "2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_LIBM 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_LIBDL 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_EXTERN_SYMS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define STDC_HEADERS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_TYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_STAT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDLIB_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRING_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_MEMORY_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRINGS_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_INTTYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDINT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_FCNTL_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRINGS_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_TIME_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_TIME_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_RESOURCE_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| /* end confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #include <stropts.h></code><br />
            </span>
            
            <span class="none">
            <code>configure:4828: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:4828: checking for stropts.h</code><br />
            </span>
            
            <span class="none">
            <code>configure:4828: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:4840: checking dlfcn.h usability</code><br />
            </span>
            
            <span class="none">
            <code>configure:4840: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:4840: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4840: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4840: checking dlfcn.h presence</code><br />
            </span>
            
            <span class="none">
            <code>configure:4840: arm-linux-androideabi-gcc -E  conftest.c</code><br />
            </span>
            
            <span class="none">
            <code>configure:4840: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4840: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4840: checking for dlfcn.h</code><br />
            </span>
            
            <span class="none">
            <code>configure:4840: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:4851: checking for inline</code><br />
            </span>
            
            <span class="none">
            <code>configure:4867: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:4867: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:4875: result: inline</code><br />
            </span>
            
            <span class="none">
            <code>configure:4902: checking for stdint.h</code><br />
            </span>
            
            <span class="none">
            <code>configure:4902: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:5052: checking for uint64_t</code><br />
            </span>
            
            <span class="none">
            <code>configure:5061: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:5075: checking return type of signal handlers</code><br />
            </span>
            
            <span class="none">
            <code>configure:5093: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>conftest.c: In function 'main':</code><br />
            </span>
            
            <span class="error">
            <code>conftest.c:40:1: error: void value not ignored as it ought to be</code><br />
            </span>
            
            <span class="none">
            <code>return *(signal (0, 0)) (0) == 1;</code><br />
            </span>
            
            <span class="none">
            <code>^</code><br />
            </span>
            
            <span class="none">
            <code>configure:5093: $? = 1</code><br />
            </span>
            
            <span class="none">
            <code>configure: failed program was:</code><br />
            </span>
            
            <span class="none">
            <code>| /* confdefs.h */</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_NAME "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_TARNAME "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_VERSION "2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_STRING "nickle 2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_BUGREPORT "http://nickle.org"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_URL ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define VERSION "2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_LIBM 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_LIBDL 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_EXTERN_SYMS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define STDC_HEADERS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_TYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_STAT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDLIB_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRING_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_MEMORY_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRINGS_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_INTTYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDINT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_FCNTL_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRINGS_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_TIME_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_TIME_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_RESOURCE_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_DLFCN_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_C_INLINE 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDINT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UINT64_T 1</code><br />
            </span>
            
            <span class="none">
            <code>| /* end confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #include <sys/types.h></code><br />
            </span>
            
            <span class="none">
            <code>| #include <signal.h></code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int</code><br />
            </span>
            
            <span class="none">
            <code>| main ()</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| return *(signal (0, 0)) (0) == 1;</code><br />
            </span>
            
            <span class="none">
            <code>|   ;</code><br />
            </span>
            
            <span class="none">
            <code>|   return 0;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>configure:5100: result: void</code><br />
            </span>
            
            <span class="none">
            <code>configure:5110: checking for vprintf</code><br />
            </span>
            
            <span class="none">
            <code>configure:5110: arm-linux-androideabi-gcc -o conftest    conftest.c -ldl -lm  >&5</code><br />
            </span>
            
            <span class="none">
            <code>conftest.c:58:6: warning: conflicting types for built-in function 'vprintf' [enabled by default]</code><br />
            </span>
            
            <span class="none">
            <code>char vprintf ();</code><br />
            </span>
            
            <span class="none">
            <code>^</code><br />
            </span>
            
            <span class="none">
            <code>configure:5110: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:5110: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:5116: checking for _doprnt</code><br />
            </span>
            
            <span class="none">
            <code>configure:5116: arm-linux-androideabi-gcc -o conftest    conftest.c -ldl -lm  >&5</code><br />
            </span>
            
            <span class="error">
            <code>/tmp/cc4CNWSh.o:conftest.c:function main: error: undefined reference to '_doprnt'</code><br />
            </span>
            
            <span class="none">
            <code>collect2: error: ld returned 1 exit status</code><br />
            </span>
            
            <span class="none">
            <code>configure:5116: $? = 1</code><br />
            </span>
            
            <span class="none">
            <code>configure: failed program was:</code><br />
            </span>
            
            <span class="none">
            <code>| /* confdefs.h */</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_NAME "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_TARNAME "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_VERSION "2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_STRING "nickle 2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_BUGREPORT "http://nickle.org"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_URL ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define VERSION "2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_LIBM 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_LIBDL 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_EXTERN_SYMS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define STDC_HEADERS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_TYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_STAT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDLIB_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRING_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_MEMORY_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRINGS_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_INTTYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDINT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_FCNTL_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRINGS_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_TIME_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_TIME_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_RESOURCE_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_DLFCN_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_C_INLINE 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDINT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UINT64_T 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define RETSIGTYPE void</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_VPRINTF 1</code><br />
            </span>
            
            <span class="none">
            <code>| /* end confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>| /* Define _doprnt to an innocuous variant, in case <limits.h> declares _doprnt.</code><br />
            </span>
            
            <span class="none">
            <code>|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define _doprnt innocuous__doprnt</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* System header to define __stub macros and hopefully few prototypes,</code><br />
            </span>
            
            <span class="none">
            <code>|     which can conflict with char _doprnt (); below.</code><br />
            </span>
            
            <span class="none">
            <code>|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since</code><br />
            </span>
            
            <span class="none">
            <code>|     <limits.h> exists even on freestanding compilers.  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __STDC__</code><br />
            </span>
            
            <span class="none">
            <code>| # include <limits.h></code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| # include <assert.h></code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #undef _doprnt</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Override any GCC internal prototype to avoid an error.</code><br />
            </span>
            
            <span class="none">
            <code>|    Use char because int might match the return type of a GCC</code><br />
            </span>
            
            <span class="none">
            <code>|    builtin and then its argument prototype would still apply.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>| extern "C"</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| char _doprnt ();</code><br />
            </span>
            
            <span class="none">
            <code>| /* The GNU C library defines this for functions which it implements</code><br />
            </span>
            
            <span class="none">
            <code>|     to always fail with ENOSYS.  Some functions are actually named</code><br />
            </span>
            
            <span class="none">
            <code>|     something starting with __ and the normal name is an alias.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #if defined __stub__doprnt || defined __stub____doprnt</code><br />
            </span>
            
            <span class="none">
            <code>| choke me</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int</code><br />
            </span>
            
            <span class="none">
            <code>| main ()</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| return _doprnt ();</code><br />
            </span>
            
            <span class="none">
            <code>|   ;</code><br />
            </span>
            
            <span class="none">
            <code>|   return 0;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>configure:5116: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5130: checking for unsetenv</code><br />
            </span>
            
            <span class="none">
            <code>configure:5130: arm-linux-androideabi-gcc -o conftest    conftest.c -ldl -lm  >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:5130: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:5130: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:5130: checking for setenv</code><br />
            </span>
            
            <span class="none">
            <code>configure:5130: arm-linux-androideabi-gcc -o conftest    conftest.c -ldl -lm  >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:5130: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:5130: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:5130: checking for putenv</code><br />
            </span>
            
            <span class="none">
            <code>configure:5130: arm-linux-androideabi-gcc -o conftest    conftest.c -ldl -lm  >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:5130: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:5130: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:5130: checking for gettimeofday</code><br />
            </span>
            
            <span class="none">
            <code>configure:5130: arm-linux-androideabi-gcc -o conftest    conftest.c -ldl -lm  >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:5130: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:5130: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:5130: checking for hstrerror</code><br />
            </span>
            
            <span class="none">
            <code>configure:5130: arm-linux-androideabi-gcc -o conftest    conftest.c -ldl -lm  >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:5130: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:5130: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:5130: checking for select</code><br />
            </span>
            
            <span class="none">
            <code>configure:5130: arm-linux-androideabi-gcc -o conftest    conftest.c -ldl -lm  >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:5130: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:5130: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:5143: checking for sigaction</code><br />
            </span>
            
            <span class="none">
            <code>configure:5143: arm-linux-androideabi-gcc -o conftest    conftest.c -ldl -lm  >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:5143: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:5143: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:5143: checking for sigrelse</code><br />
            </span>
            
            <span class="none">
            <code>configure:5143: arm-linux-androideabi-gcc -o conftest    conftest.c -ldl -lm  >&5</code><br />
            </span>
            
            <span class="error">
            <code>/tmp/ccmjn4r8.o:conftest.c:function main: error: undefined reference to 'sigrelse'</code><br />
            </span>
            
            <span class="none">
            <code>collect2: error: ld returned 1 exit status</code><br />
            </span>
            
            <span class="none">
            <code>configure:5143: $? = 1</code><br />
            </span>
            
            <span class="none">
            <code>configure: failed program was:</code><br />
            </span>
            
            <span class="none">
            <code>| /* confdefs.h */</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_NAME "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_TARNAME "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_VERSION "2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_STRING "nickle 2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_BUGREPORT "http://nickle.org"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_URL ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define VERSION "2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_LIBM 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_LIBDL 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_EXTERN_SYMS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define STDC_HEADERS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_TYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_STAT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDLIB_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRING_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_MEMORY_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRINGS_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_INTTYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDINT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_FCNTL_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRINGS_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_TIME_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_TIME_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_RESOURCE_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_DLFCN_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_C_INLINE 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDINT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UINT64_T 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define RETSIGTYPE void</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_VPRINTF 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNSETENV 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SETENV 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_PUTENV 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_GETTIMEOFDAY 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_HSTRERROR 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SELECT 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SIGACTION 1</code><br />
            </span>
            
            <span class="none">
            <code>| /* end confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>| /* Define sigrelse to an innocuous variant, in case <limits.h> declares sigrelse.</code><br />
            </span>
            
            <span class="none">
            <code>|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define sigrelse innocuous_sigrelse</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* System header to define __stub macros and hopefully few prototypes,</code><br />
            </span>
            
            <span class="none">
            <code>|     which can conflict with char sigrelse (); below.</code><br />
            </span>
            
            <span class="none">
            <code>|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since</code><br />
            </span>
            
            <span class="none">
            <code>|     <limits.h> exists even on freestanding compilers.  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __STDC__</code><br />
            </span>
            
            <span class="none">
            <code>| # include <limits.h></code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| # include <assert.h></code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #undef sigrelse</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Override any GCC internal prototype to avoid an error.</code><br />
            </span>
            
            <span class="none">
            <code>|    Use char because int might match the return type of a GCC</code><br />
            </span>
            
            <span class="none">
            <code>|    builtin and then its argument prototype would still apply.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>| extern "C"</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| char sigrelse ();</code><br />
            </span>
            
            <span class="none">
            <code>| /* The GNU C library defines this for functions which it implements</code><br />
            </span>
            
            <span class="none">
            <code>|     to always fail with ENOSYS.  Some functions are actually named</code><br />
            </span>
            
            <span class="none">
            <code>|     something starting with __ and the normal name is an alias.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #if defined __stub_sigrelse || defined __stub___sigrelse</code><br />
            </span>
            
            <span class="none">
            <code>| choke me</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int</code><br />
            </span>
            
            <span class="none">
            <code>| main ()</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| return sigrelse ();</code><br />
            </span>
            
            <span class="none">
            <code>|   ;</code><br />
            </span>
            
            <span class="none">
            <code>|   return 0;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>configure:5143: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5143: checking for sigignore</code><br />
            </span>
            
            <span class="none">
            <code>configure:5143: arm-linux-androideabi-gcc -o conftest    conftest.c -ldl -lm  >&5</code><br />
            </span>
            
            <span class="error">
            <code>/tmp/ccEno1Re.o:conftest.c:function main: error: undefined reference to 'sigignore'</code><br />
            </span>
            
            <span class="none">
            <code>collect2: error: ld returned 1 exit status</code><br />
            </span>
            
            <span class="none">
            <code>configure:5143: $? = 1</code><br />
            </span>
            
            <span class="none">
            <code>configure: failed program was:</code><br />
            </span>
            
            <span class="none">
            <code>| /* confdefs.h */</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_NAME "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_TARNAME "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_VERSION "2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_STRING "nickle 2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_BUGREPORT "http://nickle.org"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_URL ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define VERSION "2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_LIBM 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_LIBDL 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_EXTERN_SYMS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define STDC_HEADERS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_TYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_STAT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDLIB_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRING_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_MEMORY_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRINGS_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_INTTYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDINT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_FCNTL_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRINGS_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_TIME_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_TIME_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_RESOURCE_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_DLFCN_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_C_INLINE 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDINT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UINT64_T 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define RETSIGTYPE void</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_VPRINTF 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNSETENV 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SETENV 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_PUTENV 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_GETTIMEOFDAY 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_HSTRERROR 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SELECT 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SIGACTION 1</code><br />
            </span>
            
            <span class="none">
            <code>| /* end confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>| /* Define sigignore to an innocuous variant, in case <limits.h> declares sigignore.</code><br />
            </span>
            
            <span class="none">
            <code>|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #define sigignore innocuous_sigignore</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* System header to define __stub macros and hopefully few prototypes,</code><br />
            </span>
            
            <span class="none">
            <code>|     which can conflict with char sigignore (); below.</code><br />
            </span>
            
            <span class="none">
            <code>|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since</code><br />
            </span>
            
            <span class="none">
            <code>|     <limits.h> exists even on freestanding compilers.  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __STDC__</code><br />
            </span>
            
            <span class="none">
            <code>| # include <limits.h></code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| # include <assert.h></code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| #undef sigignore</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Override any GCC internal prototype to avoid an error.</code><br />
            </span>
            
            <span class="none">
            <code>|    Use char because int might match the return type of a GCC</code><br />
            </span>
            
            <span class="none">
            <code>|    builtin and then its argument prototype would still apply.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>| extern "C"</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| char sigignore ();</code><br />
            </span>
            
            <span class="none">
            <code>| /* The GNU C library defines this for functions which it implements</code><br />
            </span>
            
            <span class="none">
            <code>|     to always fail with ENOSYS.  Some functions are actually named</code><br />
            </span>
            
            <span class="none">
            <code>|     something starting with __ and the normal name is an alias.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #if defined __stub_sigignore || defined __stub___sigignore</code><br />
            </span>
            
            <span class="none">
            <code>| choke me</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| int</code><br />
            </span>
            
            <span class="none">
            <code>| main ()</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| return sigignore ();</code><br />
            </span>
            
            <span class="none">
            <code>|   ;</code><br />
            </span>
            
            <span class="none">
            <code>|   return 0;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>configure:5143: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5143: checking for setrlimit</code><br />
            </span>
            
            <span class="none">
            <code>configure:5143: arm-linux-androideabi-gcc -o conftest    conftest.c -ldl -lm  >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:5143: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:5143: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:5143: checking for getrlimit</code><br />
            </span>
            
            <span class="none">
            <code>configure:5143: arm-linux-androideabi-gcc -o conftest    conftest.c -ldl -lm  >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:5143: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:5143: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:5156: checking for dlopen</code><br />
            </span>
            
            <span class="none">
            <code>configure:5156: arm-linux-androideabi-gcc -o conftest    conftest.c -ldl -lm  >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:5156: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:5156: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:5156: checking for dlsym</code><br />
            </span>
            
            <span class="none">
            <code>configure:5156: arm-linux-androideabi-gcc -o conftest    conftest.c -ldl -lm  >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:5156: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:5156: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:5156: checking for dlerror</code><br />
            </span>
            
            <span class="none">
            <code>configure:5156: arm-linux-androideabi-gcc -o conftest    conftest.c -ldl -lm  >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:5156: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:5156: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:5156: checking for dlclose</code><br />
            </span>
            
            <span class="none">
            <code>configure:5156: arm-linux-androideabi-gcc -o conftest    conftest.c -ldl -lm  >&5</code><br />
            </span>
            
            <span class="none">
            <code>configure:5156: $? = 0</code><br />
            </span>
            
            <span class="none">
            <code>configure:5156: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:5167: checking whether getpgrp requires zero arguments</code><br />
            </span>
            
            <span class="none">
            <code>configure:5184: arm-linux-androideabi-gcc -c   conftest.c >&5</code><br />
            </span>
            
            <span class="none">
            <code>conftest.c: In function 'main':</code><br />
            </span>
            
            <span class="error">
            <code>conftest.c:85:1: error: too many arguments to function 'getpgrp'</code><br />
            </span>
            
            <span class="none">
            <code>getpgrp (0);</code><br />
            </span>
            
            <span class="none">
            <code>^</code><br />
            </span>
            
            <span class="none">
            <code>In file included from conftest.c:80:0:</code><br />
            </span>
            
            <span class="none">
            <code>/toolchain_root/sysroot/usr/include/unistd.h:61:15: note: declared here</code><br />
            </span>
            
            <span class="none">
            <code>extern pid_t  getpgrp(void);</code><br />
            </span>
            
            <span class="none">
            <code>^</code><br />
            </span>
            
            <span class="none">
            <code>configure:5184: $? = 1</code><br />
            </span>
            
            <span class="none">
            <code>configure: failed program was:</code><br />
            </span>
            
            <span class="none">
            <code>| /* confdefs.h */</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_NAME "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_TARNAME "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_VERSION "2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_STRING "nickle 2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_BUGREPORT "http://nickle.org"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_URL ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define VERSION "2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_LIBM 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_LIBDL 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_EXTERN_SYMS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define STDC_HEADERS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_TYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_STAT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDLIB_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRING_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_MEMORY_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRINGS_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_INTTYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDINT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_FCNTL_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRINGS_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_TIME_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_TIME_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_RESOURCE_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_DLFCN_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_C_INLINE 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDINT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UINT64_T 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define RETSIGTYPE void</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_VPRINTF 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNSETENV 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SETENV 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_PUTENV 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_GETTIMEOFDAY 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_HSTRERROR 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SELECT 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SIGACTION 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SETRLIMIT 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_GETRLIMIT 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_DLOPEN 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_DLSYM 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_DLERROR 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_DLCLOSE 1</code><br />
            </span>
            
            <span class="none">
            <code>| /* end confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #include <stdio.h></code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef HAVE_SYS_TYPES_H</code><br />
            </span>
            
            <span class="none">
            <code>| # include <sys/types.h></code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef HAVE_SYS_STAT_H</code><br />
            </span>
            
            <span class="none">
            <code>| # include <sys/stat.h></code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef STDC_HEADERS</code><br />
            </span>
            
            <span class="none">
            <code>| # include <stdlib.h></code><br />
            </span>
            
            <span class="none">
            <code>| # include <stddef.h></code><br />
            </span>
            
            <span class="none">
            <code>| #else</code><br />
            </span>
            
            <span class="none">
            <code>| # ifdef HAVE_STDLIB_H</code><br />
            </span>
            
            <span class="none">
            <code>| #  include <stdlib.h></code><br />
            </span>
            
            <span class="none">
            <code>| # endif</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef HAVE_STRING_H</code><br />
            </span>
            
            <span class="none">
            <code>| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H</code><br />
            </span>
            
            <span class="none">
            <code>| #  include <memory.h></code><br />
            </span>
            
            <span class="none">
            <code>| # endif</code><br />
            </span>
            
            <span class="none">
            <code>| # include <string.h></code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef HAVE_STRINGS_H</code><br />
            </span>
            
            <span class="none">
            <code>| # include <strings.h></code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef HAVE_INTTYPES_H</code><br />
            </span>
            
            <span class="none">
            <code>| # include <inttypes.h></code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef HAVE_STDINT_H</code><br />
            </span>
            
            <span class="none">
            <code>| # include <stdint.h></code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef HAVE_UNISTD_H</code><br />
            </span>
            
            <span class="none">
            <code>| # include <unistd.h></code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| int</code><br />
            </span>
            
            <span class="none">
            <code>| main ()</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| getpgrp (0);</code><br />
            </span>
            
            <span class="none">
            <code>|   ;</code><br />
            </span>
            
            <span class="none">
            <code>|   return 0;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>configure:5192: result: yes</code><br />
            </span>
            
            <span class="none">
            <code>configure:5223: checking for tparm in -lncurses</code><br />
            </span>
            
            <span class="none">
            <code>configure:5248: arm-linux-androideabi-gcc -o conftest    conftest.c -lncurses  -ldl -lm  >&5</code><br />
            </span>
            
            <span class="error">
            <code>/toolchain_root/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld: error: cannot find -lncurses</code><br />
            </span>
            
            <span class="error">
            <code>/tmp/ccQtz0ol.o:conftest.c:function main: error: undefined reference to 'tparm'</code><br />
            </span>
            
            <span class="none">
            <code>collect2: error: ld returned 1 exit status</code><br />
            </span>
            
            <span class="none">
            <code>configure:5248: $? = 1</code><br />
            </span>
            
            <span class="none">
            <code>configure: failed program was:</code><br />
            </span>
            
            <span class="none">
            <code>| /* confdefs.h */</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_NAME "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_TARNAME "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_VERSION "2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_STRING "nickle 2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_BUGREPORT "http://nickle.org"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_URL ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define VERSION "2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_LIBM 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_LIBDL 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_EXTERN_SYMS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define STDC_HEADERS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_TYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_STAT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDLIB_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRING_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_MEMORY_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRINGS_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_INTTYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDINT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_FCNTL_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRINGS_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_TIME_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_TIME_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_RESOURCE_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_DLFCN_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_C_INLINE 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDINT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UINT64_T 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define RETSIGTYPE void</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_VPRINTF 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNSETENV 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SETENV 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_PUTENV 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_GETTIMEOFDAY 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_HSTRERROR 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SELECT 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SIGACTION 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SETRLIMIT 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_GETRLIMIT 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_DLOPEN 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_DLSYM 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_DLERROR 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_DLCLOSE 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define GETPGRP_VOID 1</code><br />
            </span>
            
            <span class="none">
            <code>| /* end confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Override any GCC internal prototype to avoid an error.</code><br />
            </span>
            
            <span class="none">
            <code>|    Use char because int might match the return type of a GCC</code><br />
            </span>
            
            <span class="none">
            <code>|    builtin and then its argument prototype would still apply.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>| extern "C"</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| char tparm ();</code><br />
            </span>
            
            <span class="none">
            <code>| int</code><br />
            </span>
            
            <span class="none">
            <code>| main ()</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| return tparm ();</code><br />
            </span>
            
            <span class="none">
            <code>|   ;</code><br />
            </span>
            
            <span class="none">
            <code>|   return 0;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>configure:5257: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5262: checking for tgetent in -ltermcap</code><br />
            </span>
            
            <span class="none">
            <code>configure:5287: arm-linux-androideabi-gcc -o conftest    conftest.c -ltermcap  -ldl -lm  >&5</code><br />
            </span>
            
            <span class="error">
            <code>/toolchain_root/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld: error: cannot find -ltermcap</code><br />
            </span>
            
            <span class="error">
            <code>/tmp/ccKgGzWj.o:conftest.c:function main: error: undefined reference to 'tgetent'</code><br />
            </span>
            
            <span class="none">
            <code>collect2: error: ld returned 1 exit status</code><br />
            </span>
            
            <span class="none">
            <code>configure:5287: $? = 1</code><br />
            </span>
            
            <span class="none">
            <code>configure: failed program was:</code><br />
            </span>
            
            <span class="none">
            <code>| /* confdefs.h */</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_NAME "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_TARNAME "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_VERSION "2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_STRING "nickle 2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_BUGREPORT "http://nickle.org"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_URL ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define VERSION "2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_LIBM 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_LIBDL 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_EXTERN_SYMS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define STDC_HEADERS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_TYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_STAT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDLIB_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRING_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_MEMORY_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRINGS_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_INTTYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDINT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_FCNTL_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRINGS_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_TIME_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_TIME_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_RESOURCE_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_DLFCN_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_C_INLINE 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDINT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UINT64_T 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define RETSIGTYPE void</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_VPRINTF 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNSETENV 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SETENV 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_PUTENV 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_GETTIMEOFDAY 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_HSTRERROR 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SELECT 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SIGACTION 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SETRLIMIT 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_GETRLIMIT 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_DLOPEN 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_DLSYM 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_DLERROR 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_DLCLOSE 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define GETPGRP_VOID 1</code><br />
            </span>
            
            <span class="none">
            <code>| /* end confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Override any GCC internal prototype to avoid an error.</code><br />
            </span>
            
            <span class="none">
            <code>|    Use char because int might match the return type of a GCC</code><br />
            </span>
            
            <span class="none">
            <code>|    builtin and then its argument prototype would still apply.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>| extern "C"</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| char tgetent ();</code><br />
            </span>
            
            <span class="none">
            <code>| int</code><br />
            </span>
            
            <span class="none">
            <code>| main ()</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| return tgetent ();</code><br />
            </span>
            
            <span class="none">
            <code>|   ;</code><br />
            </span>
            
            <span class="none">
            <code>|   return 0;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>configure:5296: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5310: checking for readline in -lreadline</code><br />
            </span>
            
            <span class="none">
            <code>configure:5335: arm-linux-androideabi-gcc -o conftest      conftest.c -lreadline  -ldl -lm   >&5</code><br />
            </span>
            
            <span class="error">
            <code>/toolchain_root/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld: error: cannot find -lreadline</code><br />
            </span>
            
            <span class="error">
            <code>/tmp/cc0fryu4.o:conftest.c:function main: error: undefined reference to 'readline'</code><br />
            </span>
            
            <span class="none">
            <code>collect2: error: ld returned 1 exit status</code><br />
            </span>
            
            <span class="none">
            <code>configure:5335: $? = 1</code><br />
            </span>
            
            <span class="none">
            <code>configure: failed program was:</code><br />
            </span>
            
            <span class="none">
            <code>| /* confdefs.h */</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_NAME "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_TARNAME "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_VERSION "2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_STRING "nickle 2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_BUGREPORT "http://nickle.org"</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE_URL ""</code><br />
            </span>
            
            <span class="none">
            <code>| #define PACKAGE "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>| #define VERSION "2.70"</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_LIBM 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_LIBDL 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_EXTERN_SYMS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define STDC_HEADERS 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_TYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_STAT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDLIB_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRING_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_MEMORY_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRINGS_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_INTTYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDINT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_FCNTL_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STRINGS_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_TIME_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_TIME_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SYS_RESOURCE_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_DLFCN_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_C_INLINE 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_STDINT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UINT64_T 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define RETSIGTYPE void</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_VPRINTF 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_UNSETENV 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SETENV 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_PUTENV 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_GETTIMEOFDAY 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_HSTRERROR 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SELECT 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SIGACTION 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_SETRLIMIT 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_GETRLIMIT 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_DLOPEN 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_DLSYM 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_DLERROR 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define HAVE_DLCLOSE 1</code><br />
            </span>
            
            <span class="none">
            <code>| #define GETPGRP_VOID 1</code><br />
            </span>
            
            <span class="none">
            <code>| /* end confdefs.h.  */</code><br />
            </span>
            
            <span class="none">
            <code>|</code><br />
            </span>
            
            <span class="none">
            <code>| /* Override any GCC internal prototype to avoid an error.</code><br />
            </span>
            
            <span class="none">
            <code>|    Use char because int might match the return type of a GCC</code><br />
            </span>
            
            <span class="none">
            <code>|    builtin and then its argument prototype would still apply.  */</code><br />
            </span>
            
            <span class="none">
            <code>| #ifdef __cplusplus</code><br />
            </span>
            
            <span class="none">
            <code>| extern "C"</code><br />
            </span>
            
            <span class="none">
            <code>| #endif</code><br />
            </span>
            
            <span class="none">
            <code>| char readline ();</code><br />
            </span>
            
            <span class="none">
            <code>| int</code><br />
            </span>
            
            <span class="none">
            <code>| main ()</code><br />
            </span>
            
            <span class="none">
            <code>| {</code><br />
            </span>
            
            <span class="none">
            <code>| return readline ();</code><br />
            </span>
            
            <span class="none">
            <code>|   ;</code><br />
            </span>
            
            <span class="none">
            <code>|   return 0;</code><br />
            </span>
            
            <span class="none">
            <code>| }</code><br />
            </span>
            
            <span class="none">
            <code>configure:5344: result: no</code><br />
            </span>
            
            <span class="none">
            <code>configure:5357: result: Cannot find readline.  Build with --without-readline or set the readline path appropriately.</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>## ---------------- ##</code><br />
            </span>
            
            <span class="none">
            <code>## Cache variables. ##</code><br />
            </span>
            
            <span class="none">
            <code>## ---------------- ##</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_c_compiler_gnu=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_c_inline=inline</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_CC_set=set</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_CC_value=arm-linux-androideabi-gcc</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_CFLAGS_set=set</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_CFLAGS_value=</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_CPPFLAGS_set=set</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_CPPFLAGS_value=</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_CPP_set=</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_CPP_value=</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_LDFLAGS_set=set</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_LDFLAGS_value=</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_LIBS_set=</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_LIBS_value=</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_build_alias_set=</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_build_alias_value=</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_host_alias_set=set</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_host_alias_value=x86_64-unknown-linux</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_target_alias_set=</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_env_target_alias_value=</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func__doprnt=no</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_dlclose=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_dlerror=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_dlopen=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_dlsym=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_gethostbyname=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_getpgrp_void=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_getrlimit=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_gettimeofday=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_hstrerror=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_log=no</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_putenv=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_select=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_setenv=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_setrlimit=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_sigaction=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_sigignore=no</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_sigrelse=no</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_socket=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_unsetenv=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_func_vprintf=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_header_dlfcn_h=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_header_fcntl_h=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_header_inttypes_h=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_header_memory_h=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_header_stdc=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_header_stdint_h=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_header_stdlib_h=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_header_string_h=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_header_strings_h=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_header_stropts_h=no</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_header_sys_resource_h=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_header_sys_stat_h=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_header_sys_time_h=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_header_sys_types_h=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_header_time_h=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_header_unistd_h=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_lib_dl_dlopen=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_lib_lex='none needed'</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_lib_m_log=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_lib_ncurses_tparm=no</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_lib_readline_readline=no</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_lib_termcap_tgetent=no</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_objext=o</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_path_EGREP='/usr/sbin/grep -E'</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_path_GREP=/usr/sbin/grep</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_path_install='/usr/bin/install -c'</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_path_mkdir=/usr/sbin/mkdir</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_prog_AWK=gawk</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_prog_CC=arm-linux-androideabi-gcc</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_prog_CPP='arm-linux-androideabi-gcc -E'</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_prog_DATE=date</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_prog_LEX=flex</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_prog_YACC=yacc</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_prog_ac_ct_STRIP=strip</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_prog_cc_c89=</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_prog_cc_g=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_prog_lex_root=lex.yy</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_prog_lex_yytext_pointer=no</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_prog_make_make_set=yes</code><br />
            </span>
            
            <span class="none">
            <code>ac_cv_type_signal=void</code><br />
            </span>
            
            <span class="none">
            <code>am_cv_CC_dependencies_compiler_type=gcc3</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>## ----------------- ##</code><br />
            </span>
            
            <span class="none">
            <code>## Output variables. ##</code><br />
            </span>
            
            <span class="none">
            <code>## ----------------- ##</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>ACLOCAL='${SHELL} /tmp/nickle/src/nickle-2.70/missing --run aclocal-1.11'</code><br />
            </span>
            
            <span class="none">
            <code>AMDEPBACKSLASH='\'</code><br />
            </span>
            
            <span class="none">
            <code>AMDEP_FALSE='#'</code><br />
            </span>
            
            <span class="none">
            <code>AMDEP_TRUE=''</code><br />
            </span>
            
            <span class="none">
            <code>AMTAR='${SHELL} /tmp/nickle/src/nickle-2.70/missing --run tar'</code><br />
            </span>
            
            <span class="none">
            <code>AUTOCONF='${SHELL} /tmp/nickle/src/nickle-2.70/missing --run autoconf'</code><br />
            </span>
            
            <span class="none">
            <code>AUTOHEADER='${SHELL} /tmp/nickle/src/nickle-2.70/missing --run autoheader'</code><br />
            </span>
            
            <span class="none">
            <code>AUTOMAKE='${SHELL} /tmp/nickle/src/nickle-2.70/missing --run automake-1.11'</code><br />
            </span>
            
            <span class="none">
            <code>AWK='gawk'</code><br />
            </span>
            
            <span class="none">
            <code>CC='arm-linux-androideabi-gcc'</code><br />
            </span>
            
            <span class="none">
            <code>CCDEPMODE='depmode=gcc3'</code><br />
            </span>
            
            <span class="none">
            <code>CFLAGS=''</code><br />
            </span>
            
            <span class="none">
            <code>CPP='arm-linux-androideabi-gcc -E'</code><br />
            </span>
            
            <span class="none">
            <code>CPPFLAGS=' '</code><br />
            </span>
            
            <span class="none">
            <code>CYGPATH_W='echo'</code><br />
            </span>
            
            <span class="none">
            <code>DATE='date'</code><br />
            </span>
            
            <span class="none">
            <code>DEFS=''</code><br />
            </span>
            
            <span class="none">
            <code>DEPDIR='.deps'</code><br />
            </span>
            
            <span class="none">
            <code>ECHO_C=''</code><br />
            </span>
            
            <span class="none">
            <code>ECHO_N='-n'</code><br />
            </span>
            
            <span class="none">
            <code>ECHO_T=''</code><br />
            </span>
            
            <span class="none">
            <code>EGREP='/usr/sbin/grep -E'</code><br />
            </span>
            
            <span class="none">
            <code>EXEEXT=''</code><br />
            </span>
            
            <span class="none">
            <code>GREP='/usr/sbin/grep'</code><br />
            </span>
            
            <span class="none">
            <code>INSTALL_DATA='${INSTALL} -m 644'</code><br />
            </span>
            
            <span class="none">
            <code>INSTALL_PROGRAM='${INSTALL}'</code><br />
            </span>
            
            <span class="none">
            <code>INSTALL_SCRIPT='${INSTALL}'</code><br />
            </span>
            
            <span class="none">
            <code>INSTALL_STRIP_PROGRAM='$(install_sh) -c -s'</code><br />
            </span>
            
            <span class="none">
            <code>LDFLAGS=' '</code><br />
            </span>
            
            <span class="none">
            <code>LEX='flex'</code><br />
            </span>
            
            <span class="none">
            <code>LEXLIB=''</code><br />
            </span>
            
            <span class="none">
            <code>LEX_OUTPUT_ROOT='lex.yy'</code><br />
            </span>
            
            <span class="none">
            <code>LIBOBJS=''</code><br />
            </span>
            
            <span class="none">
            <code>LIBS='-ldl -lm  '</code><br />
            </span>
            
            <span class="none">
            <code>LN_S='ln -s'</code><br />
            </span>
            
            <span class="none">
            <code>LTLIBOBJS=''</code><br />
            </span>
            
            <span class="none">
            <code>MAINT='#'</code><br />
            </span>
            
            <span class="none">
            <code>MAINTAINER_MODE_FALSE=''</code><br />
            </span>
            
            <span class="none">
            <code>MAINTAINER_MODE_TRUE='#'</code><br />
            </span>
            
            <span class="none">
            <code>MAKEINFO='${SHELL} /tmp/nickle/src/nickle-2.70/missing --run makeinfo'</code><br />
            </span>
            
            <span class="none">
            <code>MKDIR_P='/usr/sbin/mkdir -p'</code><br />
            </span>
            
            <span class="none">
            <code>NICKLE_LDFLAGS='-Wl,-E'</code><br />
            </span>
            
            <span class="none">
            <code>OBJEXT='o'</code><br />
            </span>
            
            <span class="none">
            <code>PACKAGE='nickle'</code><br />
            </span>
            
            <span class="none">
            <code>PACKAGE_BUGREPORT='http://nickle.org'</code><br />
            </span>
            
            <span class="none">
            <code>PACKAGE_NAME='nickle'</code><br />
            </span>
            
            <span class="none">
            <code>PACKAGE_STRING='nickle 2.70'</code><br />
            </span>
            
            <span class="none">
            <code>PACKAGE_TARNAME='nickle'</code><br />
            </span>
            
            <span class="none">
            <code>PACKAGE_URL=''</code><br />
            </span>
            
            <span class="none">
            <code>PACKAGE_VERSION='2.70'</code><br />
            </span>
            
            <span class="none">
            <code>PATH_SEPARATOR=':'</code><br />
            </span>
            
            <span class="none">
            <code>SET_MAKE=''</code><br />
            </span>
            
            <span class="none">
            <code>SHELL='/bin/sh'</code><br />
            </span>
            
            <span class="none">
            <code>STRIP='strip'</code><br />
            </span>
            
            <span class="none">
            <code>VERSION='2.70'</code><br />
            </span>
            
            <span class="none">
            <code>YACC='yacc'</code><br />
            </span>
            
            <span class="none">
            <code>ac_ct_CC=''</code><br />
            </span>
            
            <span class="none">
            <code>am__EXEEXT_FALSE=''</code><br />
            </span>
            
            <span class="none">
            <code>am__EXEEXT_TRUE=''</code><br />
            </span>
            
            <span class="none">
            <code>am__fastdepCC_FALSE='#'</code><br />
            </span>
            
            <span class="none">
            <code>am__fastdepCC_TRUE=''</code><br />
            </span>
            
            <span class="none">
            <code>am__include='include'</code><br />
            </span>
            
            <span class="none">
            <code>am__isrc=''</code><br />
            </span>
            
            <span class="none">
            <code>am__leading_dot='.'</code><br />
            </span>
            
            <span class="none">
            <code>am__quote=''</code><br />
            </span>
            
            <span class="none">
            <code>am__tar='${AMTAR} chof - "$$tardir"'</code><br />
            </span>
            
            <span class="none">
            <code>am__untar='${AMTAR} xf -'</code><br />
            </span>
            
            <span class="none">
            <code>bindir='${exec_prefix}/bin'</code><br />
            </span>
            
            <span class="none">
            <code>build_alias=''</code><br />
            </span>
            
            <span class="none">
            <code>datadir='${datarootdir}'</code><br />
            </span>
            
            <span class="none">
            <code>datarootdir='${prefix}/share'</code><br />
            </span>
            
            <span class="none">
            <code>docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'</code><br />
            </span>
            
            <span class="none">
            <code>dvidir='${docdir}'</code><br />
            </span>
            
            <span class="none">
            <code>exec_prefix='NONE'</code><br />
            </span>
            
            <span class="none">
            <code>host_alias='x86_64-unknown-linux'</code><br />
            </span>
            
            <span class="none">
            <code>htmldir='${docdir}'</code><br />
            </span>
            
            <span class="none">
            <code>includedir='${prefix}/include'</code><br />
            </span>
            
            <span class="none">
            <code>infodir='${datarootdir}/info'</code><br />
            </span>
            
            <span class="none">
            <code>install_sh='${SHELL} /tmp/nickle/src/nickle-2.70/install-sh'</code><br />
            </span>
            
            <span class="none">
            <code>libdir='${exec_prefix}/lib'</code><br />
            </span>
            
            <span class="none">
            <code>libexecdir='${exec_prefix}/libexec'</code><br />
            </span>
            
            <span class="none">
            <code>localedir='${datarootdir}/locale'</code><br />
            </span>
            
            <span class="none">
            <code>localstatedir='${prefix}/var'</code><br />
            </span>
            
            <span class="none">
            <code>mandir='${datarootdir}/man'</code><br />
            </span>
            
            <span class="none">
            <code>mkdir_p='/usr/sbin/mkdir -p'</code><br />
            </span>
            
            <span class="none">
            <code>nicklelibdir=''</code><br />
            </span>
            
            <span class="none">
            <code>oldincludedir='/usr/include'</code><br />
            </span>
            
            <span class="none">
            <code>pdfdir='${docdir}'</code><br />
            </span>
            
            <span class="none">
            <code>prefix='/usr'</code><br />
            </span>
            
            <span class="none">
            <code>program_transform_name='s,x,x,'</code><br />
            </span>
            
            <span class="none">
            <code>psdir='${docdir}'</code><br />
            </span>
            
            <span class="none">
            <code>sbindir='${exec_prefix}/sbin'</code><br />
            </span>
            
            <span class="none">
            <code>sharedstatedir='${prefix}/com'</code><br />
            </span>
            
            <span class="none">
            <code>sysconfdir='${prefix}/etc'</code><br />
            </span>
            
            <span class="none">
            <code>target_alias=''</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>## ----------- ##</code><br />
            </span>
            
            <span class="none">
            <code>## confdefs.h. ##</code><br />
            </span>
            
            <span class="none">
            <code>## ----------- ##</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>/* confdefs.h */</code><br />
            </span>
            
            <span class="none">
            <code>#define PACKAGE_NAME "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>#define PACKAGE_TARNAME "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>#define PACKAGE_VERSION "2.70"</code><br />
            </span>
            
            <span class="none">
            <code>#define PACKAGE_STRING "nickle 2.70"</code><br />
            </span>
            
            <span class="none">
            <code>#define PACKAGE_BUGREPORT "http://nickle.org"</code><br />
            </span>
            
            <span class="none">
            <code>#define PACKAGE_URL ""</code><br />
            </span>
            
            <span class="none">
            <code>#define PACKAGE "nickle"</code><br />
            </span>
            
            <span class="none">
            <code>#define VERSION "2.70"</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_LIBM 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_LIBDL 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_EXTERN_SYMS 1</code><br />
            </span>
            
            <span class="none">
            <code>#define STDC_HEADERS 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_SYS_TYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_SYS_STAT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_STDLIB_H 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_STRING_H 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_MEMORY_H 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_STRINGS_H 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_INTTYPES_H 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_STDINT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_FCNTL_H 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_STRINGS_H 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_TIME_H 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_SYS_TIME_H 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_UNISTD_H 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_SYS_RESOURCE_H 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_DLFCN_H 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_C_INLINE 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_STDINT_H 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_UINT64_T 1</code><br />
            </span>
            
            <span class="none">
            <code>#define RETSIGTYPE void</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_VPRINTF 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_UNSETENV 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_SETENV 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_PUTENV 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_GETTIMEOFDAY 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_HSTRERROR 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_SELECT 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_SIGACTION 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_SETRLIMIT 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_GETRLIMIT 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_DLOPEN 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_DLSYM 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_DLERROR 1</code><br />
            </span>
            
            <span class="none">
            <code>#define HAVE_DLCLOSE 1</code><br />
            </span>
            
            <span class="none">
            <code>#define GETPGRP_VOID 1</code><br />
            </span>
            
            <span class="none">
            <code></code><br />
            </span>
            
            <span class="none">
            <code>configure: exit 1</code><br />
            </span>
            
          </div>
        
      </div>
      <br />
    
  </body>
</html>