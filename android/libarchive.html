        <html><head></head><body>
        <h1>Report for libarchive on toolchain
            <a href="index.html">android</a>
        </h1>
        <p>Return code: 0</p>
        <p>Time to run: 00:02:29</p>
        <p>Log output:</p>
        <code><pre><docker run --rm -v /tuscan_data --volumes-from tuscan_data -v /sources --volumes-from sources -v /var/cache/pacman/pkg --volumes-from pkg_cache_android -v logs:/logs make_package_container --sources-directory /sources --shared-directory /tuscan_data libarchive
:: Synchronizing package databases...
downloading repo.db...
downloading core.db...
downloading extra.db...
downloading community.db...
Found 2207 packages in cache
===> sudo -u tuscan makepkg --nobuild --syncdeps --skipinteg --skippgpcheck --skipchecksums --noconfirm --nocolor --log --noprogressbar --nocheck
==> Making package: libarchive 3.1.2-8 (Sat Nov 14 00:09:18 UTC 2015)
==> Checking runtime dependencies...
==> Checking buildtime dependencies...
==> Retrieving sources...
  -> Downloading libarchive-3.1.2.tar.gz...
  -> Found 0001-mtree-fix-line-filename-length-calculation.patch
  -> Found 0001-Limit-write-requests-to-at-most-INT_MAX.patch
  -> Found libarchive-3.1.2-acl.patch
  -> Found libarchive-3.1.2-sparce-mtree.patch
==> WARNING: Skipping all source file integrity checks.
==> Extracting sources...
  -> Extracting libarchive-3.1.2.tar.gz with bsdtar
==> Starting prepare()...
patching file libarchive/archive_write_set_format_mtree.c
patching file libarchive/archive_read_disk_entry_from_file.c
patching file libarchive/archive_write_disk_acl.c
patching file libarchive/archive_write.c
Hunk #1 succeeded at 671 (offset -2 lines).
patching file libarchive/archive_read_support_format_mtree.c
Hunk #1 succeeded at 103 (offset -1 lines).
Hunk #2 succeeded at 174 (offset -1 lines).
Hunk #3 succeeded at 229 (offset -1 lines).
Hunk #4 succeeded at 1127 (offset -1 lines).
patching file libarchive/test/test_read_format_mtree.c
Hunk #2 succeeded at 173 (offset -38 lines).
Hunk #3 succeeded at 210 (offset -40 lines).
Hunk #4 succeeded at 259 with fuzz 1 (offset -46 lines).
Hunk #5 succeeded at 315 (offset -58 lines).
Hunk #6 succeeded at 348 (offset -64 lines).
Hunk #7 succeeded at 393 (offset -68 lines).
Hunk #8 succeeded at 474 (offset -92 lines).
Hunk #9 succeeded at 541 (offset -92 lines).
Hunk #10 succeeded at 606 (offset -92 lines).
patching file tar/write.c
==> Sources are ready.
Copied source directory to /sources/libarchive
===> sudo -u tuscan PATH=/tmp/toolchain/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin CC=arm-linux-androideabi-gcc CXX=arm-linux-androideabi-g++ SYSROOT=/build/android-ndk-r10e/platforms/android-21/arch-arm makepkg --noextract --syncdeps --skipinteg --skippgpcheck --skipchecksums --noconfirm --nocolor --log --noprogressbar --nocheck
==> Making package: libarchive 3.1.2-8 (Sat Nov 14 00:09:20 UTC 2015)
==> Checking runtime dependencies...
==> Checking buildtime dependencies...
==> WARNING: Using existing $srcdir/ tree
==> Starting build()...
checking for a BSD-compatible install... /usr/bin/install -c
checking whether build environment is sane... yes
checking for x86_64-unknown-linux-strip... no
checking for strip... strip
checking for a thread-safe mkdir -p... /usr/sbin/mkdir -p
checking for gawk... gawk
checking whether make sets $(MAKE)... yes
checking whether make supports nested variables... yes
checking build system type... x86_64-unknown-linux-gnu
checking host system type... x86_64-unknown-linux-gnu
checking for x86_64-unknown-linux-gcc... arm-linux-androideabi-gcc
checking whether the C compiler works... yes
checking for C compiler default output file name... a.out
checking for suffix of executables... 
checking whether we are cross compiling... yes
checking for suffix of object files... o
checking whether we are using the GNU C compiler... yes
checking whether arm-linux-androideabi-gcc accepts -g... yes
checking for arm-linux-androideabi-gcc option to accept ISO C89... none needed
checking for style of include used by make... GNU
checking dependency style of arm-linux-androideabi-gcc... gcc3
checking whether arm-linux-androideabi-gcc and cc understand -c and -o together... yes
checking how to run the C preprocessor... arm-linux-androideabi-gcc -E
checking for grep that handles long lines and -e... /usr/sbin/grep
checking for egrep... /usr/sbin/grep -E
checking for ANSI C header files... yes
checking for sys/types.h... yes
checking for sys/stat.h... yes
checking for stdlib.h... yes
checking for string.h... yes
checking for memory.h... yes
checking for strings.h... yes
checking for inttypes.h... yes
checking for stdint.h... yes
checking for unistd.h... yes
checking minix/config.h usability... no
checking minix/config.h presence... no
checking for minix/config.h... no
checking whether it is safe to define __EXTENSIONS__... yes
checking how to print strings... printf
checking for a sed that does not truncate output... /usr/sbin/sed
checking for fgrep... /usr/sbin/grep -F
checking for ld used by arm-linux-androideabi-gcc... /tmp/toolchain/arm-linux-androideabi/bin/ld
checking if the linker (/tmp/toolchain/arm-linux-androideabi/bin/ld) is GNU ld... yes
checking for BSD- or MS-compatible name lister (nm)... /usr/sbin/nm -B
checking the name lister (/usr/sbin/nm -B) interface... BSD nm
checking whether ln -s works... yes
checking the maximum length of command line arguments... 1572864
checking whether the shell understands some XSI constructs... yes
checking whether the shell understands "+="... yes
checking how to convert x86_64-unknown-linux-gnu file names to x86_64-unknown-linux-gnu format... func_convert_file_noop
checking how to convert x86_64-unknown-linux-gnu file names to toolchain format... func_convert_file_noop
checking for /tmp/toolchain/arm-linux-androideabi/bin/ld option to reload object files... -r
checking for x86_64-unknown-linux-objdump... objdump
checking how to recognize dependent libraries... pass_all
checking for x86_64-unknown-linux-dlltool... dlltool
checking how to associate runtime and link libraries... printf %s\n
checking for x86_64-unknown-linux-ar... no
checking for ar... ar
configure: WARNING: using cross tools not prefixed with host triplet
checking for archiver @FILE support... @
checking for x86_64-unknown-linux-strip... strip
checking for x86_64-unknown-linux-ranlib... no
checking for ranlib... ranlib
checking command to parse /usr/sbin/nm -B output from arm-linux-androideabi-gcc object... ok
checking for sysroot... no
checking for x86_64-unknown-linux-mt... no
checking for mt... no
checking if : is a manifest tool... no
checking for dlfcn.h... yes
checking for objdir... .libs
checking if arm-linux-androideabi-gcc supports -fno-rtti -fno-exceptions... no
checking for arm-linux-androideabi-gcc option to produce PIC... -fPIC -DPIC
checking if arm-linux-androideabi-gcc PIC flag -fPIC -DPIC works... yes
checking if arm-linux-androideabi-gcc static flag -static works... yes
checking if arm-linux-androideabi-gcc supports -c -o file.o... yes
checking if arm-linux-androideabi-gcc supports -c -o file.o... (cached) yes
checking whether the arm-linux-androideabi-gcc linker (/tmp/toolchain/arm-linux-androideabi/bin/ld -m elf_i386) supports shared libraries... yes
checking whether -lc should be explicitly linked in... no
checking dynamic linker characteristics... GNU/Linux ld.so
checking how to hardcode library paths into programs... immediate
checking whether stripping libraries is possible... yes
checking if libtool supports shared libraries... yes
checking whether to build shared libraries... yes
checking whether to build static libraries... yes
checking for x86_64-unknown-linux-strip... (cached) strip
checking for dirent.h that defines DIR... yes
checking for library containing opendir... none required
checking for sys/wait.h that is POSIX.1 compatible... yes
checking acl/libacl.h usability... no
checking acl/libacl.h presence... no
checking for acl/libacl.h... no
checking attr/xattr.h usability... no
checking attr/xattr.h presence... no
checking for attr/xattr.h... no
checking copyfile.h usability... no
checking copyfile.h presence... no
checking for copyfile.h... no
checking ctype.h usability... yes
checking ctype.h presence... yes
checking for ctype.h... yes
checking errno.h usability... yes
checking errno.h presence... yes
checking for errno.h... yes
checking ext2fs/ext2_fs.h usability... no
checking ext2fs/ext2_fs.h presence... no
checking for ext2fs/ext2_fs.h... no
checking fcntl.h usability... yes
checking fcntl.h presence... yes
checking for fcntl.h... yes
checking grp.h usability... yes
checking grp.h presence... yes
checking for grp.h... yes
checking whether EXT2_IOC_GETFLAGS is usable... no
checking for inttypes.h... (cached) yes
checking io.h usability... no
checking io.h presence... no
checking for io.h... no
checking langinfo.h usability... no
checking langinfo.h presence... no
checking for langinfo.h... no
checking limits.h usability... yes
checking limits.h presence... yes
checking for limits.h... yes
checking linux/fiemap.h usability... yes
checking linux/fiemap.h presence... yes
checking for linux/fiemap.h... yes
checking linux/fs.h usability... yes
checking linux/fs.h presence... yes
checking for linux/fs.h... yes
checking linux/magic.h usability... yes
checking linux/magic.h presence... yes
checking for linux/magic.h... yes
checking linux/types.h usability... yes
checking linux/types.h presence... yes
checking for linux/types.h... yes
checking locale.h usability... yes
checking locale.h presence... yes
checking for locale.h... yes
checking paths.h usability... yes
checking paths.h presence... yes
checking for paths.h... yes
checking poll.h usability... yes
checking poll.h presence... yes
checking for poll.h... yes
checking pwd.h usability... yes
checking pwd.h presence... yes
checking for pwd.h... yes
checking signal.h usability... yes
checking signal.h presence... yes
checking for signal.h... yes
checking spawn.h usability... no
checking spawn.h presence... no
checking for spawn.h... no
checking stdarg.h usability... yes
checking stdarg.h presence... yes
checking for stdarg.h... yes
checking for stdint.h... (cached) yes
checking for stdlib.h... (cached) yes
checking for string.h... (cached) yes
checking sys/acl.h usability... no
checking sys/acl.h presence... no
checking for sys/acl.h... no
checking sys/cdefs.h usability... yes
checking sys/cdefs.h presence... yes
checking for sys/cdefs.h... yes
checking sys/extattr.h usability... no
checking sys/extattr.h presence... no
checking for sys/extattr.h... no
checking sys/ioctl.h usability... yes
checking sys/ioctl.h presence... yes
checking for sys/ioctl.h... yes
checking sys/mkdev.h usability... no
checking sys/mkdev.h presence... no
checking for sys/mkdev.h... no
checking sys/mount.h usability... yes
checking sys/mount.h presence... yes
checking for sys/mount.h... yes
checking sys/param.h usability... yes
checking sys/param.h presence... yes
checking for sys/param.h... yes
checking sys/poll.h usability... yes
checking sys/poll.h presence... yes
checking for sys/poll.h... yes
checking sys/select.h usability... yes
checking sys/select.h presence... yes
checking for sys/select.h... yes
checking sys/statfs.h usability... yes
checking sys/statfs.h presence... yes
checking for sys/statfs.h... yes
checking sys/statvfs.h usability... yes
checking sys/statvfs.h presence... yes
checking for sys/statvfs.h... yes
checking sys/time.h usability... yes
checking sys/time.h presence... yes
checking for sys/time.h... yes
checking sys/utime.h usability... yes
checking sys/utime.h presence... yes
checking for sys/utime.h... yes
checking sys/utsname.h usability... yes
checking sys/utsname.h presence... yes
checking for sys/utsname.h... yes
checking sys/vfs.h usability... yes
checking sys/vfs.h presence... yes
checking for sys/vfs.h... yes
checking time.h usability... yes
checking time.h presence... yes
checking for time.h... yes
checking for unistd.h... (cached) yes
checking utime.h usability... yes
checking utime.h presence... yes
checking for utime.h... yes
checking wchar.h usability... yes
checking wchar.h presence... yes
checking for wchar.h... yes
checking wctype.h usability... yes
checking wctype.h presence... yes
checking for wctype.h... yes
checking windows.h usability... no
checking windows.h presence... no
checking for windows.h... no
checking for wincrypt.h... no
checking for winioctl.h... no
checking zlib.h usability... yes
checking zlib.h presence... yes
checking for zlib.h... yes
checking for inflate in -lz... yes
checking bzlib.h usability... no
checking bzlib.h presence... no
checking for bzlib.h... no
checking for BZ2_bzDecompressInit in -lbz2... no
checking lzmadec.h usability... no
checking lzmadec.h presence... no
checking for lzmadec.h... no
checking for lzmadec_decode in -llzmadec... no
checking for ld used by GCC... /tmp/toolchain/arm-linux-androideabi/bin/ld -m elf_i386
checking if the linker (/tmp/toolchain/arm-linux-androideabi/bin/ld -m elf_i386) is GNU ld... yes
checking for shared library run path origin... done
checking for iconv... no, consider installing GNU libiconv
checking for iconv.h... no
checking lzma.h usability... no
checking lzma.h presence... no
checking for lzma.h... no
checking for lzma_stream_decoder in -llzma... no
checking lzo/lzoconf.h usability... no
checking lzo/lzoconf.h presence... no
checking for lzo/lzoconf.h... no
checking lzo/lzo1x.h usability... no
checking lzo/lzo1x.h presence... no
checking for lzo/lzo1x.h... no
checking for lzo1x_decompress_safe in -llzo2... no
checking expat.h usability... no
checking expat.h presence... no
checking for expat.h... no
checking for XML_ParserCreate in -lexpat... no
checking regex.h usability... yes
checking regex.h presence... yes
checking for regex.h... yes
checking for regcomp... yes
checking for an ANSI C-conforming const... yes
checking for uid_t in sys/types.h... yes
checking for mode_t... yes
checking for off_t... yes
checking for size_t... yes
checking for id_t... yes
checking for uintptr_t... yes
checking for struct tm.tm_gmtoff... yes
checking for struct tm.__tm_gmtoff... no
checking for struct statfs.f_namemax... no
checking for struct statvfs.f_iosize... no
checking for struct stat.st_birthtime... no
checking for struct stat.st_birthtimespec.tv_nsec... no
checking for struct stat.st_mtimespec.tv_nsec... no
checking for struct stat.st_mtim.tv_nsec... no
checking for struct stat.st_mtime_n... no
checking for struct stat.st_umtime... no
checking for struct stat.st_mtime_usec... no
checking for struct stat.st_blksize... yes
checking for struct stat.st_flags... no
checking for uintmax_t... yes
checking for unsigned long long... yes
checking for unsigned long long int... yes
checking for long long int... yes
checking for intmax_t... yes
checking for uintmax_t... (cached) yes
checking for int64_t... yes
checking for uint64_t... yes
checking for int32_t... yes
checking for uint32_t... yes
checking for int16_t... yes
checking for uint16_t... yes
checking for uint8_t... yes
checking whether SIZE_MAX is declared... yes
checking whether INT64_MAX is declared... yes
checking whether INT64_MIN is declared... yes
checking whether UINT64_MAX is declared... yes
checking whether UINT32_MAX is declared... yes
checking whether SSIZE_MAX is declared... yes
checking whether EFTYPE is declared... no
checking whether EILSEQ is declared... yes
checking for wchar_t... yes
checking size of wchar_t... 4
checking whether time.h and sys/time.h may both be included... yes
checking whether arm-linux-androideabi-gcc needs -traditional... no
checking whether sys/types.h defines makedev... yes
checking for _LARGEFILE_SOURCE value needed for large files... no
checking for working memcmp... no
checking whether lstat correctly handles trailing slash... no
checking whether lstat accepts an empty string... yes
checking whether stat accepts an empty string... yes
checking whether strerror_r is declared... yes
checking for strerror_r... yes
checking whether strerror_r returns char *... no
checking for strftime... yes
checking for vprintf... yes
checking for _doprnt... no
checking for CreateHardLinkA... no
checking for chflags... no
checking for chown... yes
checking for chroot... yes
checking for ctime_r... yes
checking for dirfd... yes
checking for fchdir... yes
checking for fchflags... no
checking for fchmod... yes
checking for fchown... yes
checking for fcntl... yes
checking for fdopendir... yes
checking for fork... yes
checking for fstat... yes
checking for fstatat... yes
checking for fstatfs... yes
checking for fstatvfs... yes
checking for ftruncate... yes
checking for futimens... yes
checking for futimes... no
checking for futimesat... no
checking for geteuid... yes
checking for getpid... yes
checking for getgrgid_r... no
checking for getgrnam_r... no
checking for getpwnam_r... yes
checking for getpwuid_r... yes
checking for getvfsbyname... no
checking for gmtime_r... yes
checking for lchflags... no
checking for lchmod... no
checking for lchown... yes
checking for link... yes
checking for localtime_r... yes
checking for lstat... yes
checking for lutimes... no
checking for mbrtowc... yes
checking for memmove... yes
checking for memset... yes
checking for mkdir... yes
checking for mkfifo... yes
checking for mknod... yes
checking for mkstemp... yes
checking for nl_langinfo... no
checking for openat... yes
checking for pipe... yes
checking for poll... yes
checking for posix_spawnp... no
checking for readlink... yes
checking for readlinkat... yes
checking for select... yes
checking for setenv... yes
checking for setlocale... yes
checking for sigaction... yes
checking for statfs... yes
checking for statvfs... yes
checking for strchr... yes
checking for strdup... yes
checking for strerror... yes
checking for strncpy_s... no
checking for strrchr... yes
checking for symlink... yes
checking for timegm... yes
checking for tzset... yes
checking for unsetenv... yes
checking for utime... yes
checking for utimensat... yes
checking for utimes... yes
checking for vfork... yes
checking for wcrtomb... yes
checking for wcscmp... yes
checking for wcscpy... yes
checking for wcslen... yes
checking for wctomb... yes
checking for wmemcmp... yes
checking for wmemcpy... yes
checking for _ctime64_s... no
checking for _fseeki64... no
checking for _get_timezone... no
checking for _localtime64_s... no
checking for _mkgmtime64... no
checking for cygwin_conv_path... no
checking whether D_MD_ORDER is declared... no
checking for struct dirent.d_namlen... no
checking for attr/xattr.h... (cached) no
checking sys/xattr.h usability... yes
checking sys/xattr.h presence... yes
checking for sys/xattr.h... yes
checking sys/ea.h usability... no
checking sys/ea.h presence... no
checking for sys/ea.h... no
checking for setxattr in -lattr... no
checking for extattr_get_file... no
checking for extattr_list_file... no
checking for extattr_set_fd... no
checking for extattr_set_file... no
checking for fgetxattr... yes
checking for flistxattr... yes
checking for fsetxattr... yes
checking for getxattr... yes
checking for lgetxattr... yes
checking for listxattr... yes
checking for llistxattr... yes
checking for lsetxattr... yes
checking for fgetea... no
checking for flistea... no
checking for fsetea... no
checking for getea... no
checking for lgetea... no
checking for listea... no
checking for llistea... no
checking for lsetea... no
checking whether EXTATTR_NAMESPACE_USER is declared... no
checking for sys/acl.h... (cached) no
checking for acl_get_file in -lacl... no
checking for acl_create_entry... no
checking for acl_init... no
checking for acl_set_fd... no
checking for acl_set_fd_np... no
checking for acl_set_file... no
checking for acl_permset_t... no
checking for acl_get_perm_np... no
checking for acl_get_perm... no
checking for acl_get_link... no
checking for acl_get_link_np... no
checking whether ACL_USER is declared... no
checking for special C compiler options needed for large files... no
checking for _FILE_OFFSET_BITS value needed for large files... unknown
checking for _LARGE_FILES value needed for large files... unknown
checking support for ARCHIVE_CRYPTO_MD5_LIBC... no
checking support for ARCHIVE_CRYPTO_MD5_LIBSYSTEM... no
checking support for ARCHIVE_CRYPTO_RMD160_LIBC... no
checking support for ARCHIVE_CRYPTO_SHA1_LIBC... no
checking support for ARCHIVE_CRYPTO_SHA1_LIBSYSTEM... no
checking support for ARCHIVE_CRYPTO_SHA256_LIBC... no
checking support for ARCHIVE_CRYPTO_SHA256_LIBC2... no
checking support for ARCHIVE_CRYPTO_SHA256_LIBC3... no
checking support for ARCHIVE_CRYPTO_SHA256_LIBSYSTEM... no
checking support for ARCHIVE_CRYPTO_SHA384_LIBC... no
checking support for ARCHIVE_CRYPTO_SHA384_LIBC2... no
checking support for ARCHIVE_CRYPTO_SHA384_LIBC3... no
checking support for ARCHIVE_CRYPTO_SHA384_LIBSYSTEM... no
checking support for ARCHIVE_CRYPTO_SHA512_LIBC... no
checking support for ARCHIVE_CRYPTO_SHA512_LIBC2... no
checking support for ARCHIVE_CRYPTO_SHA512_LIBC3... no
checking support for ARCHIVE_CRYPTO_SHA512_LIBSYSTEM... no
checking nettle/md5.h usability... no
checking nettle/md5.h presence... no
checking for nettle/md5.h... no
checking nettle/ripemd160.h usability... no
checking nettle/ripemd160.h presence... no
checking for nettle/ripemd160.h... no
checking nettle/sha.h usability... no
checking nettle/sha.h presence... no
checking for nettle/sha.h... no
checking for main in -lnettle... no
checking support for ARCHIVE_CRYPTO_MD5_NETTLE... no
checking support for ARCHIVE_CRYPTO_RMD160_NETTLE... no
checking support for ARCHIVE_CRYPTO_SHA1_NETTLE... no
checking support for ARCHIVE_CRYPTO_SHA256_NETTLE... no
checking support for ARCHIVE_CRYPTO_SHA384_NETTLE... no
checking support for ARCHIVE_CRYPTO_SHA512_NETTLE... no
checking openssl/evp.h usability... no
checking openssl/evp.h presence... no
checking for openssl/evp.h... no
checking for main in -lcrypto... no
checking support for ARCHIVE_CRYPTO_MD5_OPENSSL... no
checking support for ARCHIVE_CRYPTO_RMD160_OPENSSL... no
checking support for ARCHIVE_CRYPTO_SHA1_OPENSSL... no
checking support for ARCHIVE_CRYPTO_SHA256_OPENSSL... no
checking support for ARCHIVE_CRYPTO_SHA384_OPENSSL... no
checking support for ARCHIVE_CRYPTO_SHA512_OPENSSL... no
checking md5.h usability... no
checking md5.h presence... no
checking for md5.h... no
checking ripemd.h usability... no
checking ripemd.h presence... no
checking for ripemd.h... no
checking sha.h usability... no
checking sha.h presence... no
checking for sha.h... no
checking sha256.h usability... no
checking sha256.h presence... no
checking for sha256.h... no
checking sha512.h usability... no
checking sha512.h presence... no
checking for sha512.h... no
checking for main in -lmd... no
checking support for ARCHIVE_CRYPTO_MD5_LIBMD... no
checking support for ARCHIVE_CRYPTO_RMD160_LIBMD... no
checking support for ARCHIVE_CRYPTO_SHA1_LIBMD... no
checking support for ARCHIVE_CRYPTO_SHA256_LIBMD... no
checking support for ARCHIVE_CRYPTO_SHA512_LIBMD... no
configure: creating ./config.status
config.status: creating Makefile
config.status: creating build/pkgconfig/libarchive.pc
config.status: creating config.h
config.status: executing depfiles commands
config.status: executing libtool commands
cat ./libarchive/test/test_*.c | grep DEFINE_TEST > libarchive/test/list.h
cat ./tar/test/test_*.c | grep DEFINE_TEST > tar/test/list.h
cat ./cpio/test/test_*.c | grep DEFINE_TEST > cpio/test/list.h
make  all-am
make[1]: Entering directory '/tmp/libarchive/src/libarchive-3.1.2'
  CC     libarchive/archive_acl.lo
  CC     libarchive/archive_check_magic.lo
  CC     libarchive/archive_cmdline.lo
  CC     libarchive/archive_crypto.lo
  CC     libarchive/archive_entry.lo
  CC     libarchive/archive_entry_copy_stat.lo
  CC     libarchive/archive_entry_link_resolver.lo
  CC     libarchive/archive_entry_sparse.lo
  CC     libarchive/archive_entry_stat.lo
  CC     libarchive/archive_entry_strmode.lo
  CC     libarchive/archive_entry_xattr.lo
  CC     libarchive/archive_getdate.lo
  CC     libarchive/archive_match.lo
  CC     libarchive/archive_options.lo
  CC     libarchive/archive_pathmatch.lo
  CC     libarchive/archive_ppmd7.lo
  CC     libarchive/archive_rb.lo
  CC     libarchive/archive_read.lo
  CC     libarchive/archive_read_append_filter.lo
  CC     libarchive/archive_read_data_into_fd.lo
  CC     libarchive/archive_read_disk_entry_from_file.lo
  CC     libarchive/archive_read_disk_posix.lo
  CC     libarchive/archive_read_disk_set_standard_lookup.lo
  CC     libarchive/archive_read_extract.lo
  CC     libarchive/archive_read_open_fd.lo
  CC     libarchive/archive_read_open_file.lo
  CC     libarchive/archive_read_open_filename.lo
  CC     libarchive/archive_read_open_memory.lo
  CC     libarchive/archive_read_set_format.lo
  CC     libarchive/archive_read_set_options.lo
  CC     libarchive/archive_read_support_filter_all.lo
  CC     libarchive/archive_read_support_filter_bzip2.lo
  CC     libarchive/archive_read_support_filter_compress.lo
  CC     libarchive/archive_read_support_filter_grzip.lo
  CC     libarchive/archive_read_support_filter_gzip.lo
  CC     libarchive/archive_read_support_filter_lrzip.lo
  CC     libarchive/archive_read_support_filter_lzop.lo
  CC     libarchive/archive_read_support_filter_none.lo
  CC     libarchive/archive_read_support_filter_program.lo
  CC     libarchive/archive_read_support_filter_rpm.lo
  CC     libarchive/archive_read_support_filter_uu.lo
  CC     libarchive/archive_read_support_filter_xz.lo
  CC     libarchive/archive_read_support_format_7zip.lo
  CC     libarchive/archive_read_support_format_all.lo
  CC     libarchive/archive_read_support_format_ar.lo
  CC     libarchive/archive_read_support_format_by_code.lo
  CC     libarchive/archive_read_support_format_cab.lo
  CC     libarchive/archive_read_support_format_cpio.lo
  CC     libarchive/archive_read_support_format_empty.lo
  CC     libarchive/archive_read_support_format_iso9660.lo
  CC     libarchive/archive_read_support_format_lha.lo
  CC     libarchive/archive_read_support_format_mtree.lo
  CC     libarchive/archive_read_support_format_rar.lo
  CC     libarchive/archive_read_support_format_raw.lo
  CC     libarchive/archive_read_support_format_tar.lo
  CC     libarchive/archive_read_support_format_xar.lo
  CC     libarchive/archive_read_support_format_zip.lo
  CC     libarchive/archive_string.lo
  CC     libarchive/archive_string_sprintf.lo
  CC     libarchive/archive_util.lo
  CC     libarchive/archive_virtual.lo
  CC     libarchive/archive_write_disk_acl.lo
  CC     libarchive/archive_write.lo
  CC     libarchive/archive_write_disk_posix.lo
  CC     libarchive/archive_write_disk_set_standard_lookup.lo
  CC     libarchive/archive_write_open_fd.lo
  CC     libarchive/archive_write_open_file.lo
  CC     libarchive/archive_write_open_memory.lo
  CC     libarchive/archive_write_open_filename.lo
  CC     libarchive/archive_write_add_filter.lo
  CC     libarchive/archive_write_add_filter_b64encode.lo
  CC     libarchive/archive_write_add_filter_by_name.lo
  CC     libarchive/archive_write_add_filter_bzip2.lo
  CC     libarchive/archive_write_add_filter_compress.lo
  CC     libarchive/archive_write_add_filter_grzip.lo
  CC     libarchive/archive_write_add_filter_gzip.lo
  CC     libarchive/archive_write_add_filter_lrzip.lo
  CC     libarchive/archive_write_add_filter_lzop.lo
  CC     libarchive/archive_write_add_filter_none.lo
  CC     libarchive/archive_write_add_filter_program.lo
  CC     libarchive/archive_write_add_filter_uuencode.lo
  CC     libarchive/archive_write_add_filter_xz.lo
  CC     libarchive/archive_write_set_format.lo
  CC     libarchive/archive_write_set_format_7zip.lo
  CC     libarchive/archive_write_set_format_ar.lo
  CC     libarchive/archive_write_set_format_by_name.lo
  CC     libarchive/archive_write_set_format_cpio.lo
  CC     libarchive/archive_write_set_format_cpio_newc.lo
  CC     libarchive/archive_write_set_format_iso9660.lo
  CC     libarchive/archive_write_set_format_mtree.lo
  CC     libarchive/archive_write_set_format_pax.lo
  CC     libarchive/archive_write_set_format_shar.lo
  CC     libarchive/archive_write_set_format_ustar.lo
  CC     libarchive/archive_write_set_format_v7tar.lo
  CC     libarchive/archive_write_set_format_gnutar.lo
  CC     libarchive/archive_write_set_format_xar.lo
  CC     libarchive/archive_write_set_format_zip.lo
  CC     libarchive/archive_write_set_options.lo
  CC     libarchive/filter_fork_posix.lo
  CC     libarchive_fe/libarchive_fe_la-err.lo
  CC     libarchive_fe/libarchive_fe_la-line_reader.lo
  CC     tar/bsdtar-bsdtar.o
  CC     tar/bsdtar-cmdline.o
  CC     tar/bsdtar-creation_set.o
  CC     tar/bsdtar-read.o
  CC     tar/bsdtar-subst.o
  CC     tar/bsdtar-util.o
  CC     tar/bsdtar-write.o
  CC     cpio/bsdcpio-cmdline.o
  CC     cpio/bsdcpio-cpio.o
  CCLD   libarchive.la
  CCLD   libarchive_fe.la
ar: `u' modifier ignored since `D' is the default (see `U')
ar: `u' modifier ignored since `D' is the default (see `U')
  CCLD   bsdtar
  CCLD   bsdcpio
make[1]: Leaving directory '/tmp/libarchive/src/libarchive-3.1.2'
==> Entering fakeroot environment...
==> Starting package()...
make  install-am
make[1]: Entering directory '/tmp/libarchive/src/libarchive-3.1.2'
make[2]: Entering directory '/tmp/libarchive/src/libarchive-3.1.2'
 /usr/sbin/mkdir -p '/tmp/libarchive/pkg/libarchive/usr/include'
 /usr/sbin/mkdir -p '/tmp/libarchive/pkg/libarchive/usr/share/man/man1'
 /usr/bin/install -c -m 644 libarchive/archive.h libarchive/archive_entry.h '/tmp/libarchive/pkg/libarchive/usr/include'
 /usr/bin/install -c -m 644 tar/bsdtar.1 cpio/bsdcpio.1 '/tmp/libarchive/pkg/libarchive/usr/share/man/man1'
 /usr/sbin/mkdir -p '/tmp/libarchive/pkg/libarchive/usr/share/man/man3'
 /usr/sbin/mkdir -p '/tmp/libarchive/pkg/libarchive/usr/share/man/man5'
 /usr/bin/install -c -m 644 libarchive/cpio.5 libarchive/libarchive-formats.5 libarchive/mtree.5 libarchive/tar.5 '/tmp/libarchive/pkg/libarchive/usr/share/man/man5'
 /usr/bin/install -c -m 644 libarchive/archive_entry.3 libarchive/archive_entry_acl.3 libarchive/archive_entry_linkify.3 libarchive/archive_entry_paths.3 libarchive/archive_entry_perms.3 libarchive/archive_entry_stat.3 libarchive/archive_entry_time.3 libarchive/archive_read.3 libarchive/archive_read_data.3 libarchive/archive_read_disk.3 libarchive/archive_read_extract.3 libarchive/archive_read_filter.3 libarchive/archive_read_format.3 libarchive/archive_read_free.3 libarchive/archive_read_header.3 libarchive/archive_read_new.3 libarchive/archive_read_open.3 libarchive/archive_read_set_options.3 libarchive/archive_util.3 libarchive/archive_write.3 libarchive/archive_write_blocksize.3 libarchive/archive_write_data.3 libarchive/archive_write_disk.3 libarchive/archive_write_filter.3 libarchive/archive_write_finish_entry.3 libarchive/archive_write_format.3 libarchive/archive_write_free.3 libarchive/archive_write_header.3 libarchive/archive_write_new.3 libarchive/archive_write_open.3 libarchive/archive_write_set_options.3 libarchive/libarchive.3 libarchive/libarchive_changes.3 libarchive/libarchive_internals.3 '/tmp/libarchive/pkg/libarchive/usr/share/man/man3'
 /usr/sbin/mkdir -p '/tmp/libarchive/pkg/libarchive/usr/lib/pkgconfig'
 /usr/bin/install -c -m 644 build/pkgconfig/libarchive.pc '/tmp/libarchive/pkg/libarchive/usr/lib/pkgconfig'
 /usr/sbin/mkdir -p '/tmp/libarchive/pkg/libarchive/usr/lib'
 /bin/sh ./libtool   --mode=install /usr/bin/install -c   libarchive.la '/tmp/libarchive/pkg/libarchive/usr/lib'
libtool: install: /usr/bin/install -c .libs/libarchive.so.13.1.2 /tmp/libarchive/pkg/libarchive/usr/lib/libarchive.so.13.1.2
libtool: install: (cd /tmp/libarchive/pkg/libarchive/usr/lib && { ln -s -f libarchive.so.13.1.2 libarchive.so.13 || { rm -f libarchive.so.13 && ln -s libarchive.so.13.1.2 libarchive.so.13; }; })
libtool: install: (cd /tmp/libarchive/pkg/libarchive/usr/lib && { ln -s -f libarchive.so.13.1.2 libarchive.so || { rm -f libarchive.so && ln -s libarchive.so.13.1.2 libarchive.so; }; })
libtool: install: /usr/bin/install -c .libs/libarchive.lai /tmp/libarchive/pkg/libarchive/usr/lib/libarchive.la
libtool: install: /usr/bin/install -c .libs/libarchive.a /tmp/libarchive/pkg/libarchive/usr/lib/libarchive.a
libtool: install: chmod 644 /tmp/libarchive/pkg/libarchive/usr/lib/libarchive.a
libtool: install: ranlib /tmp/libarchive/pkg/libarchive/usr/lib/libarchive.a
libtool: install: warning: remember to run `libtool --finish /usr/lib'
 /usr/sbin/mkdir -p '/tmp/libarchive/pkg/libarchive/usr/bin'
  /bin/sh ./libtool   --mode=install /usr/bin/install -c bsdtar bsdcpio '/tmp/libarchive/pkg/libarchive/usr/bin'
libtool: install: /usr/bin/install -c bsdtar /tmp/libarchive/pkg/libarchive/usr/bin/bsdtar
libtool: install: /usr/bin/install -c bsdcpio /tmp/libarchive/pkg/libarchive/usr/bin/bsdcpio
make[2]: Leaving directory '/tmp/libarchive/src/libarchive-3.1.2'
make[1]: Leaving directory '/tmp/libarchive/src/libarchive-3.1.2'
==> Tidying install...
  -> Removing doc files...
  -> Purging unwanted files...
  -> Stripping unneeded symbols from binaries and libraries...
objcopy: Unable to recognise the format of the input file `./usr/bin/bsdcpio'
objcopy: Unable to recognise the format of the input file `./usr/bin/bsdcpio'
ln: failed to access '/tmp/libarchive/pkg/libarchive-debug/usr/lib/debug/./usr/bin/bsdcpio.debug': No such file or directory
strip: Unable to recognise the format of the input file `./usr/bin/bsdcpio'
objcopy: Unable to recognise the format of the input file `./usr/bin/bsdtar'
objcopy: Unable to recognise the format of the input file `./usr/bin/bsdtar'
ln: failed to access '/tmp/libarchive/pkg/libarchive-debug/usr/lib/debug/./usr/bin/bsdtar.debug': No such file or directory
strip: Unable to recognise the format of the input file `./usr/bin/bsdtar'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_check_magic.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_cmdline.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_crypto.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_entry.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_entry_copy_stat.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_entry_link_resolver.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_entry_sparse.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_entry_stat.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_entry_strmode.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_entry_xattr.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_getdate.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_match.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_options.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_pathmatch.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_ppmd7.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_rb.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_append_filter.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_data_into_fd.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_disk_entry_from_file.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_disk_posix.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_disk_set_standard_lookup.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_extract.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_open_fd.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_open_file.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_open_filename.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_open_memory.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_set_format.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_set_options.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_filter_all.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_filter_bzip2.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_filter_compress.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_filter_grzip.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_filter_gzip.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_filter_lrzip.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_filter_lzop.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_filter_none.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_filter_program.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_filter_rpm.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_filter_uu.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_filter_xz.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_7zip.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_all.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_ar.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_by_code.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_cab.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_cpio.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_empty.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_iso9660.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_lha.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_mtree.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_rar.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_raw.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_tar.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_xar.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_zip.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_string.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_string_sprintf.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_util.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_virtual.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_disk_acl.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_disk_posix.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_disk_set_standard_lookup.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_open_fd.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_open_file.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_open_filename.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_open_memory.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter_b64encode.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter_by_name.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter_bzip2.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter_compress.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter_grzip.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter_gzip.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter_lrzip.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter_lzop.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter_none.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter_program.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter_uuencode.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter_xz.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_7zip.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_ar.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_by_name.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_cpio.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_cpio_newc.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_iso9660.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_mtree.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_pax.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_shar.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_ustar.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_v7tar.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_gnutar.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_xar.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_zip.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_options.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(filter_fork_posix.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_check_magic.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_cmdline.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_crypto.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_entry.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_entry_copy_stat.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_entry_link_resolver.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_entry_sparse.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_entry_stat.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_entry_strmode.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_entry_xattr.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_getdate.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_match.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_options.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_pathmatch.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_ppmd7.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_rb.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_append_filter.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_data_into_fd.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_disk_entry_from_file.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_disk_posix.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_disk_set_standard_lookup.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_extract.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_open_fd.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_open_file.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_open_filename.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_open_memory.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_set_format.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_set_options.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_filter_all.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_filter_bzip2.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_filter_compress.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_filter_grzip.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_filter_gzip.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_filter_lrzip.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_filter_lzop.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_filter_none.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_filter_program.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_filter_rpm.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_filter_uu.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_filter_xz.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_7zip.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_all.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_ar.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_by_code.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_cab.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_cpio.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_empty.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_iso9660.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_lha.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_mtree.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_rar.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_raw.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_tar.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_xar.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_zip.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_string.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_string_sprintf.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_util.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_virtual.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_disk_acl.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_disk_posix.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_disk_set_standard_lookup.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_open_fd.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_open_file.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_open_filename.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_open_memory.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter_b64encode.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter_by_name.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter_bzip2.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter_compress.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter_grzip.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter_gzip.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter_lrzip.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter_lzop.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter_none.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter_program.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter_uuencode.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter_xz.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_7zip.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_ar.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_by_name.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_cpio.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_cpio_newc.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_iso9660.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_mtree.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_pax.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_shar.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_ustar.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_v7tar.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_gnutar.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_xar.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_zip.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_options.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.a(filter_fork_posix.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_check_magic.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_cmdline.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_crypto.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_entry.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_entry_copy_stat.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_entry_link_resolver.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_entry_sparse.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_entry_stat.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_entry_strmode.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_entry_xattr.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_getdate.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_match.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_options.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_pathmatch.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_ppmd7.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_rb.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_append_filter.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_data_into_fd.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_disk_entry_from_file.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_disk_posix.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_disk_set_standard_lookup.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_extract.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_open_fd.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_open_file.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_open_filename.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_open_memory.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_set_format.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_set_options.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_filter_all.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_filter_bzip2.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_filter_compress.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_filter_grzip.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_filter_gzip.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_filter_lrzip.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_filter_lzop.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_filter_none.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_filter_program.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_filter_rpm.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_filter_uu.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_filter_xz.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_7zip.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_all.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_ar.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_by_code.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_cab.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_cpio.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_empty.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_iso9660.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_lha.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_mtree.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_rar.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_raw.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_tar.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_xar.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_read_support_format_zip.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_string.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_string_sprintf.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_util.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_virtual.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_disk_acl.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_disk_posix.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_disk_set_standard_lookup.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_open_fd.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_open_file.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_open_filename.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_open_memory.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter_b64encode.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter_by_name.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter_bzip2.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter_compress.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter_grzip.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter_gzip.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter_lrzip.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter_lzop.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter_none.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter_program.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter_uuencode.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_add_filter_xz.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_7zip.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_ar.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_by_name.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_cpio.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_cpio_newc.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_iso9660.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_mtree.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_pax.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_shar.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_ustar.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_v7tar.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_gnutar.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_xar.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_format_zip.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(archive_write_set_options.o)'
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.a(filter_fork_posix.o)'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.so.13.1.2'
objcopy: Unable to recognise the format of the input file `./usr/lib/libarchive.so.13.1.2'
ln: failed to access '/tmp/libarchive/pkg/libarchive-debug/usr/lib/debug/./usr/lib/libarchive.so.13.1.2.debug': No such file or directory
strip: Unable to recognise the format of the input file `./usr/lib/libarchive.so.13.1.2'
==> Creating package "libarchive"...
  -> Generating .PKGINFO file...
  -> Generating .MTREE file...
  -> Compressing package...
==> Creating package "libarchive-debug"...
  -> Generating .PKGINFO file...
  -> Generating .MTREE file...
  -> Compressing package...
==> Leaving fakeroot environment.
==> Finished making: libarchive 3.1.2-8 (Sat Nov 14 00:11:18 UTC 2015)
===> Printing config.logs
found log at /tmp/libarchive/src/libarchive-3.1.2/config.log
____
File /tmp/libarchive/src/libarchive-3.1.2/config.log
This file contains any messages produced by compilers while
running configure, to aid debugging if configure makes a mistake.

It was created by libarchive configure 3.1.2, which was
generated by GNU Autoconf 2.69.  Invocation command line was

  $ ./configure --host x86_64-unknown-linux --prefix=/usr --without-xml2

## --------- ##
## Platform. ##
## --------- ##

hostname = 8847e89226ca
uname -m = x86_64
uname -r = 3.13.0-66-generic
uname -s = Linux
uname -v = #108-Ubuntu SMP Wed Oct 7 15:20:27 UTC 2015

/usr/bin/uname -p = unknown
/bin/uname -X     = unknown

/bin/arch              = unknown
/usr/bin/arch -k       = unknown
/usr/convex/getsysinfo = unknown
/usr/bin/hostinfo      = unknown
/bin/machine           = unknown
/usr/bin/oslevel       = unknown
/bin/universe          = unknown

PATH: /tmp/toolchain/bin
PATH: /usr/local/sbin
PATH: /usr/local/bin
PATH: /usr/sbin
PATH: /usr/bin
PATH: /sbin
PATH: /bin


## ----------- ##
## Core tests. ##
## ----------- ##

configure:2801: checking for a BSD-compatible install
configure:2869: result: /usr/bin/install -c
configure:2880: checking whether build environment is sane
configure:2930: result: yes
configure:2979: checking for x86_64-unknown-linux-strip
configure:3009: result: no
configure:3019: checking for strip
configure:3035: found /usr/sbin/strip
configure:3046: result: strip
configure:3071: checking for a thread-safe mkdir -p
configure:3110: result: /usr/sbin/mkdir -p
configure:3123: checking for gawk
configure:3139: found /usr/sbin/gawk
configure:3150: result: gawk
configure:3161: checking whether make sets $(MAKE)
configure:3183: result: yes
configure:3274: checking whether make supports nested variables
configure:3291: result: yes
configure:3364: checking build system type
configure:3378: result: x86_64-unknown-linux-gnu
configure:3398: checking host system type
configure:3411: result: x86_64-unknown-linux-gnu
configure:3470: checking for x86_64-unknown-linux-gcc
configure:3497: result: arm-linux-androideabi-gcc
configure:3766: checking for C compiler version
configure:3775: arm-linux-androideabi-gcc --version >&5
arm-linux-androideabi-gcc (GCC) 4.8
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

configure:3786: $? = 0
configure:3775: arm-linux-androideabi-gcc -v >&5
Using built-in specs.
COLLECT_GCC=arm-linux-androideabi-gcc
COLLECT_LTO_WRAPPER=/tmp/toolchain/bin/../libexec/gcc/arm-linux-androideabi/4.8/lto-wrapper
Target: arm-linux-androideabi
Configured with: /s/ndk-toolchain/src/build/../gcc/gcc-4.8/configure --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --target=arm-linux-androideabi --host=x86_64-linux-gnu --build=x86_64-linux-gnu --with-gnu-as --with-gnu-ld --enable-languages=c,c++ --with-gmp=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpfr=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-mpc=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-cloog=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-isl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --with-ppl=/tmp/ndk-andrewhsieh/build/toolchain/temp-install --disable-ppl-version-check --disable-cloog-version-check --disable-isl-version-check --enable-cloog-backend=isl --with-host-libstdcxx='-static-libgcc -Wl,-Bstatic,-lstdc++,-Bdynamic -lm' --disable-libssp --enable-threads --disable-nls --disable-libmudflap --disable-libgomp --disable-libstdc__-v3 --disable-sjlj-exceptions --disable-shared --disable-tls --disable-libitm --with-float=soft --with-fpu=vfp --with-arch=armv5te --enable-target-optspace --enable-initfini-array --disable-nls --prefix=/tmp/ndk-andrewhsieh/build/toolchain/prefix --with-sysroot=/tmp/ndk-andrewhsieh/build/toolchain/prefix/sysroot --with-binutils-version=2.25 --with-mpfr-version=3.1.1 --with-mpc-version=1.0.1 --with-gmp-version=5.0.5 --with-gcc-version=4.8 --with-gdb-version=7.7 --with-python=/usr/local/google/home/andrewhsieh/mydroid/ndk/prebuilt/linux-x86_64/bin/python-config.sh --with-gxx-include-dir=/tmp/ndk-andrewhsieh/build/toolchain/prefix/include/c++/4.8 --with-bugurl=http://source.android.com/source/report-bugs.html --enable-languages=c,c++ --disable-bootstrap --enable-plugins --enable-libgomp --enable-gnu-indirect-function --disable-libsanitizer --enable-gold --enable-threads --enable-graphite=yes --with-cloog-version=0.18.0 --with-isl-version=0.11.1 --enable-eh-frame-hdr-for-static --with-arch=armv5te --program-transform-name='s&^&arm-linux-androideabi-&' --enable-gold=default
Thread model: posix
gcc version 4.8 (GCC) 
configure:3786: $? = 0
configure:3775: arm-linux-androideabi-gcc -V >&5
arm-linux-androideabi-gcc: error: unrecognized command line option '-V'
arm-linux-androideabi-gcc: fatal error: no input files
compilation terminated.
configure:3786: $? = 1
configure:3775: arm-linux-androideabi-gcc -qversion >&5
arm-linux-androideabi-gcc: error: unrecognized command line option '-qversion'
arm-linux-androideabi-gcc: fatal error: no input files
compilation terminated.
configure:3786: $? = 1
configure:3806: checking whether the C compiler works
configure:3828: arm-linux-androideabi-gcc     conftest.c  >&5
configure:3832: $? = 0
configure:3880: result: yes
configure:3883: checking for C compiler default output file name
configure:3885: result: a.out
configure:3891: checking for suffix of executables
configure:3898: arm-linux-androideabi-gcc -o conftest     conftest.c  >&5
configure:3902: $? = 0
configure:3924: result: 
configure:3946: checking whether we are cross compiling
configure:3954: arm-linux-androideabi-gcc -o conftest     conftest.c  >&5
configure:3958: $? = 0
configure:3965: ./conftest
./configure: line 3967: ./conftest: cannot execute binary file: Exec format error
configure:3969: $? = 126
configure:3984: result: yes
configure:3989: checking for suffix of object files
configure:4011: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:4015: $? = 0
configure:4036: result: o
configure:4040: checking whether we are using the GNU C compiler
configure:4059: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:4059: $? = 0
configure:4068: result: yes
configure:4077: checking whether arm-linux-androideabi-gcc accepts -g
configure:4097: arm-linux-androideabi-gcc -c -g  conftest.c >&5
configure:4097: $? = 0
configure:4138: result: yes
configure:4155: checking for arm-linux-androideabi-gcc option to accept ISO C89
configure:4218: arm-linux-androideabi-gcc  -c    conftest.c >&5
configure:4218: $? = 0
configure:4231: result: none needed
configure:4262: checking for style of include used by make
configure:4290: result: GNU
configure:4316: checking dependency style of arm-linux-androideabi-gcc
configure:4427: result: gcc3
configure:4443: checking whether arm-linux-androideabi-gcc and cc understand -c and -o together
configure:4474: arm-linux-androideabi-gcc -c conftest.c -o conftest2.o >&5
configure:4478: $? = 0
configure:4484: arm-linux-androideabi-gcc -c conftest.c -o conftest2.o >&5
configure:4488: $? = 0
configure:4499: cc -c conftest.c >&5
configure:4503: $? = 0
configure:4511: cc -c conftest.c -o conftest2.o >&5
configure:4515: $? = 0
configure:4521: cc -c conftest.c -o conftest2.o >&5
configure:4525: $? = 0
configure:4543: result: yes
configure:4574: checking how to run the C preprocessor
configure:4605: arm-linux-androideabi-gcc -E  conftest.c
configure:4605: $? = 0
configure:4619: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:15:28: fatal error: ac_nonexistent.h: No such file or directory
 #include <ac_nonexistent.h>
                            ^
compilation terminated.
configure:4619: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| /* end confdefs.h.  */
| #include <ac_nonexistent.h>
configure:4644: result: arm-linux-androideabi-gcc -E
configure:4664: arm-linux-androideabi-gcc -E  conftest.c
configure:4664: $? = 0
configure:4678: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:15:28: fatal error: ac_nonexistent.h: No such file or directory
 #include <ac_nonexistent.h>
                            ^
compilation terminated.
configure:4678: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| /* end confdefs.h.  */
| #include <ac_nonexistent.h>
configure:4707: checking for grep that handles long lines and -e
configure:4765: result: /usr/sbin/grep
configure:4770: checking for egrep
configure:4832: result: /usr/sbin/grep -E
configure:4837: checking for ANSI C header files
configure:4857: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:4857: $? = 0
configure:4941: result: yes
configure:4954: checking for sys/types.h
configure:4954: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:4954: $? = 0
configure:4954: result: yes
configure:4954: checking for sys/stat.h
configure:4954: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:4954: $? = 0
configure:4954: result: yes
configure:4954: checking for stdlib.h
configure:4954: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:4954: $? = 0
configure:4954: result: yes
configure:4954: checking for string.h
configure:4954: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:4954: $? = 0
configure:4954: result: yes
configure:4954: checking for memory.h
configure:4954: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:4954: $? = 0
configure:4954: result: yes
configure:4954: checking for strings.h
configure:4954: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:4954: $? = 0
configure:4954: result: yes
configure:4954: checking for inttypes.h
configure:4954: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:4954: $? = 0
configure:4954: result: yes
configure:4954: checking for stdint.h
configure:4954: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:4954: $? = 0
configure:4954: result: yes
configure:4954: checking for unistd.h
configure:4954: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:4954: $? = 0
configure:4954: result: yes
configure:4967: checking minix/config.h usability
configure:4967: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:58:26: fatal error: minix/config.h: No such file or directory
 #include <minix/config.h>
                          ^
compilation terminated.
configure:4967: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <minix/config.h>
configure:4967: result: no
configure:4967: checking minix/config.h presence
configure:4967: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:25:26: fatal error: minix/config.h: No such file or directory
 #include <minix/config.h>
                          ^
compilation terminated.
configure:4967: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| /* end confdefs.h.  */
| #include <minix/config.h>
configure:4967: result: no
configure:4967: checking for minix/config.h
configure:4967: result: no
configure:4988: checking whether it is safe to define __EXTENSIONS__
configure:5006: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:5006: $? = 0
configure:5013: result: yes
configure:5376: checking how to print strings
configure:5403: result: printf
configure:5424: checking for a sed that does not truncate output
configure:5488: result: /usr/sbin/sed
configure:5506: checking for fgrep
configure:5568: result: /usr/sbin/grep -F
configure:5603: checking for ld used by arm-linux-androideabi-gcc
configure:5670: result: /tmp/toolchain/arm-linux-androideabi/bin/ld
configure:5677: checking if the linker (/tmp/toolchain/arm-linux-androideabi/bin/ld) is GNU ld
configure:5692: result: yes
configure:5704: checking for BSD- or MS-compatible name lister (nm)
configure:5753: result: /usr/sbin/nm -B
configure:5883: checking the name lister (/usr/sbin/nm -B) interface
configure:5890: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:5893: /usr/sbin/nm -B "conftest.o"
configure:5896: output
00000000 b $d
00000000 B some_variable
configure:5903: result: BSD nm
configure:5906: checking whether ln -s works
configure:5910: result: yes
configure:5918: checking the maximum length of command line arguments
configure:6048: result: 1572864
configure:6065: checking whether the shell understands some XSI constructs
configure:6075: result: yes
configure:6079: checking whether the shell understands "+="
configure:6085: result: yes
configure:6120: checking how to convert x86_64-unknown-linux-gnu file names to x86_64-unknown-linux-gnu format
configure:6160: result: func_convert_file_noop
configure:6167: checking how to convert x86_64-unknown-linux-gnu file names to toolchain format
configure:6187: result: func_convert_file_noop
configure:6194: checking for /tmp/toolchain/arm-linux-androideabi/bin/ld option to reload object files
configure:6201: result: -r
configure:6235: checking for x86_64-unknown-linux-objdump
configure:6262: result: objdump
configure:6331: checking how to recognize dependent libraries
configure:6529: result: pass_all
configure:6574: checking for x86_64-unknown-linux-dlltool
configure:6601: result: dlltool
configure:6671: checking how to associate runtime and link libraries
configure:6698: result: printf %s\n
configure:6714: checking for x86_64-unknown-linux-ar
configure:6744: result: no
configure:6758: checking for ar
configure:6774: found /usr/sbin/ar
configure:6785: result: ar
configure:6801: WARNING: using cross tools not prefixed with host triplet
configure:6822: checking for archiver @FILE support
configure:6839: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:6839: $? = 0
configure:6842: ar cru libconftest.a @conftest.lst >&5
ar: `u' modifier ignored since `D' is the default (see `U')
configure:6845: $? = 0
configure:6850: ar cru libconftest.a @conftest.lst >&5
ar: `u' modifier ignored since `D' is the default (see `U')
ar: conftest.o: No such file or directory
configure:6853: $? = 1
configure:6865: result: @
configure:6883: checking for x86_64-unknown-linux-strip
configure:6910: result: strip
configure:6982: checking for x86_64-unknown-linux-ranlib
configure:7012: result: no
configure:7022: checking for ranlib
configure:7038: found /usr/sbin/ranlib
configure:7049: result: ranlib
configure:7151: checking command to parse /usr/sbin/nm -B output from arm-linux-androideabi-gcc object
configure:7271: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:7274: $? = 0
configure:7278: /usr/sbin/nm -B conftest.o \| sed -n -e 's/^.*[ ]\([ABCDGIRSTW][ABCDGIRSTW]*\)[ ][ ]*\([_A-Za-z][_A-Za-z0-9]*\)$/\1 \2 \2/p' | sed '/ __gnu_lto/d' \> conftest.nm
configure:7281: $? = 0
configure:7347: arm-linux-androideabi-gcc -o conftest     conftest.c conftstm.o >&5
configure:7350: $? = 0
configure:7388: result: ok
configure:7425: checking for sysroot
configure:7455: result: no
configure:7532: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:7535: $? = 0
configure:7671: checking for x86_64-unknown-linux-mt
configure:7701: result: no
configure:7711: checking for mt
configure:7741: result: no
configure:7761: checking if : is a manifest tool
configure:7767: : '-?'
configure:7775: result: no
configure:8414: checking for dlfcn.h
configure:8414: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:8414: $? = 0
configure:8414: result: yes
configure:8618: checking for objdir
configure:8633: result: .libs
configure:8900: checking if arm-linux-androideabi-gcc supports -fno-rtti -fno-exceptions
configure:8918: arm-linux-androideabi-gcc -c    -fno-rtti -fno-exceptions conftest.c >&5
cc1: warning: command line option '-fno-rtti' is valid for C++/ObjC++ but not for C [enabled by default]
configure:8922: $? = 0
configure:8935: result: no
configure:9262: checking for arm-linux-androideabi-gcc option to produce PIC
configure:9269: result: -fPIC -DPIC
configure:9277: checking if arm-linux-androideabi-gcc PIC flag -fPIC -DPIC works
configure:9295: arm-linux-androideabi-gcc -c    -fPIC -DPIC -DPIC conftest.c >&5
configure:9299: $? = 0
configure:9312: result: yes
configure:9341: checking if arm-linux-androideabi-gcc static flag -static works
configure:9369: result: yes
configure:9384: checking if arm-linux-androideabi-gcc supports -c -o file.o
configure:9405: arm-linux-androideabi-gcc -c    -o out/conftest2.o conftest.c >&5
configure:9409: $? = 0
configure:9431: result: yes
configure:9439: checking if arm-linux-androideabi-gcc supports -c -o file.o
configure:9486: result: yes
configure:9519: checking whether the arm-linux-androideabi-gcc linker (/tmp/toolchain/arm-linux-androideabi/bin/ld -m elf_i386) supports shared libraries
configure:10676: result: yes
configure:10713: checking whether -lc should be explicitly linked in
configure:10721: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:10724: $? = 0
configure:10739: arm-linux-androideabi-gcc -shared  -fPIC -DPIC conftest.o  -v -Wl,-soname -Wl,conftest -o conftest 2\>\&1 \| /usr/sbin/grep  -lc  \>/dev/null 2\>\&1
configure:10742: $? = 0
configure:10756: result: no
configure:10916: checking dynamic linker characteristics
configure:11416: arm-linux-androideabi-gcc -o conftest     -Wl,-rpath -Wl,/foo conftest.c  >&5
configure:11416: $? = 0
configure:11650: result: GNU/Linux ld.so
configure:11757: checking how to hardcode library paths into programs
configure:11782: result: immediate
configure:12322: checking whether stripping libraries is possible
configure:12327: result: yes
configure:12362: checking if libtool supports shared libraries
configure:12364: result: yes
configure:12367: checking whether to build shared libraries
configure:12388: result: yes
configure:12391: checking whether to build static libraries
configure:12395: result: yes
configure:12435: checking for x86_64-unknown-linux-strip
configure:12462: result: strip
configure:12670: checking for dirent.h that defines DIR
configure:12689: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:12689: $? = 0
configure:12697: result: yes
configure:12710: checking for library containing opendir
configure:12741: arm-linux-androideabi-gcc -o conftest     conftest.c  >&5
configure:12741: $? = 0
configure:12758: result: none required
configure:12825: checking for sys/wait.h that is POSIX.1 compatible
configure:12851: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:12851: $? = 0
configure:12858: result: yes
configure:12869: checking acl/libacl.h usability
configure:12869: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:67:24: fatal error: acl/libacl.h: No such file or directory
 #include <acl/libacl.h>
                        ^
compilation terminated.
configure:12869: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <acl/libacl.h>
configure:12869: result: no
configure:12869: checking acl/libacl.h presence
configure:12869: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:34:24: fatal error: acl/libacl.h: No such file or directory
 #include <acl/libacl.h>
                        ^
compilation terminated.
configure:12869: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| /* end confdefs.h.  */
| #include <acl/libacl.h>
configure:12869: result: no
configure:12869: checking for acl/libacl.h
configure:12869: result: no
configure:12869: checking attr/xattr.h usability
configure:12869: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:67:24: fatal error: attr/xattr.h: No such file or directory
 #include <attr/xattr.h>
                        ^
compilation terminated.
configure:12869: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <attr/xattr.h>
configure:12869: result: no
configure:12869: checking attr/xattr.h presence
configure:12869: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:34:24: fatal error: attr/xattr.h: No such file or directory
 #include <attr/xattr.h>
                        ^
compilation terminated.
configure:12869: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| /* end confdefs.h.  */
| #include <attr/xattr.h>
configure:12869: result: no
configure:12869: checking for attr/xattr.h
configure:12869: result: no
configure:12869: checking copyfile.h usability
configure:12869: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:67:22: fatal error: copyfile.h: No such file or directory
 #include <copyfile.h>
                      ^
compilation terminated.
configure:12869: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <copyfile.h>
configure:12869: result: no
configure:12869: checking copyfile.h presence
configure:12869: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:34:22: fatal error: copyfile.h: No such file or directory
 #include <copyfile.h>
                      ^
compilation terminated.
configure:12869: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| /* end confdefs.h.  */
| #include <copyfile.h>
configure:12869: result: no
configure:12869: checking for copyfile.h
configure:12869: result: no
configure:12869: checking ctype.h usability
configure:12869: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:12869: $? = 0
configure:12869: result: yes
configure:12869: checking ctype.h presence
configure:12869: arm-linux-androideabi-gcc -E  conftest.c
configure:12869: $? = 0
configure:12869: result: yes
configure:12869: checking for ctype.h
configure:12869: result: yes
configure:12882: checking errno.h usability
configure:12882: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:12882: $? = 0
configure:12882: result: yes
configure:12882: checking errno.h presence
configure:12882: arm-linux-androideabi-gcc -E  conftest.c
configure:12882: $? = 0
configure:12882: result: yes
configure:12882: checking for errno.h
configure:12882: result: yes
configure:12882: checking ext2fs/ext2_fs.h usability
configure:12882: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:69:28: fatal error: ext2fs/ext2_fs.h: No such file or directory
 #include <ext2fs/ext2_fs.h>
                            ^
compilation terminated.
configure:12882: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <ext2fs/ext2_fs.h>
configure:12882: result: no
configure:12882: checking ext2fs/ext2_fs.h presence
configure:12882: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:36:28: fatal error: ext2fs/ext2_fs.h: No such file or directory
 #include <ext2fs/ext2_fs.h>
                            ^
compilation terminated.
configure:12882: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| /* end confdefs.h.  */
| #include <ext2fs/ext2_fs.h>
configure:12882: result: no
configure:12882: checking for ext2fs/ext2_fs.h
configure:12882: result: no
configure:12882: checking fcntl.h usability
configure:12882: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:12882: $? = 0
configure:12882: result: yes
configure:12882: checking fcntl.h presence
configure:12882: arm-linux-androideabi-gcc -E  conftest.c
configure:12882: $? = 0
configure:12882: result: yes
configure:12882: checking for fcntl.h
configure:12882: result: yes
configure:12882: checking grp.h usability
configure:12882: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:12882: $? = 0
configure:12882: result: yes
configure:12882: checking grp.h presence
configure:12882: arm-linux-androideabi-gcc -E  conftest.c
configure:12882: $? = 0
configure:12882: result: yes
configure:12882: checking for grp.h
configure:12882: result: yes
configure:12893: checking whether EXT2_IOC_GETFLAGS is usable
configure:12910: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:39:28: fatal error: ext2fs/ext2_fs.h: No such file or directory
 #include <ext2fs/ext2_fs.h>
                            ^
compilation terminated.
configure:12910: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| /* end confdefs.h.  */
| #include <sys/ioctl.h>
| #include <ext2fs/ext2_fs.h>
| int
| main ()
| {
| int x = EXT2_IOC_GETFLAGS
|   ;
|   return 0;
| }
configure:12917: result: no
configure:12931: checking for inttypes.h
configure:12931: result: yes
configure:12931: checking io.h usability
configure:12931: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:72:16: fatal error: io.h: No such file or directory
 #include <io.h>
                ^
compilation terminated.
configure:12931: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <io.h>
configure:12931: result: no
configure:12931: checking io.h presence
configure:12931: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:39:16: fatal error: io.h: No such file or directory
 #include <io.h>
                ^
compilation terminated.
configure:12931: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| /* end confdefs.h.  */
| #include <io.h>
configure:12931: result: no
configure:12931: checking for io.h
configure:12931: result: no
configure:12931: checking langinfo.h usability
configure:12931: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:72:22: fatal error: langinfo.h: No such file or directory
 #include <langinfo.h>
                      ^
compilation terminated.
configure:12931: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <langinfo.h>
configure:12931: result: no
configure:12931: checking langinfo.h presence
configure:12931: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:39:22: fatal error: langinfo.h: No such file or directory
 #include <langinfo.h>
                      ^
compilation terminated.
configure:12931: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| /* end confdefs.h.  */
| #include <langinfo.h>
configure:12931: result: no
configure:12931: checking for langinfo.h
configure:12931: result: no
configure:12931: checking limits.h usability
configure:12931: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:12931: $? = 0
configure:12931: result: yes
configure:12931: checking limits.h presence
configure:12931: arm-linux-androideabi-gcc -E  conftest.c
configure:12931: $? = 0
configure:12931: result: yes
configure:12931: checking for limits.h
configure:12931: result: yes
configure:12944: checking linux/fiemap.h usability
configure:12944: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:12944: $? = 0
configure:12944: result: yes
configure:12944: checking linux/fiemap.h presence
configure:12944: arm-linux-androideabi-gcc -E  conftest.c
configure:12944: $? = 0
configure:12944: result: yes
configure:12944: checking for linux/fiemap.h
configure:12944: result: yes
configure:12944: checking linux/fs.h usability
configure:12944: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:12944: $? = 0
configure:12944: result: yes
configure:12944: checking linux/fs.h presence
configure:12944: arm-linux-androideabi-gcc -E  conftest.c
configure:12944: $? = 0
configure:12944: result: yes
configure:12944: checking for linux/fs.h
configure:12944: result: yes
configure:12944: checking linux/magic.h usability
configure:12944: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:12944: $? = 0
configure:12944: result: yes
configure:12944: checking linux/magic.h presence
configure:12944: arm-linux-androideabi-gcc -E  conftest.c
configure:12944: $? = 0
configure:12944: result: yes
configure:12944: checking for linux/magic.h
configure:12944: result: yes
configure:12944: checking linux/types.h usability
configure:12944: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:12944: $? = 0
configure:12944: result: yes
configure:12944: checking linux/types.h presence
configure:12944: arm-linux-androideabi-gcc -E  conftest.c
configure:12944: $? = 0
configure:12944: result: yes
configure:12944: checking for linux/types.h
configure:12944: result: yes
configure:12957: checking locale.h usability
configure:12957: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:12957: $? = 0
configure:12957: result: yes
configure:12957: checking locale.h presence
configure:12957: arm-linux-androideabi-gcc -E  conftest.c
configure:12957: $? = 0
configure:12957: result: yes
configure:12957: checking for locale.h
configure:12957: result: yes
configure:12957: checking paths.h usability
configure:12957: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:12957: $? = 0
configure:12957: result: yes
configure:12957: checking paths.h presence
configure:12957: arm-linux-androideabi-gcc -E  conftest.c
configure:12957: $? = 0
configure:12957: result: yes
configure:12957: checking for paths.h
configure:12957: result: yes
configure:12957: checking poll.h usability
configure:12957: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:12957: $? = 0
configure:12957: result: yes
configure:12957: checking poll.h presence
configure:12957: arm-linux-androideabi-gcc -E  conftest.c
configure:12957: $? = 0
configure:12957: result: yes
configure:12957: checking for poll.h
configure:12957: result: yes
configure:12957: checking pwd.h usability
configure:12957: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:12957: $? = 0
configure:12957: result: yes
configure:12957: checking pwd.h presence
configure:12957: arm-linux-androideabi-gcc -E  conftest.c
configure:12957: $? = 0
configure:12957: result: yes
configure:12957: checking for pwd.h
configure:12957: result: yes
configure:12957: checking signal.h usability
configure:12957: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:12957: $? = 0
configure:12957: result: yes
configure:12957: checking signal.h presence
configure:12957: arm-linux-androideabi-gcc -E  conftest.c
configure:12957: $? = 0
configure:12957: result: yes
configure:12957: checking for signal.h
configure:12957: result: yes
configure:12957: checking spawn.h usability
configure:12957: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:82:19: fatal error: spawn.h: No such file or directory
 #include <spawn.h>
                   ^
compilation terminated.
configure:12957: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <spawn.h>
configure:12957: result: no
configure:12957: checking spawn.h presence
configure:12957: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:49:19: fatal error: spawn.h: No such file or directory
 #include <spawn.h>
                   ^
compilation terminated.
configure:12957: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| /* end confdefs.h.  */
| #include <spawn.h>
configure:12957: result: no
configure:12957: checking for spawn.h
configure:12957: result: no
configure:12970: checking stdarg.h usability
configure:12970: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:12970: $? = 0
configure:12970: result: yes
configure:12970: checking stdarg.h presence
configure:12970: arm-linux-androideabi-gcc -E  conftest.c
configure:12970: $? = 0
configure:12970: result: yes
configure:12970: checking for stdarg.h
configure:12970: result: yes
configure:12970: checking for stdint.h
configure:12970: result: yes
configure:12970: checking for stdlib.h
configure:12970: result: yes
configure:12970: checking for string.h
configure:12970: result: yes
configure:12983: checking sys/acl.h usability
configure:12983: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:86:21: fatal error: sys/acl.h: No such file or directory
 #include <sys/acl.h>
                     ^
compilation terminated.
configure:12983: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <sys/acl.h>
configure:12983: result: no
configure:12983: checking sys/acl.h presence
configure:12983: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:53:21: fatal error: sys/acl.h: No such file or directory
 #include <sys/acl.h>
                     ^
compilation terminated.
configure:12983: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| /* end confdefs.h.  */
| #include <sys/acl.h>
configure:12983: result: no
configure:12983: checking for sys/acl.h
configure:12983: result: no
configure:12983: checking sys/cdefs.h usability
configure:12983: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:12983: $? = 0
configure:12983: result: yes
configure:12983: checking sys/cdefs.h presence
configure:12983: arm-linux-androideabi-gcc -E  conftest.c
configure:12983: $? = 0
configure:12983: result: yes
configure:12983: checking for sys/cdefs.h
configure:12983: result: yes
configure:12983: checking sys/extattr.h usability
configure:12983: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:87:25: fatal error: sys/extattr.h: No such file or directory
 #include <sys/extattr.h>
                         ^
compilation terminated.
configure:12983: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <sys/extattr.h>
configure:12983: result: no
configure:12983: checking sys/extattr.h presence
configure:12983: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:54:25: fatal error: sys/extattr.h: No such file or directory
 #include <sys/extattr.h>
                         ^
compilation terminated.
configure:12983: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| /* end confdefs.h.  */
| #include <sys/extattr.h>
configure:12983: result: no
configure:12983: checking for sys/extattr.h
configure:12983: result: no
configure:12996: checking sys/ioctl.h usability
configure:12996: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:12996: $? = 0
configure:12996: result: yes
configure:12996: checking sys/ioctl.h presence
configure:12996: arm-linux-androideabi-gcc -E  conftest.c
configure:12996: $? = 0
configure:12996: result: yes
configure:12996: checking for sys/ioctl.h
configure:12996: result: yes
configure:12996: checking sys/mkdev.h usability
configure:12996: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:88:23: fatal error: sys/mkdev.h: No such file or directory
 #include <sys/mkdev.h>
                       ^
compilation terminated.
configure:12996: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <sys/mkdev.h>
configure:12996: result: no
configure:12996: checking sys/mkdev.h presence
configure:12996: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:55:23: fatal error: sys/mkdev.h: No such file or directory
 #include <sys/mkdev.h>
                       ^
compilation terminated.
configure:12996: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| /* end confdefs.h.  */
| #include <sys/mkdev.h>
configure:12996: result: no
configure:12996: checking for sys/mkdev.h
configure:12996: result: no
configure:12996: checking sys/mount.h usability
configure:12996: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:12996: $? = 0
configure:12996: result: yes
configure:12996: checking sys/mount.h presence
configure:12996: arm-linux-androideabi-gcc -E  conftest.c
configure:12996: $? = 0
configure:12996: result: yes
configure:12996: checking for sys/mount.h
configure:12996: result: yes
configure:13009: checking sys/param.h usability
configure:13009: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:13009: $? = 0
configure:13009: result: yes
configure:13009: checking sys/param.h presence
configure:13009: arm-linux-androideabi-gcc -E  conftest.c
configure:13009: $? = 0
configure:13009: result: yes
configure:13009: checking for sys/param.h
configure:13009: result: yes
configure:13009: checking sys/poll.h usability
configure:13009: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:13009: $? = 0
configure:13009: result: yes
configure:13009: checking sys/poll.h presence
configure:13009: arm-linux-androideabi-gcc -E  conftest.c
configure:13009: $? = 0
configure:13009: result: yes
configure:13009: checking for sys/poll.h
configure:13009: result: yes
configure:13009: checking sys/select.h usability
configure:13009: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:13009: $? = 0
configure:13009: result: yes
configure:13009: checking sys/select.h presence
configure:13009: arm-linux-androideabi-gcc -E  conftest.c
configure:13009: $? = 0
configure:13009: result: yes
configure:13009: checking for sys/select.h
configure:13009: result: yes
configure:13009: checking sys/statfs.h usability
configure:13009: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:13009: $? = 0
configure:13009: result: yes
configure:13009: checking sys/statfs.h presence
configure:13009: arm-linux-androideabi-gcc -E  conftest.c
configure:13009: $? = 0
configure:13009: result: yes
configure:13009: checking for sys/statfs.h
configure:13009: result: yes
configure:13009: checking sys/statvfs.h usability
configure:13009: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:13009: $? = 0
configure:13009: result: yes
configure:13009: checking sys/statvfs.h presence
configure:13009: arm-linux-androideabi-gcc -E  conftest.c
configure:13009: $? = 0
configure:13009: result: yes
configure:13009: checking for sys/statvfs.h
configure:13009: result: yes
configure:13022: checking sys/time.h usability
configure:13022: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:13022: $? = 0
configure:13022: result: yes
configure:13022: checking sys/time.h presence
configure:13022: arm-linux-androideabi-gcc -E  conftest.c
configure:13022: $? = 0
configure:13022: result: yes
configure:13022: checking for sys/time.h
configure:13022: result: yes
configure:13022: checking sys/utime.h usability
configure:13022: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:13022: $? = 0
configure:13022: result: yes
configure:13022: checking sys/utime.h presence
configure:13022: arm-linux-androideabi-gcc -E  conftest.c
configure:13022: $? = 0
configure:13022: result: yes
configure:13022: checking for sys/utime.h
configure:13022: result: yes
configure:13022: checking sys/utsname.h usability
configure:13022: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:13022: $? = 0
configure:13022: result: yes
configure:13022: checking sys/utsname.h presence
configure:13022: arm-linux-androideabi-gcc -E  conftest.c
configure:13022: $? = 0
configure:13022: result: yes
configure:13022: checking for sys/utsname.h
configure:13022: result: yes
configure:13022: checking sys/vfs.h usability
configure:13022: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:13022: $? = 0
configure:13022: result: yes
configure:13022: checking sys/vfs.h presence
configure:13022: arm-linux-androideabi-gcc -E  conftest.c
configure:13022: $? = 0
configure:13022: result: yes
configure:13022: checking for sys/vfs.h
configure:13022: result: yes
configure:13035: checking time.h usability
configure:13035: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:13035: $? = 0
configure:13035: result: yes
configure:13035: checking time.h presence
configure:13035: arm-linux-androideabi-gcc -E  conftest.c
configure:13035: $? = 0
configure:13035: result: yes
configure:13035: checking for time.h
configure:13035: result: yes
configure:13035: checking for unistd.h
configure:13035: result: yes
configure:13035: checking utime.h usability
configure:13035: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:13035: $? = 0
configure:13035: result: yes
configure:13035: checking utime.h presence
configure:13035: arm-linux-androideabi-gcc -E  conftest.c
configure:13035: $? = 0
configure:13035: result: yes
configure:13035: checking for utime.h
configure:13035: result: yes
configure:13035: checking wchar.h usability
configure:13035: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:13035: $? = 0
configure:13035: result: yes
configure:13035: checking wchar.h presence
configure:13035: arm-linux-androideabi-gcc -E  conftest.c
configure:13035: $? = 0
configure:13035: result: yes
configure:13035: checking for wchar.h
configure:13035: result: yes
configure:13035: checking wctype.h usability
configure:13035: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:13035: $? = 0
configure:13035: result: yes
configure:13035: checking wctype.h presence
configure:13035: arm-linux-androideabi-gcc -E  conftest.c
configure:13035: $? = 0
configure:13035: result: yes
configure:13035: checking for wctype.h
configure:13035: result: yes
configure:13047: checking windows.h usability
configure:13047: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:103:21: fatal error: windows.h: No such file or directory
 #include <windows.h>
                     ^
compilation terminated.
configure:13047: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <windows.h>
configure:13047: result: no
configure:13047: checking windows.h presence
configure:13047: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:70:21: fatal error: windows.h: No such file or directory
 #include <windows.h>
                     ^
compilation terminated.
configure:13047: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| /* end confdefs.h.  */
| #include <windows.h>
configure:13047: result: no
configure:13047: checking for windows.h
configure:13047: result: no
configure:13061: checking for wincrypt.h
configure:13061: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:75:22: fatal error: wincrypt.h: No such file or directory
 #include <wincrypt.h>
                      ^
compilation terminated.
configure:13061: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| /* end confdefs.h.  */
| #ifdef HAVE_WINDOWS_H
| # include <windows.h>
| #endif
| 
| 
| #include <wincrypt.h>
configure:13061: result: no
configure:13061: checking for winioctl.h
configure:13061: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:75:22: fatal error: winioctl.h: No such file or directory
 #include <winioctl.h>
                      ^
compilation terminated.
configure:13061: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| /* end confdefs.h.  */
| #ifdef HAVE_WINDOWS_H
| # include <windows.h>
| #endif
| 
| 
| #include <winioctl.h>
configure:13061: result: no
configure:13087: checking zlib.h usability
configure:13087: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:13087: $? = 0
configure:13087: result: yes
configure:13087: checking zlib.h presence
configure:13087: arm-linux-androideabi-gcc -E  conftest.c
configure:13087: $? = 0
configure:13087: result: yes
configure:13087: checking for zlib.h
configure:13087: result: yes
configure:13097: checking for inflate in -lz
configure:13122: arm-linux-androideabi-gcc -o conftest     conftest.c -lz   >&5
configure:13122: $? = 0
configure:13131: result: yes
configure:13154: checking bzlib.h usability
configure:13154: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:105:19: fatal error: bzlib.h: No such file or directory
 #include <bzlib.h>
                   ^
compilation terminated.
configure:13154: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <bzlib.h>
configure:13154: result: no
configure:13154: checking bzlib.h presence
configure:13154: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:72:19: fatal error: bzlib.h: No such file or directory
 #include <bzlib.h>
                   ^
compilation terminated.
configure:13154: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| /* end confdefs.h.  */
| #include <bzlib.h>
configure:13154: result: no
configure:13154: checking for bzlib.h
configure:13154: result: no
configure:13193: checking for BZ2_bzDecompressInit in -lbz2
configure:13218: arm-linux-androideabi-gcc -o conftest     conftest.c -lbz2  -lz  >&5
/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld: error: cannot find -lbz2
/tmp/ccWqTQKa.o:conftest.c:function main: error: undefined reference to 'BZ2_bzDecompressInit'
collect2: error: ld returned 1 exit status
configure:13218: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| /* end confdefs.h.  */
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char BZ2_bzDecompressInit ();
| int
| main ()
| {
| return BZ2_bzDecompressInit ();
|   ;
|   return 0;
| }
configure:13227: result: no
configure:13252: checking lzmadec.h usability
configure:13252: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:105:21: fatal error: lzmadec.h: No such file or directory
 #include <lzmadec.h>
                     ^
compilation terminated.
configure:13252: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <lzmadec.h>
configure:13252: result: no
configure:13252: checking lzmadec.h presence
configure:13252: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:72:21: fatal error: lzmadec.h: No such file or directory
 #include <lzmadec.h>
                     ^
compilation terminated.
configure:13252: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| /* end confdefs.h.  */
| #include <lzmadec.h>
configure:13252: result: no
configure:13252: checking for lzmadec.h
configure:13252: result: no
configure:13262: checking for lzmadec_decode in -llzmadec
configure:13287: arm-linux-androideabi-gcc -o conftest     conftest.c -llzmadec  -lz  >&5
/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld: error: cannot find -llzmadec
/tmp/ccsLJXIy.o:conftest.c:function main: error: undefined reference to 'lzmadec_decode'
collect2: error: ld returned 1 exit status
configure:13287: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| /* end confdefs.h.  */
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char lzmadec_decode ();
| int
| main ()
| {
| return lzmadec_decode ();
|   ;
|   return 0;
| }
configure:13296: result: no
configure:13356: checking for ld used by GCC
configure:13420: result: /tmp/toolchain/arm-linux-androideabi/bin/ld -m elf_i386
configure:13427: checking if the linker (/tmp/toolchain/arm-linux-androideabi/bin/ld -m elf_i386) is GNU ld
configure:13440: result: yes
configure:13447: checking for shared library run path origin
configure:13460: result: done
configure:14038: checking for iconv
configure:14062: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
conftest.c:74:19: fatal error: iconv.h: No such file or directory
 #include <iconv.h>
                   ^
compilation terminated.
configure:14062: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| /* end confdefs.h.  */
| 
| #include <stdlib.h>
| #include <iconv.h>
| 
| int
| main ()
| {
| iconv_t cd = iconv_open("","");
|            iconv(cd,NULL,NULL,NULL,NULL);
|            iconv_close(cd);
|   ;
|   return 0;
| }
configure:14086: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  -liconv >&5
conftest.c:74:19: fatal error: iconv.h: No such file or directory
 #include <iconv.h>
                   ^
compilation terminated.
configure:14086: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| /* end confdefs.h.  */
| 
| #include <stdlib.h>
| #include <iconv.h>
| 
| int
| main ()
| {
| iconv_t cd = iconv_open("","");
|              iconv(cd,NULL,NULL,NULL,NULL);
|              iconv_close(cd);
|   ;
|   return 0;
| }
configure:14096: result: no, consider installing GNU libiconv
configure:14312: checking for iconv.h
configure:14312: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:74:19: fatal error: iconv.h: No such file or directory
 #include <iconv.h>
                   ^
compilation terminated.
configure:14312: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| /* end confdefs.h.  */
| #include <stdlib.h>
| 
| #include <iconv.h>
configure:14312: result: no
configure:14411: checking lzma.h usability
configure:14411: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:105:18: fatal error: lzma.h: No such file or directory
 #include <lzma.h>
                  ^
compilation terminated.
configure:14411: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <lzma.h>
configure:14411: result: no
configure:14411: checking lzma.h presence
configure:14411: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:72:18: fatal error: lzma.h: No such file or directory
 #include <lzma.h>
                  ^
compilation terminated.
configure:14411: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| /* end confdefs.h.  */
| #include <lzma.h>
configure:14411: result: no
configure:14411: checking for lzma.h
configure:14411: result: no
configure:14421: checking for lzma_stream_decoder in -llzma
configure:14446: arm-linux-androideabi-gcc -o conftest     conftest.c -llzma  -lz  >&5
/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld: error: cannot find -llzma
/tmp/ccUxh6E8.o:conftest.c:function main: error: undefined reference to 'lzma_stream_decoder'
collect2: error: ld returned 1 exit status
configure:14446: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| /* end confdefs.h.  */
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char lzma_stream_decoder ();
| int
| main ()
| {
| return lzma_stream_decoder ();
|   ;
|   return 0;
| }
configure:14455: result: no
configure:14479: checking lzo/lzoconf.h usability
configure:14479: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:105:25: fatal error: lzo/lzoconf.h: No such file or directory
 #include <lzo/lzoconf.h>
                         ^
compilation terminated.
configure:14479: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <lzo/lzoconf.h>
configure:14479: result: no
configure:14479: checking lzo/lzoconf.h presence
configure:14479: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:72:25: fatal error: lzo/lzoconf.h: No such file or directory
 #include <lzo/lzoconf.h>
                         ^
compilation terminated.
configure:14479: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| /* end confdefs.h.  */
| #include <lzo/lzoconf.h>
configure:14479: result: no
configure:14479: checking for lzo/lzoconf.h
configure:14479: result: no
configure:14479: checking lzo/lzo1x.h usability
configure:14479: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:105:23: fatal error: lzo/lzo1x.h: No such file or directory
 #include <lzo/lzo1x.h>
                       ^
compilation terminated.
configure:14479: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <lzo/lzo1x.h>
configure:14479: result: no
configure:14479: checking lzo/lzo1x.h presence
configure:14479: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:72:23: fatal error: lzo/lzo1x.h: No such file or directory
 #include <lzo/lzo1x.h>
                       ^
compilation terminated.
configure:14479: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| /* end confdefs.h.  */
| #include <lzo/lzo1x.h>
configure:14479: result: no
configure:14479: checking for lzo/lzo1x.h
configure:14479: result: no
configure:14489: checking for lzo1x_decompress_safe in -llzo2
configure:14514: arm-linux-androideabi-gcc -o conftest     conftest.c -llzo2  -lz  >&5
/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld: error: cannot find -llzo2
/tmp/cccHKguu.o:conftest.c:function main: error: undefined reference to 'lzo1x_decompress_safe'
collect2: error: ld returned 1 exit status
configure:14514: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| /* end confdefs.h.  */
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char lzo1x_decompress_safe ();
| int
| main ()
| {
| return lzo1x_decompress_safe ();
|   ;
|   return 0;
| }
configure:14523: result: no
configure:14719: checking expat.h usability
configure:14719: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:105:19: fatal error: expat.h: No such file or directory
 #include <expat.h>
                   ^
compilation terminated.
configure:14719: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <expat.h>
configure:14719: result: no
configure:14719: checking expat.h presence
configure:14719: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:72:19: fatal error: expat.h: No such file or directory
 #include <expat.h>
                   ^
compilation terminated.
configure:14719: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| /* end confdefs.h.  */
| #include <expat.h>
configure:14719: result: no
configure:14719: checking for expat.h
configure:14719: result: no
configure:14729: checking for XML_ParserCreate in -lexpat
configure:14754: arm-linux-androideabi-gcc -o conftest     conftest.c -lexpat  -lz  >&5
/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld: error: cannot find -lexpat
/tmp/cckkhEY1.o:conftest.c:function main: error: undefined reference to 'XML_ParserCreate'
collect2: error: ld returned 1 exit status
configure:14754: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| /* end confdefs.h.  */
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char XML_ParserCreate ();
| int
| main ()
| {
| return XML_ParserCreate ();
|   ;
|   return 0;
| }
configure:14763: result: no
configure:14789: checking regex.h usability
configure:14789: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:14789: $? = 0
configure:14789: result: yes
configure:14789: checking regex.h presence
configure:14789: arm-linux-androideabi-gcc -E  conftest.c
configure:14789: $? = 0
configure:14789: result: yes
configure:14789: checking for regex.h
configure:14789: result: yes
configure:14800: checking for regcomp
configure:14800: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:14800: $? = 0
configure:14800: result: yes
configure:15064: checking for an ANSI C-conforming const
configure:15130: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:15130: $? = 0
configure:15137: result: yes
configure:15147: checking for uid_t in sys/types.h
configure:15166: result: yes
configure:15185: checking for mode_t
configure:15185: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:15185: $? = 0
configure:15185: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:109:21: error: expected expression before ')' token
 if (sizeof ((mode_t)))
                     ^
configure:15185: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| if (sizeof ((mode_t)))
| 	    return 0;
|   ;
|   return 0;
| }
configure:15185: result: yes
configure:15198: checking for off_t
configure:15198: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:15198: $? = 0
configure:15198: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:109:20: error: expected expression before ')' token
 if (sizeof ((off_t)))
                    ^
configure:15198: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| if (sizeof ((off_t)))
| 	    return 0;
|   ;
|   return 0;
| }
configure:15198: result: yes
configure:15209: checking for size_t
configure:15209: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:15209: $? = 0
configure:15209: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:109:21: error: expected expression before ')' token
 if (sizeof ((size_t)))
                     ^
configure:15209: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| if (sizeof ((size_t)))
| 	    return 0;
|   ;
|   return 0;
| }
configure:15209: result: yes
configure:15220: checking for id_t
configure:15220: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:15220: $? = 0
configure:15220: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:109:19: error: expected expression before ')' token
 if (sizeof ((id_t)))
                   ^
configure:15220: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| if (sizeof ((id_t)))
| 	    return 0;
|   ;
|   return 0;
| }
configure:15220: result: yes
configure:15231: checking for uintptr_t
configure:15231: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:15231: $? = 0
configure:15231: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:109:24: error: expected expression before ')' token
 if (sizeof ((uintptr_t)))
                        ^
configure:15231: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| if (sizeof ((uintptr_t)))
| 	    return 0;
|   ;
|   return 0;
| }
configure:15231: result: yes
configure:15244: checking for struct tm.tm_gmtoff
configure:15244: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:15244: $? = 0
configure:15244: result: yes
configure:15256: checking for struct tm.__tm_gmtoff
configure:15256: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:82:12: error: 'struct tm' has no member named '__tm_gmtoff'
 if (ac_aggr.__tm_gmtoff)
            ^
configure:15256: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| /* end confdefs.h.  */
| 
| #include <time.h>
| 
| 
| int
| main ()
| {
| static struct tm ac_aggr;
| if (ac_aggr.__tm_gmtoff)
| return 0;
|   ;
|   return 0;
| }
configure:15256: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:82:19: error: 'struct tm' has no member named '__tm_gmtoff'
 if (sizeof ac_aggr.__tm_gmtoff)
                   ^
configure:15256: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| /* end confdefs.h.  */
| 
| #include <time.h>
| 
| 
| int
| main ()
| {
| static struct tm ac_aggr;
| if (sizeof ac_aggr.__tm_gmtoff)
| return 0;
|   ;
|   return 0;
| }
configure:15256: result: no
configure:15271: checking for struct statfs.f_namemax
configure:15271: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:82:22: error: storage size of 'ac_aggr' isn't known
 static struct statfs ac_aggr;
                      ^
configure:15271: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| /* end confdefs.h.  */
| 
| #include <sys/param.h>
| #include <sys/mount.h>
| 
| 
| int
| main ()
| {
| static struct statfs ac_aggr;
| if (ac_aggr.f_namemax)
| return 0;
|   ;
|   return 0;
| }
configure:15271: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:82:22: error: storage size of 'ac_aggr' isn't known
 static struct statfs ac_aggr;
                      ^
configure:15271: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| /* end confdefs.h.  */
| 
| #include <sys/param.h>
| #include <sys/mount.h>
| 
| 
| int
| main ()
| {
| static struct statfs ac_aggr;
| if (sizeof ac_aggr.f_namemax)
| return 0;
|   ;
|   return 0;
| }
configure:15271: result: no
configure:15287: checking for struct statvfs.f_iosize
configure:15287: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:82:12: error: 'struct statvfs' has no member named 'f_iosize'
 if (ac_aggr.f_iosize)
            ^
configure:15287: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| /* end confdefs.h.  */
| 
| #include <sys/statvfs.h>
| 
| 
| int
| main ()
| {
| static struct statvfs ac_aggr;
| if (ac_aggr.f_iosize)
| return 0;
|   ;
|   return 0;
| }
configure:15287: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:82:19: error: 'struct statvfs' has no member named 'f_iosize'
 if (sizeof ac_aggr.f_iosize)
                   ^
configure:15287: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| /* end confdefs.h.  */
| 
| #include <sys/statvfs.h>
| 
| 
| int
| main ()
| {
| static struct statvfs ac_aggr;
| if (sizeof ac_aggr.f_iosize)
| return 0;
|   ;
|   return 0;
| }
configure:15287: result: no
configure:15302: checking for struct stat.st_birthtime
configure:15302: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:111:12: error: 'struct stat' has no member named 'st_birthtime'
 if (ac_aggr.st_birthtime)
            ^
configure:15302: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static struct stat ac_aggr;
| if (ac_aggr.st_birthtime)
| return 0;
|   ;
|   return 0;
| }
configure:15302: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:111:19: error: 'struct stat' has no member named 'st_birthtime'
 if (sizeof ac_aggr.st_birthtime)
                   ^
configure:15302: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static struct stat ac_aggr;
| if (sizeof ac_aggr.st_birthtime)
| return 0;
|   ;
|   return 0;
| }
configure:15302: result: no
configure:15314: checking for struct stat.st_birthtimespec.tv_nsec
configure:15314: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:111:12: error: 'struct stat' has no member named 'st_birthtimespec'
 if (ac_aggr.st_birthtimespec.tv_nsec)
            ^
configure:15314: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static struct stat ac_aggr;
| if (ac_aggr.st_birthtimespec.tv_nsec)
| return 0;
|   ;
|   return 0;
| }
configure:15314: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:111:19: error: 'struct stat' has no member named 'st_birthtimespec'
 if (sizeof ac_aggr.st_birthtimespec.tv_nsec)
                   ^
configure:15314: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static struct stat ac_aggr;
| if (sizeof ac_aggr.st_birthtimespec.tv_nsec)
| return 0;
|   ;
|   return 0;
| }
configure:15314: result: no
configure:15324: checking for struct stat.st_mtimespec.tv_nsec
configure:15324: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:111:12: error: 'struct stat' has no member named 'st_mtimespec'
 if (ac_aggr.st_mtimespec.tv_nsec)
            ^
configure:15324: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static struct stat ac_aggr;
| if (ac_aggr.st_mtimespec.tv_nsec)
| return 0;
|   ;
|   return 0;
| }
configure:15324: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:111:19: error: 'struct stat' has no member named 'st_mtimespec'
 if (sizeof ac_aggr.st_mtimespec.tv_nsec)
                   ^
configure:15324: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static struct stat ac_aggr;
| if (sizeof ac_aggr.st_mtimespec.tv_nsec)
| return 0;
|   ;
|   return 0;
| }
configure:15324: result: no
configure:15334: checking for struct stat.st_mtim.tv_nsec
configure:15334: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:111:12: error: 'struct stat' has no member named 'st_mtim'
 if (ac_aggr.st_mtim.tv_nsec)
            ^
configure:15334: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static struct stat ac_aggr;
| if (ac_aggr.st_mtim.tv_nsec)
| return 0;
|   ;
|   return 0;
| }
configure:15334: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:111:19: error: 'struct stat' has no member named 'st_mtim'
 if (sizeof ac_aggr.st_mtim.tv_nsec)
                   ^
configure:15334: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static struct stat ac_aggr;
| if (sizeof ac_aggr.st_mtim.tv_nsec)
| return 0;
|   ;
|   return 0;
| }
configure:15334: result: no
configure:15344: checking for struct stat.st_mtime_n
configure:15344: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:111:12: error: 'struct stat' has no member named 'st_mtime_n'
 if (ac_aggr.st_mtime_n)
            ^
configure:15344: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static struct stat ac_aggr;
| if (ac_aggr.st_mtime_n)
| return 0;
|   ;
|   return 0;
| }
configure:15344: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:111:19: error: 'struct stat' has no member named 'st_mtime_n'
 if (sizeof ac_aggr.st_mtime_n)
                   ^
configure:15344: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static struct stat ac_aggr;
| if (sizeof ac_aggr.st_mtime_n)
| return 0;
|   ;
|   return 0;
| }
configure:15344: result: no
configure:15354: checking for struct stat.st_umtime
configure:15354: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:111:12: error: 'struct stat' has no member named 'st_umtime'
 if (ac_aggr.st_umtime)
            ^
configure:15354: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static struct stat ac_aggr;
| if (ac_aggr.st_umtime)
| return 0;
|   ;
|   return 0;
| }
configure:15354: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:111:19: error: 'struct stat' has no member named 'st_umtime'
 if (sizeof ac_aggr.st_umtime)
                   ^
configure:15354: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static struct stat ac_aggr;
| if (sizeof ac_aggr.st_umtime)
| return 0;
|   ;
|   return 0;
| }
configure:15354: result: no
configure:15364: checking for struct stat.st_mtime_usec
configure:15364: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:111:12: error: 'struct stat' has no member named 'st_mtime_usec'
 if (ac_aggr.st_mtime_usec)
            ^
configure:15364: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static struct stat ac_aggr;
| if (ac_aggr.st_mtime_usec)
| return 0;
|   ;
|   return 0;
| }
configure:15364: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:111:19: error: 'struct stat' has no member named 'st_mtime_usec'
 if (sizeof ac_aggr.st_mtime_usec)
                   ^
configure:15364: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static struct stat ac_aggr;
| if (sizeof ac_aggr.st_mtime_usec)
| return 0;
|   ;
|   return 0;
| }
configure:15364: result: no
configure:15375: checking for struct stat.st_blksize
configure:15375: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:15375: $? = 0
configure:15375: result: yes
configure:15386: checking for struct stat.st_flags
configure:15386: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:112:12: error: 'struct stat' has no member named 'st_flags'
 if (ac_aggr.st_flags)
            ^
configure:15386: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static struct stat ac_aggr;
| if (ac_aggr.st_flags)
| return 0;
|   ;
|   return 0;
| }
configure:15386: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:112:19: error: 'struct stat' has no member named 'st_flags'
 if (sizeof ac_aggr.st_flags)
                   ^
configure:15386: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static struct stat ac_aggr;
| if (sizeof ac_aggr.st_flags)
| return 0;
|   ;
|   return 0;
| }
configure:15386: result: no
configure:15400: checking for uintmax_t
configure:15400: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:15400: $? = 0
configure:15400: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:111:24: error: expected expression before ')' token
 if (sizeof ((uintmax_t)))
                        ^
configure:15400: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| if (sizeof ((uintmax_t)))
| 	    return 0;
|   ;
|   return 0;
| }
configure:15400: result: yes
configure:15409: checking for unsigned long long
configure:15409: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:15409: $? = 0
configure:15409: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:112:33: error: expected expression before ')' token
 if (sizeof ((unsigned long long)))
                                 ^
configure:15409: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| if (sizeof ((unsigned long long)))
| 	    return 0;
|   ;
|   return 0;
| }
configure:15409: result: yes
configure:15423: checking for unsigned long long int
configure:15462: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:15462: $? = 0
configure:15471: result: yes
configure:15481: checking for long long int
configure:15531: result: yes
configure:15541: checking for intmax_t
configure:15541: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:15541: $? = 0
configure:15541: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:115:23: error: expected expression before ')' token
 if (sizeof ((intmax_t)))
                       ^
configure:15541: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| if (sizeof ((intmax_t)))
| 	    return 0;
|   ;
|   return 0;
| }
configure:15541: result: yes
configure:15560: checking for uintmax_t
configure:15560: result: yes
configure:15577: checking for int64_t
configure:15577: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:15577: $? = 0
configure:15577: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:119:53: warning: integer overflow in expression [-Woverflow]
    < (int64_t) (((((int64_t) 1 << N) << N) - 1) * 2 + 2))];
                                                     ^
conftest.c:118:12: error: storage size of 'test_array' isn't constant
 static int test_array [1 - 2 * !((int64_t) (((((int64_t) 1 << N) << N) - 1) * 2 + 1)
            ^
configure:15577: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| 	        enum { N = 64 / 2 - 1 };
| int
| main ()
| {
| static int test_array [1 - 2 * !((int64_t) (((((int64_t) 1 << N) << N) - 1) * 2 + 1)
| 		 < (int64_t) (((((int64_t) 1 << N) << N) - 1) * 2 + 2))];
| test_array [0] = 0;
| return test_array [0];
| 
|   ;
|   return 0;
| }
configure:15577: result: yes
configure:15588: checking for uint64_t
configure:15588: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:15588: $? = 0
configure:15588: result: yes
configure:15602: checking for int32_t
configure:15602: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:15602: $? = 0
configure:15602: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:119:53: warning: integer overflow in expression [-Woverflow]
    < (int32_t) (((((int32_t) 1 << N) << N) - 1) * 2 + 2))];
                                                     ^
conftest.c:118:12: error: storage size of 'test_array' isn't constant
 static int test_array [1 - 2 * !((int32_t) (((((int32_t) 1 << N) << N) - 1) * 2 + 1)
            ^
configure:15602: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| 	        enum { N = 32 / 2 - 1 };
| int
| main ()
| {
| static int test_array [1 - 2 * !((int32_t) (((((int32_t) 1 << N) << N) - 1) * 2 + 1)
| 		 < (int32_t) (((((int32_t) 1 << N) << N) - 1) * 2 + 2))];
| test_array [0] = 0;
| return test_array [0];
| 
|   ;
|   return 0;
| }
configure:15602: result: yes
configure:15613: checking for uint32_t
configure:15613: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:15613: $? = 0
configure:15613: result: yes
configure:15627: checking for int16_t
configure:15627: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:15627: $? = 0
configure:15627: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:118:12: error: size of array 'test_array' is negative
 static int test_array [1 - 2 * !((int16_t) (((((int16_t) 1 << N) << N) - 1) * 2 + 1)
            ^
configure:15627: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| 	        enum { N = 16 / 2 - 1 };
| int
| main ()
| {
| static int test_array [1 - 2 * !((int16_t) (((((int16_t) 1 << N) << N) - 1) * 2 + 1)
| 		 < (int16_t) (((((int16_t) 1 << N) << N) - 1) * 2 + 2))];
| test_array [0] = 0;
| return test_array [0];
| 
|   ;
|   return 0;
| }
configure:15627: result: yes
configure:15638: checking for uint16_t
configure:15638: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:15638: $? = 0
configure:15638: result: yes
configure:15650: checking for uint8_t
configure:15650: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:15650: $? = 0
configure:15650: result: yes
configure:15665: checking whether SIZE_MAX is declared
configure:15665: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:15665: $? = 0
configure:15665: result: yes
configure:15675: checking whether INT64_MAX is declared
configure:15675: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:15675: $? = 0
configure:15675: result: yes
configure:15685: checking whether INT64_MIN is declared
configure:15685: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:15685: $? = 0
configure:15685: result: yes
configure:15695: checking whether UINT64_MAX is declared
configure:15695: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:15695: $? = 0
configure:15695: result: yes
configure:15705: checking whether UINT32_MAX is declared
configure:15705: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:15705: $? = 0
configure:15705: result: yes
configure:15717: checking whether SSIZE_MAX is declared
configure:15717: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:15717: $? = 0
configure:15717: result: yes
configure:15726: checking whether EFTYPE is declared
configure:15726: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:96:10: error: 'EFTYPE' undeclared (first use in this function)
   (void) EFTYPE;
          ^
conftest.c:96:10: note: each undeclared identifier is reported only once for each function it appears in
configure:15726: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| /* end confdefs.h.  */
| #include <errno.h>
| 
| int
| main ()
| {
| #ifndef EFTYPE
| #ifdef __cplusplus
|   (void) EFTYPE;
| #else
|   (void) EFTYPE;
| #endif
| #endif
| 
|   ;
|   return 0;
| }
configure:15726: result: no
configure:15734: checking whether EILSEQ is declared
configure:15734: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:15734: $? = 0
configure:15734: result: yes
configure:15742: checking for wchar_t
configure:15742: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:15742: $? = 0
configure:15742: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:124:22: error: expected expression before ')' token
 if (sizeof ((wchar_t)))
                      ^
configure:15742: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| if (sizeof ((wchar_t)))
| 	    return 0;
|   ;
|   return 0;
| }
configure:15742: result: yes
configure:15752: checking size of wchar_t
configure:15757: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:15757: $? = 0
configure:15757: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:125:12: error: size of array 'test_array' is negative
 static int test_array [1 - 2 * !(((long int) (sizeof (wchar_t))) <= 0)];
            ^
configure:15757: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static int test_array [1 - 2 * !(((long int) (sizeof (wchar_t))) <= 0)];
| test_array [0] = 0;
| return test_array [0];
| 
|   ;
|   return 0;
| }
configure:15757: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:125:12: error: size of array 'test_array' is negative
 static int test_array [1 - 2 * !(((long int) (sizeof (wchar_t))) <= 1)];
            ^
configure:15757: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static int test_array [1 - 2 * !(((long int) (sizeof (wchar_t))) <= 1)];
| test_array [0] = 0;
| return test_array [0];
| 
|   ;
|   return 0;
| }
configure:15757: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:125:12: error: size of array 'test_array' is negative
 static int test_array [1 - 2 * !(((long int) (sizeof (wchar_t))) <= 3)];
            ^
configure:15757: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| static int test_array [1 - 2 * !(((long int) (sizeof (wchar_t))) <= 3)];
| test_array [0] = 0;
| return test_array [0];
| 
|   ;
|   return 0;
| }
configure:15757: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:15757: $? = 0
configure:15757: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:15757: $? = 0
configure:15757: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:15757: $? = 0
configure:15771: result: 4
configure:15784: checking whether time.h and sys/time.h may both be included
configure:15804: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:15804: $? = 0
configure:15811: result: yes
configure:15822: checking whether arm-linux-androideabi-gcc needs -traditional
configure:15856: result: no
configure:15863: checking whether sys/types.h defines makedev
configure:15879: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:15879: $? = 0
configure:15888: result: yes
configure:15913: checking for _LARGEFILE_SOURCE value needed for large files
configure:15932: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:15932: $? = 0
configure:15960: result: no
configure:15981: checking for working memcmp
configure:16034: result: no
configure:16043: checking whether lstat correctly handles trailing slash
configure:16086: result: no
configure:16105: checking whether lstat accepts an empty string
configure:16135: result: yes
configure:16151: checking whether stat accepts an empty string
configure:16181: result: yes
configure:16197: checking whether strerror_r is declared
configure:16197: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:16197: $? = 0
configure:16197: result: yes
configure:16210: checking for strerror_r
configure:16210: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16210: $? = 0
configure:16210: result: yes
configure:16219: checking whether strerror_r returns char *
configure:16243: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:134:13: error: invalid type argument of unary '*' (have 'int')
    char x = *strerror_r (0, buf, sizeof buf);
             ^
conftest.c:135:14: warning: initialization makes pointer from integer without a cast [enabled by default]
    char *p = strerror_r (0, buf, sizeof buf);
              ^
configure:16243: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| int
| main ()
| {
| 
| 	  char buf[100];
| 	  char x = *strerror_r (0, buf, sizeof buf);
| 	  char *p = strerror_r (0, buf, sizeof buf);
| 	  return !p || x;
| 
|   ;
|   return 0;
| }
configure:16281: result: no
configure:16291: checking for strftime
configure:16291: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
conftest.c:119:6: warning: conflicting types for built-in function 'strftime' [enabled by default]
 char strftime ();
      ^
configure:16291: $? = 0
configure:16291: result: yes
configure:16346: checking for vprintf
configure:16346: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
conftest.c:120:6: warning: conflicting types for built-in function 'vprintf' [enabled by default]
 char vprintf ();
      ^
configure:16346: $? = 0
configure:16346: result: yes
configure:16352: checking for _doprnt
configure:16352: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/ccC6QXne.o:conftest.c:function main: error: undefined reference to '_doprnt'
collect2: error: ld returned 1 exit status
configure:16352: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| /* end confdefs.h.  */
| /* Define _doprnt to an innocuous variant, in case <limits.h> declares _doprnt.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define _doprnt innocuous__doprnt
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char _doprnt (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef _doprnt
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char _doprnt ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub__doprnt || defined __stub____doprnt
| choke me
| #endif
| 
| int
| main ()
| {
| return _doprnt ();
|   ;
|   return 0;
| }
configure:16352: result: no
configure:16367: checking for CreateHardLinkA
configure:16402: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
conftest.c:107:16: error: expected '=', ',', ';', 'asm' or '__attribute__' before 'CreateHardLinkA'
 char __stdcall CreateHardLinkA ( const char *, const char *, void * );
                ^
conftest.c: In function 'main':
conftest.c:119:5: error: 'CreateHardLinkA' undeclared (first use in this function)
 f = CreateHardLinkA;
     ^
conftest.c:119:5: note: each undeclared identifier is reported only once for each function it appears in
configure:16402: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| /* end confdefs.h.  */
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char __stdcall CreateHardLinkA ( const char *, const char *, void * ) below.  */
| #include <assert.h>
| /* Override any gcc2 internal prototype to avoid an error.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| /* We use char because int might match the return type of a gcc2
|    builtin and then its argument prototype would still apply.  */
| char __stdcall CreateHardLinkA ( const char *, const char *, void * );
| char (*f) ( const char *, const char *, void * );
| 
| int
| main ()
| {
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined (__stub_CreateHardLinkA) || defined (__stub___CreateHardLinkA)
| choke me
| #else
| f = CreateHardLinkA;
| #endif
| 
|   ;
|   return 0;
| }
configure:16410: result: no
configure:16418: checking for chflags
configure:16418: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/ccwcXDFq.o:conftest.c:function main: error: undefined reference to 'chflags'
collect2: error: ld returned 1 exit status
configure:16418: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| /* end confdefs.h.  */
| /* Define chflags to an innocuous variant, in case <limits.h> declares chflags.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define chflags innocuous_chflags
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char chflags (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef chflags
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char chflags ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_chflags || defined __stub___chflags
| choke me
| #endif
| 
| int
| main ()
| {
| return chflags ();
|   ;
|   return 0;
| }
configure:16418: result: no
configure:16418: checking for chown
configure:16418: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16418: $? = 0
configure:16418: result: yes
configure:16418: checking for chroot
configure:16418: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16418: $? = 0
configure:16418: result: yes
configure:16418: checking for ctime_r
configure:16418: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16418: $? = 0
configure:16418: result: yes
configure:16418: checking for dirfd
configure:16418: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16418: $? = 0
configure:16418: result: yes
configure:16430: checking for fchdir
configure:16430: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16430: $? = 0
configure:16430: result: yes
configure:16430: checking for fchflags
configure:16430: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/ccSFB1F0.o:conftest.c:function main: error: undefined reference to 'fchflags'
collect2: error: ld returned 1 exit status
configure:16430: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| /* end confdefs.h.  */
| /* Define fchflags to an innocuous variant, in case <limits.h> declares fchflags.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define fchflags innocuous_fchflags
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char fchflags (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef fchflags
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char fchflags ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_fchflags || defined __stub___fchflags
| choke me
| #endif
| 
| int
| main ()
| {
| return fchflags ();
|   ;
|   return 0;
| }
configure:16430: result: no
configure:16430: checking for fchmod
configure:16430: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16430: $? = 0
configure:16430: result: yes
configure:16430: checking for fchown
configure:16430: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16430: $? = 0
configure:16430: result: yes
configure:16430: checking for fcntl
configure:16430: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16430: $? = 0
configure:16430: result: yes
configure:16430: checking for fdopendir
configure:16430: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16430: $? = 0
configure:16430: result: yes
configure:16430: checking for fork
configure:16430: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
conftest.c:130:6: warning: conflicting types for built-in function 'fork' [enabled by default]
 char fork ();
      ^
configure:16430: $? = 0
configure:16430: result: yes
configure:16442: checking for fstat
configure:16442: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16442: $? = 0
configure:16442: result: yes
configure:16442: checking for fstatat
configure:16442: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16442: $? = 0
configure:16442: result: yes
configure:16442: checking for fstatfs
configure:16442: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16442: $? = 0
configure:16442: result: yes
configure:16442: checking for fstatvfs
configure:16442: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16442: $? = 0
configure:16442: result: yes
configure:16442: checking for ftruncate
configure:16442: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16442: $? = 0
configure:16442: result: yes
configure:16454: checking for futimens
configure:16454: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16454: $? = 0
configure:16454: result: yes
configure:16454: checking for futimes
configure:16454: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/ccgZVWR7.o:conftest.c:function main: error: undefined reference to 'futimes'
collect2: error: ld returned 1 exit status
configure:16454: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| /* end confdefs.h.  */
| /* Define futimes to an innocuous variant, in case <limits.h> declares futimes.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define futimes innocuous_futimes
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char futimes (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef futimes
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char futimes ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_futimes || defined __stub___futimes
| choke me
| #endif
| 
| int
| main ()
| {
| return futimes ();
|   ;
|   return 0;
| }
configure:16454: result: no
configure:16454: checking for futimesat
configure:16454: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/cciqDV9y.o:conftest.c:function main: error: undefined reference to 'futimesat'
collect2: error: ld returned 1 exit status
configure:16454: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| /* end confdefs.h.  */
| /* Define futimesat to an innocuous variant, in case <limits.h> declares futimesat.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define futimesat innocuous_futimesat
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char futimesat (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef futimesat
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char futimesat ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_futimesat || defined __stub___futimesat
| choke me
| #endif
| 
| int
| main ()
| {
| return futimesat ();
|   ;
|   return 0;
| }
configure:16454: result: no
configure:16466: checking for geteuid
configure:16466: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16466: $? = 0
configure:16466: result: yes
configure:16466: checking for getpid
configure:16466: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16466: $? = 0
configure:16466: result: yes
configure:16466: checking for getgrgid_r
configure:16466: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/ccqQWt4b.o:conftest.c:function main: error: undefined reference to 'getgrgid_r'
collect2: error: ld returned 1 exit status
configure:16466: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| /* end confdefs.h.  */
| /* Define getgrgid_r to an innocuous variant, in case <limits.h> declares getgrgid_r.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define getgrgid_r innocuous_getgrgid_r
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char getgrgid_r (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef getgrgid_r
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char getgrgid_r ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_getgrgid_r || defined __stub___getgrgid_r
| choke me
| #endif
| 
| int
| main ()
| {
| return getgrgid_r ();
|   ;
|   return 0;
| }
configure:16466: result: no
configure:16466: checking for getgrnam_r
configure:16466: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/cc4bIQee.o:conftest.c:function main: error: undefined reference to 'getgrnam_r'
collect2: error: ld returned 1 exit status
configure:16466: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| /* end confdefs.h.  */
| /* Define getgrnam_r to an innocuous variant, in case <limits.h> declares getgrnam_r.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define getgrnam_r innocuous_getgrnam_r
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char getgrnam_r (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef getgrnam_r
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char getgrnam_r ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_getgrnam_r || defined __stub___getgrnam_r
| choke me
| #endif
| 
| int
| main ()
| {
| return getgrnam_r ();
|   ;
|   return 0;
| }
configure:16466: result: no
configure:16478: checking for getpwnam_r
configure:16478: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16478: $? = 0
configure:16478: result: yes
configure:16478: checking for getpwuid_r
configure:16478: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16478: $? = 0
configure:16478: result: yes
configure:16478: checking for getvfsbyname
configure:16478: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/cc66U2Vm.o:conftest.c:function main: error: undefined reference to 'getvfsbyname'
collect2: error: ld returned 1 exit status
configure:16478: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| /* end confdefs.h.  */
| /* Define getvfsbyname to an innocuous variant, in case <limits.h> declares getvfsbyname.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define getvfsbyname innocuous_getvfsbyname
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char getvfsbyname (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef getvfsbyname
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char getvfsbyname ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_getvfsbyname || defined __stub___getvfsbyname
| choke me
| #endif
| 
| int
| main ()
| {
| return getvfsbyname ();
|   ;
|   return 0;
| }
configure:16478: result: no
configure:16478: checking for gmtime_r
configure:16478: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16478: $? = 0
configure:16478: result: yes
configure:16490: checking for lchflags
configure:16490: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/cc8Ct9IP.o:conftest.c:function main: error: undefined reference to 'lchflags'
collect2: error: ld returned 1 exit status
configure:16490: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| /* end confdefs.h.  */
| /* Define lchflags to an innocuous variant, in case <limits.h> declares lchflags.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define lchflags innocuous_lchflags
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char lchflags (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef lchflags
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char lchflags ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_lchflags || defined __stub___lchflags
| choke me
| #endif
| 
| int
| main ()
| {
| return lchflags ();
|   ;
|   return 0;
| }
configure:16490: result: no
configure:16490: checking for lchmod
configure:16490: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/ccAPBXc4.o:conftest.c:function main: error: undefined reference to 'lchmod'
collect2: error: ld returned 1 exit status
configure:16490: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| /* end confdefs.h.  */
| /* Define lchmod to an innocuous variant, in case <limits.h> declares lchmod.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define lchmod innocuous_lchmod
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char lchmod (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef lchmod
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char lchmod ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_lchmod || defined __stub___lchmod
| choke me
| #endif
| 
| int
| main ()
| {
| return lchmod ();
|   ;
|   return 0;
| }
configure:16490: result: no
configure:16490: checking for lchown
configure:16490: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16490: $? = 0
configure:16490: result: yes
configure:16490: checking for link
configure:16490: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16490: $? = 0
configure:16490: result: yes
configure:16490: checking for localtime_r
configure:16490: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16490: $? = 0
configure:16490: result: yes
configure:16490: checking for lstat
configure:16490: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16490: $? = 0
configure:16490: result: yes
configure:16490: checking for lutimes
configure:16490: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/cceR1FoV.o:conftest.c:function main: error: undefined reference to 'lutimes'
collect2: error: ld returned 1 exit status
configure:16490: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| /* end confdefs.h.  */
| /* Define lutimes to an innocuous variant, in case <limits.h> declares lutimes.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define lutimes innocuous_lutimes
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char lutimes (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef lutimes
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char lutimes ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_lutimes || defined __stub___lutimes
| choke me
| #endif
| 
| int
| main ()
| {
| return lutimes ();
|   ;
|   return 0;
| }
configure:16490: result: no
configure:16502: checking for mbrtowc
configure:16502: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16502: $? = 0
configure:16502: result: yes
configure:16502: checking for memmove
configure:16502: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
conftest.c:147:6: warning: conflicting types for built-in function 'memmove' [enabled by default]
 char memmove ();
      ^
configure:16502: $? = 0
configure:16502: result: yes
configure:16502: checking for memset
configure:16502: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
conftest.c:148:6: warning: conflicting types for built-in function 'memset' [enabled by default]
 char memset ();
      ^
configure:16502: $? = 0
configure:16502: result: yes
configure:16514: checking for mkdir
configure:16514: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16514: $? = 0
configure:16514: result: yes
configure:16514: checking for mkfifo
configure:16514: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16514: $? = 0
configure:16514: result: yes
configure:16514: checking for mknod
configure:16514: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16514: $? = 0
configure:16514: result: yes
configure:16514: checking for mkstemp
configure:16514: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16514: $? = 0
configure:16514: result: yes
configure:16526: checking for nl_langinfo
configure:16526: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/ccGZCk9q.o:conftest.c:function main: error: undefined reference to 'nl_langinfo'
collect2: error: ld returned 1 exit status
configure:16526: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| /* end confdefs.h.  */
| /* Define nl_langinfo to an innocuous variant, in case <limits.h> declares nl_langinfo.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define nl_langinfo innocuous_nl_langinfo
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char nl_langinfo (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef nl_langinfo
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char nl_langinfo ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_nl_langinfo || defined __stub___nl_langinfo
| choke me
| #endif
| 
| int
| main ()
| {
| return nl_langinfo ();
|   ;
|   return 0;
| }
configure:16526: result: no
configure:16526: checking for openat
configure:16526: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16526: $? = 0
configure:16526: result: yes
configure:16526: checking for pipe
configure:16526: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16526: $? = 0
configure:16526: result: yes
configure:16526: checking for poll
configure:16526: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16526: $? = 0
configure:16526: result: yes
configure:16526: checking for posix_spawnp
configure:16526: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/ccyuGICh.o:conftest.c:function main: error: undefined reference to 'posix_spawnp'
collect2: error: ld returned 1 exit status
configure:16526: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| /* end confdefs.h.  */
| /* Define posix_spawnp to an innocuous variant, in case <limits.h> declares posix_spawnp.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define posix_spawnp innocuous_posix_spawnp
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char posix_spawnp (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef posix_spawnp
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char posix_spawnp ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_posix_spawnp || defined __stub___posix_spawnp
| choke me
| #endif
| 
| int
| main ()
| {
| return posix_spawnp ();
|   ;
|   return 0;
| }
configure:16526: result: no
configure:16526: checking for readlink
configure:16526: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16526: $? = 0
configure:16526: result: yes
configure:16526: checking for readlinkat
configure:16526: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16526: $? = 0
configure:16526: result: yes
configure:16538: checking for select
configure:16538: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16538: $? = 0
configure:16538: result: yes
configure:16538: checking for setenv
configure:16538: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16538: $? = 0
configure:16538: result: yes
configure:16538: checking for setlocale
configure:16538: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16538: $? = 0
configure:16538: result: yes
configure:16538: checking for sigaction
configure:16538: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16538: $? = 0
configure:16538: result: yes
configure:16538: checking for statfs
configure:16538: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16538: $? = 0
configure:16538: result: yes
configure:16538: checking for statvfs
configure:16538: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16538: $? = 0
configure:16538: result: yes
configure:16550: checking for strchr
configure:16550: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
conftest.c:164:6: warning: conflicting types for built-in function 'strchr' [enabled by default]
 char strchr ();
      ^
configure:16550: $? = 0
configure:16550: result: yes
configure:16550: checking for strdup
configure:16550: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
conftest.c:165:6: warning: conflicting types for built-in function 'strdup' [enabled by default]
 char strdup ();
      ^
configure:16550: $? = 0
configure:16550: result: yes
configure:16550: checking for strerror
configure:16550: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16550: $? = 0
configure:16550: result: yes
configure:16550: checking for strncpy_s
configure:16550: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/ccOSr2J2.o:conftest.c:function main: error: undefined reference to 'strncpy_s'
collect2: error: ld returned 1 exit status
configure:16550: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| /* end confdefs.h.  */
| /* Define strncpy_s to an innocuous variant, in case <limits.h> declares strncpy_s.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define strncpy_s innocuous_strncpy_s
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char strncpy_s (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef strncpy_s
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char strncpy_s ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_strncpy_s || defined __stub___strncpy_s
| choke me
| #endif
| 
| int
| main ()
| {
| return strncpy_s ();
|   ;
|   return 0;
| }
configure:16550: result: no
configure:16550: checking for strrchr
configure:16550: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
conftest.c:167:6: warning: conflicting types for built-in function 'strrchr' [enabled by default]
 char strrchr ();
      ^
configure:16550: $? = 0
configure:16550: result: yes
configure:16550: checking for symlink
configure:16550: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16550: $? = 0
configure:16550: result: yes
configure:16550: checking for timegm
configure:16550: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16550: $? = 0
configure:16550: result: yes
configure:16562: checking for tzset
configure:16562: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16562: $? = 0
configure:16562: result: yes
configure:16562: checking for unsetenv
configure:16562: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16562: $? = 0
configure:16562: result: yes
configure:16562: checking for utime
configure:16562: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16562: $? = 0
configure:16562: result: yes
configure:16562: checking for utimensat
configure:16562: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16562: $? = 0
configure:16562: result: yes
configure:16562: checking for utimes
configure:16562: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16562: $? = 0
configure:16562: result: yes
configure:16562: checking for vfork
configure:16562: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16562: $? = 0
configure:16562: result: yes
configure:16574: checking for wcrtomb
configure:16574: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16574: $? = 0
configure:16574: result: yes
configure:16574: checking for wcscmp
configure:16574: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16574: $? = 0
configure:16574: result: yes
configure:16574: checking for wcscpy
configure:16574: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16574: $? = 0
configure:16574: result: yes
configure:16574: checking for wcslen
configure:16574: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16574: $? = 0
configure:16574: result: yes
configure:16574: checking for wctomb
configure:16574: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16574: $? = 0
configure:16574: result: yes
configure:16574: checking for wmemcmp
configure:16574: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16574: $? = 0
configure:16574: result: yes
configure:16574: checking for wmemcpy
configure:16574: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16574: $? = 0
configure:16574: result: yes
configure:16586: checking for _ctime64_s
configure:16586: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/ccqcp9nf.o:conftest.c:function main: error: undefined reference to '_ctime64_s'
collect2: error: ld returned 1 exit status
configure:16586: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| /* end confdefs.h.  */
| /* Define _ctime64_s to an innocuous variant, in case <limits.h> declares _ctime64_s.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define _ctime64_s innocuous__ctime64_s
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char _ctime64_s (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef _ctime64_s
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char _ctime64_s ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub__ctime64_s || defined __stub____ctime64_s
| choke me
| #endif
| 
| int
| main ()
| {
| return _ctime64_s ();
|   ;
|   return 0;
| }
configure:16586: result: no
configure:16586: checking for _fseeki64
configure:16586: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/ccMvcrZr.o:conftest.c:function main: error: undefined reference to '_fseeki64'
collect2: error: ld returned 1 exit status
configure:16586: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| /* end confdefs.h.  */
| /* Define _fseeki64 to an innocuous variant, in case <limits.h> declares _fseeki64.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define _fseeki64 innocuous__fseeki64
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char _fseeki64 (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef _fseeki64
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char _fseeki64 ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub__fseeki64 || defined __stub____fseeki64
| choke me
| #endif
| 
| int
| main ()
| {
| return _fseeki64 ();
|   ;
|   return 0;
| }
configure:16586: result: no
configure:16598: checking for _get_timezone
configure:16598: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/ccou1Kbe.o:conftest.c:function main: error: undefined reference to '_get_timezone'
collect2: error: ld returned 1 exit status
configure:16598: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| /* end confdefs.h.  */
| /* Define _get_timezone to an innocuous variant, in case <limits.h> declares _get_timezone.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define _get_timezone innocuous__get_timezone
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char _get_timezone (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef _get_timezone
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char _get_timezone ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub__get_timezone || defined __stub____get_timezone
| choke me
| #endif
| 
| int
| main ()
| {
| return _get_timezone ();
|   ;
|   return 0;
| }
configure:16598: result: no
configure:16598: checking for _localtime64_s
configure:16598: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/ccQO74Ml.o:conftest.c:function main: error: undefined reference to '_localtime64_s'
collect2: error: ld returned 1 exit status
configure:16598: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| /* end confdefs.h.  */
| /* Define _localtime64_s to an innocuous variant, in case <limits.h> declares _localtime64_s.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define _localtime64_s innocuous__localtime64_s
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char _localtime64_s (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef _localtime64_s
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char _localtime64_s ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub__localtime64_s || defined __stub____localtime64_s
| choke me
| #endif
| 
| int
| main ()
| {
| return _localtime64_s ();
|   ;
|   return 0;
| }
configure:16598: result: no
configure:16598: checking for _mkgmtime64
configure:16598: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/ccYemzJx.o:conftest.c:function main: error: undefined reference to '_mkgmtime64'
collect2: error: ld returned 1 exit status
configure:16598: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| /* end confdefs.h.  */
| /* Define _mkgmtime64 to an innocuous variant, in case <limits.h> declares _mkgmtime64.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define _mkgmtime64 innocuous__mkgmtime64
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char _mkgmtime64 (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef _mkgmtime64
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char _mkgmtime64 ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub__mkgmtime64 || defined __stub____mkgmtime64
| choke me
| #endif
| 
| int
| main ()
| {
| return _mkgmtime64 ();
|   ;
|   return 0;
| }
configure:16598: result: no
configure:16610: checking for cygwin_conv_path
configure:16610: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/ccEKExXF.o:conftest.c:function main: error: undefined reference to 'cygwin_conv_path'
collect2: error: ld returned 1 exit status
configure:16610: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| /* end confdefs.h.  */
| /* Define cygwin_conv_path to an innocuous variant, in case <limits.h> declares cygwin_conv_path.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define cygwin_conv_path innocuous_cygwin_conv_path
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char cygwin_conv_path (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef cygwin_conv_path
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char cygwin_conv_path ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_cygwin_conv_path || defined __stub___cygwin_conv_path
| choke me
| #endif
| 
| int
| main ()
| {
| return cygwin_conv_path ();
|   ;
|   return 0;
| }
configure:16610: result: no
configure:16634: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:16634: $? = 0
configure:16645: checking whether D_MD_ORDER is declared
configure:16645: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:173:10: error: 'D_MD_ORDER' undeclared (first use in this function)
   (void) D_MD_ORDER;
          ^
conftest.c:173:10: note: each undeclared identifier is reported only once for each function it appears in
configure:16645: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| /* end confdefs.h.  */
| #if HAVE_LANGINFO_H
| #include <langinfo.h>
| #endif
| 
| 
| int
| main ()
| {
| #ifndef D_MD_ORDER
| #ifdef __cplusplus
|   (void) D_MD_ORDER;
| #else
|   (void) D_MD_ORDER;
| #endif
| #endif
| 
|   ;
|   return 0;
| }
configure:16645: result: no
configure:16660: checking for struct dirent.d_namlen
configure:16660: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:170:12: error: 'struct dirent' has no member named 'd_namlen'
 if (ac_aggr.d_namlen)
            ^
configure:16660: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| /* end confdefs.h.  */
| #if HAVE_DIRENT_H
| #include <dirent.h>
| #endif
| 
| 
| int
| main ()
| {
| static struct dirent ac_aggr;
| if (ac_aggr.d_namlen)
| return 0;
|   ;
|   return 0;
| }
configure:16660: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:170:19: error: 'struct dirent' has no member named 'd_namlen'
 if (sizeof ac_aggr.d_namlen)
                   ^
configure:16660: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| /* end confdefs.h.  */
| #if HAVE_DIRENT_H
| #include <dirent.h>
| #endif
| 
| 
| int
| main ()
| {
| static struct dirent ac_aggr;
| if (sizeof ac_aggr.d_namlen)
| return 0;
|   ;
|   return 0;
| }
configure:16660: result: no
configure:16680: checking for attr/xattr.h
configure:16680: result: no
configure:16693: checking sys/xattr.h usability
configure:16693: arm-linux-androideabi-gcc -c    conftest.c >&5
configure:16693: $? = 0
configure:16693: result: yes
configure:16693: checking sys/xattr.h presence
configure:16693: arm-linux-androideabi-gcc -E  conftest.c
configure:16693: $? = 0
configure:16693: result: yes
configure:16693: checking for sys/xattr.h
configure:16693: result: yes
configure:16693: checking sys/ea.h usability
configure:16693: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:195:20: fatal error: sys/ea.h: No such file or directory
 #include <sys/ea.h>
                    ^
compilation terminated.
configure:16693: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <sys/ea.h>
configure:16693: result: no
configure:16693: checking sys/ea.h presence
configure:16693: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:162:20: fatal error: sys/ea.h: No such file or directory
 #include <sys/ea.h>
                    ^
compilation terminated.
configure:16693: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| /* end confdefs.h.  */
| #include <sys/ea.h>
configure:16693: result: no
configure:16693: checking for sys/ea.h
configure:16693: result: no
configure:16703: checking for setxattr in -lattr
configure:16728: arm-linux-androideabi-gcc -o conftest     conftest.c -lattr  -lz  >&5
/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld: error: cannot find -lattr
collect2: error: ld returned 1 exit status
configure:16728: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| /* end confdefs.h.  */
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char setxattr ();
| int
| main ()
| {
| return setxattr ();
|   ;
|   return 0;
| }
configure:16737: result: no
configure:16751: checking for extattr_get_file
configure:16751: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/ccUVwCLT.o:conftest.c:function main: error: undefined reference to 'extattr_get_file'
collect2: error: ld returned 1 exit status
configure:16751: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| /* end confdefs.h.  */
| /* Define extattr_get_file to an innocuous variant, in case <limits.h> declares extattr_get_file.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define extattr_get_file innocuous_extattr_get_file
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char extattr_get_file (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef extattr_get_file
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char extattr_get_file ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_extattr_get_file || defined __stub___extattr_get_file
| choke me
| #endif
| 
| int
| main ()
| {
| return extattr_get_file ();
|   ;
|   return 0;
| }
configure:16751: result: no
configure:16751: checking for extattr_list_file
configure:16751: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/cccnvLc3.o:conftest.c:function main: error: undefined reference to 'extattr_list_file'
collect2: error: ld returned 1 exit status
configure:16751: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| /* end confdefs.h.  */
| /* Define extattr_list_file to an innocuous variant, in case <limits.h> declares extattr_list_file.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define extattr_list_file innocuous_extattr_list_file
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char extattr_list_file (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef extattr_list_file
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char extattr_list_file ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_extattr_list_file || defined __stub___extattr_list_file
| choke me
| #endif
| 
| int
| main ()
| {
| return extattr_list_file ();
|   ;
|   return 0;
| }
configure:16751: result: no
configure:16763: checking for extattr_set_fd
configure:16763: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/ccqmWz8e.o:conftest.c:function main: error: undefined reference to 'extattr_set_fd'
collect2: error: ld returned 1 exit status
configure:16763: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| /* end confdefs.h.  */
| /* Define extattr_set_fd to an innocuous variant, in case <limits.h> declares extattr_set_fd.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define extattr_set_fd innocuous_extattr_set_fd
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char extattr_set_fd (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef extattr_set_fd
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char extattr_set_fd ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_extattr_set_fd || defined __stub___extattr_set_fd
| choke me
| #endif
| 
| int
| main ()
| {
| return extattr_set_fd ();
|   ;
|   return 0;
| }
configure:16763: result: no
configure:16763: checking for extattr_set_file
configure:16763: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/ccext0zl.o:conftest.c:function main: error: undefined reference to 'extattr_set_file'
collect2: error: ld returned 1 exit status
configure:16763: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| /* end confdefs.h.  */
| /* Define extattr_set_file to an innocuous variant, in case <limits.h> declares extattr_set_file.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define extattr_set_file innocuous_extattr_set_file
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char extattr_set_file (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef extattr_set_file
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char extattr_set_file ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_extattr_set_file || defined __stub___extattr_set_file
| choke me
| #endif
| 
| int
| main ()
| {
| return extattr_set_file ();
|   ;
|   return 0;
| }
configure:16763: result: no
configure:16775: checking for fgetxattr
configure:16775: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16775: $? = 0
configure:16775: result: yes
configure:16775: checking for flistxattr
configure:16775: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16775: $? = 0
configure:16775: result: yes
configure:16775: checking for fsetxattr
configure:16775: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16775: $? = 0
configure:16775: result: yes
configure:16775: checking for getxattr
configure:16775: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16775: $? = 0
configure:16775: result: yes
configure:16787: checking for lgetxattr
configure:16787: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16787: $? = 0
configure:16787: result: yes
configure:16787: checking for listxattr
configure:16787: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16787: $? = 0
configure:16787: result: yes
configure:16787: checking for llistxattr
configure:16787: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16787: $? = 0
configure:16787: result: yes
configure:16787: checking for lsetxattr
configure:16787: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
configure:16787: $? = 0
configure:16787: result: yes
configure:16799: checking for fgetea
configure:16799: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/ccWLe6Yh.o:conftest.c:function main: error: undefined reference to 'fgetea'
collect2: error: ld returned 1 exit status
configure:16799: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| /* end confdefs.h.  */
| /* Define fgetea to an innocuous variant, in case <limits.h> declares fgetea.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define fgetea innocuous_fgetea
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char fgetea (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef fgetea
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char fgetea ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_fgetea || defined __stub___fgetea
| choke me
| #endif
| 
| int
| main ()
| {
| return fgetea ();
|   ;
|   return 0;
| }
configure:16799: result: no
configure:16799: checking for flistea
configure:16799: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/cce87OTW.o:conftest.c:function main: error: undefined reference to 'flistea'
collect2: error: ld returned 1 exit status
configure:16799: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| /* end confdefs.h.  */
| /* Define flistea to an innocuous variant, in case <limits.h> declares flistea.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define flistea innocuous_flistea
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char flistea (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef flistea
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char flistea ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_flistea || defined __stub___flistea
| choke me
| #endif
| 
| int
| main ()
| {
| return flistea ();
|   ;
|   return 0;
| }
configure:16799: result: no
configure:16799: checking for fsetea
configure:16799: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/ccymPv5h.o:conftest.c:function main: error: undefined reference to 'fsetea'
collect2: error: ld returned 1 exit status
configure:16799: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| /* end confdefs.h.  */
| /* Define fsetea to an innocuous variant, in case <limits.h> declares fsetea.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define fsetea innocuous_fsetea
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char fsetea (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef fsetea
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char fsetea ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_fsetea || defined __stub___fsetea
| choke me
| #endif
| 
| int
| main ()
| {
| return fsetea ();
|   ;
|   return 0;
| }
configure:16799: result: no
configure:16799: checking for getea
configure:16799: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/cccFZcXx.o:conftest.c:function main: error: undefined reference to 'getea'
collect2: error: ld returned 1 exit status
configure:16799: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| /* end confdefs.h.  */
| /* Define getea to an innocuous variant, in case <limits.h> declares getea.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define getea innocuous_getea
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char getea (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef getea
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char getea ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_getea || defined __stub___getea
| choke me
| #endif
| 
| int
| main ()
| {
| return getea ();
|   ;
|   return 0;
| }
configure:16799: result: no
configure:16811: checking for lgetea
configure:16811: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/ccG8tOQW.o:conftest.c:function main: error: undefined reference to 'lgetea'
collect2: error: ld returned 1 exit status
configure:16811: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| /* end confdefs.h.  */
| /* Define lgetea to an innocuous variant, in case <limits.h> declares lgetea.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define lgetea innocuous_lgetea
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char lgetea (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef lgetea
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char lgetea ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_lgetea || defined __stub___lgetea
| choke me
| #endif
| 
| int
| main ()
| {
| return lgetea ();
|   ;
|   return 0;
| }
configure:16811: result: no
configure:16811: checking for listea
configure:16811: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/cc047t2e.o:conftest.c:function main: error: undefined reference to 'listea'
collect2: error: ld returned 1 exit status
configure:16811: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| /* end confdefs.h.  */
| /* Define listea to an innocuous variant, in case <limits.h> declares listea.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define listea innocuous_listea
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char listea (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef listea
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char listea ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_listea || defined __stub___listea
| choke me
| #endif
| 
| int
| main ()
| {
| return listea ();
|   ;
|   return 0;
| }
configure:16811: result: no
configure:16811: checking for llistea
configure:16811: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/cc8QpZFr.o:conftest.c:function main: error: undefined reference to 'llistea'
collect2: error: ld returned 1 exit status
configure:16811: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| /* end confdefs.h.  */
| /* Define llistea to an innocuous variant, in case <limits.h> declares llistea.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define llistea innocuous_llistea
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char llistea (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef llistea
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char llistea ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_llistea || defined __stub___llistea
| choke me
| #endif
| 
| int
| main ()
| {
| return llistea ();
|   ;
|   return 0;
| }
configure:16811: result: no
configure:16811: checking for lsetea
configure:16811: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/ccKNSmYp.o:conftest.c:function main: error: undefined reference to 'lsetea'
collect2: error: ld returned 1 exit status
configure:16811: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| /* end confdefs.h.  */
| /* Define lsetea to an innocuous variant, in case <limits.h> declares lsetea.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define lsetea innocuous_lsetea
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char lsetea (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef lsetea
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char lsetea ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_lsetea || defined __stub___lsetea
| choke me
| #endif
| 
| int
| main ()
| {
| return lsetea ();
|   ;
|   return 0;
| }
configure:16811: result: no
configure:16820: checking whether EXTATTR_NAMESPACE_USER is declared
configure:16820: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:171:25: fatal error: sys/extattr.h: No such file or directory
 #include <sys/extattr.h>
                         ^
compilation terminated.
configure:16820: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| /* end confdefs.h.  */
| #include <sys/types.h>
| #include <sys/extattr.h>
| 
| 
| int
| main ()
| {
| #ifndef EXTATTR_NAMESPACE_USER
| #ifdef __cplusplus
|   (void) EXTATTR_NAMESPACE_USER;
| #else
|   (void) EXTATTR_NAMESPACE_USER;
| #endif
| #endif
| 
|   ;
|   return 0;
| }
configure:16820: result: no
configure:16852: checking for sys/acl.h
configure:16852: result: no
configure:16862: checking for acl_get_file in -lacl
configure:16887: arm-linux-androideabi-gcc -o conftest     conftest.c -lacl  -lz  >&5
/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld: error: cannot find -lacl
/tmp/ccQpGHYw.o:conftest.c:function main: error: undefined reference to 'acl_get_file'
collect2: error: ld returned 1 exit status
configure:16887: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char acl_get_file ();
| int
| main ()
| {
| return acl_get_file ();
|   ;
|   return 0;
| }
configure:16896: result: no
configure:16910: checking for acl_create_entry
configure:16910: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/ccygjmHF.o:conftest.c:function main: error: undefined reference to 'acl_create_entry'
collect2: error: ld returned 1 exit status
configure:16910: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| /* Define acl_create_entry to an innocuous variant, in case <limits.h> declares acl_create_entry.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define acl_create_entry innocuous_acl_create_entry
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char acl_create_entry (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef acl_create_entry
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char acl_create_entry ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_acl_create_entry || defined __stub___acl_create_entry
| choke me
| #endif
| 
| int
| main ()
| {
| return acl_create_entry ();
|   ;
|   return 0;
| }
configure:16910: result: no
configure:16910: checking for acl_init
configure:16910: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/ccUsva1M.o:conftest.c:function main: error: undefined reference to 'acl_init'
collect2: error: ld returned 1 exit status
configure:16910: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| /* Define acl_init to an innocuous variant, in case <limits.h> declares acl_init.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define acl_init innocuous_acl_init
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char acl_init (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef acl_init
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char acl_init ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_acl_init || defined __stub___acl_init
| choke me
| #endif
| 
| int
| main ()
| {
| return acl_init ();
|   ;
|   return 0;
| }
configure:16910: result: no
configure:16910: checking for acl_set_fd
configure:16910: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/cc0NR5Qj.o:conftest.c:function main: error: undefined reference to 'acl_set_fd'
collect2: error: ld returned 1 exit status
configure:16910: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| /* Define acl_set_fd to an innocuous variant, in case <limits.h> declares acl_set_fd.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define acl_set_fd innocuous_acl_set_fd
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char acl_set_fd (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef acl_set_fd
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char acl_set_fd ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_acl_set_fd || defined __stub___acl_set_fd
| choke me
| #endif
| 
| int
| main ()
| {
| return acl_set_fd ();
|   ;
|   return 0;
| }
configure:16910: result: no
configure:16910: checking for acl_set_fd_np
configure:16910: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/cc6F3cnq.o:conftest.c:function main: error: undefined reference to 'acl_set_fd_np'
collect2: error: ld returned 1 exit status
configure:16910: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| /* Define acl_set_fd_np to an innocuous variant, in case <limits.h> declares acl_set_fd_np.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define acl_set_fd_np innocuous_acl_set_fd_np
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char acl_set_fd_np (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef acl_set_fd_np
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char acl_set_fd_np ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_acl_set_fd_np || defined __stub___acl_set_fd_np
| choke me
| #endif
| 
| int
| main ()
| {
| return acl_set_fd_np ();
|   ;
|   return 0;
| }
configure:16910: result: no
configure:16910: checking for acl_set_file
configure:16910: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/cccNmRTV.o:conftest.c:function main: error: undefined reference to 'acl_set_file'
collect2: error: ld returned 1 exit status
configure:16910: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| /* Define acl_set_file to an innocuous variant, in case <limits.h> declares acl_set_file.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define acl_set_file innocuous_acl_set_file
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char acl_set_file (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef acl_set_file
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char acl_set_file ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_acl_set_file || defined __stub___acl_set_file
| choke me
| #endif
| 
| int
| main ()
| {
| return acl_set_file ();
|   ;
|   return 0;
| }
configure:16910: result: no
configure:16920: checking for acl_permset_t
configure:16920: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c: In function 'main':
conftest.c:182:13: error: 'acl_permset_t' undeclared (first use in this function)
 if (sizeof (acl_permset_t))
             ^
conftest.c:182:13: note: each undeclared identifier is reported only once for each function it appears in
configure:16920: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| #if HAVE_SYS_TYPES_H
| 	#include <sys/types.h>
| 	#endif
| 	#if HAVE_SYS_ACL_H
| 	#include <sys/acl.h>
| 	#endif
| 
| 
| int
| main ()
| {
| if (sizeof (acl_permset_t))
| 	 return 0;
|   ;
|   return 0;
| }
configure:16920: result: no
configure:16946: checking for acl_get_perm_np
configure:16946: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/ccs7ShxC.o:conftest.c:function main: error: undefined reference to 'acl_get_perm_np'
collect2: error: ld returned 1 exit status
configure:16946: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| /* Define acl_get_perm_np to an innocuous variant, in case <limits.h> declares acl_get_perm_np.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define acl_get_perm_np innocuous_acl_get_perm_np
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char acl_get_perm_np (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef acl_get_perm_np
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char acl_get_perm_np ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_acl_get_perm_np || defined __stub___acl_get_perm_np
| choke me
| #endif
| 
| int
| main ()
| {
| return acl_get_perm_np ();
|   ;
|   return 0;
| }
configure:16946: result: no
configure:16946: checking for acl_get_perm
configure:16946: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/ccOwTL5O.o:conftest.c:function main: error: undefined reference to 'acl_get_perm'
collect2: error: ld returned 1 exit status
configure:16946: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| /* Define acl_get_perm to an innocuous variant, in case <limits.h> declares acl_get_perm.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define acl_get_perm innocuous_acl_get_perm
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char acl_get_perm (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef acl_get_perm
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char acl_get_perm ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_acl_get_perm || defined __stub___acl_get_perm
| choke me
| #endif
| 
| int
| main ()
| {
| return acl_get_perm ();
|   ;
|   return 0;
| }
configure:16946: result: no
configure:16946: checking for acl_get_link
configure:16946: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/cc2dFSda.o:conftest.c:function main: error: undefined reference to 'acl_get_link'
collect2: error: ld returned 1 exit status
configure:16946: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| /* Define acl_get_link to an innocuous variant, in case <limits.h> declares acl_get_link.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define acl_get_link innocuous_acl_get_link
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char acl_get_link (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef acl_get_link
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char acl_get_link ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_acl_get_link || defined __stub___acl_get_link
| choke me
| #endif
| 
| int
| main ()
| {
| return acl_get_link ();
|   ;
|   return 0;
| }
configure:16946: result: no
configure:16946: checking for acl_get_link_np
configure:16946: arm-linux-androideabi-gcc -o conftest     conftest.c -lz  >&5
/tmp/ccOJAzld.o:conftest.c:function main: error: undefined reference to 'acl_get_link_np'
collect2: error: ld returned 1 exit status
configure:16946: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| /* Define acl_get_link_np to an innocuous variant, in case <limits.h> declares acl_get_link_np.
|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
| #define acl_get_link_np innocuous_acl_get_link_np
| 
| /* System header to define __stub macros and hopefully few prototypes,
|     which can conflict with char acl_get_link_np (); below.
|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
|     <limits.h> exists even on freestanding compilers.  */
| 
| #ifdef __STDC__
| # include <limits.h>
| #else
| # include <assert.h>
| #endif
| 
| #undef acl_get_link_np
| 
| /* Override any GCC internal prototype to avoid an error.
|    Use char because int might match the return type of a GCC
|    builtin and then its argument prototype would still apply.  */
| #ifdef __cplusplus
| extern "C"
| #endif
| char acl_get_link_np ();
| /* The GNU C library defines this for functions which it implements
|     to always fail with ENOSYS.  Some functions are actually named
|     something starting with __ and the normal name is an alias.  */
| #if defined __stub_acl_get_link_np || defined __stub___acl_get_link_np
| choke me
| #endif
| 
| int
| main ()
| {
| return acl_get_link_np ();
|   ;
|   return 0;
| }
configure:16946: result: no
configure:16958: checking whether ACL_USER is declared
configure:16958: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:171:21: fatal error: sys/acl.h: No such file or directory
 #include <sys/acl.h>
                     ^
compilation terminated.
configure:16958: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| #include <sys/acl.h>
| 
| int
| main ()
| {
| #ifndef ACL_USER
| #ifdef __cplusplus
|   (void) ACL_USER;
| #else
|   (void) ACL_USER;
| #endif
| #endif
| 
|   ;
|   return 0;
| }
configure:16958: result: no
configure:16976: checking for special C compiler options needed for large files
configure:17021: result: no
configure:17027: checking for _FILE_OFFSET_BITS value needed for large files
configure:17052: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:177:3: warning: left shift count >= width of type [enabled by default]
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
   ^
conftest.c:177:3: warning: left shift count >= width of type [enabled by default]
conftest.c:178:10: warning: left shift count >= width of type [enabled by default]
          && LARGE_OFF_T % 2147483647 == 1)
          ^
conftest.c:178:10: warning: left shift count >= width of type [enabled by default]
conftest.c:177:7: error: variably modified 'off_t_is_large' at file scope
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
       ^
configure:17052: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| #include <sys/types.h>
|  /* Check that off_t can represent 2**63 - 1 correctly.
|     We can't simply define LARGE_OFF_T to be 9223372036854775807,
|     since some C++ compilers masquerading as C compilers
|     incorrectly reject 9223372036854775807.  */
| #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
|   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
| 		       && LARGE_OFF_T % 2147483647 == 1)
| 		      ? 1 : -1];
| int
| main ()
| {
| 
|   ;
|   return 0;
| }
configure:17076: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:178:3: warning: left shift count >= width of type [enabled by default]
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
   ^
conftest.c:178:3: warning: left shift count >= width of type [enabled by default]
conftest.c:179:10: warning: left shift count >= width of type [enabled by default]
          && LARGE_OFF_T % 2147483647 == 1)
          ^
conftest.c:179:10: warning: left shift count >= width of type [enabled by default]
conftest.c:178:7: error: variably modified 'off_t_is_large' at file scope
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
       ^
configure:17076: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| #define _FILE_OFFSET_BITS 64
| #include <sys/types.h>
|  /* Check that off_t can represent 2**63 - 1 correctly.
|     We can't simply define LARGE_OFF_T to be 9223372036854775807,
|     since some C++ compilers masquerading as C compilers
|     incorrectly reject 9223372036854775807.  */
| #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
|   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
| 		       && LARGE_OFF_T % 2147483647 == 1)
| 		      ? 1 : -1];
| int
| main ()
| {
| 
|   ;
|   return 0;
| }
configure:17084: result: unknown
configure:17096: checking for _LARGE_FILES value needed for large files
configure:17121: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:177:3: warning: left shift count >= width of type [enabled by default]
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
   ^
conftest.c:177:3: warning: left shift count >= width of type [enabled by default]
conftest.c:178:10: warning: left shift count >= width of type [enabled by default]
          && LARGE_OFF_T % 2147483647 == 1)
          ^
conftest.c:178:10: warning: left shift count >= width of type [enabled by default]
conftest.c:177:7: error: variably modified 'off_t_is_large' at file scope
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
       ^
configure:17121: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| #include <sys/types.h>
|  /* Check that off_t can represent 2**63 - 1 correctly.
|     We can't simply define LARGE_OFF_T to be 9223372036854775807,
|     since some C++ compilers masquerading as C compilers
|     incorrectly reject 9223372036854775807.  */
| #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
|   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
| 		       && LARGE_OFF_T % 2147483647 == 1)
| 		      ? 1 : -1];
| int
| main ()
| {
| 
|   ;
|   return 0;
| }
configure:17145: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:178:3: warning: left shift count >= width of type [enabled by default]
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
   ^
conftest.c:178:3: warning: left shift count >= width of type [enabled by default]
conftest.c:179:10: warning: left shift count >= width of type [enabled by default]
          && LARGE_OFF_T % 2147483647 == 1)
          ^
conftest.c:179:10: warning: left shift count >= width of type [enabled by default]
conftest.c:178:7: error: variably modified 'off_t_is_large' at file scope
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
       ^
configure:17145: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| #define _LARGE_FILES 1
| #include <sys/types.h>
|  /* Check that off_t can represent 2**63 - 1 correctly.
|     We can't simply define LARGE_OFF_T to be 9223372036854775807,
|     since some C++ compilers masquerading as C compilers
|     incorrectly reject 9223372036854775807.  */
| #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
|   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
| 		       && LARGE_OFF_T % 2147483647 == 1)
| 		      ? 1 : -1];
| int
| main ()
| {
| 
|   ;
|   return 0;
| }
configure:17153: result: unknown
configure:17183: checking support for ARCHIVE_CRYPTO_MD5_LIBC
configure:17205: arm-linux-androideabi-gcc -o conftest    -I. -I. -I./libarchive  conftest.c -lz  >&5
In file included from conftest.c:206:0:
./libarchive/archive_crypto_private.h:61:17: fatal error: md5.h: No such file or directory
 #include <md5.h>
                 ^
compilation terminated.
configure:17205: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| #define ARCHIVE_MD5_COMPILE_TEST
| #define ARCHIVE_CRYPTO_MD5_LIBC
| #define PLATFORM_CONFIG_H "check_crypto_md.h"
| 
| /*-
| * Copyright (c) 2003-2007 Tim Kientzle
| * Copyright (c) 2011 Andres Mejia
| * Copyright (c) 2011 Michihiro NAKAJIMA
| * All rights reserved.
| *
| * Redistribution and use in source and binary forms, with or without
| * modification, are permitted provided that the following conditions
| * are met:
| * 1. Redistributions of source code must retain the above copyright
| *    notice, this list of conditions and the following disclaimer.
| * 2. Redistributions in binary form must reproduce the above copyright
| *    notice, this list of conditions and the following disclaimer in the
| *    documentation and/or other materials provided with the distribution.
| *
| * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
| * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
| * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
| * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
| * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
| * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
| * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
| * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
| * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
| * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
| */
| 
| #include "archive_platform.h"
| 
| #include "archive.h"
| #include "archive_crypto_private.h"
| 
| /* In particular, force the configure probe to break if it tries
|  * to test a combination of OpenSSL and libmd. */
| #if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
| #error Cannot use both OpenSSL and libmd.
| #endif
| 
| /*
|  * Message digest functions for Windows platform.
|  */
| #if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
| 	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
| 	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| /*
|  * Initialize a Message digest.
|  */
| static int
| win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
| {
| 
| 	ctx->valid = 0;
| 	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
| 		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
| 			return (ARCHIVE_FAILED);
| 		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
| 			return (ARCHIVE_FAILED);
| 	}
| 
| 	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
| 		CryptReleaseContext(ctx->cryptProv, 0);
| 		return (ARCHIVE_FAILED);
| 	}
| 
| 	ctx->valid = 1;
| 	return (ARCHIVE_OK);
| }
| 
| /*
|  * Update a Message digest.
|  */
| static int
| win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
| {
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptHashData(ctx->hash,
| 		      (unsigned char *)(uintptr_t)buf,
| 		      (DWORD)len, 0);
| 	return (ARCHIVE_OK);
| }
| 
| static int
| win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
| {
| 	DWORD siglen = (DWORD)bufsize;
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
| 	CryptDestroyHash(ctx->hash);
| 	CryptReleaseContext(ctx->cryptProv, 0);
| 	ctx->valid = 0;
| 	return (ARCHIVE_OK);
| }
| 
| #endif /* defined(ARCHIVE_CRYPTO_*_WIN) */
| 
| 
| /* MD5 implementations */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
| 
| static int
| __archive_libc_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
| 
| static int
| __archive_libmd_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
| 
| static int
| __archive_libsystem_md5init(archive_md5_ctx *ctx)
| {
|   CC_MD5_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_MD5_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
| {
|   CC_MD5_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
| 
| static int
| __archive_nettle_md5init(archive_md5_ctx *ctx)
| {
|   md5_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   md5_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
| {
|   md5_digest(ctx, MD5_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
| 
| static int
| __archive_openssl_md5init(archive_md5_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_md5());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
| 
| static int
| __archive_windowsapi_md5init(archive_md5_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_MD5));
| }
| 
| static int
| __archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 16, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_md5init(archive_md5_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5final(archive_md5_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* RIPEMD160 implementations */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
| 
| static int
| __archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RMD160Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RMD160Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RMD160Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
| 
| static int
| __archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RIPEMD160_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RIPEMD160_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RIPEMD160_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
| 
| static int
| __archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   ripemd160_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   ripemd160_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
| 
| static int
| __archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_ripemd160());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #else
| 
| static int
| __archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA1 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
| 
| static int
| __archive_libc_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
| 
| static int
| __archive_libmd_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha1init(archive_sha1_ctx *ctx)
| {
|   CC_SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   CC_SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
| 
| static int
| __archive_nettle_sha1init(archive_sha1_ctx *ctx)
| {
|   sha1_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha1_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
| 
| static int
| __archive_openssl_sha1init(archive_sha1_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha1());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
| 
| static int
| __archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA1));
| }
| 
| static int
| __archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 20, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha1init(archive_sha1_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA256 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
| 
| static int
| __archive_libc_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
| 
| static int
| __archive_libc2_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
| 
| static int
| __archive_libc3_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
| 
| static int
| __archive_libmd_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha256init(archive_sha256_ctx *ctx)
| {
|   CC_SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   CC_SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
| 
| static int
| __archive_nettle_sha256init(archive_sha256_ctx *ctx)
| {
|   sha256_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha256_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
| 
| static int
| __archive_openssl_sha256init(archive_sha256_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha256());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
| 
| static int
| __archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_256));
| }
| 
| static int
| __archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 32, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha256init(archive_sha256_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA384 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
| 
| static int
| __archive_libc_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
| 
| static int
| __archive_libc2_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
| 
| static int
| __archive_libc3_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha384init(archive_sha384_ctx *ctx)
| {
|   CC_SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   CC_SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
| 
| static int
| __archive_nettle_sha384init(archive_sha384_ctx *ctx)
| {
|   sha384_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha384_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
| 
| static int
| __archive_openssl_sha384init(archive_sha384_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha384());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
| 
| static int
| __archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_384));
| }
| 
| static int
| __archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 48, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha384init(archive_sha384_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA512 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
| 
| static int
| __archive_libc_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
| 
| static int
| __archive_libc2_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
| 
| static int
| __archive_libc3_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
| 
| static int
| __archive_libmd_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha512init(archive_sha512_ctx *ctx)
| {
|   CC_SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   CC_SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
| 
| static int
| __archive_nettle_sha512init(archive_sha512_ctx *ctx)
| {
|   sha512_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha512_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
| 
| static int
| __archive_openssl_sha512init(archive_sha512_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha512());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| static int
| __archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_512));
| }
| 
| static int
| __archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 64, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha512init(archive_sha512_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* NOTE: Crypto functions are set based on availability and by the following
|  * order of preference.
|  * 1. libc
|  * 2. libc2
|  * 3. libc3
|  * 4. libSystem
|  * 5. Nettle
|  * 6. OpenSSL
|  * 7. libmd
|  * 8. Windows API
|  */
| const struct archive_crypto __archive_crypto =
| {
| /* MD5 */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
|   &__archive_libc_md5init,
|   &__archive_libc_md5update,
|   &__archive_libc_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
|   &__archive_libmd_md5init,
|   &__archive_libmd_md5update,
|   &__archive_libmd_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
|   &__archive_libsystem_md5init,
|   &__archive_libsystem_md5update,
|   &__archive_libsystem_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
|   &__archive_nettle_md5init,
|   &__archive_nettle_md5update,
|   &__archive_nettle_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
|   &__archive_openssl_md5init,
|   &__archive_openssl_md5update,
|   &__archive_openssl_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
|   &__archive_windowsapi_md5init,
|   &__archive_windowsapi_md5update,
|   &__archive_windowsapi_md5final,
| #elif !defined(ARCHIVE_MD5_COMPILE_TEST)
|   &__archive_stub_md5init,
|   &__archive_stub_md5update,
|   &__archive_stub_md5final,
| #endif
| 
| /* RIPEMD160 */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
|   &__archive_libc_ripemd160init,
|   &__archive_libc_ripemd160update,
|   &__archive_libc_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
|   &__archive_libmd_ripemd160init,
|   &__archive_libmd_ripemd160update,
|   &__archive_libmd_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
|   &__archive_nettle_ripemd160init,
|   &__archive_nettle_ripemd160update,
|   &__archive_nettle_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
|   &__archive_openssl_ripemd160init,
|   &__archive_openssl_ripemd160update,
|   &__archive_openssl_ripemd160final,
| #elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
|   &__archive_stub_ripemd160init,
|   &__archive_stub_ripemd160update,
|   &__archive_stub_ripemd160final,
| #endif
| 
| /* SHA1 */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
|   &__archive_libc_sha1init,
|   &__archive_libc_sha1update,
|   &__archive_libc_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
|   &__archive_libmd_sha1init,
|   &__archive_libmd_sha1update,
|   &__archive_libmd_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
|   &__archive_libsystem_sha1init,
|   &__archive_libsystem_sha1update,
|   &__archive_libsystem_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
|   &__archive_nettle_sha1init,
|   &__archive_nettle_sha1update,
|   &__archive_nettle_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
|   &__archive_openssl_sha1init,
|   &__archive_openssl_sha1update,
|   &__archive_openssl_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
|   &__archive_windowsapi_sha1init,
|   &__archive_windowsapi_sha1update,
|   &__archive_windowsapi_sha1final,
| #elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
|   &__archive_stub_sha1init,
|   &__archive_stub_sha1update,
|   &__archive_stub_sha1final,
| #endif
| 
| /* SHA256 */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
|   &__archive_libc_sha256init,
|   &__archive_libc_sha256update,
|   &__archive_libc_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
|   &__archive_libc2_sha256init,
|   &__archive_libc2_sha256update,
|   &__archive_libc2_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
|   &__archive_libc3_sha256init,
|   &__archive_libc3_sha256update,
|   &__archive_libc3_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
|   &__archive_libmd_sha256init,
|   &__archive_libmd_sha256update,
|   &__archive_libmd_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
|   &__archive_libsystem_sha256init,
|   &__archive_libsystem_sha256update,
|   &__archive_libsystem_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
|   &__archive_nettle_sha256init,
|   &__archive_nettle_sha256update,
|   &__archive_nettle_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
|   &__archive_openssl_sha256init,
|   &__archive_openssl_sha256update,
|   &__archive_openssl_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
|   &__archive_windowsapi_sha256init,
|   &__archive_windowsapi_sha256update,
|   &__archive_windowsapi_sha256final,
| #elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
|   &__archive_stub_sha256init,
|   &__archive_stub_sha256update,
|   &__archive_stub_sha256final,
| #endif
| 
| /* SHA384 */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
|   &__archive_libc_sha384init,
|   &__archive_libc_sha384update,
|   &__archive_libc_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
|   &__archive_libc2_sha384init,
|   &__archive_libc2_sha384update,
|   &__archive_libc2_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
|   &__archive_libc3_sha384init,
|   &__archive_libc3_sha384update,
|   &__archive_libc3_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
|   &__archive_libsystem_sha384init,
|   &__archive_libsystem_sha384update,
|   &__archive_libsystem_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
|   &__archive_nettle_sha384init,
|   &__archive_nettle_sha384update,
|   &__archive_nettle_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
|   &__archive_openssl_sha384init,
|   &__archive_openssl_sha384update,
|   &__archive_openssl_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
|   &__archive_windowsapi_sha384init,
|   &__archive_windowsapi_sha384update,
|   &__archive_windowsapi_sha384final,
| #elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
|   &__archive_stub_sha384init,
|   &__archive_stub_sha384update,
|   &__archive_stub_sha384final,
| #endif
| 
| /* SHA512 */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
|   &__archive_libc_sha512init,
|   &__archive_libc_sha512update,
|   &__archive_libc_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
|   &__archive_libc2_sha512init,
|   &__archive_libc2_sha512update,
|   &__archive_libc2_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
|   &__archive_libc3_sha512init,
|   &__archive_libc3_sha512update,
|   &__archive_libc3_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
|   &__archive_libmd_sha512init,
|   &__archive_libmd_sha512update,
|   &__archive_libmd_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
|   &__archive_libsystem_sha512init,
|   &__archive_libsystem_sha512update,
|   &__archive_libsystem_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
|   &__archive_nettle_sha512init,
|   &__archive_nettle_sha512update,
|   &__archive_nettle_sha512final,
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
|   &__archive_openssl_sha512init,
|   &__archive_openssl_sha512update,
|   &__archive_openssl_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
|   &__archive_windowsapi_sha512init,
|   &__archive_windowsapi_sha512update,
|   &__archive_windowsapi_sha512final
| #elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
|   &__archive_stub_sha512init,
|   &__archive_stub_sha512update,
|   &__archive_stub_sha512final
| #endif
| };
| 
| int
| main(int argc, char **argv)
| {
|   archive_md5_ctx ctx;
|   archive_md5_init(&ctx);
|   archive_md5_update(&ctx, *argv, argc);
|   archive_md5_final(&ctx, NULL);
|   return 0;
| }
| 
configure:17215: result: no
configure:17229: checking support for ARCHIVE_CRYPTO_MD5_LIBSYSTEM
configure:17251: arm-linux-androideabi-gcc -o conftest    -I. -I. -I./libarchive  conftest.c -lz  >&5
In file included from conftest.c:206:0:
./libarchive/archive_crypto_private.h:112:39: fatal error: CommonCrypto/CommonDigest.h: No such file or directory
 #include <CommonCrypto/CommonDigest.h>
                                       ^
compilation terminated.
configure:17251: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| #define ARCHIVE_MD5_COMPILE_TEST
| #define ARCHIVE_CRYPTO_MD5_LIBSYSTEM
| #define PLATFORM_CONFIG_H "check_crypto_md.h"
| 
| /*-
| * Copyright (c) 2003-2007 Tim Kientzle
| * Copyright (c) 2011 Andres Mejia
| * Copyright (c) 2011 Michihiro NAKAJIMA
| * All rights reserved.
| *
| * Redistribution and use in source and binary forms, with or without
| * modification, are permitted provided that the following conditions
| * are met:
| * 1. Redistributions of source code must retain the above copyright
| *    notice, this list of conditions and the following disclaimer.
| * 2. Redistributions in binary form must reproduce the above copyright
| *    notice, this list of conditions and the following disclaimer in the
| *    documentation and/or other materials provided with the distribution.
| *
| * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
| * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
| * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
| * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
| * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
| * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
| * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
| * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
| * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
| * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
| */
| 
| #include "archive_platform.h"
| 
| #include "archive.h"
| #include "archive_crypto_private.h"
| 
| /* In particular, force the configure probe to break if it tries
|  * to test a combination of OpenSSL and libmd. */
| #if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
| #error Cannot use both OpenSSL and libmd.
| #endif
| 
| /*
|  * Message digest functions for Windows platform.
|  */
| #if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
| 	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
| 	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| /*
|  * Initialize a Message digest.
|  */
| static int
| win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
| {
| 
| 	ctx->valid = 0;
| 	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
| 		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
| 			return (ARCHIVE_FAILED);
| 		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
| 			return (ARCHIVE_FAILED);
| 	}
| 
| 	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
| 		CryptReleaseContext(ctx->cryptProv, 0);
| 		return (ARCHIVE_FAILED);
| 	}
| 
| 	ctx->valid = 1;
| 	return (ARCHIVE_OK);
| }
| 
| /*
|  * Update a Message digest.
|  */
| static int
| win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
| {
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptHashData(ctx->hash,
| 		      (unsigned char *)(uintptr_t)buf,
| 		      (DWORD)len, 0);
| 	return (ARCHIVE_OK);
| }
| 
| static int
| win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
| {
| 	DWORD siglen = (DWORD)bufsize;
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
| 	CryptDestroyHash(ctx->hash);
| 	CryptReleaseContext(ctx->cryptProv, 0);
| 	ctx->valid = 0;
| 	return (ARCHIVE_OK);
| }
| 
| #endif /* defined(ARCHIVE_CRYPTO_*_WIN) */
| 
| 
| /* MD5 implementations */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
| 
| static int
| __archive_libc_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
| 
| static int
| __archive_libmd_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
| 
| static int
| __archive_libsystem_md5init(archive_md5_ctx *ctx)
| {
|   CC_MD5_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_MD5_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
| {
|   CC_MD5_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
| 
| static int
| __archive_nettle_md5init(archive_md5_ctx *ctx)
| {
|   md5_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   md5_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
| {
|   md5_digest(ctx, MD5_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
| 
| static int
| __archive_openssl_md5init(archive_md5_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_md5());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
| 
| static int
| __archive_windowsapi_md5init(archive_md5_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_MD5));
| }
| 
| static int
| __archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 16, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_md5init(archive_md5_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5final(archive_md5_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* RIPEMD160 implementations */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
| 
| static int
| __archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RMD160Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RMD160Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RMD160Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
| 
| static int
| __archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RIPEMD160_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RIPEMD160_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RIPEMD160_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
| 
| static int
| __archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   ripemd160_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   ripemd160_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
| 
| static int
| __archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_ripemd160());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #else
| 
| static int
| __archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA1 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
| 
| static int
| __archive_libc_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
| 
| static int
| __archive_libmd_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha1init(archive_sha1_ctx *ctx)
| {
|   CC_SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   CC_SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
| 
| static int
| __archive_nettle_sha1init(archive_sha1_ctx *ctx)
| {
|   sha1_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha1_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
| 
| static int
| __archive_openssl_sha1init(archive_sha1_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha1());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
| 
| static int
| __archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA1));
| }
| 
| static int
| __archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 20, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha1init(archive_sha1_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA256 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
| 
| static int
| __archive_libc_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
| 
| static int
| __archive_libc2_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
| 
| static int
| __archive_libc3_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
| 
| static int
| __archive_libmd_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha256init(archive_sha256_ctx *ctx)
| {
|   CC_SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   CC_SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
| 
| static int
| __archive_nettle_sha256init(archive_sha256_ctx *ctx)
| {
|   sha256_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha256_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
| 
| static int
| __archive_openssl_sha256init(archive_sha256_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha256());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
| 
| static int
| __archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_256));
| }
| 
| static int
| __archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 32, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha256init(archive_sha256_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA384 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
| 
| static int
| __archive_libc_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
| 
| static int
| __archive_libc2_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
| 
| static int
| __archive_libc3_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha384init(archive_sha384_ctx *ctx)
| {
|   CC_SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   CC_SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
| 
| static int
| __archive_nettle_sha384init(archive_sha384_ctx *ctx)
| {
|   sha384_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha384_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
| 
| static int
| __archive_openssl_sha384init(archive_sha384_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha384());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
| 
| static int
| __archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_384));
| }
| 
| static int
| __archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 48, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha384init(archive_sha384_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA512 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
| 
| static int
| __archive_libc_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
| 
| static int
| __archive_libc2_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
| 
| static int
| __archive_libc3_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
| 
| static int
| __archive_libmd_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha512init(archive_sha512_ctx *ctx)
| {
|   CC_SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   CC_SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
| 
| static int
| __archive_nettle_sha512init(archive_sha512_ctx *ctx)
| {
|   sha512_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha512_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
| 
| static int
| __archive_openssl_sha512init(archive_sha512_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha512());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| static int
| __archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_512));
| }
| 
| static int
| __archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 64, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha512init(archive_sha512_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* NOTE: Crypto functions are set based on availability and by the following
|  * order of preference.
|  * 1. libc
|  * 2. libc2
|  * 3. libc3
|  * 4. libSystem
|  * 5. Nettle
|  * 6. OpenSSL
|  * 7. libmd
|  * 8. Windows API
|  */
| const struct archive_crypto __archive_crypto =
| {
| /* MD5 */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
|   &__archive_libc_md5init,
|   &__archive_libc_md5update,
|   &__archive_libc_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
|   &__archive_libmd_md5init,
|   &__archive_libmd_md5update,
|   &__archive_libmd_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
|   &__archive_libsystem_md5init,
|   &__archive_libsystem_md5update,
|   &__archive_libsystem_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
|   &__archive_nettle_md5init,
|   &__archive_nettle_md5update,
|   &__archive_nettle_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
|   &__archive_openssl_md5init,
|   &__archive_openssl_md5update,
|   &__archive_openssl_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
|   &__archive_windowsapi_md5init,
|   &__archive_windowsapi_md5update,
|   &__archive_windowsapi_md5final,
| #elif !defined(ARCHIVE_MD5_COMPILE_TEST)
|   &__archive_stub_md5init,
|   &__archive_stub_md5update,
|   &__archive_stub_md5final,
| #endif
| 
| /* RIPEMD160 */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
|   &__archive_libc_ripemd160init,
|   &__archive_libc_ripemd160update,
|   &__archive_libc_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
|   &__archive_libmd_ripemd160init,
|   &__archive_libmd_ripemd160update,
|   &__archive_libmd_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
|   &__archive_nettle_ripemd160init,
|   &__archive_nettle_ripemd160update,
|   &__archive_nettle_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
|   &__archive_openssl_ripemd160init,
|   &__archive_openssl_ripemd160update,
|   &__archive_openssl_ripemd160final,
| #elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
|   &__archive_stub_ripemd160init,
|   &__archive_stub_ripemd160update,
|   &__archive_stub_ripemd160final,
| #endif
| 
| /* SHA1 */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
|   &__archive_libc_sha1init,
|   &__archive_libc_sha1update,
|   &__archive_libc_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
|   &__archive_libmd_sha1init,
|   &__archive_libmd_sha1update,
|   &__archive_libmd_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
|   &__archive_libsystem_sha1init,
|   &__archive_libsystem_sha1update,
|   &__archive_libsystem_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
|   &__archive_nettle_sha1init,
|   &__archive_nettle_sha1update,
|   &__archive_nettle_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
|   &__archive_openssl_sha1init,
|   &__archive_openssl_sha1update,
|   &__archive_openssl_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
|   &__archive_windowsapi_sha1init,
|   &__archive_windowsapi_sha1update,
|   &__archive_windowsapi_sha1final,
| #elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
|   &__archive_stub_sha1init,
|   &__archive_stub_sha1update,
|   &__archive_stub_sha1final,
| #endif
| 
| /* SHA256 */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
|   &__archive_libc_sha256init,
|   &__archive_libc_sha256update,
|   &__archive_libc_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
|   &__archive_libc2_sha256init,
|   &__archive_libc2_sha256update,
|   &__archive_libc2_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
|   &__archive_libc3_sha256init,
|   &__archive_libc3_sha256update,
|   &__archive_libc3_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
|   &__archive_libmd_sha256init,
|   &__archive_libmd_sha256update,
|   &__archive_libmd_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
|   &__archive_libsystem_sha256init,
|   &__archive_libsystem_sha256update,
|   &__archive_libsystem_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
|   &__archive_nettle_sha256init,
|   &__archive_nettle_sha256update,
|   &__archive_nettle_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
|   &__archive_openssl_sha256init,
|   &__archive_openssl_sha256update,
|   &__archive_openssl_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
|   &__archive_windowsapi_sha256init,
|   &__archive_windowsapi_sha256update,
|   &__archive_windowsapi_sha256final,
| #elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
|   &__archive_stub_sha256init,
|   &__archive_stub_sha256update,
|   &__archive_stub_sha256final,
| #endif
| 
| /* SHA384 */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
|   &__archive_libc_sha384init,
|   &__archive_libc_sha384update,
|   &__archive_libc_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
|   &__archive_libc2_sha384init,
|   &__archive_libc2_sha384update,
|   &__archive_libc2_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
|   &__archive_libc3_sha384init,
|   &__archive_libc3_sha384update,
|   &__archive_libc3_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
|   &__archive_libsystem_sha384init,
|   &__archive_libsystem_sha384update,
|   &__archive_libsystem_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
|   &__archive_nettle_sha384init,
|   &__archive_nettle_sha384update,
|   &__archive_nettle_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
|   &__archive_openssl_sha384init,
|   &__archive_openssl_sha384update,
|   &__archive_openssl_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
|   &__archive_windowsapi_sha384init,
|   &__archive_windowsapi_sha384update,
|   &__archive_windowsapi_sha384final,
| #elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
|   &__archive_stub_sha384init,
|   &__archive_stub_sha384update,
|   &__archive_stub_sha384final,
| #endif
| 
| /* SHA512 */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
|   &__archive_libc_sha512init,
|   &__archive_libc_sha512update,
|   &__archive_libc_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
|   &__archive_libc2_sha512init,
|   &__archive_libc2_sha512update,
|   &__archive_libc2_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
|   &__archive_libc3_sha512init,
|   &__archive_libc3_sha512update,
|   &__archive_libc3_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
|   &__archive_libmd_sha512init,
|   &__archive_libmd_sha512update,
|   &__archive_libmd_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
|   &__archive_libsystem_sha512init,
|   &__archive_libsystem_sha512update,
|   &__archive_libsystem_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
|   &__archive_nettle_sha512init,
|   &__archive_nettle_sha512update,
|   &__archive_nettle_sha512final,
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
|   &__archive_openssl_sha512init,
|   &__archive_openssl_sha512update,
|   &__archive_openssl_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
|   &__archive_windowsapi_sha512init,
|   &__archive_windowsapi_sha512update,
|   &__archive_windowsapi_sha512final
| #elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
|   &__archive_stub_sha512init,
|   &__archive_stub_sha512update,
|   &__archive_stub_sha512final
| #endif
| };
| 
| int
| main(int argc, char **argv)
| {
|   archive_md5_ctx ctx;
|   archive_md5_init(&ctx);
|   archive_md5_update(&ctx, *argv, argc);
|   archive_md5_final(&ctx, NULL);
|   return 0;
| }
| 
configure:17261: result: no
configure:17275: checking support for ARCHIVE_CRYPTO_RMD160_LIBC
configure:17297: arm-linux-androideabi-gcc -o conftest    -I. -I. -I./libarchive  conftest.c -lz  >&5
In file included from conftest.c:206:0:
./libarchive/archive_crypto_private.h:64:20: fatal error: rmd160.h: No such file or directory
 #include <rmd160.h>
                    ^
compilation terminated.
configure:17297: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| #define ARCHIVE_RMD160_COMPILE_TEST
| #define ARCHIVE_CRYPTO_RMD160_LIBC
| #define PLATFORM_CONFIG_H "check_crypto_md.h"
| 
| /*-
| * Copyright (c) 2003-2007 Tim Kientzle
| * Copyright (c) 2011 Andres Mejia
| * Copyright (c) 2011 Michihiro NAKAJIMA
| * All rights reserved.
| *
| * Redistribution and use in source and binary forms, with or without
| * modification, are permitted provided that the following conditions
| * are met:
| * 1. Redistributions of source code must retain the above copyright
| *    notice, this list of conditions and the following disclaimer.
| * 2. Redistributions in binary form must reproduce the above copyright
| *    notice, this list of conditions and the following disclaimer in the
| *    documentation and/or other materials provided with the distribution.
| *
| * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
| * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
| * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
| * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
| * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
| * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
| * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
| * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
| * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
| * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
| */
| 
| #include "archive_platform.h"
| 
| #include "archive.h"
| #include "archive_crypto_private.h"
| 
| /* In particular, force the configure probe to break if it tries
|  * to test a combination of OpenSSL and libmd. */
| #if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
| #error Cannot use both OpenSSL and libmd.
| #endif
| 
| /*
|  * Message digest functions for Windows platform.
|  */
| #if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
| 	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
| 	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| /*
|  * Initialize a Message digest.
|  */
| static int
| win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
| {
| 
| 	ctx->valid = 0;
| 	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
| 		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
| 			return (ARCHIVE_FAILED);
| 		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
| 			return (ARCHIVE_FAILED);
| 	}
| 
| 	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
| 		CryptReleaseContext(ctx->cryptProv, 0);
| 		return (ARCHIVE_FAILED);
| 	}
| 
| 	ctx->valid = 1;
| 	return (ARCHIVE_OK);
| }
| 
| /*
|  * Update a Message digest.
|  */
| static int
| win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
| {
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptHashData(ctx->hash,
| 		      (unsigned char *)(uintptr_t)buf,
| 		      (DWORD)len, 0);
| 	return (ARCHIVE_OK);
| }
| 
| static int
| win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
| {
| 	DWORD siglen = (DWORD)bufsize;
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
| 	CryptDestroyHash(ctx->hash);
| 	CryptReleaseContext(ctx->cryptProv, 0);
| 	ctx->valid = 0;
| 	return (ARCHIVE_OK);
| }
| 
| #endif /* defined(ARCHIVE_CRYPTO_*_WIN) */
| 
| 
| /* MD5 implementations */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
| 
| static int
| __archive_libc_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
| 
| static int
| __archive_libmd_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
| 
| static int
| __archive_libsystem_md5init(archive_md5_ctx *ctx)
| {
|   CC_MD5_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_MD5_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
| {
|   CC_MD5_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
| 
| static int
| __archive_nettle_md5init(archive_md5_ctx *ctx)
| {
|   md5_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   md5_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
| {
|   md5_digest(ctx, MD5_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
| 
| static int
| __archive_openssl_md5init(archive_md5_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_md5());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
| 
| static int
| __archive_windowsapi_md5init(archive_md5_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_MD5));
| }
| 
| static int
| __archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 16, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_md5init(archive_md5_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5final(archive_md5_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* RIPEMD160 implementations */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
| 
| static int
| __archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RMD160Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RMD160Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RMD160Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
| 
| static int
| __archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RIPEMD160_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RIPEMD160_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RIPEMD160_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
| 
| static int
| __archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   ripemd160_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   ripemd160_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
| 
| static int
| __archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_ripemd160());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #else
| 
| static int
| __archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA1 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
| 
| static int
| __archive_libc_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
| 
| static int
| __archive_libmd_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha1init(archive_sha1_ctx *ctx)
| {
|   CC_SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   CC_SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
| 
| static int
| __archive_nettle_sha1init(archive_sha1_ctx *ctx)
| {
|   sha1_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha1_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
| 
| static int
| __archive_openssl_sha1init(archive_sha1_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha1());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
| 
| static int
| __archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA1));
| }
| 
| static int
| __archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 20, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha1init(archive_sha1_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA256 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
| 
| static int
| __archive_libc_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
| 
| static int
| __archive_libc2_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
| 
| static int
| __archive_libc3_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
| 
| static int
| __archive_libmd_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha256init(archive_sha256_ctx *ctx)
| {
|   CC_SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   CC_SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
| 
| static int
| __archive_nettle_sha256init(archive_sha256_ctx *ctx)
| {
|   sha256_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha256_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
| 
| static int
| __archive_openssl_sha256init(archive_sha256_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha256());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
| 
| static int
| __archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_256));
| }
| 
| static int
| __archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 32, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha256init(archive_sha256_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA384 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
| 
| static int
| __archive_libc_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
| 
| static int
| __archive_libc2_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
| 
| static int
| __archive_libc3_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha384init(archive_sha384_ctx *ctx)
| {
|   CC_SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   CC_SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
| 
| static int
| __archive_nettle_sha384init(archive_sha384_ctx *ctx)
| {
|   sha384_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha384_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
| 
| static int
| __archive_openssl_sha384init(archive_sha384_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha384());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
| 
| static int
| __archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_384));
| }
| 
| static int
| __archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 48, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha384init(archive_sha384_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA512 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
| 
| static int
| __archive_libc_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
| 
| static int
| __archive_libc2_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
| 
| static int
| __archive_libc3_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
| 
| static int
| __archive_libmd_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha512init(archive_sha512_ctx *ctx)
| {
|   CC_SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   CC_SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
| 
| static int
| __archive_nettle_sha512init(archive_sha512_ctx *ctx)
| {
|   sha512_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha512_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
| 
| static int
| __archive_openssl_sha512init(archive_sha512_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha512());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| static int
| __archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_512));
| }
| 
| static int
| __archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 64, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha512init(archive_sha512_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* NOTE: Crypto functions are set based on availability and by the following
|  * order of preference.
|  * 1. libc
|  * 2. libc2
|  * 3. libc3
|  * 4. libSystem
|  * 5. Nettle
|  * 6. OpenSSL
|  * 7. libmd
|  * 8. Windows API
|  */
| const struct archive_crypto __archive_crypto =
| {
| /* MD5 */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
|   &__archive_libc_md5init,
|   &__archive_libc_md5update,
|   &__archive_libc_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
|   &__archive_libmd_md5init,
|   &__archive_libmd_md5update,
|   &__archive_libmd_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
|   &__archive_libsystem_md5init,
|   &__archive_libsystem_md5update,
|   &__archive_libsystem_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
|   &__archive_nettle_md5init,
|   &__archive_nettle_md5update,
|   &__archive_nettle_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
|   &__archive_openssl_md5init,
|   &__archive_openssl_md5update,
|   &__archive_openssl_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
|   &__archive_windowsapi_md5init,
|   &__archive_windowsapi_md5update,
|   &__archive_windowsapi_md5final,
| #elif !defined(ARCHIVE_MD5_COMPILE_TEST)
|   &__archive_stub_md5init,
|   &__archive_stub_md5update,
|   &__archive_stub_md5final,
| #endif
| 
| /* RIPEMD160 */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
|   &__archive_libc_ripemd160init,
|   &__archive_libc_ripemd160update,
|   &__archive_libc_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
|   &__archive_libmd_ripemd160init,
|   &__archive_libmd_ripemd160update,
|   &__archive_libmd_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
|   &__archive_nettle_ripemd160init,
|   &__archive_nettle_ripemd160update,
|   &__archive_nettle_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
|   &__archive_openssl_ripemd160init,
|   &__archive_openssl_ripemd160update,
|   &__archive_openssl_ripemd160final,
| #elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
|   &__archive_stub_ripemd160init,
|   &__archive_stub_ripemd160update,
|   &__archive_stub_ripemd160final,
| #endif
| 
| /* SHA1 */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
|   &__archive_libc_sha1init,
|   &__archive_libc_sha1update,
|   &__archive_libc_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
|   &__archive_libmd_sha1init,
|   &__archive_libmd_sha1update,
|   &__archive_libmd_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
|   &__archive_libsystem_sha1init,
|   &__archive_libsystem_sha1update,
|   &__archive_libsystem_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
|   &__archive_nettle_sha1init,
|   &__archive_nettle_sha1update,
|   &__archive_nettle_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
|   &__archive_openssl_sha1init,
|   &__archive_openssl_sha1update,
|   &__archive_openssl_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
|   &__archive_windowsapi_sha1init,
|   &__archive_windowsapi_sha1update,
|   &__archive_windowsapi_sha1final,
| #elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
|   &__archive_stub_sha1init,
|   &__archive_stub_sha1update,
|   &__archive_stub_sha1final,
| #endif
| 
| /* SHA256 */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
|   &__archive_libc_sha256init,
|   &__archive_libc_sha256update,
|   &__archive_libc_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
|   &__archive_libc2_sha256init,
|   &__archive_libc2_sha256update,
|   &__archive_libc2_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
|   &__archive_libc3_sha256init,
|   &__archive_libc3_sha256update,
|   &__archive_libc3_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
|   &__archive_libmd_sha256init,
|   &__archive_libmd_sha256update,
|   &__archive_libmd_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
|   &__archive_libsystem_sha256init,
|   &__archive_libsystem_sha256update,
|   &__archive_libsystem_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
|   &__archive_nettle_sha256init,
|   &__archive_nettle_sha256update,
|   &__archive_nettle_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
|   &__archive_openssl_sha256init,
|   &__archive_openssl_sha256update,
|   &__archive_openssl_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
|   &__archive_windowsapi_sha256init,
|   &__archive_windowsapi_sha256update,
|   &__archive_windowsapi_sha256final,
| #elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
|   &__archive_stub_sha256init,
|   &__archive_stub_sha256update,
|   &__archive_stub_sha256final,
| #endif
| 
| /* SHA384 */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
|   &__archive_libc_sha384init,
|   &__archive_libc_sha384update,
|   &__archive_libc_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
|   &__archive_libc2_sha384init,
|   &__archive_libc2_sha384update,
|   &__archive_libc2_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
|   &__archive_libc3_sha384init,
|   &__archive_libc3_sha384update,
|   &__archive_libc3_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
|   &__archive_libsystem_sha384init,
|   &__archive_libsystem_sha384update,
|   &__archive_libsystem_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
|   &__archive_nettle_sha384init,
|   &__archive_nettle_sha384update,
|   &__archive_nettle_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
|   &__archive_openssl_sha384init,
|   &__archive_openssl_sha384update,
|   &__archive_openssl_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
|   &__archive_windowsapi_sha384init,
|   &__archive_windowsapi_sha384update,
|   &__archive_windowsapi_sha384final,
| #elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
|   &__archive_stub_sha384init,
|   &__archive_stub_sha384update,
|   &__archive_stub_sha384final,
| #endif
| 
| /* SHA512 */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
|   &__archive_libc_sha512init,
|   &__archive_libc_sha512update,
|   &__archive_libc_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
|   &__archive_libc2_sha512init,
|   &__archive_libc2_sha512update,
|   &__archive_libc2_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
|   &__archive_libc3_sha512init,
|   &__archive_libc3_sha512update,
|   &__archive_libc3_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
|   &__archive_libmd_sha512init,
|   &__archive_libmd_sha512update,
|   &__archive_libmd_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
|   &__archive_libsystem_sha512init,
|   &__archive_libsystem_sha512update,
|   &__archive_libsystem_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
|   &__archive_nettle_sha512init,
|   &__archive_nettle_sha512update,
|   &__archive_nettle_sha512final,
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
|   &__archive_openssl_sha512init,
|   &__archive_openssl_sha512update,
|   &__archive_openssl_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
|   &__archive_windowsapi_sha512init,
|   &__archive_windowsapi_sha512update,
|   &__archive_windowsapi_sha512final
| #elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
|   &__archive_stub_sha512init,
|   &__archive_stub_sha512update,
|   &__archive_stub_sha512final
| #endif
| };
| 
| int
| main(int argc, char **argv)
| {
|   archive_rmd160_ctx ctx;
|   archive_rmd160_init(&ctx);
|   archive_rmd160_update(&ctx, *argv, argc);
|   archive_rmd160_final(&ctx, NULL);
|   return 0;
| }
| 
configure:17307: result: no
configure:17321: checking support for ARCHIVE_CRYPTO_SHA1_LIBC
configure:17343: arm-linux-androideabi-gcc -o conftest    -I. -I. -I./libarchive  conftest.c -lz  >&5
In file included from conftest.c:206:0:
./libarchive/archive_crypto_private.h:67:18: fatal error: sha1.h: No such file or directory
 #include <sha1.h>
                  ^
compilation terminated.
configure:17343: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| #define ARCHIVE_SHA1_COMPILE_TEST
| #define ARCHIVE_CRYPTO_SHA1_LIBC
| #define PLATFORM_CONFIG_H "check_crypto_md.h"
| 
| /*-
| * Copyright (c) 2003-2007 Tim Kientzle
| * Copyright (c) 2011 Andres Mejia
| * Copyright (c) 2011 Michihiro NAKAJIMA
| * All rights reserved.
| *
| * Redistribution and use in source and binary forms, with or without
| * modification, are permitted provided that the following conditions
| * are met:
| * 1. Redistributions of source code must retain the above copyright
| *    notice, this list of conditions and the following disclaimer.
| * 2. Redistributions in binary form must reproduce the above copyright
| *    notice, this list of conditions and the following disclaimer in the
| *    documentation and/or other materials provided with the distribution.
| *
| * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
| * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
| * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
| * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
| * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
| * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
| * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
| * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
| * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
| * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
| */
| 
| #include "archive_platform.h"
| 
| #include "archive.h"
| #include "archive_crypto_private.h"
| 
| /* In particular, force the configure probe to break if it tries
|  * to test a combination of OpenSSL and libmd. */
| #if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
| #error Cannot use both OpenSSL and libmd.
| #endif
| 
| /*
|  * Message digest functions for Windows platform.
|  */
| #if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
| 	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
| 	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| /*
|  * Initialize a Message digest.
|  */
| static int
| win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
| {
| 
| 	ctx->valid = 0;
| 	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
| 		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
| 			return (ARCHIVE_FAILED);
| 		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
| 			return (ARCHIVE_FAILED);
| 	}
| 
| 	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
| 		CryptReleaseContext(ctx->cryptProv, 0);
| 		return (ARCHIVE_FAILED);
| 	}
| 
| 	ctx->valid = 1;
| 	return (ARCHIVE_OK);
| }
| 
| /*
|  * Update a Message digest.
|  */
| static int
| win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
| {
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptHashData(ctx->hash,
| 		      (unsigned char *)(uintptr_t)buf,
| 		      (DWORD)len, 0);
| 	return (ARCHIVE_OK);
| }
| 
| static int
| win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
| {
| 	DWORD siglen = (DWORD)bufsize;
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
| 	CryptDestroyHash(ctx->hash);
| 	CryptReleaseContext(ctx->cryptProv, 0);
| 	ctx->valid = 0;
| 	return (ARCHIVE_OK);
| }
| 
| #endif /* defined(ARCHIVE_CRYPTO_*_WIN) */
| 
| 
| /* MD5 implementations */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
| 
| static int
| __archive_libc_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
| 
| static int
| __archive_libmd_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
| 
| static int
| __archive_libsystem_md5init(archive_md5_ctx *ctx)
| {
|   CC_MD5_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_MD5_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
| {
|   CC_MD5_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
| 
| static int
| __archive_nettle_md5init(archive_md5_ctx *ctx)
| {
|   md5_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   md5_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
| {
|   md5_digest(ctx, MD5_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
| 
| static int
| __archive_openssl_md5init(archive_md5_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_md5());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
| 
| static int
| __archive_windowsapi_md5init(archive_md5_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_MD5));
| }
| 
| static int
| __archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 16, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_md5init(archive_md5_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5final(archive_md5_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* RIPEMD160 implementations */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
| 
| static int
| __archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RMD160Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RMD160Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RMD160Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
| 
| static int
| __archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RIPEMD160_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RIPEMD160_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RIPEMD160_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
| 
| static int
| __archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   ripemd160_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   ripemd160_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
| 
| static int
| __archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_ripemd160());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #else
| 
| static int
| __archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA1 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
| 
| static int
| __archive_libc_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
| 
| static int
| __archive_libmd_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha1init(archive_sha1_ctx *ctx)
| {
|   CC_SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   CC_SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
| 
| static int
| __archive_nettle_sha1init(archive_sha1_ctx *ctx)
| {
|   sha1_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha1_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
| 
| static int
| __archive_openssl_sha1init(archive_sha1_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha1());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
| 
| static int
| __archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA1));
| }
| 
| static int
| __archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 20, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha1init(archive_sha1_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA256 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
| 
| static int
| __archive_libc_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
| 
| static int
| __archive_libc2_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
| 
| static int
| __archive_libc3_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
| 
| static int
| __archive_libmd_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha256init(archive_sha256_ctx *ctx)
| {
|   CC_SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   CC_SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
| 
| static int
| __archive_nettle_sha256init(archive_sha256_ctx *ctx)
| {
|   sha256_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha256_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
| 
| static int
| __archive_openssl_sha256init(archive_sha256_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha256());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
| 
| static int
| __archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_256));
| }
| 
| static int
| __archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 32, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha256init(archive_sha256_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA384 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
| 
| static int
| __archive_libc_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
| 
| static int
| __archive_libc2_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
| 
| static int
| __archive_libc3_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha384init(archive_sha384_ctx *ctx)
| {
|   CC_SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   CC_SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
| 
| static int
| __archive_nettle_sha384init(archive_sha384_ctx *ctx)
| {
|   sha384_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha384_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
| 
| static int
| __archive_openssl_sha384init(archive_sha384_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha384());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
| 
| static int
| __archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_384));
| }
| 
| static int
| __archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 48, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha384init(archive_sha384_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA512 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
| 
| static int
| __archive_libc_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
| 
| static int
| __archive_libc2_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
| 
| static int
| __archive_libc3_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
| 
| static int
| __archive_libmd_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha512init(archive_sha512_ctx *ctx)
| {
|   CC_SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   CC_SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
| 
| static int
| __archive_nettle_sha512init(archive_sha512_ctx *ctx)
| {
|   sha512_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha512_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
| 
| static int
| __archive_openssl_sha512init(archive_sha512_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha512());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| static int
| __archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_512));
| }
| 
| static int
| __archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 64, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha512init(archive_sha512_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* NOTE: Crypto functions are set based on availability and by the following
|  * order of preference.
|  * 1. libc
|  * 2. libc2
|  * 3. libc3
|  * 4. libSystem
|  * 5. Nettle
|  * 6. OpenSSL
|  * 7. libmd
|  * 8. Windows API
|  */
| const struct archive_crypto __archive_crypto =
| {
| /* MD5 */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
|   &__archive_libc_md5init,
|   &__archive_libc_md5update,
|   &__archive_libc_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
|   &__archive_libmd_md5init,
|   &__archive_libmd_md5update,
|   &__archive_libmd_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
|   &__archive_libsystem_md5init,
|   &__archive_libsystem_md5update,
|   &__archive_libsystem_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
|   &__archive_nettle_md5init,
|   &__archive_nettle_md5update,
|   &__archive_nettle_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
|   &__archive_openssl_md5init,
|   &__archive_openssl_md5update,
|   &__archive_openssl_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
|   &__archive_windowsapi_md5init,
|   &__archive_windowsapi_md5update,
|   &__archive_windowsapi_md5final,
| #elif !defined(ARCHIVE_MD5_COMPILE_TEST)
|   &__archive_stub_md5init,
|   &__archive_stub_md5update,
|   &__archive_stub_md5final,
| #endif
| 
| /* RIPEMD160 */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
|   &__archive_libc_ripemd160init,
|   &__archive_libc_ripemd160update,
|   &__archive_libc_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
|   &__archive_libmd_ripemd160init,
|   &__archive_libmd_ripemd160update,
|   &__archive_libmd_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
|   &__archive_nettle_ripemd160init,
|   &__archive_nettle_ripemd160update,
|   &__archive_nettle_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
|   &__archive_openssl_ripemd160init,
|   &__archive_openssl_ripemd160update,
|   &__archive_openssl_ripemd160final,
| #elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
|   &__archive_stub_ripemd160init,
|   &__archive_stub_ripemd160update,
|   &__archive_stub_ripemd160final,
| #endif
| 
| /* SHA1 */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
|   &__archive_libc_sha1init,
|   &__archive_libc_sha1update,
|   &__archive_libc_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
|   &__archive_libmd_sha1init,
|   &__archive_libmd_sha1update,
|   &__archive_libmd_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
|   &__archive_libsystem_sha1init,
|   &__archive_libsystem_sha1update,
|   &__archive_libsystem_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
|   &__archive_nettle_sha1init,
|   &__archive_nettle_sha1update,
|   &__archive_nettle_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
|   &__archive_openssl_sha1init,
|   &__archive_openssl_sha1update,
|   &__archive_openssl_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
|   &__archive_windowsapi_sha1init,
|   &__archive_windowsapi_sha1update,
|   &__archive_windowsapi_sha1final,
| #elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
|   &__archive_stub_sha1init,
|   &__archive_stub_sha1update,
|   &__archive_stub_sha1final,
| #endif
| 
| /* SHA256 */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
|   &__archive_libc_sha256init,
|   &__archive_libc_sha256update,
|   &__archive_libc_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
|   &__archive_libc2_sha256init,
|   &__archive_libc2_sha256update,
|   &__archive_libc2_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
|   &__archive_libc3_sha256init,
|   &__archive_libc3_sha256update,
|   &__archive_libc3_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
|   &__archive_libmd_sha256init,
|   &__archive_libmd_sha256update,
|   &__archive_libmd_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
|   &__archive_libsystem_sha256init,
|   &__archive_libsystem_sha256update,
|   &__archive_libsystem_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
|   &__archive_nettle_sha256init,
|   &__archive_nettle_sha256update,
|   &__archive_nettle_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
|   &__archive_openssl_sha256init,
|   &__archive_openssl_sha256update,
|   &__archive_openssl_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
|   &__archive_windowsapi_sha256init,
|   &__archive_windowsapi_sha256update,
|   &__archive_windowsapi_sha256final,
| #elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
|   &__archive_stub_sha256init,
|   &__archive_stub_sha256update,
|   &__archive_stub_sha256final,
| #endif
| 
| /* SHA384 */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
|   &__archive_libc_sha384init,
|   &__archive_libc_sha384update,
|   &__archive_libc_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
|   &__archive_libc2_sha384init,
|   &__archive_libc2_sha384update,
|   &__archive_libc2_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
|   &__archive_libc3_sha384init,
|   &__archive_libc3_sha384update,
|   &__archive_libc3_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
|   &__archive_libsystem_sha384init,
|   &__archive_libsystem_sha384update,
|   &__archive_libsystem_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
|   &__archive_nettle_sha384init,
|   &__archive_nettle_sha384update,
|   &__archive_nettle_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
|   &__archive_openssl_sha384init,
|   &__archive_openssl_sha384update,
|   &__archive_openssl_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
|   &__archive_windowsapi_sha384init,
|   &__archive_windowsapi_sha384update,
|   &__archive_windowsapi_sha384final,
| #elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
|   &__archive_stub_sha384init,
|   &__archive_stub_sha384update,
|   &__archive_stub_sha384final,
| #endif
| 
| /* SHA512 */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
|   &__archive_libc_sha512init,
|   &__archive_libc_sha512update,
|   &__archive_libc_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
|   &__archive_libc2_sha512init,
|   &__archive_libc2_sha512update,
|   &__archive_libc2_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
|   &__archive_libc3_sha512init,
|   &__archive_libc3_sha512update,
|   &__archive_libc3_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
|   &__archive_libmd_sha512init,
|   &__archive_libmd_sha512update,
|   &__archive_libmd_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
|   &__archive_libsystem_sha512init,
|   &__archive_libsystem_sha512update,
|   &__archive_libsystem_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
|   &__archive_nettle_sha512init,
|   &__archive_nettle_sha512update,
|   &__archive_nettle_sha512final,
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
|   &__archive_openssl_sha512init,
|   &__archive_openssl_sha512update,
|   &__archive_openssl_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
|   &__archive_windowsapi_sha512init,
|   &__archive_windowsapi_sha512update,
|   &__archive_windowsapi_sha512final
| #elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
|   &__archive_stub_sha512init,
|   &__archive_stub_sha512update,
|   &__archive_stub_sha512final
| #endif
| };
| 
| int
| main(int argc, char **argv)
| {
|   archive_sha1_ctx ctx;
|   archive_sha1_init(&ctx);
|   archive_sha1_update(&ctx, *argv, argc);
|   archive_sha1_final(&ctx, NULL);
|   return 0;
| }
| 
configure:17353: result: no
configure:17367: checking support for ARCHIVE_CRYPTO_SHA1_LIBSYSTEM
configure:17389: arm-linux-androideabi-gcc -o conftest    -I. -I. -I./libarchive  conftest.c -lz  >&5
In file included from conftest.c:206:0:
./libarchive/archive_crypto_private.h:112:39: fatal error: CommonCrypto/CommonDigest.h: No such file or directory
 #include <CommonCrypto/CommonDigest.h>
                                       ^
compilation terminated.
configure:17389: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| #define ARCHIVE_SHA1_COMPILE_TEST
| #define ARCHIVE_CRYPTO_SHA1_LIBSYSTEM
| #define PLATFORM_CONFIG_H "check_crypto_md.h"
| 
| /*-
| * Copyright (c) 2003-2007 Tim Kientzle
| * Copyright (c) 2011 Andres Mejia
| * Copyright (c) 2011 Michihiro NAKAJIMA
| * All rights reserved.
| *
| * Redistribution and use in source and binary forms, with or without
| * modification, are permitted provided that the following conditions
| * are met:
| * 1. Redistributions of source code must retain the above copyright
| *    notice, this list of conditions and the following disclaimer.
| * 2. Redistributions in binary form must reproduce the above copyright
| *    notice, this list of conditions and the following disclaimer in the
| *    documentation and/or other materials provided with the distribution.
| *
| * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
| * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
| * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
| * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
| * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
| * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
| * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
| * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
| * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
| * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
| */
| 
| #include "archive_platform.h"
| 
| #include "archive.h"
| #include "archive_crypto_private.h"
| 
| /* In particular, force the configure probe to break if it tries
|  * to test a combination of OpenSSL and libmd. */
| #if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
| #error Cannot use both OpenSSL and libmd.
| #endif
| 
| /*
|  * Message digest functions for Windows platform.
|  */
| #if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
| 	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
| 	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| /*
|  * Initialize a Message digest.
|  */
| static int
| win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
| {
| 
| 	ctx->valid = 0;
| 	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
| 		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
| 			return (ARCHIVE_FAILED);
| 		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
| 			return (ARCHIVE_FAILED);
| 	}
| 
| 	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
| 		CryptReleaseContext(ctx->cryptProv, 0);
| 		return (ARCHIVE_FAILED);
| 	}
| 
| 	ctx->valid = 1;
| 	return (ARCHIVE_OK);
| }
| 
| /*
|  * Update a Message digest.
|  */
| static int
| win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
| {
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptHashData(ctx->hash,
| 		      (unsigned char *)(uintptr_t)buf,
| 		      (DWORD)len, 0);
| 	return (ARCHIVE_OK);
| }
| 
| static int
| win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
| {
| 	DWORD siglen = (DWORD)bufsize;
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
| 	CryptDestroyHash(ctx->hash);
| 	CryptReleaseContext(ctx->cryptProv, 0);
| 	ctx->valid = 0;
| 	return (ARCHIVE_OK);
| }
| 
| #endif /* defined(ARCHIVE_CRYPTO_*_WIN) */
| 
| 
| /* MD5 implementations */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
| 
| static int
| __archive_libc_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
| 
| static int
| __archive_libmd_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
| 
| static int
| __archive_libsystem_md5init(archive_md5_ctx *ctx)
| {
|   CC_MD5_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_MD5_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
| {
|   CC_MD5_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
| 
| static int
| __archive_nettle_md5init(archive_md5_ctx *ctx)
| {
|   md5_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   md5_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
| {
|   md5_digest(ctx, MD5_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
| 
| static int
| __archive_openssl_md5init(archive_md5_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_md5());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
| 
| static int
| __archive_windowsapi_md5init(archive_md5_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_MD5));
| }
| 
| static int
| __archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 16, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_md5init(archive_md5_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5final(archive_md5_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* RIPEMD160 implementations */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
| 
| static int
| __archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RMD160Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RMD160Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RMD160Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
| 
| static int
| __archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RIPEMD160_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RIPEMD160_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RIPEMD160_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
| 
| static int
| __archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   ripemd160_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   ripemd160_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
| 
| static int
| __archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_ripemd160());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #else
| 
| static int
| __archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA1 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
| 
| static int
| __archive_libc_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
| 
| static int
| __archive_libmd_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha1init(archive_sha1_ctx *ctx)
| {
|   CC_SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   CC_SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
| 
| static int
| __archive_nettle_sha1init(archive_sha1_ctx *ctx)
| {
|   sha1_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha1_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
| 
| static int
| __archive_openssl_sha1init(archive_sha1_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha1());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
| 
| static int
| __archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA1));
| }
| 
| static int
| __archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 20, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha1init(archive_sha1_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA256 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
| 
| static int
| __archive_libc_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
| 
| static int
| __archive_libc2_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
| 
| static int
| __archive_libc3_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
| 
| static int
| __archive_libmd_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha256init(archive_sha256_ctx *ctx)
| {
|   CC_SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   CC_SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
| 
| static int
| __archive_nettle_sha256init(archive_sha256_ctx *ctx)
| {
|   sha256_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha256_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
| 
| static int
| __archive_openssl_sha256init(archive_sha256_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha256());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
| 
| static int
| __archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_256));
| }
| 
| static int
| __archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 32, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha256init(archive_sha256_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA384 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
| 
| static int
| __archive_libc_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
| 
| static int
| __archive_libc2_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
| 
| static int
| __archive_libc3_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha384init(archive_sha384_ctx *ctx)
| {
|   CC_SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   CC_SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
| 
| static int
| __archive_nettle_sha384init(archive_sha384_ctx *ctx)
| {
|   sha384_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha384_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
| 
| static int
| __archive_openssl_sha384init(archive_sha384_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha384());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
| 
| static int
| __archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_384));
| }
| 
| static int
| __archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 48, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha384init(archive_sha384_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA512 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
| 
| static int
| __archive_libc_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
| 
| static int
| __archive_libc2_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
| 
| static int
| __archive_libc3_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
| 
| static int
| __archive_libmd_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha512init(archive_sha512_ctx *ctx)
| {
|   CC_SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   CC_SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
| 
| static int
| __archive_nettle_sha512init(archive_sha512_ctx *ctx)
| {
|   sha512_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha512_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
| 
| static int
| __archive_openssl_sha512init(archive_sha512_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha512());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| static int
| __archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_512));
| }
| 
| static int
| __archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 64, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha512init(archive_sha512_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* NOTE: Crypto functions are set based on availability and by the following
|  * order of preference.
|  * 1. libc
|  * 2. libc2
|  * 3. libc3
|  * 4. libSystem
|  * 5. Nettle
|  * 6. OpenSSL
|  * 7. libmd
|  * 8. Windows API
|  */
| const struct archive_crypto __archive_crypto =
| {
| /* MD5 */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
|   &__archive_libc_md5init,
|   &__archive_libc_md5update,
|   &__archive_libc_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
|   &__archive_libmd_md5init,
|   &__archive_libmd_md5update,
|   &__archive_libmd_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
|   &__archive_libsystem_md5init,
|   &__archive_libsystem_md5update,
|   &__archive_libsystem_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
|   &__archive_nettle_md5init,
|   &__archive_nettle_md5update,
|   &__archive_nettle_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
|   &__archive_openssl_md5init,
|   &__archive_openssl_md5update,
|   &__archive_openssl_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
|   &__archive_windowsapi_md5init,
|   &__archive_windowsapi_md5update,
|   &__archive_windowsapi_md5final,
| #elif !defined(ARCHIVE_MD5_COMPILE_TEST)
|   &__archive_stub_md5init,
|   &__archive_stub_md5update,
|   &__archive_stub_md5final,
| #endif
| 
| /* RIPEMD160 */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
|   &__archive_libc_ripemd160init,
|   &__archive_libc_ripemd160update,
|   &__archive_libc_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
|   &__archive_libmd_ripemd160init,
|   &__archive_libmd_ripemd160update,
|   &__archive_libmd_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
|   &__archive_nettle_ripemd160init,
|   &__archive_nettle_ripemd160update,
|   &__archive_nettle_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
|   &__archive_openssl_ripemd160init,
|   &__archive_openssl_ripemd160update,
|   &__archive_openssl_ripemd160final,
| #elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
|   &__archive_stub_ripemd160init,
|   &__archive_stub_ripemd160update,
|   &__archive_stub_ripemd160final,
| #endif
| 
| /* SHA1 */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
|   &__archive_libc_sha1init,
|   &__archive_libc_sha1update,
|   &__archive_libc_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
|   &__archive_libmd_sha1init,
|   &__archive_libmd_sha1update,
|   &__archive_libmd_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
|   &__archive_libsystem_sha1init,
|   &__archive_libsystem_sha1update,
|   &__archive_libsystem_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
|   &__archive_nettle_sha1init,
|   &__archive_nettle_sha1update,
|   &__archive_nettle_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
|   &__archive_openssl_sha1init,
|   &__archive_openssl_sha1update,
|   &__archive_openssl_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
|   &__archive_windowsapi_sha1init,
|   &__archive_windowsapi_sha1update,
|   &__archive_windowsapi_sha1final,
| #elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
|   &__archive_stub_sha1init,
|   &__archive_stub_sha1update,
|   &__archive_stub_sha1final,
| #endif
| 
| /* SHA256 */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
|   &__archive_libc_sha256init,
|   &__archive_libc_sha256update,
|   &__archive_libc_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
|   &__archive_libc2_sha256init,
|   &__archive_libc2_sha256update,
|   &__archive_libc2_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
|   &__archive_libc3_sha256init,
|   &__archive_libc3_sha256update,
|   &__archive_libc3_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
|   &__archive_libmd_sha256init,
|   &__archive_libmd_sha256update,
|   &__archive_libmd_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
|   &__archive_libsystem_sha256init,
|   &__archive_libsystem_sha256update,
|   &__archive_libsystem_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
|   &__archive_nettle_sha256init,
|   &__archive_nettle_sha256update,
|   &__archive_nettle_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
|   &__archive_openssl_sha256init,
|   &__archive_openssl_sha256update,
|   &__archive_openssl_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
|   &__archive_windowsapi_sha256init,
|   &__archive_windowsapi_sha256update,
|   &__archive_windowsapi_sha256final,
| #elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
|   &__archive_stub_sha256init,
|   &__archive_stub_sha256update,
|   &__archive_stub_sha256final,
| #endif
| 
| /* SHA384 */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
|   &__archive_libc_sha384init,
|   &__archive_libc_sha384update,
|   &__archive_libc_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
|   &__archive_libc2_sha384init,
|   &__archive_libc2_sha384update,
|   &__archive_libc2_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
|   &__archive_libc3_sha384init,
|   &__archive_libc3_sha384update,
|   &__archive_libc3_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
|   &__archive_libsystem_sha384init,
|   &__archive_libsystem_sha384update,
|   &__archive_libsystem_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
|   &__archive_nettle_sha384init,
|   &__archive_nettle_sha384update,
|   &__archive_nettle_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
|   &__archive_openssl_sha384init,
|   &__archive_openssl_sha384update,
|   &__archive_openssl_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
|   &__archive_windowsapi_sha384init,
|   &__archive_windowsapi_sha384update,
|   &__archive_windowsapi_sha384final,
| #elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
|   &__archive_stub_sha384init,
|   &__archive_stub_sha384update,
|   &__archive_stub_sha384final,
| #endif
| 
| /* SHA512 */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
|   &__archive_libc_sha512init,
|   &__archive_libc_sha512update,
|   &__archive_libc_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
|   &__archive_libc2_sha512init,
|   &__archive_libc2_sha512update,
|   &__archive_libc2_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
|   &__archive_libc3_sha512init,
|   &__archive_libc3_sha512update,
|   &__archive_libc3_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
|   &__archive_libmd_sha512init,
|   &__archive_libmd_sha512update,
|   &__archive_libmd_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
|   &__archive_libsystem_sha512init,
|   &__archive_libsystem_sha512update,
|   &__archive_libsystem_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
|   &__archive_nettle_sha512init,
|   &__archive_nettle_sha512update,
|   &__archive_nettle_sha512final,
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
|   &__archive_openssl_sha512init,
|   &__archive_openssl_sha512update,
|   &__archive_openssl_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
|   &__archive_windowsapi_sha512init,
|   &__archive_windowsapi_sha512update,
|   &__archive_windowsapi_sha512final
| #elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
|   &__archive_stub_sha512init,
|   &__archive_stub_sha512update,
|   &__archive_stub_sha512final
| #endif
| };
| 
| int
| main(int argc, char **argv)
| {
|   archive_sha1_ctx ctx;
|   archive_sha1_init(&ctx);
|   archive_sha1_update(&ctx, *argv, argc);
|   archive_sha1_final(&ctx, NULL);
|   return 0;
| }
| 
configure:17399: result: no
configure:17413: checking support for ARCHIVE_CRYPTO_SHA256_LIBC
configure:17435: arm-linux-androideabi-gcc -o conftest    -I. -I. -I./libarchive  conftest.c -lz  >&5
In file included from conftest.c:206:0:
./libarchive/archive_crypto_private.h:78:18: fatal error: sha2.h: No such file or directory
 #include <sha2.h>
                  ^
compilation terminated.
configure:17435: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| #define ARCHIVE_SHA256_COMPILE_TEST
| #define ARCHIVE_CRYPTO_SHA256_LIBC
| #define PLATFORM_CONFIG_H "check_crypto_md.h"
| 
| /*-
| * Copyright (c) 2003-2007 Tim Kientzle
| * Copyright (c) 2011 Andres Mejia
| * Copyright (c) 2011 Michihiro NAKAJIMA
| * All rights reserved.
| *
| * Redistribution and use in source and binary forms, with or without
| * modification, are permitted provided that the following conditions
| * are met:
| * 1. Redistributions of source code must retain the above copyright
| *    notice, this list of conditions and the following disclaimer.
| * 2. Redistributions in binary form must reproduce the above copyright
| *    notice, this list of conditions and the following disclaimer in the
| *    documentation and/or other materials provided with the distribution.
| *
| * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
| * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
| * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
| * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
| * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
| * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
| * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
| * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
| * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
| * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
| */
| 
| #include "archive_platform.h"
| 
| #include "archive.h"
| #include "archive_crypto_private.h"
| 
| /* In particular, force the configure probe to break if it tries
|  * to test a combination of OpenSSL and libmd. */
| #if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
| #error Cannot use both OpenSSL and libmd.
| #endif
| 
| /*
|  * Message digest functions for Windows platform.
|  */
| #if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
| 	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
| 	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| /*
|  * Initialize a Message digest.
|  */
| static int
| win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
| {
| 
| 	ctx->valid = 0;
| 	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
| 		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
| 			return (ARCHIVE_FAILED);
| 		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
| 			return (ARCHIVE_FAILED);
| 	}
| 
| 	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
| 		CryptReleaseContext(ctx->cryptProv, 0);
| 		return (ARCHIVE_FAILED);
| 	}
| 
| 	ctx->valid = 1;
| 	return (ARCHIVE_OK);
| }
| 
| /*
|  * Update a Message digest.
|  */
| static int
| win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
| {
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptHashData(ctx->hash,
| 		      (unsigned char *)(uintptr_t)buf,
| 		      (DWORD)len, 0);
| 	return (ARCHIVE_OK);
| }
| 
| static int
| win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
| {
| 	DWORD siglen = (DWORD)bufsize;
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
| 	CryptDestroyHash(ctx->hash);
| 	CryptReleaseContext(ctx->cryptProv, 0);
| 	ctx->valid = 0;
| 	return (ARCHIVE_OK);
| }
| 
| #endif /* defined(ARCHIVE_CRYPTO_*_WIN) */
| 
| 
| /* MD5 implementations */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
| 
| static int
| __archive_libc_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
| 
| static int
| __archive_libmd_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
| 
| static int
| __archive_libsystem_md5init(archive_md5_ctx *ctx)
| {
|   CC_MD5_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_MD5_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
| {
|   CC_MD5_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
| 
| static int
| __archive_nettle_md5init(archive_md5_ctx *ctx)
| {
|   md5_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   md5_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
| {
|   md5_digest(ctx, MD5_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
| 
| static int
| __archive_openssl_md5init(archive_md5_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_md5());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
| 
| static int
| __archive_windowsapi_md5init(archive_md5_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_MD5));
| }
| 
| static int
| __archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 16, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_md5init(archive_md5_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5final(archive_md5_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* RIPEMD160 implementations */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
| 
| static int
| __archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RMD160Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RMD160Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RMD160Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
| 
| static int
| __archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RIPEMD160_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RIPEMD160_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RIPEMD160_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
| 
| static int
| __archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   ripemd160_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   ripemd160_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
| 
| static int
| __archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_ripemd160());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #else
| 
| static int
| __archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA1 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
| 
| static int
| __archive_libc_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
| 
| static int
| __archive_libmd_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha1init(archive_sha1_ctx *ctx)
| {
|   CC_SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   CC_SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
| 
| static int
| __archive_nettle_sha1init(archive_sha1_ctx *ctx)
| {
|   sha1_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha1_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
| 
| static int
| __archive_openssl_sha1init(archive_sha1_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha1());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
| 
| static int
| __archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA1));
| }
| 
| static int
| __archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 20, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha1init(archive_sha1_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA256 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
| 
| static int
| __archive_libc_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
| 
| static int
| __archive_libc2_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
| 
| static int
| __archive_libc3_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
| 
| static int
| __archive_libmd_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha256init(archive_sha256_ctx *ctx)
| {
|   CC_SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   CC_SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
| 
| static int
| __archive_nettle_sha256init(archive_sha256_ctx *ctx)
| {
|   sha256_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha256_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
| 
| static int
| __archive_openssl_sha256init(archive_sha256_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha256());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
| 
| static int
| __archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_256));
| }
| 
| static int
| __archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 32, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha256init(archive_sha256_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA384 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
| 
| static int
| __archive_libc_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
| 
| static int
| __archive_libc2_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
| 
| static int
| __archive_libc3_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha384init(archive_sha384_ctx *ctx)
| {
|   CC_SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   CC_SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
| 
| static int
| __archive_nettle_sha384init(archive_sha384_ctx *ctx)
| {
|   sha384_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha384_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
| 
| static int
| __archive_openssl_sha384init(archive_sha384_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha384());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
| 
| static int
| __archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_384));
| }
| 
| static int
| __archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 48, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha384init(archive_sha384_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA512 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
| 
| static int
| __archive_libc_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
| 
| static int
| __archive_libc2_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
| 
| static int
| __archive_libc3_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
| 
| static int
| __archive_libmd_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha512init(archive_sha512_ctx *ctx)
| {
|   CC_SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   CC_SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
| 
| static int
| __archive_nettle_sha512init(archive_sha512_ctx *ctx)
| {
|   sha512_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha512_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
| 
| static int
| __archive_openssl_sha512init(archive_sha512_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha512());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| static int
| __archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_512));
| }
| 
| static int
| __archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 64, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha512init(archive_sha512_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* NOTE: Crypto functions are set based on availability and by the following
|  * order of preference.
|  * 1. libc
|  * 2. libc2
|  * 3. libc3
|  * 4. libSystem
|  * 5. Nettle
|  * 6. OpenSSL
|  * 7. libmd
|  * 8. Windows API
|  */
| const struct archive_crypto __archive_crypto =
| {
| /* MD5 */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
|   &__archive_libc_md5init,
|   &__archive_libc_md5update,
|   &__archive_libc_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
|   &__archive_libmd_md5init,
|   &__archive_libmd_md5update,
|   &__archive_libmd_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
|   &__archive_libsystem_md5init,
|   &__archive_libsystem_md5update,
|   &__archive_libsystem_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
|   &__archive_nettle_md5init,
|   &__archive_nettle_md5update,
|   &__archive_nettle_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
|   &__archive_openssl_md5init,
|   &__archive_openssl_md5update,
|   &__archive_openssl_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
|   &__archive_windowsapi_md5init,
|   &__archive_windowsapi_md5update,
|   &__archive_windowsapi_md5final,
| #elif !defined(ARCHIVE_MD5_COMPILE_TEST)
|   &__archive_stub_md5init,
|   &__archive_stub_md5update,
|   &__archive_stub_md5final,
| #endif
| 
| /* RIPEMD160 */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
|   &__archive_libc_ripemd160init,
|   &__archive_libc_ripemd160update,
|   &__archive_libc_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
|   &__archive_libmd_ripemd160init,
|   &__archive_libmd_ripemd160update,
|   &__archive_libmd_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
|   &__archive_nettle_ripemd160init,
|   &__archive_nettle_ripemd160update,
|   &__archive_nettle_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
|   &__archive_openssl_ripemd160init,
|   &__archive_openssl_ripemd160update,
|   &__archive_openssl_ripemd160final,
| #elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
|   &__archive_stub_ripemd160init,
|   &__archive_stub_ripemd160update,
|   &__archive_stub_ripemd160final,
| #endif
| 
| /* SHA1 */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
|   &__archive_libc_sha1init,
|   &__archive_libc_sha1update,
|   &__archive_libc_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
|   &__archive_libmd_sha1init,
|   &__archive_libmd_sha1update,
|   &__archive_libmd_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
|   &__archive_libsystem_sha1init,
|   &__archive_libsystem_sha1update,
|   &__archive_libsystem_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
|   &__archive_nettle_sha1init,
|   &__archive_nettle_sha1update,
|   &__archive_nettle_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
|   &__archive_openssl_sha1init,
|   &__archive_openssl_sha1update,
|   &__archive_openssl_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
|   &__archive_windowsapi_sha1init,
|   &__archive_windowsapi_sha1update,
|   &__archive_windowsapi_sha1final,
| #elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
|   &__archive_stub_sha1init,
|   &__archive_stub_sha1update,
|   &__archive_stub_sha1final,
| #endif
| 
| /* SHA256 */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
|   &__archive_libc_sha256init,
|   &__archive_libc_sha256update,
|   &__archive_libc_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
|   &__archive_libc2_sha256init,
|   &__archive_libc2_sha256update,
|   &__archive_libc2_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
|   &__archive_libc3_sha256init,
|   &__archive_libc3_sha256update,
|   &__archive_libc3_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
|   &__archive_libmd_sha256init,
|   &__archive_libmd_sha256update,
|   &__archive_libmd_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
|   &__archive_libsystem_sha256init,
|   &__archive_libsystem_sha256update,
|   &__archive_libsystem_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
|   &__archive_nettle_sha256init,
|   &__archive_nettle_sha256update,
|   &__archive_nettle_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
|   &__archive_openssl_sha256init,
|   &__archive_openssl_sha256update,
|   &__archive_openssl_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
|   &__archive_windowsapi_sha256init,
|   &__archive_windowsapi_sha256update,
|   &__archive_windowsapi_sha256final,
| #elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
|   &__archive_stub_sha256init,
|   &__archive_stub_sha256update,
|   &__archive_stub_sha256final,
| #endif
| 
| /* SHA384 */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
|   &__archive_libc_sha384init,
|   &__archive_libc_sha384update,
|   &__archive_libc_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
|   &__archive_libc2_sha384init,
|   &__archive_libc2_sha384update,
|   &__archive_libc2_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
|   &__archive_libc3_sha384init,
|   &__archive_libc3_sha384update,
|   &__archive_libc3_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
|   &__archive_libsystem_sha384init,
|   &__archive_libsystem_sha384update,
|   &__archive_libsystem_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
|   &__archive_nettle_sha384init,
|   &__archive_nettle_sha384update,
|   &__archive_nettle_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
|   &__archive_openssl_sha384init,
|   &__archive_openssl_sha384update,
|   &__archive_openssl_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
|   &__archive_windowsapi_sha384init,
|   &__archive_windowsapi_sha384update,
|   &__archive_windowsapi_sha384final,
| #elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
|   &__archive_stub_sha384init,
|   &__archive_stub_sha384update,
|   &__archive_stub_sha384final,
| #endif
| 
| /* SHA512 */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
|   &__archive_libc_sha512init,
|   &__archive_libc_sha512update,
|   &__archive_libc_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
|   &__archive_libc2_sha512init,
|   &__archive_libc2_sha512update,
|   &__archive_libc2_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
|   &__archive_libc3_sha512init,
|   &__archive_libc3_sha512update,
|   &__archive_libc3_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
|   &__archive_libmd_sha512init,
|   &__archive_libmd_sha512update,
|   &__archive_libmd_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
|   &__archive_libsystem_sha512init,
|   &__archive_libsystem_sha512update,
|   &__archive_libsystem_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
|   &__archive_nettle_sha512init,
|   &__archive_nettle_sha512update,
|   &__archive_nettle_sha512final,
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
|   &__archive_openssl_sha512init,
|   &__archive_openssl_sha512update,
|   &__archive_openssl_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
|   &__archive_windowsapi_sha512init,
|   &__archive_windowsapi_sha512update,
|   &__archive_windowsapi_sha512final
| #elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
|   &__archive_stub_sha512init,
|   &__archive_stub_sha512update,
|   &__archive_stub_sha512final
| #endif
| };
| 
| int
| main(int argc, char **argv)
| {
|   archive_sha256_ctx ctx;
|   archive_sha256_init(&ctx);
|   archive_sha256_update(&ctx, *argv, argc);
|   archive_sha256_final(&ctx, NULL);
|   return 0;
| }
| 
configure:17445: result: no
configure:17459: checking support for ARCHIVE_CRYPTO_SHA256_LIBC2
configure:17481: arm-linux-androideabi-gcc -o conftest    -I. -I. -I./libarchive  conftest.c -lz  >&5
In file included from conftest.c:206:0:
./libarchive/archive_crypto_private.h:78:18: fatal error: sha2.h: No such file or directory
 #include <sha2.h>
                  ^
compilation terminated.
configure:17481: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| #define ARCHIVE_SHA256_COMPILE_TEST
| #define ARCHIVE_CRYPTO_SHA256_LIBC2
| #define PLATFORM_CONFIG_H "check_crypto_md.h"
| 
| /*-
| * Copyright (c) 2003-2007 Tim Kientzle
| * Copyright (c) 2011 Andres Mejia
| * Copyright (c) 2011 Michihiro NAKAJIMA
| * All rights reserved.
| *
| * Redistribution and use in source and binary forms, with or without
| * modification, are permitted provided that the following conditions
| * are met:
| * 1. Redistributions of source code must retain the above copyright
| *    notice, this list of conditions and the following disclaimer.
| * 2. Redistributions in binary form must reproduce the above copyright
| *    notice, this list of conditions and the following disclaimer in the
| *    documentation and/or other materials provided with the distribution.
| *
| * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
| * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
| * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
| * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
| * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
| * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
| * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
| * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
| * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
| * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
| */
| 
| #include "archive_platform.h"
| 
| #include "archive.h"
| #include "archive_crypto_private.h"
| 
| /* In particular, force the configure probe to break if it tries
|  * to test a combination of OpenSSL and libmd. */
| #if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
| #error Cannot use both OpenSSL and libmd.
| #endif
| 
| /*
|  * Message digest functions for Windows platform.
|  */
| #if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
| 	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
| 	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| /*
|  * Initialize a Message digest.
|  */
| static int
| win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
| {
| 
| 	ctx->valid = 0;
| 	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
| 		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
| 			return (ARCHIVE_FAILED);
| 		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
| 			return (ARCHIVE_FAILED);
| 	}
| 
| 	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
| 		CryptReleaseContext(ctx->cryptProv, 0);
| 		return (ARCHIVE_FAILED);
| 	}
| 
| 	ctx->valid = 1;
| 	return (ARCHIVE_OK);
| }
| 
| /*
|  * Update a Message digest.
|  */
| static int
| win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
| {
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptHashData(ctx->hash,
| 		      (unsigned char *)(uintptr_t)buf,
| 		      (DWORD)len, 0);
| 	return (ARCHIVE_OK);
| }
| 
| static int
| win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
| {
| 	DWORD siglen = (DWORD)bufsize;
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
| 	CryptDestroyHash(ctx->hash);
| 	CryptReleaseContext(ctx->cryptProv, 0);
| 	ctx->valid = 0;
| 	return (ARCHIVE_OK);
| }
| 
| #endif /* defined(ARCHIVE_CRYPTO_*_WIN) */
| 
| 
| /* MD5 implementations */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
| 
| static int
| __archive_libc_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
| 
| static int
| __archive_libmd_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
| 
| static int
| __archive_libsystem_md5init(archive_md5_ctx *ctx)
| {
|   CC_MD5_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_MD5_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
| {
|   CC_MD5_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
| 
| static int
| __archive_nettle_md5init(archive_md5_ctx *ctx)
| {
|   md5_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   md5_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
| {
|   md5_digest(ctx, MD5_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
| 
| static int
| __archive_openssl_md5init(archive_md5_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_md5());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
| 
| static int
| __archive_windowsapi_md5init(archive_md5_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_MD5));
| }
| 
| static int
| __archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 16, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_md5init(archive_md5_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5final(archive_md5_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* RIPEMD160 implementations */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
| 
| static int
| __archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RMD160Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RMD160Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RMD160Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
| 
| static int
| __archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RIPEMD160_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RIPEMD160_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RIPEMD160_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
| 
| static int
| __archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   ripemd160_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   ripemd160_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
| 
| static int
| __archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_ripemd160());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #else
| 
| static int
| __archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA1 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
| 
| static int
| __archive_libc_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
| 
| static int
| __archive_libmd_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha1init(archive_sha1_ctx *ctx)
| {
|   CC_SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   CC_SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
| 
| static int
| __archive_nettle_sha1init(archive_sha1_ctx *ctx)
| {
|   sha1_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha1_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
| 
| static int
| __archive_openssl_sha1init(archive_sha1_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha1());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
| 
| static int
| __archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA1));
| }
| 
| static int
| __archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 20, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha1init(archive_sha1_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA256 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
| 
| static int
| __archive_libc_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
| 
| static int
| __archive_libc2_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
| 
| static int
| __archive_libc3_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
| 
| static int
| __archive_libmd_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha256init(archive_sha256_ctx *ctx)
| {
|   CC_SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   CC_SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
| 
| static int
| __archive_nettle_sha256init(archive_sha256_ctx *ctx)
| {
|   sha256_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha256_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
| 
| static int
| __archive_openssl_sha256init(archive_sha256_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha256());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
| 
| static int
| __archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_256));
| }
| 
| static int
| __archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 32, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha256init(archive_sha256_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA384 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
| 
| static int
| __archive_libc_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
| 
| static int
| __archive_libc2_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
| 
| static int
| __archive_libc3_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha384init(archive_sha384_ctx *ctx)
| {
|   CC_SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   CC_SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
| 
| static int
| __archive_nettle_sha384init(archive_sha384_ctx *ctx)
| {
|   sha384_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha384_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
| 
| static int
| __archive_openssl_sha384init(archive_sha384_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha384());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
| 
| static int
| __archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_384));
| }
| 
| static int
| __archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 48, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha384init(archive_sha384_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA512 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
| 
| static int
| __archive_libc_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
| 
| static int
| __archive_libc2_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
| 
| static int
| __archive_libc3_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
| 
| static int
| __archive_libmd_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha512init(archive_sha512_ctx *ctx)
| {
|   CC_SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   CC_SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
| 
| static int
| __archive_nettle_sha512init(archive_sha512_ctx *ctx)
| {
|   sha512_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha512_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
| 
| static int
| __archive_openssl_sha512init(archive_sha512_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha512());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| static int
| __archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_512));
| }
| 
| static int
| __archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 64, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha512init(archive_sha512_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* NOTE: Crypto functions are set based on availability and by the following
|  * order of preference.
|  * 1. libc
|  * 2. libc2
|  * 3. libc3
|  * 4. libSystem
|  * 5. Nettle
|  * 6. OpenSSL
|  * 7. libmd
|  * 8. Windows API
|  */
| const struct archive_crypto __archive_crypto =
| {
| /* MD5 */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
|   &__archive_libc_md5init,
|   &__archive_libc_md5update,
|   &__archive_libc_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
|   &__archive_libmd_md5init,
|   &__archive_libmd_md5update,
|   &__archive_libmd_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
|   &__archive_libsystem_md5init,
|   &__archive_libsystem_md5update,
|   &__archive_libsystem_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
|   &__archive_nettle_md5init,
|   &__archive_nettle_md5update,
|   &__archive_nettle_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
|   &__archive_openssl_md5init,
|   &__archive_openssl_md5update,
|   &__archive_openssl_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
|   &__archive_windowsapi_md5init,
|   &__archive_windowsapi_md5update,
|   &__archive_windowsapi_md5final,
| #elif !defined(ARCHIVE_MD5_COMPILE_TEST)
|   &__archive_stub_md5init,
|   &__archive_stub_md5update,
|   &__archive_stub_md5final,
| #endif
| 
| /* RIPEMD160 */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
|   &__archive_libc_ripemd160init,
|   &__archive_libc_ripemd160update,
|   &__archive_libc_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
|   &__archive_libmd_ripemd160init,
|   &__archive_libmd_ripemd160update,
|   &__archive_libmd_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
|   &__archive_nettle_ripemd160init,
|   &__archive_nettle_ripemd160update,
|   &__archive_nettle_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
|   &__archive_openssl_ripemd160init,
|   &__archive_openssl_ripemd160update,
|   &__archive_openssl_ripemd160final,
| #elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
|   &__archive_stub_ripemd160init,
|   &__archive_stub_ripemd160update,
|   &__archive_stub_ripemd160final,
| #endif
| 
| /* SHA1 */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
|   &__archive_libc_sha1init,
|   &__archive_libc_sha1update,
|   &__archive_libc_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
|   &__archive_libmd_sha1init,
|   &__archive_libmd_sha1update,
|   &__archive_libmd_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
|   &__archive_libsystem_sha1init,
|   &__archive_libsystem_sha1update,
|   &__archive_libsystem_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
|   &__archive_nettle_sha1init,
|   &__archive_nettle_sha1update,
|   &__archive_nettle_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
|   &__archive_openssl_sha1init,
|   &__archive_openssl_sha1update,
|   &__archive_openssl_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
|   &__archive_windowsapi_sha1init,
|   &__archive_windowsapi_sha1update,
|   &__archive_windowsapi_sha1final,
| #elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
|   &__archive_stub_sha1init,
|   &__archive_stub_sha1update,
|   &__archive_stub_sha1final,
| #endif
| 
| /* SHA256 */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
|   &__archive_libc_sha256init,
|   &__archive_libc_sha256update,
|   &__archive_libc_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
|   &__archive_libc2_sha256init,
|   &__archive_libc2_sha256update,
|   &__archive_libc2_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
|   &__archive_libc3_sha256init,
|   &__archive_libc3_sha256update,
|   &__archive_libc3_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
|   &__archive_libmd_sha256init,
|   &__archive_libmd_sha256update,
|   &__archive_libmd_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
|   &__archive_libsystem_sha256init,
|   &__archive_libsystem_sha256update,
|   &__archive_libsystem_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
|   &__archive_nettle_sha256init,
|   &__archive_nettle_sha256update,
|   &__archive_nettle_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
|   &__archive_openssl_sha256init,
|   &__archive_openssl_sha256update,
|   &__archive_openssl_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
|   &__archive_windowsapi_sha256init,
|   &__archive_windowsapi_sha256update,
|   &__archive_windowsapi_sha256final,
| #elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
|   &__archive_stub_sha256init,
|   &__archive_stub_sha256update,
|   &__archive_stub_sha256final,
| #endif
| 
| /* SHA384 */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
|   &__archive_libc_sha384init,
|   &__archive_libc_sha384update,
|   &__archive_libc_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
|   &__archive_libc2_sha384init,
|   &__archive_libc2_sha384update,
|   &__archive_libc2_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
|   &__archive_libc3_sha384init,
|   &__archive_libc3_sha384update,
|   &__archive_libc3_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
|   &__archive_libsystem_sha384init,
|   &__archive_libsystem_sha384update,
|   &__archive_libsystem_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
|   &__archive_nettle_sha384init,
|   &__archive_nettle_sha384update,
|   &__archive_nettle_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
|   &__archive_openssl_sha384init,
|   &__archive_openssl_sha384update,
|   &__archive_openssl_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
|   &__archive_windowsapi_sha384init,
|   &__archive_windowsapi_sha384update,
|   &__archive_windowsapi_sha384final,
| #elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
|   &__archive_stub_sha384init,
|   &__archive_stub_sha384update,
|   &__archive_stub_sha384final,
| #endif
| 
| /* SHA512 */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
|   &__archive_libc_sha512init,
|   &__archive_libc_sha512update,
|   &__archive_libc_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
|   &__archive_libc2_sha512init,
|   &__archive_libc2_sha512update,
|   &__archive_libc2_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
|   &__archive_libc3_sha512init,
|   &__archive_libc3_sha512update,
|   &__archive_libc3_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
|   &__archive_libmd_sha512init,
|   &__archive_libmd_sha512update,
|   &__archive_libmd_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
|   &__archive_libsystem_sha512init,
|   &__archive_libsystem_sha512update,
|   &__archive_libsystem_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
|   &__archive_nettle_sha512init,
|   &__archive_nettle_sha512update,
|   &__archive_nettle_sha512final,
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
|   &__archive_openssl_sha512init,
|   &__archive_openssl_sha512update,
|   &__archive_openssl_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
|   &__archive_windowsapi_sha512init,
|   &__archive_windowsapi_sha512update,
|   &__archive_windowsapi_sha512final
| #elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
|   &__archive_stub_sha512init,
|   &__archive_stub_sha512update,
|   &__archive_stub_sha512final
| #endif
| };
| 
| int
| main(int argc, char **argv)
| {
|   archive_sha256_ctx ctx;
|   archive_sha256_init(&ctx);
|   archive_sha256_update(&ctx, *argv, argc);
|   archive_sha256_final(&ctx, NULL);
|   return 0;
| }
| 
configure:17491: result: no
configure:17505: checking support for ARCHIVE_CRYPTO_SHA256_LIBC3
configure:17527: arm-linux-androideabi-gcc -o conftest    -I. -I. -I./libarchive  conftest.c -lz  >&5
In file included from conftest.c:206:0:
./libarchive/archive_crypto_private.h:78:18: fatal error: sha2.h: No such file or directory
 #include <sha2.h>
                  ^
compilation terminated.
configure:17527: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| #define ARCHIVE_SHA256_COMPILE_TEST
| #define ARCHIVE_CRYPTO_SHA256_LIBC3
| #define PLATFORM_CONFIG_H "check_crypto_md.h"
| 
| /*-
| * Copyright (c) 2003-2007 Tim Kientzle
| * Copyright (c) 2011 Andres Mejia
| * Copyright (c) 2011 Michihiro NAKAJIMA
| * All rights reserved.
| *
| * Redistribution and use in source and binary forms, with or without
| * modification, are permitted provided that the following conditions
| * are met:
| * 1. Redistributions of source code must retain the above copyright
| *    notice, this list of conditions and the following disclaimer.
| * 2. Redistributions in binary form must reproduce the above copyright
| *    notice, this list of conditions and the following disclaimer in the
| *    documentation and/or other materials provided with the distribution.
| *
| * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
| * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
| * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
| * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
| * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
| * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
| * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
| * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
| * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
| * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
| */
| 
| #include "archive_platform.h"
| 
| #include "archive.h"
| #include "archive_crypto_private.h"
| 
| /* In particular, force the configure probe to break if it tries
|  * to test a combination of OpenSSL and libmd. */
| #if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
| #error Cannot use both OpenSSL and libmd.
| #endif
| 
| /*
|  * Message digest functions for Windows platform.
|  */
| #if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
| 	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
| 	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| /*
|  * Initialize a Message digest.
|  */
| static int
| win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
| {
| 
| 	ctx->valid = 0;
| 	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
| 		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
| 			return (ARCHIVE_FAILED);
| 		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
| 			return (ARCHIVE_FAILED);
| 	}
| 
| 	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
| 		CryptReleaseContext(ctx->cryptProv, 0);
| 		return (ARCHIVE_FAILED);
| 	}
| 
| 	ctx->valid = 1;
| 	return (ARCHIVE_OK);
| }
| 
| /*
|  * Update a Message digest.
|  */
| static int
| win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
| {
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptHashData(ctx->hash,
| 		      (unsigned char *)(uintptr_t)buf,
| 		      (DWORD)len, 0);
| 	return (ARCHIVE_OK);
| }
| 
| static int
| win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
| {
| 	DWORD siglen = (DWORD)bufsize;
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
| 	CryptDestroyHash(ctx->hash);
| 	CryptReleaseContext(ctx->cryptProv, 0);
| 	ctx->valid = 0;
| 	return (ARCHIVE_OK);
| }
| 
| #endif /* defined(ARCHIVE_CRYPTO_*_WIN) */
| 
| 
| /* MD5 implementations */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
| 
| static int
| __archive_libc_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
| 
| static int
| __archive_libmd_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
| 
| static int
| __archive_libsystem_md5init(archive_md5_ctx *ctx)
| {
|   CC_MD5_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_MD5_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
| {
|   CC_MD5_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
| 
| static int
| __archive_nettle_md5init(archive_md5_ctx *ctx)
| {
|   md5_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   md5_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
| {
|   md5_digest(ctx, MD5_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
| 
| static int
| __archive_openssl_md5init(archive_md5_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_md5());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
| 
| static int
| __archive_windowsapi_md5init(archive_md5_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_MD5));
| }
| 
| static int
| __archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 16, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_md5init(archive_md5_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5final(archive_md5_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* RIPEMD160 implementations */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
| 
| static int
| __archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RMD160Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RMD160Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RMD160Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
| 
| static int
| __archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RIPEMD160_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RIPEMD160_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RIPEMD160_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
| 
| static int
| __archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   ripemd160_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   ripemd160_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
| 
| static int
| __archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_ripemd160());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #else
| 
| static int
| __archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA1 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
| 
| static int
| __archive_libc_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
| 
| static int
| __archive_libmd_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha1init(archive_sha1_ctx *ctx)
| {
|   CC_SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   CC_SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
| 
| static int
| __archive_nettle_sha1init(archive_sha1_ctx *ctx)
| {
|   sha1_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha1_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
| 
| static int
| __archive_openssl_sha1init(archive_sha1_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha1());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
| 
| static int
| __archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA1));
| }
| 
| static int
| __archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 20, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha1init(archive_sha1_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA256 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
| 
| static int
| __archive_libc_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
| 
| static int
| __archive_libc2_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
| 
| static int
| __archive_libc3_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
| 
| static int
| __archive_libmd_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha256init(archive_sha256_ctx *ctx)
| {
|   CC_SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   CC_SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
| 
| static int
| __archive_nettle_sha256init(archive_sha256_ctx *ctx)
| {
|   sha256_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha256_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
| 
| static int
| __archive_openssl_sha256init(archive_sha256_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha256());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
| 
| static int
| __archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_256));
| }
| 
| static int
| __archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 32, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha256init(archive_sha256_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA384 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
| 
| static int
| __archive_libc_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
| 
| static int
| __archive_libc2_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
| 
| static int
| __archive_libc3_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha384init(archive_sha384_ctx *ctx)
| {
|   CC_SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   CC_SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
| 
| static int
| __archive_nettle_sha384init(archive_sha384_ctx *ctx)
| {
|   sha384_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha384_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
| 
| static int
| __archive_openssl_sha384init(archive_sha384_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha384());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
| 
| static int
| __archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_384));
| }
| 
| static int
| __archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 48, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha384init(archive_sha384_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA512 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
| 
| static int
| __archive_libc_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
| 
| static int
| __archive_libc2_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
| 
| static int
| __archive_libc3_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
| 
| static int
| __archive_libmd_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha512init(archive_sha512_ctx *ctx)
| {
|   CC_SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   CC_SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
| 
| static int
| __archive_nettle_sha512init(archive_sha512_ctx *ctx)
| {
|   sha512_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha512_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
| 
| static int
| __archive_openssl_sha512init(archive_sha512_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha512());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| static int
| __archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_512));
| }
| 
| static int
| __archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 64, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha512init(archive_sha512_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* NOTE: Crypto functions are set based on availability and by the following
|  * order of preference.
|  * 1. libc
|  * 2. libc2
|  * 3. libc3
|  * 4. libSystem
|  * 5. Nettle
|  * 6. OpenSSL
|  * 7. libmd
|  * 8. Windows API
|  */
| const struct archive_crypto __archive_crypto =
| {
| /* MD5 */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
|   &__archive_libc_md5init,
|   &__archive_libc_md5update,
|   &__archive_libc_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
|   &__archive_libmd_md5init,
|   &__archive_libmd_md5update,
|   &__archive_libmd_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
|   &__archive_libsystem_md5init,
|   &__archive_libsystem_md5update,
|   &__archive_libsystem_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
|   &__archive_nettle_md5init,
|   &__archive_nettle_md5update,
|   &__archive_nettle_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
|   &__archive_openssl_md5init,
|   &__archive_openssl_md5update,
|   &__archive_openssl_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
|   &__archive_windowsapi_md5init,
|   &__archive_windowsapi_md5update,
|   &__archive_windowsapi_md5final,
| #elif !defined(ARCHIVE_MD5_COMPILE_TEST)
|   &__archive_stub_md5init,
|   &__archive_stub_md5update,
|   &__archive_stub_md5final,
| #endif
| 
| /* RIPEMD160 */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
|   &__archive_libc_ripemd160init,
|   &__archive_libc_ripemd160update,
|   &__archive_libc_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
|   &__archive_libmd_ripemd160init,
|   &__archive_libmd_ripemd160update,
|   &__archive_libmd_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
|   &__archive_nettle_ripemd160init,
|   &__archive_nettle_ripemd160update,
|   &__archive_nettle_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
|   &__archive_openssl_ripemd160init,
|   &__archive_openssl_ripemd160update,
|   &__archive_openssl_ripemd160final,
| #elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
|   &__archive_stub_ripemd160init,
|   &__archive_stub_ripemd160update,
|   &__archive_stub_ripemd160final,
| #endif
| 
| /* SHA1 */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
|   &__archive_libc_sha1init,
|   &__archive_libc_sha1update,
|   &__archive_libc_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
|   &__archive_libmd_sha1init,
|   &__archive_libmd_sha1update,
|   &__archive_libmd_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
|   &__archive_libsystem_sha1init,
|   &__archive_libsystem_sha1update,
|   &__archive_libsystem_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
|   &__archive_nettle_sha1init,
|   &__archive_nettle_sha1update,
|   &__archive_nettle_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
|   &__archive_openssl_sha1init,
|   &__archive_openssl_sha1update,
|   &__archive_openssl_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
|   &__archive_windowsapi_sha1init,
|   &__archive_windowsapi_sha1update,
|   &__archive_windowsapi_sha1final,
| #elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
|   &__archive_stub_sha1init,
|   &__archive_stub_sha1update,
|   &__archive_stub_sha1final,
| #endif
| 
| /* SHA256 */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
|   &__archive_libc_sha256init,
|   &__archive_libc_sha256update,
|   &__archive_libc_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
|   &__archive_libc2_sha256init,
|   &__archive_libc2_sha256update,
|   &__archive_libc2_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
|   &__archive_libc3_sha256init,
|   &__archive_libc3_sha256update,
|   &__archive_libc3_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
|   &__archive_libmd_sha256init,
|   &__archive_libmd_sha256update,
|   &__archive_libmd_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
|   &__archive_libsystem_sha256init,
|   &__archive_libsystem_sha256update,
|   &__archive_libsystem_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
|   &__archive_nettle_sha256init,
|   &__archive_nettle_sha256update,
|   &__archive_nettle_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
|   &__archive_openssl_sha256init,
|   &__archive_openssl_sha256update,
|   &__archive_openssl_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
|   &__archive_windowsapi_sha256init,
|   &__archive_windowsapi_sha256update,
|   &__archive_windowsapi_sha256final,
| #elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
|   &__archive_stub_sha256init,
|   &__archive_stub_sha256update,
|   &__archive_stub_sha256final,
| #endif
| 
| /* SHA384 */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
|   &__archive_libc_sha384init,
|   &__archive_libc_sha384update,
|   &__archive_libc_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
|   &__archive_libc2_sha384init,
|   &__archive_libc2_sha384update,
|   &__archive_libc2_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
|   &__archive_libc3_sha384init,
|   &__archive_libc3_sha384update,
|   &__archive_libc3_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
|   &__archive_libsystem_sha384init,
|   &__archive_libsystem_sha384update,
|   &__archive_libsystem_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
|   &__archive_nettle_sha384init,
|   &__archive_nettle_sha384update,
|   &__archive_nettle_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
|   &__archive_openssl_sha384init,
|   &__archive_openssl_sha384update,
|   &__archive_openssl_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
|   &__archive_windowsapi_sha384init,
|   &__archive_windowsapi_sha384update,
|   &__archive_windowsapi_sha384final,
| #elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
|   &__archive_stub_sha384init,
|   &__archive_stub_sha384update,
|   &__archive_stub_sha384final,
| #endif
| 
| /* SHA512 */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
|   &__archive_libc_sha512init,
|   &__archive_libc_sha512update,
|   &__archive_libc_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
|   &__archive_libc2_sha512init,
|   &__archive_libc2_sha512update,
|   &__archive_libc2_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
|   &__archive_libc3_sha512init,
|   &__archive_libc3_sha512update,
|   &__archive_libc3_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
|   &__archive_libmd_sha512init,
|   &__archive_libmd_sha512update,
|   &__archive_libmd_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
|   &__archive_libsystem_sha512init,
|   &__archive_libsystem_sha512update,
|   &__archive_libsystem_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
|   &__archive_nettle_sha512init,
|   &__archive_nettle_sha512update,
|   &__archive_nettle_sha512final,
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
|   &__archive_openssl_sha512init,
|   &__archive_openssl_sha512update,
|   &__archive_openssl_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
|   &__archive_windowsapi_sha512init,
|   &__archive_windowsapi_sha512update,
|   &__archive_windowsapi_sha512final
| #elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
|   &__archive_stub_sha512init,
|   &__archive_stub_sha512update,
|   &__archive_stub_sha512final
| #endif
| };
| 
| int
| main(int argc, char **argv)
| {
|   archive_sha256_ctx ctx;
|   archive_sha256_init(&ctx);
|   archive_sha256_update(&ctx, *argv, argc);
|   archive_sha256_final(&ctx, NULL);
|   return 0;
| }
| 
configure:17537: result: no
configure:17551: checking support for ARCHIVE_CRYPTO_SHA256_LIBSYSTEM
configure:17573: arm-linux-androideabi-gcc -o conftest    -I. -I. -I./libarchive  conftest.c -lz  >&5
In file included from conftest.c:206:0:
./libarchive/archive_crypto_private.h:112:39: fatal error: CommonCrypto/CommonDigest.h: No such file or directory
 #include <CommonCrypto/CommonDigest.h>
                                       ^
compilation terminated.
configure:17573: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| #define ARCHIVE_SHA256_COMPILE_TEST
| #define ARCHIVE_CRYPTO_SHA256_LIBSYSTEM
| #define PLATFORM_CONFIG_H "check_crypto_md.h"
| 
| /*-
| * Copyright (c) 2003-2007 Tim Kientzle
| * Copyright (c) 2011 Andres Mejia
| * Copyright (c) 2011 Michihiro NAKAJIMA
| * All rights reserved.
| *
| * Redistribution and use in source and binary forms, with or without
| * modification, are permitted provided that the following conditions
| * are met:
| * 1. Redistributions of source code must retain the above copyright
| *    notice, this list of conditions and the following disclaimer.
| * 2. Redistributions in binary form must reproduce the above copyright
| *    notice, this list of conditions and the following disclaimer in the
| *    documentation and/or other materials provided with the distribution.
| *
| * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
| * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
| * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
| * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
| * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
| * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
| * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
| * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
| * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
| * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
| */
| 
| #include "archive_platform.h"
| 
| #include "archive.h"
| #include "archive_crypto_private.h"
| 
| /* In particular, force the configure probe to break if it tries
|  * to test a combination of OpenSSL and libmd. */
| #if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
| #error Cannot use both OpenSSL and libmd.
| #endif
| 
| /*
|  * Message digest functions for Windows platform.
|  */
| #if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
| 	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
| 	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| /*
|  * Initialize a Message digest.
|  */
| static int
| win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
| {
| 
| 	ctx->valid = 0;
| 	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
| 		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
| 			return (ARCHIVE_FAILED);
| 		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
| 			return (ARCHIVE_FAILED);
| 	}
| 
| 	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
| 		CryptReleaseContext(ctx->cryptProv, 0);
| 		return (ARCHIVE_FAILED);
| 	}
| 
| 	ctx->valid = 1;
| 	return (ARCHIVE_OK);
| }
| 
| /*
|  * Update a Message digest.
|  */
| static int
| win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
| {
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptHashData(ctx->hash,
| 		      (unsigned char *)(uintptr_t)buf,
| 		      (DWORD)len, 0);
| 	return (ARCHIVE_OK);
| }
| 
| static int
| win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
| {
| 	DWORD siglen = (DWORD)bufsize;
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
| 	CryptDestroyHash(ctx->hash);
| 	CryptReleaseContext(ctx->cryptProv, 0);
| 	ctx->valid = 0;
| 	return (ARCHIVE_OK);
| }
| 
| #endif /* defined(ARCHIVE_CRYPTO_*_WIN) */
| 
| 
| /* MD5 implementations */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
| 
| static int
| __archive_libc_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
| 
| static int
| __archive_libmd_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
| 
| static int
| __archive_libsystem_md5init(archive_md5_ctx *ctx)
| {
|   CC_MD5_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_MD5_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
| {
|   CC_MD5_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
| 
| static int
| __archive_nettle_md5init(archive_md5_ctx *ctx)
| {
|   md5_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   md5_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
| {
|   md5_digest(ctx, MD5_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
| 
| static int
| __archive_openssl_md5init(archive_md5_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_md5());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
| 
| static int
| __archive_windowsapi_md5init(archive_md5_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_MD5));
| }
| 
| static int
| __archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 16, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_md5init(archive_md5_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5final(archive_md5_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* RIPEMD160 implementations */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
| 
| static int
| __archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RMD160Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RMD160Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RMD160Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
| 
| static int
| __archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RIPEMD160_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RIPEMD160_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RIPEMD160_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
| 
| static int
| __archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   ripemd160_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   ripemd160_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
| 
| static int
| __archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_ripemd160());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #else
| 
| static int
| __archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA1 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
| 
| static int
| __archive_libc_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
| 
| static int
| __archive_libmd_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha1init(archive_sha1_ctx *ctx)
| {
|   CC_SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   CC_SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
| 
| static int
| __archive_nettle_sha1init(archive_sha1_ctx *ctx)
| {
|   sha1_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha1_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
| 
| static int
| __archive_openssl_sha1init(archive_sha1_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha1());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
| 
| static int
| __archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA1));
| }
| 
| static int
| __archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 20, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha1init(archive_sha1_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA256 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
| 
| static int
| __archive_libc_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
| 
| static int
| __archive_libc2_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
| 
| static int
| __archive_libc3_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
| 
| static int
| __archive_libmd_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha256init(archive_sha256_ctx *ctx)
| {
|   CC_SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   CC_SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
| 
| static int
| __archive_nettle_sha256init(archive_sha256_ctx *ctx)
| {
|   sha256_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha256_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
| 
| static int
| __archive_openssl_sha256init(archive_sha256_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha256());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
| 
| static int
| __archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_256));
| }
| 
| static int
| __archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 32, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha256init(archive_sha256_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA384 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
| 
| static int
| __archive_libc_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
| 
| static int
| __archive_libc2_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
| 
| static int
| __archive_libc3_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha384init(archive_sha384_ctx *ctx)
| {
|   CC_SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   CC_SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
| 
| static int
| __archive_nettle_sha384init(archive_sha384_ctx *ctx)
| {
|   sha384_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha384_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
| 
| static int
| __archive_openssl_sha384init(archive_sha384_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha384());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
| 
| static int
| __archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_384));
| }
| 
| static int
| __archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 48, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha384init(archive_sha384_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA512 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
| 
| static int
| __archive_libc_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
| 
| static int
| __archive_libc2_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
| 
| static int
| __archive_libc3_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
| 
| static int
| __archive_libmd_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha512init(archive_sha512_ctx *ctx)
| {
|   CC_SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   CC_SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
| 
| static int
| __archive_nettle_sha512init(archive_sha512_ctx *ctx)
| {
|   sha512_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha512_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
| 
| static int
| __archive_openssl_sha512init(archive_sha512_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha512());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| static int
| __archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_512));
| }
| 
| static int
| __archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 64, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha512init(archive_sha512_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* NOTE: Crypto functions are set based on availability and by the following
|  * order of preference.
|  * 1. libc
|  * 2. libc2
|  * 3. libc3
|  * 4. libSystem
|  * 5. Nettle
|  * 6. OpenSSL
|  * 7. libmd
|  * 8. Windows API
|  */
| const struct archive_crypto __archive_crypto =
| {
| /* MD5 */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
|   &__archive_libc_md5init,
|   &__archive_libc_md5update,
|   &__archive_libc_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
|   &__archive_libmd_md5init,
|   &__archive_libmd_md5update,
|   &__archive_libmd_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
|   &__archive_libsystem_md5init,
|   &__archive_libsystem_md5update,
|   &__archive_libsystem_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
|   &__archive_nettle_md5init,
|   &__archive_nettle_md5update,
|   &__archive_nettle_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
|   &__archive_openssl_md5init,
|   &__archive_openssl_md5update,
|   &__archive_openssl_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
|   &__archive_windowsapi_md5init,
|   &__archive_windowsapi_md5update,
|   &__archive_windowsapi_md5final,
| #elif !defined(ARCHIVE_MD5_COMPILE_TEST)
|   &__archive_stub_md5init,
|   &__archive_stub_md5update,
|   &__archive_stub_md5final,
| #endif
| 
| /* RIPEMD160 */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
|   &__archive_libc_ripemd160init,
|   &__archive_libc_ripemd160update,
|   &__archive_libc_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
|   &__archive_libmd_ripemd160init,
|   &__archive_libmd_ripemd160update,
|   &__archive_libmd_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
|   &__archive_nettle_ripemd160init,
|   &__archive_nettle_ripemd160update,
|   &__archive_nettle_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
|   &__archive_openssl_ripemd160init,
|   &__archive_openssl_ripemd160update,
|   &__archive_openssl_ripemd160final,
| #elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
|   &__archive_stub_ripemd160init,
|   &__archive_stub_ripemd160update,
|   &__archive_stub_ripemd160final,
| #endif
| 
| /* SHA1 */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
|   &__archive_libc_sha1init,
|   &__archive_libc_sha1update,
|   &__archive_libc_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
|   &__archive_libmd_sha1init,
|   &__archive_libmd_sha1update,
|   &__archive_libmd_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
|   &__archive_libsystem_sha1init,
|   &__archive_libsystem_sha1update,
|   &__archive_libsystem_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
|   &__archive_nettle_sha1init,
|   &__archive_nettle_sha1update,
|   &__archive_nettle_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
|   &__archive_openssl_sha1init,
|   &__archive_openssl_sha1update,
|   &__archive_openssl_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
|   &__archive_windowsapi_sha1init,
|   &__archive_windowsapi_sha1update,
|   &__archive_windowsapi_sha1final,
| #elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
|   &__archive_stub_sha1init,
|   &__archive_stub_sha1update,
|   &__archive_stub_sha1final,
| #endif
| 
| /* SHA256 */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
|   &__archive_libc_sha256init,
|   &__archive_libc_sha256update,
|   &__archive_libc_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
|   &__archive_libc2_sha256init,
|   &__archive_libc2_sha256update,
|   &__archive_libc2_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
|   &__archive_libc3_sha256init,
|   &__archive_libc3_sha256update,
|   &__archive_libc3_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
|   &__archive_libmd_sha256init,
|   &__archive_libmd_sha256update,
|   &__archive_libmd_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
|   &__archive_libsystem_sha256init,
|   &__archive_libsystem_sha256update,
|   &__archive_libsystem_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
|   &__archive_nettle_sha256init,
|   &__archive_nettle_sha256update,
|   &__archive_nettle_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
|   &__archive_openssl_sha256init,
|   &__archive_openssl_sha256update,
|   &__archive_openssl_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
|   &__archive_windowsapi_sha256init,
|   &__archive_windowsapi_sha256update,
|   &__archive_windowsapi_sha256final,
| #elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
|   &__archive_stub_sha256init,
|   &__archive_stub_sha256update,
|   &__archive_stub_sha256final,
| #endif
| 
| /* SHA384 */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
|   &__archive_libc_sha384init,
|   &__archive_libc_sha384update,
|   &__archive_libc_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
|   &__archive_libc2_sha384init,
|   &__archive_libc2_sha384update,
|   &__archive_libc2_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
|   &__archive_libc3_sha384init,
|   &__archive_libc3_sha384update,
|   &__archive_libc3_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
|   &__archive_libsystem_sha384init,
|   &__archive_libsystem_sha384update,
|   &__archive_libsystem_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
|   &__archive_nettle_sha384init,
|   &__archive_nettle_sha384update,
|   &__archive_nettle_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
|   &__archive_openssl_sha384init,
|   &__archive_openssl_sha384update,
|   &__archive_openssl_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
|   &__archive_windowsapi_sha384init,
|   &__archive_windowsapi_sha384update,
|   &__archive_windowsapi_sha384final,
| #elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
|   &__archive_stub_sha384init,
|   &__archive_stub_sha384update,
|   &__archive_stub_sha384final,
| #endif
| 
| /* SHA512 */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
|   &__archive_libc_sha512init,
|   &__archive_libc_sha512update,
|   &__archive_libc_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
|   &__archive_libc2_sha512init,
|   &__archive_libc2_sha512update,
|   &__archive_libc2_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
|   &__archive_libc3_sha512init,
|   &__archive_libc3_sha512update,
|   &__archive_libc3_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
|   &__archive_libmd_sha512init,
|   &__archive_libmd_sha512update,
|   &__archive_libmd_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
|   &__archive_libsystem_sha512init,
|   &__archive_libsystem_sha512update,
|   &__archive_libsystem_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
|   &__archive_nettle_sha512init,
|   &__archive_nettle_sha512update,
|   &__archive_nettle_sha512final,
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
|   &__archive_openssl_sha512init,
|   &__archive_openssl_sha512update,
|   &__archive_openssl_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
|   &__archive_windowsapi_sha512init,
|   &__archive_windowsapi_sha512update,
|   &__archive_windowsapi_sha512final
| #elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
|   &__archive_stub_sha512init,
|   &__archive_stub_sha512update,
|   &__archive_stub_sha512final
| #endif
| };
| 
| int
| main(int argc, char **argv)
| {
|   archive_sha256_ctx ctx;
|   archive_sha256_init(&ctx);
|   archive_sha256_update(&ctx, *argv, argc);
|   archive_sha256_final(&ctx, NULL);
|   return 0;
| }
| 
configure:17583: result: no
configure:17597: checking support for ARCHIVE_CRYPTO_SHA384_LIBC
configure:17619: arm-linux-androideabi-gcc -o conftest    -I. -I. -I./libarchive  conftest.c -lz  >&5
In file included from conftest.c:206:0:
./libarchive/archive_crypto_private.h:78:18: fatal error: sha2.h: No such file or directory
 #include <sha2.h>
                  ^
compilation terminated.
configure:17619: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| #define ARCHIVE_SHA384_COMPILE_TEST
| #define ARCHIVE_CRYPTO_SHA384_LIBC
| #define PLATFORM_CONFIG_H "check_crypto_md.h"
| 
| /*-
| * Copyright (c) 2003-2007 Tim Kientzle
| * Copyright (c) 2011 Andres Mejia
| * Copyright (c) 2011 Michihiro NAKAJIMA
| * All rights reserved.
| *
| * Redistribution and use in source and binary forms, with or without
| * modification, are permitted provided that the following conditions
| * are met:
| * 1. Redistributions of source code must retain the above copyright
| *    notice, this list of conditions and the following disclaimer.
| * 2. Redistributions in binary form must reproduce the above copyright
| *    notice, this list of conditions and the following disclaimer in the
| *    documentation and/or other materials provided with the distribution.
| *
| * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
| * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
| * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
| * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
| * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
| * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
| * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
| * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
| * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
| * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
| */
| 
| #include "archive_platform.h"
| 
| #include "archive.h"
| #include "archive_crypto_private.h"
| 
| /* In particular, force the configure probe to break if it tries
|  * to test a combination of OpenSSL and libmd. */
| #if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
| #error Cannot use both OpenSSL and libmd.
| #endif
| 
| /*
|  * Message digest functions for Windows platform.
|  */
| #if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
| 	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
| 	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| /*
|  * Initialize a Message digest.
|  */
| static int
| win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
| {
| 
| 	ctx->valid = 0;
| 	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
| 		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
| 			return (ARCHIVE_FAILED);
| 		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
| 			return (ARCHIVE_FAILED);
| 	}
| 
| 	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
| 		CryptReleaseContext(ctx->cryptProv, 0);
| 		return (ARCHIVE_FAILED);
| 	}
| 
| 	ctx->valid = 1;
| 	return (ARCHIVE_OK);
| }
| 
| /*
|  * Update a Message digest.
|  */
| static int
| win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
| {
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptHashData(ctx->hash,
| 		      (unsigned char *)(uintptr_t)buf,
| 		      (DWORD)len, 0);
| 	return (ARCHIVE_OK);
| }
| 
| static int
| win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
| {
| 	DWORD siglen = (DWORD)bufsize;
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
| 	CryptDestroyHash(ctx->hash);
| 	CryptReleaseContext(ctx->cryptProv, 0);
| 	ctx->valid = 0;
| 	return (ARCHIVE_OK);
| }
| 
| #endif /* defined(ARCHIVE_CRYPTO_*_WIN) */
| 
| 
| /* MD5 implementations */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
| 
| static int
| __archive_libc_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
| 
| static int
| __archive_libmd_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
| 
| static int
| __archive_libsystem_md5init(archive_md5_ctx *ctx)
| {
|   CC_MD5_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_MD5_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
| {
|   CC_MD5_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
| 
| static int
| __archive_nettle_md5init(archive_md5_ctx *ctx)
| {
|   md5_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   md5_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
| {
|   md5_digest(ctx, MD5_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
| 
| static int
| __archive_openssl_md5init(archive_md5_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_md5());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
| 
| static int
| __archive_windowsapi_md5init(archive_md5_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_MD5));
| }
| 
| static int
| __archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 16, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_md5init(archive_md5_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5final(archive_md5_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* RIPEMD160 implementations */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
| 
| static int
| __archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RMD160Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RMD160Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RMD160Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
| 
| static int
| __archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RIPEMD160_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RIPEMD160_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RIPEMD160_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
| 
| static int
| __archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   ripemd160_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   ripemd160_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
| 
| static int
| __archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_ripemd160());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #else
| 
| static int
| __archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA1 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
| 
| static int
| __archive_libc_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
| 
| static int
| __archive_libmd_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha1init(archive_sha1_ctx *ctx)
| {
|   CC_SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   CC_SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
| 
| static int
| __archive_nettle_sha1init(archive_sha1_ctx *ctx)
| {
|   sha1_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha1_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
| 
| static int
| __archive_openssl_sha1init(archive_sha1_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha1());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
| 
| static int
| __archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA1));
| }
| 
| static int
| __archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 20, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha1init(archive_sha1_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA256 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
| 
| static int
| __archive_libc_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
| 
| static int
| __archive_libc2_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
| 
| static int
| __archive_libc3_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
| 
| static int
| __archive_libmd_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha256init(archive_sha256_ctx *ctx)
| {
|   CC_SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   CC_SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
| 
| static int
| __archive_nettle_sha256init(archive_sha256_ctx *ctx)
| {
|   sha256_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha256_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
| 
| static int
| __archive_openssl_sha256init(archive_sha256_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha256());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
| 
| static int
| __archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_256));
| }
| 
| static int
| __archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 32, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha256init(archive_sha256_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA384 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
| 
| static int
| __archive_libc_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
| 
| static int
| __archive_libc2_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
| 
| static int
| __archive_libc3_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha384init(archive_sha384_ctx *ctx)
| {
|   CC_SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   CC_SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
| 
| static int
| __archive_nettle_sha384init(archive_sha384_ctx *ctx)
| {
|   sha384_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha384_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
| 
| static int
| __archive_openssl_sha384init(archive_sha384_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha384());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
| 
| static int
| __archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_384));
| }
| 
| static int
| __archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 48, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha384init(archive_sha384_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA512 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
| 
| static int
| __archive_libc_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
| 
| static int
| __archive_libc2_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
| 
| static int
| __archive_libc3_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
| 
| static int
| __archive_libmd_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha512init(archive_sha512_ctx *ctx)
| {
|   CC_SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   CC_SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
| 
| static int
| __archive_nettle_sha512init(archive_sha512_ctx *ctx)
| {
|   sha512_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha512_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
| 
| static int
| __archive_openssl_sha512init(archive_sha512_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha512());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| static int
| __archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_512));
| }
| 
| static int
| __archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 64, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha512init(archive_sha512_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* NOTE: Crypto functions are set based on availability and by the following
|  * order of preference.
|  * 1. libc
|  * 2. libc2
|  * 3. libc3
|  * 4. libSystem
|  * 5. Nettle
|  * 6. OpenSSL
|  * 7. libmd
|  * 8. Windows API
|  */
| const struct archive_crypto __archive_crypto =
| {
| /* MD5 */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
|   &__archive_libc_md5init,
|   &__archive_libc_md5update,
|   &__archive_libc_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
|   &__archive_libmd_md5init,
|   &__archive_libmd_md5update,
|   &__archive_libmd_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
|   &__archive_libsystem_md5init,
|   &__archive_libsystem_md5update,
|   &__archive_libsystem_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
|   &__archive_nettle_md5init,
|   &__archive_nettle_md5update,
|   &__archive_nettle_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
|   &__archive_openssl_md5init,
|   &__archive_openssl_md5update,
|   &__archive_openssl_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
|   &__archive_windowsapi_md5init,
|   &__archive_windowsapi_md5update,
|   &__archive_windowsapi_md5final,
| #elif !defined(ARCHIVE_MD5_COMPILE_TEST)
|   &__archive_stub_md5init,
|   &__archive_stub_md5update,
|   &__archive_stub_md5final,
| #endif
| 
| /* RIPEMD160 */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
|   &__archive_libc_ripemd160init,
|   &__archive_libc_ripemd160update,
|   &__archive_libc_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
|   &__archive_libmd_ripemd160init,
|   &__archive_libmd_ripemd160update,
|   &__archive_libmd_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
|   &__archive_nettle_ripemd160init,
|   &__archive_nettle_ripemd160update,
|   &__archive_nettle_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
|   &__archive_openssl_ripemd160init,
|   &__archive_openssl_ripemd160update,
|   &__archive_openssl_ripemd160final,
| #elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
|   &__archive_stub_ripemd160init,
|   &__archive_stub_ripemd160update,
|   &__archive_stub_ripemd160final,
| #endif
| 
| /* SHA1 */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
|   &__archive_libc_sha1init,
|   &__archive_libc_sha1update,
|   &__archive_libc_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
|   &__archive_libmd_sha1init,
|   &__archive_libmd_sha1update,
|   &__archive_libmd_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
|   &__archive_libsystem_sha1init,
|   &__archive_libsystem_sha1update,
|   &__archive_libsystem_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
|   &__archive_nettle_sha1init,
|   &__archive_nettle_sha1update,
|   &__archive_nettle_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
|   &__archive_openssl_sha1init,
|   &__archive_openssl_sha1update,
|   &__archive_openssl_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
|   &__archive_windowsapi_sha1init,
|   &__archive_windowsapi_sha1update,
|   &__archive_windowsapi_sha1final,
| #elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
|   &__archive_stub_sha1init,
|   &__archive_stub_sha1update,
|   &__archive_stub_sha1final,
| #endif
| 
| /* SHA256 */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
|   &__archive_libc_sha256init,
|   &__archive_libc_sha256update,
|   &__archive_libc_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
|   &__archive_libc2_sha256init,
|   &__archive_libc2_sha256update,
|   &__archive_libc2_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
|   &__archive_libc3_sha256init,
|   &__archive_libc3_sha256update,
|   &__archive_libc3_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
|   &__archive_libmd_sha256init,
|   &__archive_libmd_sha256update,
|   &__archive_libmd_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
|   &__archive_libsystem_sha256init,
|   &__archive_libsystem_sha256update,
|   &__archive_libsystem_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
|   &__archive_nettle_sha256init,
|   &__archive_nettle_sha256update,
|   &__archive_nettle_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
|   &__archive_openssl_sha256init,
|   &__archive_openssl_sha256update,
|   &__archive_openssl_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
|   &__archive_windowsapi_sha256init,
|   &__archive_windowsapi_sha256update,
|   &__archive_windowsapi_sha256final,
| #elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
|   &__archive_stub_sha256init,
|   &__archive_stub_sha256update,
|   &__archive_stub_sha256final,
| #endif
| 
| /* SHA384 */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
|   &__archive_libc_sha384init,
|   &__archive_libc_sha384update,
|   &__archive_libc_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
|   &__archive_libc2_sha384init,
|   &__archive_libc2_sha384update,
|   &__archive_libc2_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
|   &__archive_libc3_sha384init,
|   &__archive_libc3_sha384update,
|   &__archive_libc3_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
|   &__archive_libsystem_sha384init,
|   &__archive_libsystem_sha384update,
|   &__archive_libsystem_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
|   &__archive_nettle_sha384init,
|   &__archive_nettle_sha384update,
|   &__archive_nettle_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
|   &__archive_openssl_sha384init,
|   &__archive_openssl_sha384update,
|   &__archive_openssl_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
|   &__archive_windowsapi_sha384init,
|   &__archive_windowsapi_sha384update,
|   &__archive_windowsapi_sha384final,
| #elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
|   &__archive_stub_sha384init,
|   &__archive_stub_sha384update,
|   &__archive_stub_sha384final,
| #endif
| 
| /* SHA512 */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
|   &__archive_libc_sha512init,
|   &__archive_libc_sha512update,
|   &__archive_libc_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
|   &__archive_libc2_sha512init,
|   &__archive_libc2_sha512update,
|   &__archive_libc2_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
|   &__archive_libc3_sha512init,
|   &__archive_libc3_sha512update,
|   &__archive_libc3_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
|   &__archive_libmd_sha512init,
|   &__archive_libmd_sha512update,
|   &__archive_libmd_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
|   &__archive_libsystem_sha512init,
|   &__archive_libsystem_sha512update,
|   &__archive_libsystem_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
|   &__archive_nettle_sha512init,
|   &__archive_nettle_sha512update,
|   &__archive_nettle_sha512final,
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
|   &__archive_openssl_sha512init,
|   &__archive_openssl_sha512update,
|   &__archive_openssl_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
|   &__archive_windowsapi_sha512init,
|   &__archive_windowsapi_sha512update,
|   &__archive_windowsapi_sha512final
| #elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
|   &__archive_stub_sha512init,
|   &__archive_stub_sha512update,
|   &__archive_stub_sha512final
| #endif
| };
| 
| int
| main(int argc, char **argv)
| {
|   archive_sha384_ctx ctx;
|   archive_sha384_init(&ctx);
|   archive_sha384_update(&ctx, *argv, argc);
|   archive_sha384_final(&ctx, NULL);
|   return 0;
| }
| 
configure:17629: result: no
configure:17643: checking support for ARCHIVE_CRYPTO_SHA384_LIBC2
configure:17665: arm-linux-androideabi-gcc -o conftest    -I. -I. -I./libarchive  conftest.c -lz  >&5
In file included from conftest.c:206:0:
./libarchive/archive_crypto_private.h:78:18: fatal error: sha2.h: No such file or directory
 #include <sha2.h>
                  ^
compilation terminated.
configure:17665: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| #define ARCHIVE_SHA384_COMPILE_TEST
| #define ARCHIVE_CRYPTO_SHA384_LIBC2
| #define PLATFORM_CONFIG_H "check_crypto_md.h"
| 
| /*-
| * Copyright (c) 2003-2007 Tim Kientzle
| * Copyright (c) 2011 Andres Mejia
| * Copyright (c) 2011 Michihiro NAKAJIMA
| * All rights reserved.
| *
| * Redistribution and use in source and binary forms, with or without
| * modification, are permitted provided that the following conditions
| * are met:
| * 1. Redistributions of source code must retain the above copyright
| *    notice, this list of conditions and the following disclaimer.
| * 2. Redistributions in binary form must reproduce the above copyright
| *    notice, this list of conditions and the following disclaimer in the
| *    documentation and/or other materials provided with the distribution.
| *
| * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
| * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
| * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
| * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
| * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
| * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
| * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
| * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
| * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
| * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
| */
| 
| #include "archive_platform.h"
| 
| #include "archive.h"
| #include "archive_crypto_private.h"
| 
| /* In particular, force the configure probe to break if it tries
|  * to test a combination of OpenSSL and libmd. */
| #if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
| #error Cannot use both OpenSSL and libmd.
| #endif
| 
| /*
|  * Message digest functions for Windows platform.
|  */
| #if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
| 	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
| 	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| /*
|  * Initialize a Message digest.
|  */
| static int
| win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
| {
| 
| 	ctx->valid = 0;
| 	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
| 		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
| 			return (ARCHIVE_FAILED);
| 		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
| 			return (ARCHIVE_FAILED);
| 	}
| 
| 	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
| 		CryptReleaseContext(ctx->cryptProv, 0);
| 		return (ARCHIVE_FAILED);
| 	}
| 
| 	ctx->valid = 1;
| 	return (ARCHIVE_OK);
| }
| 
| /*
|  * Update a Message digest.
|  */
| static int
| win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
| {
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptHashData(ctx->hash,
| 		      (unsigned char *)(uintptr_t)buf,
| 		      (DWORD)len, 0);
| 	return (ARCHIVE_OK);
| }
| 
| static int
| win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
| {
| 	DWORD siglen = (DWORD)bufsize;
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
| 	CryptDestroyHash(ctx->hash);
| 	CryptReleaseContext(ctx->cryptProv, 0);
| 	ctx->valid = 0;
| 	return (ARCHIVE_OK);
| }
| 
| #endif /* defined(ARCHIVE_CRYPTO_*_WIN) */
| 
| 
| /* MD5 implementations */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
| 
| static int
| __archive_libc_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
| 
| static int
| __archive_libmd_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
| 
| static int
| __archive_libsystem_md5init(archive_md5_ctx *ctx)
| {
|   CC_MD5_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_MD5_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
| {
|   CC_MD5_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
| 
| static int
| __archive_nettle_md5init(archive_md5_ctx *ctx)
| {
|   md5_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   md5_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
| {
|   md5_digest(ctx, MD5_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
| 
| static int
| __archive_openssl_md5init(archive_md5_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_md5());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
| 
| static int
| __archive_windowsapi_md5init(archive_md5_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_MD5));
| }
| 
| static int
| __archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 16, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_md5init(archive_md5_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5final(archive_md5_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* RIPEMD160 implementations */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
| 
| static int
| __archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RMD160Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RMD160Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RMD160Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
| 
| static int
| __archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RIPEMD160_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RIPEMD160_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RIPEMD160_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
| 
| static int
| __archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   ripemd160_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   ripemd160_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
| 
| static int
| __archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_ripemd160());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #else
| 
| static int
| __archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA1 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
| 
| static int
| __archive_libc_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
| 
| static int
| __archive_libmd_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha1init(archive_sha1_ctx *ctx)
| {
|   CC_SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   CC_SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
| 
| static int
| __archive_nettle_sha1init(archive_sha1_ctx *ctx)
| {
|   sha1_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha1_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
| 
| static int
| __archive_openssl_sha1init(archive_sha1_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha1());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
| 
| static int
| __archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA1));
| }
| 
| static int
| __archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 20, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha1init(archive_sha1_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA256 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
| 
| static int
| __archive_libc_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
| 
| static int
| __archive_libc2_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
| 
| static int
| __archive_libc3_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
| 
| static int
| __archive_libmd_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha256init(archive_sha256_ctx *ctx)
| {
|   CC_SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   CC_SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
| 
| static int
| __archive_nettle_sha256init(archive_sha256_ctx *ctx)
| {
|   sha256_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha256_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
| 
| static int
| __archive_openssl_sha256init(archive_sha256_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha256());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
| 
| static int
| __archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_256));
| }
| 
| static int
| __archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 32, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha256init(archive_sha256_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA384 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
| 
| static int
| __archive_libc_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
| 
| static int
| __archive_libc2_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
| 
| static int
| __archive_libc3_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha384init(archive_sha384_ctx *ctx)
| {
|   CC_SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   CC_SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
| 
| static int
| __archive_nettle_sha384init(archive_sha384_ctx *ctx)
| {
|   sha384_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha384_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
| 
| static int
| __archive_openssl_sha384init(archive_sha384_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha384());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
| 
| static int
| __archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_384));
| }
| 
| static int
| __archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 48, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha384init(archive_sha384_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA512 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
| 
| static int
| __archive_libc_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
| 
| static int
| __archive_libc2_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
| 
| static int
| __archive_libc3_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
| 
| static int
| __archive_libmd_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha512init(archive_sha512_ctx *ctx)
| {
|   CC_SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   CC_SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
| 
| static int
| __archive_nettle_sha512init(archive_sha512_ctx *ctx)
| {
|   sha512_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha512_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
| 
| static int
| __archive_openssl_sha512init(archive_sha512_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha512());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| static int
| __archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_512));
| }
| 
| static int
| __archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 64, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha512init(archive_sha512_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* NOTE: Crypto functions are set based on availability and by the following
|  * order of preference.
|  * 1. libc
|  * 2. libc2
|  * 3. libc3
|  * 4. libSystem
|  * 5. Nettle
|  * 6. OpenSSL
|  * 7. libmd
|  * 8. Windows API
|  */
| const struct archive_crypto __archive_crypto =
| {
| /* MD5 */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
|   &__archive_libc_md5init,
|   &__archive_libc_md5update,
|   &__archive_libc_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
|   &__archive_libmd_md5init,
|   &__archive_libmd_md5update,
|   &__archive_libmd_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
|   &__archive_libsystem_md5init,
|   &__archive_libsystem_md5update,
|   &__archive_libsystem_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
|   &__archive_nettle_md5init,
|   &__archive_nettle_md5update,
|   &__archive_nettle_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
|   &__archive_openssl_md5init,
|   &__archive_openssl_md5update,
|   &__archive_openssl_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
|   &__archive_windowsapi_md5init,
|   &__archive_windowsapi_md5update,
|   &__archive_windowsapi_md5final,
| #elif !defined(ARCHIVE_MD5_COMPILE_TEST)
|   &__archive_stub_md5init,
|   &__archive_stub_md5update,
|   &__archive_stub_md5final,
| #endif
| 
| /* RIPEMD160 */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
|   &__archive_libc_ripemd160init,
|   &__archive_libc_ripemd160update,
|   &__archive_libc_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
|   &__archive_libmd_ripemd160init,
|   &__archive_libmd_ripemd160update,
|   &__archive_libmd_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
|   &__archive_nettle_ripemd160init,
|   &__archive_nettle_ripemd160update,
|   &__archive_nettle_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
|   &__archive_openssl_ripemd160init,
|   &__archive_openssl_ripemd160update,
|   &__archive_openssl_ripemd160final,
| #elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
|   &__archive_stub_ripemd160init,
|   &__archive_stub_ripemd160update,
|   &__archive_stub_ripemd160final,
| #endif
| 
| /* SHA1 */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
|   &__archive_libc_sha1init,
|   &__archive_libc_sha1update,
|   &__archive_libc_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
|   &__archive_libmd_sha1init,
|   &__archive_libmd_sha1update,
|   &__archive_libmd_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
|   &__archive_libsystem_sha1init,
|   &__archive_libsystem_sha1update,
|   &__archive_libsystem_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
|   &__archive_nettle_sha1init,
|   &__archive_nettle_sha1update,
|   &__archive_nettle_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
|   &__archive_openssl_sha1init,
|   &__archive_openssl_sha1update,
|   &__archive_openssl_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
|   &__archive_windowsapi_sha1init,
|   &__archive_windowsapi_sha1update,
|   &__archive_windowsapi_sha1final,
| #elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
|   &__archive_stub_sha1init,
|   &__archive_stub_sha1update,
|   &__archive_stub_sha1final,
| #endif
| 
| /* SHA256 */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
|   &__archive_libc_sha256init,
|   &__archive_libc_sha256update,
|   &__archive_libc_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
|   &__archive_libc2_sha256init,
|   &__archive_libc2_sha256update,
|   &__archive_libc2_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
|   &__archive_libc3_sha256init,
|   &__archive_libc3_sha256update,
|   &__archive_libc3_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
|   &__archive_libmd_sha256init,
|   &__archive_libmd_sha256update,
|   &__archive_libmd_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
|   &__archive_libsystem_sha256init,
|   &__archive_libsystem_sha256update,
|   &__archive_libsystem_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
|   &__archive_nettle_sha256init,
|   &__archive_nettle_sha256update,
|   &__archive_nettle_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
|   &__archive_openssl_sha256init,
|   &__archive_openssl_sha256update,
|   &__archive_openssl_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
|   &__archive_windowsapi_sha256init,
|   &__archive_windowsapi_sha256update,
|   &__archive_windowsapi_sha256final,
| #elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
|   &__archive_stub_sha256init,
|   &__archive_stub_sha256update,
|   &__archive_stub_sha256final,
| #endif
| 
| /* SHA384 */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
|   &__archive_libc_sha384init,
|   &__archive_libc_sha384update,
|   &__archive_libc_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
|   &__archive_libc2_sha384init,
|   &__archive_libc2_sha384update,
|   &__archive_libc2_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
|   &__archive_libc3_sha384init,
|   &__archive_libc3_sha384update,
|   &__archive_libc3_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
|   &__archive_libsystem_sha384init,
|   &__archive_libsystem_sha384update,
|   &__archive_libsystem_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
|   &__archive_nettle_sha384init,
|   &__archive_nettle_sha384update,
|   &__archive_nettle_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
|   &__archive_openssl_sha384init,
|   &__archive_openssl_sha384update,
|   &__archive_openssl_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
|   &__archive_windowsapi_sha384init,
|   &__archive_windowsapi_sha384update,
|   &__archive_windowsapi_sha384final,
| #elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
|   &__archive_stub_sha384init,
|   &__archive_stub_sha384update,
|   &__archive_stub_sha384final,
| #endif
| 
| /* SHA512 */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
|   &__archive_libc_sha512init,
|   &__archive_libc_sha512update,
|   &__archive_libc_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
|   &__archive_libc2_sha512init,
|   &__archive_libc2_sha512update,
|   &__archive_libc2_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
|   &__archive_libc3_sha512init,
|   &__archive_libc3_sha512update,
|   &__archive_libc3_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
|   &__archive_libmd_sha512init,
|   &__archive_libmd_sha512update,
|   &__archive_libmd_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
|   &__archive_libsystem_sha512init,
|   &__archive_libsystem_sha512update,
|   &__archive_libsystem_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
|   &__archive_nettle_sha512init,
|   &__archive_nettle_sha512update,
|   &__archive_nettle_sha512final,
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
|   &__archive_openssl_sha512init,
|   &__archive_openssl_sha512update,
|   &__archive_openssl_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
|   &__archive_windowsapi_sha512init,
|   &__archive_windowsapi_sha512update,
|   &__archive_windowsapi_sha512final
| #elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
|   &__archive_stub_sha512init,
|   &__archive_stub_sha512update,
|   &__archive_stub_sha512final
| #endif
| };
| 
| int
| main(int argc, char **argv)
| {
|   archive_sha384_ctx ctx;
|   archive_sha384_init(&ctx);
|   archive_sha384_update(&ctx, *argv, argc);
|   archive_sha384_final(&ctx, NULL);
|   return 0;
| }
| 
configure:17675: result: no
configure:17689: checking support for ARCHIVE_CRYPTO_SHA384_LIBC3
configure:17711: arm-linux-androideabi-gcc -o conftest    -I. -I. -I./libarchive  conftest.c -lz  >&5
In file included from conftest.c:206:0:
./libarchive/archive_crypto_private.h:78:18: fatal error: sha2.h: No such file or directory
 #include <sha2.h>
                  ^
compilation terminated.
configure:17711: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| #define ARCHIVE_SHA384_COMPILE_TEST
| #define ARCHIVE_CRYPTO_SHA384_LIBC3
| #define PLATFORM_CONFIG_H "check_crypto_md.h"
| 
| /*-
| * Copyright (c) 2003-2007 Tim Kientzle
| * Copyright (c) 2011 Andres Mejia
| * Copyright (c) 2011 Michihiro NAKAJIMA
| * All rights reserved.
| *
| * Redistribution and use in source and binary forms, with or without
| * modification, are permitted provided that the following conditions
| * are met:
| * 1. Redistributions of source code must retain the above copyright
| *    notice, this list of conditions and the following disclaimer.
| * 2. Redistributions in binary form must reproduce the above copyright
| *    notice, this list of conditions and the following disclaimer in the
| *    documentation and/or other materials provided with the distribution.
| *
| * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
| * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
| * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
| * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
| * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
| * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
| * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
| * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
| * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
| * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
| */
| 
| #include "archive_platform.h"
| 
| #include "archive.h"
| #include "archive_crypto_private.h"
| 
| /* In particular, force the configure probe to break if it tries
|  * to test a combination of OpenSSL and libmd. */
| #if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
| #error Cannot use both OpenSSL and libmd.
| #endif
| 
| /*
|  * Message digest functions for Windows platform.
|  */
| #if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
| 	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
| 	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| /*
|  * Initialize a Message digest.
|  */
| static int
| win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
| {
| 
| 	ctx->valid = 0;
| 	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
| 		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
| 			return (ARCHIVE_FAILED);
| 		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
| 			return (ARCHIVE_FAILED);
| 	}
| 
| 	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
| 		CryptReleaseContext(ctx->cryptProv, 0);
| 		return (ARCHIVE_FAILED);
| 	}
| 
| 	ctx->valid = 1;
| 	return (ARCHIVE_OK);
| }
| 
| /*
|  * Update a Message digest.
|  */
| static int
| win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
| {
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptHashData(ctx->hash,
| 		      (unsigned char *)(uintptr_t)buf,
| 		      (DWORD)len, 0);
| 	return (ARCHIVE_OK);
| }
| 
| static int
| win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
| {
| 	DWORD siglen = (DWORD)bufsize;
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
| 	CryptDestroyHash(ctx->hash);
| 	CryptReleaseContext(ctx->cryptProv, 0);
| 	ctx->valid = 0;
| 	return (ARCHIVE_OK);
| }
| 
| #endif /* defined(ARCHIVE_CRYPTO_*_WIN) */
| 
| 
| /* MD5 implementations */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
| 
| static int
| __archive_libc_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
| 
| static int
| __archive_libmd_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
| 
| static int
| __archive_libsystem_md5init(archive_md5_ctx *ctx)
| {
|   CC_MD5_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_MD5_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
| {
|   CC_MD5_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
| 
| static int
| __archive_nettle_md5init(archive_md5_ctx *ctx)
| {
|   md5_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   md5_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
| {
|   md5_digest(ctx, MD5_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
| 
| static int
| __archive_openssl_md5init(archive_md5_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_md5());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
| 
| static int
| __archive_windowsapi_md5init(archive_md5_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_MD5));
| }
| 
| static int
| __archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 16, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_md5init(archive_md5_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5final(archive_md5_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* RIPEMD160 implementations */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
| 
| static int
| __archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RMD160Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RMD160Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RMD160Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
| 
| static int
| __archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RIPEMD160_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RIPEMD160_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RIPEMD160_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
| 
| static int
| __archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   ripemd160_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   ripemd160_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
| 
| static int
| __archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_ripemd160());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #else
| 
| static int
| __archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA1 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
| 
| static int
| __archive_libc_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
| 
| static int
| __archive_libmd_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha1init(archive_sha1_ctx *ctx)
| {
|   CC_SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   CC_SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
| 
| static int
| __archive_nettle_sha1init(archive_sha1_ctx *ctx)
| {
|   sha1_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha1_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
| 
| static int
| __archive_openssl_sha1init(archive_sha1_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha1());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
| 
| static int
| __archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA1));
| }
| 
| static int
| __archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 20, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha1init(archive_sha1_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA256 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
| 
| static int
| __archive_libc_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
| 
| static int
| __archive_libc2_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
| 
| static int
| __archive_libc3_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
| 
| static int
| __archive_libmd_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha256init(archive_sha256_ctx *ctx)
| {
|   CC_SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   CC_SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
| 
| static int
| __archive_nettle_sha256init(archive_sha256_ctx *ctx)
| {
|   sha256_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha256_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
| 
| static int
| __archive_openssl_sha256init(archive_sha256_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha256());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
| 
| static int
| __archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_256));
| }
| 
| static int
| __archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 32, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha256init(archive_sha256_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA384 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
| 
| static int
| __archive_libc_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
| 
| static int
| __archive_libc2_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
| 
| static int
| __archive_libc3_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha384init(archive_sha384_ctx *ctx)
| {
|   CC_SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   CC_SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
| 
| static int
| __archive_nettle_sha384init(archive_sha384_ctx *ctx)
| {
|   sha384_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha384_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
| 
| static int
| __archive_openssl_sha384init(archive_sha384_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha384());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
| 
| static int
| __archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_384));
| }
| 
| static int
| __archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 48, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha384init(archive_sha384_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA512 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
| 
| static int
| __archive_libc_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
| 
| static int
| __archive_libc2_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
| 
| static int
| __archive_libc3_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
| 
| static int
| __archive_libmd_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha512init(archive_sha512_ctx *ctx)
| {
|   CC_SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   CC_SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
| 
| static int
| __archive_nettle_sha512init(archive_sha512_ctx *ctx)
| {
|   sha512_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha512_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
| 
| static int
| __archive_openssl_sha512init(archive_sha512_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha512());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| static int
| __archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_512));
| }
| 
| static int
| __archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 64, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha512init(archive_sha512_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* NOTE: Crypto functions are set based on availability and by the following
|  * order of preference.
|  * 1. libc
|  * 2. libc2
|  * 3. libc3
|  * 4. libSystem
|  * 5. Nettle
|  * 6. OpenSSL
|  * 7. libmd
|  * 8. Windows API
|  */
| const struct archive_crypto __archive_crypto =
| {
| /* MD5 */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
|   &__archive_libc_md5init,
|   &__archive_libc_md5update,
|   &__archive_libc_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
|   &__archive_libmd_md5init,
|   &__archive_libmd_md5update,
|   &__archive_libmd_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
|   &__archive_libsystem_md5init,
|   &__archive_libsystem_md5update,
|   &__archive_libsystem_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
|   &__archive_nettle_md5init,
|   &__archive_nettle_md5update,
|   &__archive_nettle_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
|   &__archive_openssl_md5init,
|   &__archive_openssl_md5update,
|   &__archive_openssl_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
|   &__archive_windowsapi_md5init,
|   &__archive_windowsapi_md5update,
|   &__archive_windowsapi_md5final,
| #elif !defined(ARCHIVE_MD5_COMPILE_TEST)
|   &__archive_stub_md5init,
|   &__archive_stub_md5update,
|   &__archive_stub_md5final,
| #endif
| 
| /* RIPEMD160 */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
|   &__archive_libc_ripemd160init,
|   &__archive_libc_ripemd160update,
|   &__archive_libc_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
|   &__archive_libmd_ripemd160init,
|   &__archive_libmd_ripemd160update,
|   &__archive_libmd_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
|   &__archive_nettle_ripemd160init,
|   &__archive_nettle_ripemd160update,
|   &__archive_nettle_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
|   &__archive_openssl_ripemd160init,
|   &__archive_openssl_ripemd160update,
|   &__archive_openssl_ripemd160final,
| #elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
|   &__archive_stub_ripemd160init,
|   &__archive_stub_ripemd160update,
|   &__archive_stub_ripemd160final,
| #endif
| 
| /* SHA1 */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
|   &__archive_libc_sha1init,
|   &__archive_libc_sha1update,
|   &__archive_libc_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
|   &__archive_libmd_sha1init,
|   &__archive_libmd_sha1update,
|   &__archive_libmd_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
|   &__archive_libsystem_sha1init,
|   &__archive_libsystem_sha1update,
|   &__archive_libsystem_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
|   &__archive_nettle_sha1init,
|   &__archive_nettle_sha1update,
|   &__archive_nettle_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
|   &__archive_openssl_sha1init,
|   &__archive_openssl_sha1update,
|   &__archive_openssl_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
|   &__archive_windowsapi_sha1init,
|   &__archive_windowsapi_sha1update,
|   &__archive_windowsapi_sha1final,
| #elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
|   &__archive_stub_sha1init,
|   &__archive_stub_sha1update,
|   &__archive_stub_sha1final,
| #endif
| 
| /* SHA256 */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
|   &__archive_libc_sha256init,
|   &__archive_libc_sha256update,
|   &__archive_libc_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
|   &__archive_libc2_sha256init,
|   &__archive_libc2_sha256update,
|   &__archive_libc2_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
|   &__archive_libc3_sha256init,
|   &__archive_libc3_sha256update,
|   &__archive_libc3_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
|   &__archive_libmd_sha256init,
|   &__archive_libmd_sha256update,
|   &__archive_libmd_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
|   &__archive_libsystem_sha256init,
|   &__archive_libsystem_sha256update,
|   &__archive_libsystem_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
|   &__archive_nettle_sha256init,
|   &__archive_nettle_sha256update,
|   &__archive_nettle_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
|   &__archive_openssl_sha256init,
|   &__archive_openssl_sha256update,
|   &__archive_openssl_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
|   &__archive_windowsapi_sha256init,
|   &__archive_windowsapi_sha256update,
|   &__archive_windowsapi_sha256final,
| #elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
|   &__archive_stub_sha256init,
|   &__archive_stub_sha256update,
|   &__archive_stub_sha256final,
| #endif
| 
| /* SHA384 */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
|   &__archive_libc_sha384init,
|   &__archive_libc_sha384update,
|   &__archive_libc_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
|   &__archive_libc2_sha384init,
|   &__archive_libc2_sha384update,
|   &__archive_libc2_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
|   &__archive_libc3_sha384init,
|   &__archive_libc3_sha384update,
|   &__archive_libc3_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
|   &__archive_libsystem_sha384init,
|   &__archive_libsystem_sha384update,
|   &__archive_libsystem_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
|   &__archive_nettle_sha384init,
|   &__archive_nettle_sha384update,
|   &__archive_nettle_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
|   &__archive_openssl_sha384init,
|   &__archive_openssl_sha384update,
|   &__archive_openssl_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
|   &__archive_windowsapi_sha384init,
|   &__archive_windowsapi_sha384update,
|   &__archive_windowsapi_sha384final,
| #elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
|   &__archive_stub_sha384init,
|   &__archive_stub_sha384update,
|   &__archive_stub_sha384final,
| #endif
| 
| /* SHA512 */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
|   &__archive_libc_sha512init,
|   &__archive_libc_sha512update,
|   &__archive_libc_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
|   &__archive_libc2_sha512init,
|   &__archive_libc2_sha512update,
|   &__archive_libc2_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
|   &__archive_libc3_sha512init,
|   &__archive_libc3_sha512update,
|   &__archive_libc3_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
|   &__archive_libmd_sha512init,
|   &__archive_libmd_sha512update,
|   &__archive_libmd_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
|   &__archive_libsystem_sha512init,
|   &__archive_libsystem_sha512update,
|   &__archive_libsystem_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
|   &__archive_nettle_sha512init,
|   &__archive_nettle_sha512update,
|   &__archive_nettle_sha512final,
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
|   &__archive_openssl_sha512init,
|   &__archive_openssl_sha512update,
|   &__archive_openssl_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
|   &__archive_windowsapi_sha512init,
|   &__archive_windowsapi_sha512update,
|   &__archive_windowsapi_sha512final
| #elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
|   &__archive_stub_sha512init,
|   &__archive_stub_sha512update,
|   &__archive_stub_sha512final
| #endif
| };
| 
| int
| main(int argc, char **argv)
| {
|   archive_sha384_ctx ctx;
|   archive_sha384_init(&ctx);
|   archive_sha384_update(&ctx, *argv, argc);
|   archive_sha384_final(&ctx, NULL);
|   return 0;
| }
| 
configure:17721: result: no
configure:17735: checking support for ARCHIVE_CRYPTO_SHA384_LIBSYSTEM
configure:17757: arm-linux-androideabi-gcc -o conftest    -I. -I. -I./libarchive  conftest.c -lz  >&5
In file included from conftest.c:206:0:
./libarchive/archive_crypto_private.h:112:39: fatal error: CommonCrypto/CommonDigest.h: No such file or directory
 #include <CommonCrypto/CommonDigest.h>
                                       ^
compilation terminated.
configure:17757: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| #define ARCHIVE_SHA384_COMPILE_TEST
| #define ARCHIVE_CRYPTO_SHA384_LIBSYSTEM
| #define PLATFORM_CONFIG_H "check_crypto_md.h"
| 
| /*-
| * Copyright (c) 2003-2007 Tim Kientzle
| * Copyright (c) 2011 Andres Mejia
| * Copyright (c) 2011 Michihiro NAKAJIMA
| * All rights reserved.
| *
| * Redistribution and use in source and binary forms, with or without
| * modification, are permitted provided that the following conditions
| * are met:
| * 1. Redistributions of source code must retain the above copyright
| *    notice, this list of conditions and the following disclaimer.
| * 2. Redistributions in binary form must reproduce the above copyright
| *    notice, this list of conditions and the following disclaimer in the
| *    documentation and/or other materials provided with the distribution.
| *
| * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
| * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
| * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
| * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
| * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
| * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
| * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
| * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
| * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
| * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
| */
| 
| #include "archive_platform.h"
| 
| #include "archive.h"
| #include "archive_crypto_private.h"
| 
| /* In particular, force the configure probe to break if it tries
|  * to test a combination of OpenSSL and libmd. */
| #if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
| #error Cannot use both OpenSSL and libmd.
| #endif
| 
| /*
|  * Message digest functions for Windows platform.
|  */
| #if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
| 	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
| 	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| /*
|  * Initialize a Message digest.
|  */
| static int
| win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
| {
| 
| 	ctx->valid = 0;
| 	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
| 		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
| 			return (ARCHIVE_FAILED);
| 		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
| 			return (ARCHIVE_FAILED);
| 	}
| 
| 	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
| 		CryptReleaseContext(ctx->cryptProv, 0);
| 		return (ARCHIVE_FAILED);
| 	}
| 
| 	ctx->valid = 1;
| 	return (ARCHIVE_OK);
| }
| 
| /*
|  * Update a Message digest.
|  */
| static int
| win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
| {
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptHashData(ctx->hash,
| 		      (unsigned char *)(uintptr_t)buf,
| 		      (DWORD)len, 0);
| 	return (ARCHIVE_OK);
| }
| 
| static int
| win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
| {
| 	DWORD siglen = (DWORD)bufsize;
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
| 	CryptDestroyHash(ctx->hash);
| 	CryptReleaseContext(ctx->cryptProv, 0);
| 	ctx->valid = 0;
| 	return (ARCHIVE_OK);
| }
| 
| #endif /* defined(ARCHIVE_CRYPTO_*_WIN) */
| 
| 
| /* MD5 implementations */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
| 
| static int
| __archive_libc_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
| 
| static int
| __archive_libmd_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
| 
| static int
| __archive_libsystem_md5init(archive_md5_ctx *ctx)
| {
|   CC_MD5_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_MD5_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
| {
|   CC_MD5_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
| 
| static int
| __archive_nettle_md5init(archive_md5_ctx *ctx)
| {
|   md5_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   md5_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
| {
|   md5_digest(ctx, MD5_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
| 
| static int
| __archive_openssl_md5init(archive_md5_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_md5());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
| 
| static int
| __archive_windowsapi_md5init(archive_md5_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_MD5));
| }
| 
| static int
| __archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 16, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_md5init(archive_md5_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5final(archive_md5_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* RIPEMD160 implementations */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
| 
| static int
| __archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RMD160Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RMD160Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RMD160Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
| 
| static int
| __archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RIPEMD160_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RIPEMD160_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RIPEMD160_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
| 
| static int
| __archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   ripemd160_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   ripemd160_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
| 
| static int
| __archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_ripemd160());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #else
| 
| static int
| __archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA1 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
| 
| static int
| __archive_libc_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
| 
| static int
| __archive_libmd_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha1init(archive_sha1_ctx *ctx)
| {
|   CC_SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   CC_SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
| 
| static int
| __archive_nettle_sha1init(archive_sha1_ctx *ctx)
| {
|   sha1_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha1_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
| 
| static int
| __archive_openssl_sha1init(archive_sha1_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha1());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
| 
| static int
| __archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA1));
| }
| 
| static int
| __archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 20, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha1init(archive_sha1_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA256 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
| 
| static int
| __archive_libc_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
| 
| static int
| __archive_libc2_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
| 
| static int
| __archive_libc3_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
| 
| static int
| __archive_libmd_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha256init(archive_sha256_ctx *ctx)
| {
|   CC_SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   CC_SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
| 
| static int
| __archive_nettle_sha256init(archive_sha256_ctx *ctx)
| {
|   sha256_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha256_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
| 
| static int
| __archive_openssl_sha256init(archive_sha256_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha256());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
| 
| static int
| __archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_256));
| }
| 
| static int
| __archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 32, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha256init(archive_sha256_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA384 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
| 
| static int
| __archive_libc_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
| 
| static int
| __archive_libc2_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
| 
| static int
| __archive_libc3_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha384init(archive_sha384_ctx *ctx)
| {
|   CC_SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   CC_SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
| 
| static int
| __archive_nettle_sha384init(archive_sha384_ctx *ctx)
| {
|   sha384_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha384_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
| 
| static int
| __archive_openssl_sha384init(archive_sha384_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha384());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
| 
| static int
| __archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_384));
| }
| 
| static int
| __archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 48, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha384init(archive_sha384_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA512 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
| 
| static int
| __archive_libc_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
| 
| static int
| __archive_libc2_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
| 
| static int
| __archive_libc3_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
| 
| static int
| __archive_libmd_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha512init(archive_sha512_ctx *ctx)
| {
|   CC_SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   CC_SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
| 
| static int
| __archive_nettle_sha512init(archive_sha512_ctx *ctx)
| {
|   sha512_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha512_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
| 
| static int
| __archive_openssl_sha512init(archive_sha512_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha512());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| static int
| __archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_512));
| }
| 
| static int
| __archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 64, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha512init(archive_sha512_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* NOTE: Crypto functions are set based on availability and by the following
|  * order of preference.
|  * 1. libc
|  * 2. libc2
|  * 3. libc3
|  * 4. libSystem
|  * 5. Nettle
|  * 6. OpenSSL
|  * 7. libmd
|  * 8. Windows API
|  */
| const struct archive_crypto __archive_crypto =
| {
| /* MD5 */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
|   &__archive_libc_md5init,
|   &__archive_libc_md5update,
|   &__archive_libc_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
|   &__archive_libmd_md5init,
|   &__archive_libmd_md5update,
|   &__archive_libmd_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
|   &__archive_libsystem_md5init,
|   &__archive_libsystem_md5update,
|   &__archive_libsystem_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
|   &__archive_nettle_md5init,
|   &__archive_nettle_md5update,
|   &__archive_nettle_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
|   &__archive_openssl_md5init,
|   &__archive_openssl_md5update,
|   &__archive_openssl_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
|   &__archive_windowsapi_md5init,
|   &__archive_windowsapi_md5update,
|   &__archive_windowsapi_md5final,
| #elif !defined(ARCHIVE_MD5_COMPILE_TEST)
|   &__archive_stub_md5init,
|   &__archive_stub_md5update,
|   &__archive_stub_md5final,
| #endif
| 
| /* RIPEMD160 */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
|   &__archive_libc_ripemd160init,
|   &__archive_libc_ripemd160update,
|   &__archive_libc_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
|   &__archive_libmd_ripemd160init,
|   &__archive_libmd_ripemd160update,
|   &__archive_libmd_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
|   &__archive_nettle_ripemd160init,
|   &__archive_nettle_ripemd160update,
|   &__archive_nettle_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
|   &__archive_openssl_ripemd160init,
|   &__archive_openssl_ripemd160update,
|   &__archive_openssl_ripemd160final,
| #elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
|   &__archive_stub_ripemd160init,
|   &__archive_stub_ripemd160update,
|   &__archive_stub_ripemd160final,
| #endif
| 
| /* SHA1 */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
|   &__archive_libc_sha1init,
|   &__archive_libc_sha1update,
|   &__archive_libc_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
|   &__archive_libmd_sha1init,
|   &__archive_libmd_sha1update,
|   &__archive_libmd_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
|   &__archive_libsystem_sha1init,
|   &__archive_libsystem_sha1update,
|   &__archive_libsystem_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
|   &__archive_nettle_sha1init,
|   &__archive_nettle_sha1update,
|   &__archive_nettle_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
|   &__archive_openssl_sha1init,
|   &__archive_openssl_sha1update,
|   &__archive_openssl_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
|   &__archive_windowsapi_sha1init,
|   &__archive_windowsapi_sha1update,
|   &__archive_windowsapi_sha1final,
| #elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
|   &__archive_stub_sha1init,
|   &__archive_stub_sha1update,
|   &__archive_stub_sha1final,
| #endif
| 
| /* SHA256 */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
|   &__archive_libc_sha256init,
|   &__archive_libc_sha256update,
|   &__archive_libc_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
|   &__archive_libc2_sha256init,
|   &__archive_libc2_sha256update,
|   &__archive_libc2_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
|   &__archive_libc3_sha256init,
|   &__archive_libc3_sha256update,
|   &__archive_libc3_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
|   &__archive_libmd_sha256init,
|   &__archive_libmd_sha256update,
|   &__archive_libmd_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
|   &__archive_libsystem_sha256init,
|   &__archive_libsystem_sha256update,
|   &__archive_libsystem_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
|   &__archive_nettle_sha256init,
|   &__archive_nettle_sha256update,
|   &__archive_nettle_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
|   &__archive_openssl_sha256init,
|   &__archive_openssl_sha256update,
|   &__archive_openssl_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
|   &__archive_windowsapi_sha256init,
|   &__archive_windowsapi_sha256update,
|   &__archive_windowsapi_sha256final,
| #elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
|   &__archive_stub_sha256init,
|   &__archive_stub_sha256update,
|   &__archive_stub_sha256final,
| #endif
| 
| /* SHA384 */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
|   &__archive_libc_sha384init,
|   &__archive_libc_sha384update,
|   &__archive_libc_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
|   &__archive_libc2_sha384init,
|   &__archive_libc2_sha384update,
|   &__archive_libc2_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
|   &__archive_libc3_sha384init,
|   &__archive_libc3_sha384update,
|   &__archive_libc3_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
|   &__archive_libsystem_sha384init,
|   &__archive_libsystem_sha384update,
|   &__archive_libsystem_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
|   &__archive_nettle_sha384init,
|   &__archive_nettle_sha384update,
|   &__archive_nettle_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
|   &__archive_openssl_sha384init,
|   &__archive_openssl_sha384update,
|   &__archive_openssl_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
|   &__archive_windowsapi_sha384init,
|   &__archive_windowsapi_sha384update,
|   &__archive_windowsapi_sha384final,
| #elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
|   &__archive_stub_sha384init,
|   &__archive_stub_sha384update,
|   &__archive_stub_sha384final,
| #endif
| 
| /* SHA512 */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
|   &__archive_libc_sha512init,
|   &__archive_libc_sha512update,
|   &__archive_libc_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
|   &__archive_libc2_sha512init,
|   &__archive_libc2_sha512update,
|   &__archive_libc2_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
|   &__archive_libc3_sha512init,
|   &__archive_libc3_sha512update,
|   &__archive_libc3_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
|   &__archive_libmd_sha512init,
|   &__archive_libmd_sha512update,
|   &__archive_libmd_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
|   &__archive_libsystem_sha512init,
|   &__archive_libsystem_sha512update,
|   &__archive_libsystem_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
|   &__archive_nettle_sha512init,
|   &__archive_nettle_sha512update,
|   &__archive_nettle_sha512final,
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
|   &__archive_openssl_sha512init,
|   &__archive_openssl_sha512update,
|   &__archive_openssl_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
|   &__archive_windowsapi_sha512init,
|   &__archive_windowsapi_sha512update,
|   &__archive_windowsapi_sha512final
| #elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
|   &__archive_stub_sha512init,
|   &__archive_stub_sha512update,
|   &__archive_stub_sha512final
| #endif
| };
| 
| int
| main(int argc, char **argv)
| {
|   archive_sha384_ctx ctx;
|   archive_sha384_init(&ctx);
|   archive_sha384_update(&ctx, *argv, argc);
|   archive_sha384_final(&ctx, NULL);
|   return 0;
| }
| 
configure:17767: result: no
configure:17781: checking support for ARCHIVE_CRYPTO_SHA512_LIBC
configure:17803: arm-linux-androideabi-gcc -o conftest    -I. -I. -I./libarchive  conftest.c -lz  >&5
In file included from conftest.c:206:0:
./libarchive/archive_crypto_private.h:78:18: fatal error: sha2.h: No such file or directory
 #include <sha2.h>
                  ^
compilation terminated.
configure:17803: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| #define ARCHIVE_SHA512_COMPILE_TEST
| #define ARCHIVE_CRYPTO_SHA512_LIBC
| #define PLATFORM_CONFIG_H "check_crypto_md.h"
| 
| /*-
| * Copyright (c) 2003-2007 Tim Kientzle
| * Copyright (c) 2011 Andres Mejia
| * Copyright (c) 2011 Michihiro NAKAJIMA
| * All rights reserved.
| *
| * Redistribution and use in source and binary forms, with or without
| * modification, are permitted provided that the following conditions
| * are met:
| * 1. Redistributions of source code must retain the above copyright
| *    notice, this list of conditions and the following disclaimer.
| * 2. Redistributions in binary form must reproduce the above copyright
| *    notice, this list of conditions and the following disclaimer in the
| *    documentation and/or other materials provided with the distribution.
| *
| * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
| * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
| * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
| * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
| * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
| * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
| * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
| * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
| * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
| * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
| */
| 
| #include "archive_platform.h"
| 
| #include "archive.h"
| #include "archive_crypto_private.h"
| 
| /* In particular, force the configure probe to break if it tries
|  * to test a combination of OpenSSL and libmd. */
| #if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
| #error Cannot use both OpenSSL and libmd.
| #endif
| 
| /*
|  * Message digest functions for Windows platform.
|  */
| #if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
| 	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
| 	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| /*
|  * Initialize a Message digest.
|  */
| static int
| win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
| {
| 
| 	ctx->valid = 0;
| 	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
| 		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
| 			return (ARCHIVE_FAILED);
| 		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
| 			return (ARCHIVE_FAILED);
| 	}
| 
| 	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
| 		CryptReleaseContext(ctx->cryptProv, 0);
| 		return (ARCHIVE_FAILED);
| 	}
| 
| 	ctx->valid = 1;
| 	return (ARCHIVE_OK);
| }
| 
| /*
|  * Update a Message digest.
|  */
| static int
| win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
| {
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptHashData(ctx->hash,
| 		      (unsigned char *)(uintptr_t)buf,
| 		      (DWORD)len, 0);
| 	return (ARCHIVE_OK);
| }
| 
| static int
| win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
| {
| 	DWORD siglen = (DWORD)bufsize;
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
| 	CryptDestroyHash(ctx->hash);
| 	CryptReleaseContext(ctx->cryptProv, 0);
| 	ctx->valid = 0;
| 	return (ARCHIVE_OK);
| }
| 
| #endif /* defined(ARCHIVE_CRYPTO_*_WIN) */
| 
| 
| /* MD5 implementations */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
| 
| static int
| __archive_libc_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
| 
| static int
| __archive_libmd_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
| 
| static int
| __archive_libsystem_md5init(archive_md5_ctx *ctx)
| {
|   CC_MD5_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_MD5_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
| {
|   CC_MD5_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
| 
| static int
| __archive_nettle_md5init(archive_md5_ctx *ctx)
| {
|   md5_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   md5_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
| {
|   md5_digest(ctx, MD5_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
| 
| static int
| __archive_openssl_md5init(archive_md5_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_md5());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
| 
| static int
| __archive_windowsapi_md5init(archive_md5_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_MD5));
| }
| 
| static int
| __archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 16, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_md5init(archive_md5_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5final(archive_md5_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* RIPEMD160 implementations */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
| 
| static int
| __archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RMD160Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RMD160Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RMD160Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
| 
| static int
| __archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RIPEMD160_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RIPEMD160_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RIPEMD160_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
| 
| static int
| __archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   ripemd160_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   ripemd160_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
| 
| static int
| __archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_ripemd160());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #else
| 
| static int
| __archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA1 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
| 
| static int
| __archive_libc_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
| 
| static int
| __archive_libmd_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha1init(archive_sha1_ctx *ctx)
| {
|   CC_SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   CC_SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
| 
| static int
| __archive_nettle_sha1init(archive_sha1_ctx *ctx)
| {
|   sha1_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha1_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
| 
| static int
| __archive_openssl_sha1init(archive_sha1_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha1());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
| 
| static int
| __archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA1));
| }
| 
| static int
| __archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 20, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha1init(archive_sha1_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA256 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
| 
| static int
| __archive_libc_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
| 
| static int
| __archive_libc2_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
| 
| static int
| __archive_libc3_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
| 
| static int
| __archive_libmd_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha256init(archive_sha256_ctx *ctx)
| {
|   CC_SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   CC_SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
| 
| static int
| __archive_nettle_sha256init(archive_sha256_ctx *ctx)
| {
|   sha256_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha256_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
| 
| static int
| __archive_openssl_sha256init(archive_sha256_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha256());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
| 
| static int
| __archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_256));
| }
| 
| static int
| __archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 32, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha256init(archive_sha256_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA384 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
| 
| static int
| __archive_libc_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
| 
| static int
| __archive_libc2_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
| 
| static int
| __archive_libc3_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha384init(archive_sha384_ctx *ctx)
| {
|   CC_SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   CC_SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
| 
| static int
| __archive_nettle_sha384init(archive_sha384_ctx *ctx)
| {
|   sha384_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha384_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
| 
| static int
| __archive_openssl_sha384init(archive_sha384_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha384());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
| 
| static int
| __archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_384));
| }
| 
| static int
| __archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 48, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha384init(archive_sha384_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA512 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
| 
| static int
| __archive_libc_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
| 
| static int
| __archive_libc2_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
| 
| static int
| __archive_libc3_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
| 
| static int
| __archive_libmd_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha512init(archive_sha512_ctx *ctx)
| {
|   CC_SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   CC_SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
| 
| static int
| __archive_nettle_sha512init(archive_sha512_ctx *ctx)
| {
|   sha512_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha512_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
| 
| static int
| __archive_openssl_sha512init(archive_sha512_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha512());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| static int
| __archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_512));
| }
| 
| static int
| __archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 64, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha512init(archive_sha512_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* NOTE: Crypto functions are set based on availability and by the following
|  * order of preference.
|  * 1. libc
|  * 2. libc2
|  * 3. libc3
|  * 4. libSystem
|  * 5. Nettle
|  * 6. OpenSSL
|  * 7. libmd
|  * 8. Windows API
|  */
| const struct archive_crypto __archive_crypto =
| {
| /* MD5 */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
|   &__archive_libc_md5init,
|   &__archive_libc_md5update,
|   &__archive_libc_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
|   &__archive_libmd_md5init,
|   &__archive_libmd_md5update,
|   &__archive_libmd_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
|   &__archive_libsystem_md5init,
|   &__archive_libsystem_md5update,
|   &__archive_libsystem_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
|   &__archive_nettle_md5init,
|   &__archive_nettle_md5update,
|   &__archive_nettle_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
|   &__archive_openssl_md5init,
|   &__archive_openssl_md5update,
|   &__archive_openssl_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
|   &__archive_windowsapi_md5init,
|   &__archive_windowsapi_md5update,
|   &__archive_windowsapi_md5final,
| #elif !defined(ARCHIVE_MD5_COMPILE_TEST)
|   &__archive_stub_md5init,
|   &__archive_stub_md5update,
|   &__archive_stub_md5final,
| #endif
| 
| /* RIPEMD160 */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
|   &__archive_libc_ripemd160init,
|   &__archive_libc_ripemd160update,
|   &__archive_libc_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
|   &__archive_libmd_ripemd160init,
|   &__archive_libmd_ripemd160update,
|   &__archive_libmd_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
|   &__archive_nettle_ripemd160init,
|   &__archive_nettle_ripemd160update,
|   &__archive_nettle_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
|   &__archive_openssl_ripemd160init,
|   &__archive_openssl_ripemd160update,
|   &__archive_openssl_ripemd160final,
| #elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
|   &__archive_stub_ripemd160init,
|   &__archive_stub_ripemd160update,
|   &__archive_stub_ripemd160final,
| #endif
| 
| /* SHA1 */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
|   &__archive_libc_sha1init,
|   &__archive_libc_sha1update,
|   &__archive_libc_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
|   &__archive_libmd_sha1init,
|   &__archive_libmd_sha1update,
|   &__archive_libmd_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
|   &__archive_libsystem_sha1init,
|   &__archive_libsystem_sha1update,
|   &__archive_libsystem_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
|   &__archive_nettle_sha1init,
|   &__archive_nettle_sha1update,
|   &__archive_nettle_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
|   &__archive_openssl_sha1init,
|   &__archive_openssl_sha1update,
|   &__archive_openssl_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
|   &__archive_windowsapi_sha1init,
|   &__archive_windowsapi_sha1update,
|   &__archive_windowsapi_sha1final,
| #elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
|   &__archive_stub_sha1init,
|   &__archive_stub_sha1update,
|   &__archive_stub_sha1final,
| #endif
| 
| /* SHA256 */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
|   &__archive_libc_sha256init,
|   &__archive_libc_sha256update,
|   &__archive_libc_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
|   &__archive_libc2_sha256init,
|   &__archive_libc2_sha256update,
|   &__archive_libc2_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
|   &__archive_libc3_sha256init,
|   &__archive_libc3_sha256update,
|   &__archive_libc3_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
|   &__archive_libmd_sha256init,
|   &__archive_libmd_sha256update,
|   &__archive_libmd_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
|   &__archive_libsystem_sha256init,
|   &__archive_libsystem_sha256update,
|   &__archive_libsystem_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
|   &__archive_nettle_sha256init,
|   &__archive_nettle_sha256update,
|   &__archive_nettle_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
|   &__archive_openssl_sha256init,
|   &__archive_openssl_sha256update,
|   &__archive_openssl_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
|   &__archive_windowsapi_sha256init,
|   &__archive_windowsapi_sha256update,
|   &__archive_windowsapi_sha256final,
| #elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
|   &__archive_stub_sha256init,
|   &__archive_stub_sha256update,
|   &__archive_stub_sha256final,
| #endif
| 
| /* SHA384 */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
|   &__archive_libc_sha384init,
|   &__archive_libc_sha384update,
|   &__archive_libc_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
|   &__archive_libc2_sha384init,
|   &__archive_libc2_sha384update,
|   &__archive_libc2_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
|   &__archive_libc3_sha384init,
|   &__archive_libc3_sha384update,
|   &__archive_libc3_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
|   &__archive_libsystem_sha384init,
|   &__archive_libsystem_sha384update,
|   &__archive_libsystem_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
|   &__archive_nettle_sha384init,
|   &__archive_nettle_sha384update,
|   &__archive_nettle_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
|   &__archive_openssl_sha384init,
|   &__archive_openssl_sha384update,
|   &__archive_openssl_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
|   &__archive_windowsapi_sha384init,
|   &__archive_windowsapi_sha384update,
|   &__archive_windowsapi_sha384final,
| #elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
|   &__archive_stub_sha384init,
|   &__archive_stub_sha384update,
|   &__archive_stub_sha384final,
| #endif
| 
| /* SHA512 */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
|   &__archive_libc_sha512init,
|   &__archive_libc_sha512update,
|   &__archive_libc_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
|   &__archive_libc2_sha512init,
|   &__archive_libc2_sha512update,
|   &__archive_libc2_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
|   &__archive_libc3_sha512init,
|   &__archive_libc3_sha512update,
|   &__archive_libc3_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
|   &__archive_libmd_sha512init,
|   &__archive_libmd_sha512update,
|   &__archive_libmd_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
|   &__archive_libsystem_sha512init,
|   &__archive_libsystem_sha512update,
|   &__archive_libsystem_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
|   &__archive_nettle_sha512init,
|   &__archive_nettle_sha512update,
|   &__archive_nettle_sha512final,
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
|   &__archive_openssl_sha512init,
|   &__archive_openssl_sha512update,
|   &__archive_openssl_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
|   &__archive_windowsapi_sha512init,
|   &__archive_windowsapi_sha512update,
|   &__archive_windowsapi_sha512final
| #elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
|   &__archive_stub_sha512init,
|   &__archive_stub_sha512update,
|   &__archive_stub_sha512final
| #endif
| };
| 
| int
| main(int argc, char **argv)
| {
|   archive_sha512_ctx ctx;
|   archive_sha512_init(&ctx);
|   archive_sha512_update(&ctx, *argv, argc);
|   archive_sha512_final(&ctx, NULL);
|   return 0;
| }
| 
configure:17813: result: no
configure:17827: checking support for ARCHIVE_CRYPTO_SHA512_LIBC2
configure:17849: arm-linux-androideabi-gcc -o conftest    -I. -I. -I./libarchive  conftest.c -lz  >&5
In file included from conftest.c:206:0:
./libarchive/archive_crypto_private.h:78:18: fatal error: sha2.h: No such file or directory
 #include <sha2.h>
                  ^
compilation terminated.
configure:17849: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| #define ARCHIVE_SHA512_COMPILE_TEST
| #define ARCHIVE_CRYPTO_SHA512_LIBC2
| #define PLATFORM_CONFIG_H "check_crypto_md.h"
| 
| /*-
| * Copyright (c) 2003-2007 Tim Kientzle
| * Copyright (c) 2011 Andres Mejia
| * Copyright (c) 2011 Michihiro NAKAJIMA
| * All rights reserved.
| *
| * Redistribution and use in source and binary forms, with or without
| * modification, are permitted provided that the following conditions
| * are met:
| * 1. Redistributions of source code must retain the above copyright
| *    notice, this list of conditions and the following disclaimer.
| * 2. Redistributions in binary form must reproduce the above copyright
| *    notice, this list of conditions and the following disclaimer in the
| *    documentation and/or other materials provided with the distribution.
| *
| * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
| * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
| * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
| * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
| * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
| * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
| * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
| * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
| * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
| * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
| */
| 
| #include "archive_platform.h"
| 
| #include "archive.h"
| #include "archive_crypto_private.h"
| 
| /* In particular, force the configure probe to break if it tries
|  * to test a combination of OpenSSL and libmd. */
| #if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
| #error Cannot use both OpenSSL and libmd.
| #endif
| 
| /*
|  * Message digest functions for Windows platform.
|  */
| #if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
| 	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
| 	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| /*
|  * Initialize a Message digest.
|  */
| static int
| win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
| {
| 
| 	ctx->valid = 0;
| 	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
| 		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
| 			return (ARCHIVE_FAILED);
| 		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
| 			return (ARCHIVE_FAILED);
| 	}
| 
| 	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
| 		CryptReleaseContext(ctx->cryptProv, 0);
| 		return (ARCHIVE_FAILED);
| 	}
| 
| 	ctx->valid = 1;
| 	return (ARCHIVE_OK);
| }
| 
| /*
|  * Update a Message digest.
|  */
| static int
| win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
| {
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptHashData(ctx->hash,
| 		      (unsigned char *)(uintptr_t)buf,
| 		      (DWORD)len, 0);
| 	return (ARCHIVE_OK);
| }
| 
| static int
| win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
| {
| 	DWORD siglen = (DWORD)bufsize;
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
| 	CryptDestroyHash(ctx->hash);
| 	CryptReleaseContext(ctx->cryptProv, 0);
| 	ctx->valid = 0;
| 	return (ARCHIVE_OK);
| }
| 
| #endif /* defined(ARCHIVE_CRYPTO_*_WIN) */
| 
| 
| /* MD5 implementations */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
| 
| static int
| __archive_libc_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
| 
| static int
| __archive_libmd_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
| 
| static int
| __archive_libsystem_md5init(archive_md5_ctx *ctx)
| {
|   CC_MD5_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_MD5_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
| {
|   CC_MD5_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
| 
| static int
| __archive_nettle_md5init(archive_md5_ctx *ctx)
| {
|   md5_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   md5_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
| {
|   md5_digest(ctx, MD5_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
| 
| static int
| __archive_openssl_md5init(archive_md5_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_md5());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
| 
| static int
| __archive_windowsapi_md5init(archive_md5_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_MD5));
| }
| 
| static int
| __archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 16, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_md5init(archive_md5_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5final(archive_md5_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* RIPEMD160 implementations */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
| 
| static int
| __archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RMD160Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RMD160Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RMD160Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
| 
| static int
| __archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RIPEMD160_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RIPEMD160_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RIPEMD160_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
| 
| static int
| __archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   ripemd160_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   ripemd160_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
| 
| static int
| __archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_ripemd160());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #else
| 
| static int
| __archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA1 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
| 
| static int
| __archive_libc_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
| 
| static int
| __archive_libmd_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha1init(archive_sha1_ctx *ctx)
| {
|   CC_SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   CC_SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
| 
| static int
| __archive_nettle_sha1init(archive_sha1_ctx *ctx)
| {
|   sha1_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha1_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
| 
| static int
| __archive_openssl_sha1init(archive_sha1_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha1());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
| 
| static int
| __archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA1));
| }
| 
| static int
| __archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 20, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha1init(archive_sha1_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA256 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
| 
| static int
| __archive_libc_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
| 
| static int
| __archive_libc2_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
| 
| static int
| __archive_libc3_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
| 
| static int
| __archive_libmd_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha256init(archive_sha256_ctx *ctx)
| {
|   CC_SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   CC_SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
| 
| static int
| __archive_nettle_sha256init(archive_sha256_ctx *ctx)
| {
|   sha256_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha256_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
| 
| static int
| __archive_openssl_sha256init(archive_sha256_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha256());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
| 
| static int
| __archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_256));
| }
| 
| static int
| __archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 32, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha256init(archive_sha256_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA384 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
| 
| static int
| __archive_libc_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
| 
| static int
| __archive_libc2_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
| 
| static int
| __archive_libc3_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha384init(archive_sha384_ctx *ctx)
| {
|   CC_SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   CC_SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
| 
| static int
| __archive_nettle_sha384init(archive_sha384_ctx *ctx)
| {
|   sha384_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha384_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
| 
| static int
| __archive_openssl_sha384init(archive_sha384_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha384());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
| 
| static int
| __archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_384));
| }
| 
| static int
| __archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 48, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha384init(archive_sha384_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA512 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
| 
| static int
| __archive_libc_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
| 
| static int
| __archive_libc2_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
| 
| static int
| __archive_libc3_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
| 
| static int
| __archive_libmd_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha512init(archive_sha512_ctx *ctx)
| {
|   CC_SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   CC_SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
| 
| static int
| __archive_nettle_sha512init(archive_sha512_ctx *ctx)
| {
|   sha512_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha512_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
| 
| static int
| __archive_openssl_sha512init(archive_sha512_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha512());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| static int
| __archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_512));
| }
| 
| static int
| __archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 64, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha512init(archive_sha512_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* NOTE: Crypto functions are set based on availability and by the following
|  * order of preference.
|  * 1. libc
|  * 2. libc2
|  * 3. libc3
|  * 4. libSystem
|  * 5. Nettle
|  * 6. OpenSSL
|  * 7. libmd
|  * 8. Windows API
|  */
| const struct archive_crypto __archive_crypto =
| {
| /* MD5 */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
|   &__archive_libc_md5init,
|   &__archive_libc_md5update,
|   &__archive_libc_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
|   &__archive_libmd_md5init,
|   &__archive_libmd_md5update,
|   &__archive_libmd_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
|   &__archive_libsystem_md5init,
|   &__archive_libsystem_md5update,
|   &__archive_libsystem_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
|   &__archive_nettle_md5init,
|   &__archive_nettle_md5update,
|   &__archive_nettle_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
|   &__archive_openssl_md5init,
|   &__archive_openssl_md5update,
|   &__archive_openssl_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
|   &__archive_windowsapi_md5init,
|   &__archive_windowsapi_md5update,
|   &__archive_windowsapi_md5final,
| #elif !defined(ARCHIVE_MD5_COMPILE_TEST)
|   &__archive_stub_md5init,
|   &__archive_stub_md5update,
|   &__archive_stub_md5final,
| #endif
| 
| /* RIPEMD160 */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
|   &__archive_libc_ripemd160init,
|   &__archive_libc_ripemd160update,
|   &__archive_libc_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
|   &__archive_libmd_ripemd160init,
|   &__archive_libmd_ripemd160update,
|   &__archive_libmd_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
|   &__archive_nettle_ripemd160init,
|   &__archive_nettle_ripemd160update,
|   &__archive_nettle_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
|   &__archive_openssl_ripemd160init,
|   &__archive_openssl_ripemd160update,
|   &__archive_openssl_ripemd160final,
| #elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
|   &__archive_stub_ripemd160init,
|   &__archive_stub_ripemd160update,
|   &__archive_stub_ripemd160final,
| #endif
| 
| /* SHA1 */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
|   &__archive_libc_sha1init,
|   &__archive_libc_sha1update,
|   &__archive_libc_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
|   &__archive_libmd_sha1init,
|   &__archive_libmd_sha1update,
|   &__archive_libmd_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
|   &__archive_libsystem_sha1init,
|   &__archive_libsystem_sha1update,
|   &__archive_libsystem_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
|   &__archive_nettle_sha1init,
|   &__archive_nettle_sha1update,
|   &__archive_nettle_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
|   &__archive_openssl_sha1init,
|   &__archive_openssl_sha1update,
|   &__archive_openssl_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
|   &__archive_windowsapi_sha1init,
|   &__archive_windowsapi_sha1update,
|   &__archive_windowsapi_sha1final,
| #elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
|   &__archive_stub_sha1init,
|   &__archive_stub_sha1update,
|   &__archive_stub_sha1final,
| #endif
| 
| /* SHA256 */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
|   &__archive_libc_sha256init,
|   &__archive_libc_sha256update,
|   &__archive_libc_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
|   &__archive_libc2_sha256init,
|   &__archive_libc2_sha256update,
|   &__archive_libc2_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
|   &__archive_libc3_sha256init,
|   &__archive_libc3_sha256update,
|   &__archive_libc3_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
|   &__archive_libmd_sha256init,
|   &__archive_libmd_sha256update,
|   &__archive_libmd_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
|   &__archive_libsystem_sha256init,
|   &__archive_libsystem_sha256update,
|   &__archive_libsystem_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
|   &__archive_nettle_sha256init,
|   &__archive_nettle_sha256update,
|   &__archive_nettle_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
|   &__archive_openssl_sha256init,
|   &__archive_openssl_sha256update,
|   &__archive_openssl_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
|   &__archive_windowsapi_sha256init,
|   &__archive_windowsapi_sha256update,
|   &__archive_windowsapi_sha256final,
| #elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
|   &__archive_stub_sha256init,
|   &__archive_stub_sha256update,
|   &__archive_stub_sha256final,
| #endif
| 
| /* SHA384 */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
|   &__archive_libc_sha384init,
|   &__archive_libc_sha384update,
|   &__archive_libc_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
|   &__archive_libc2_sha384init,
|   &__archive_libc2_sha384update,
|   &__archive_libc2_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
|   &__archive_libc3_sha384init,
|   &__archive_libc3_sha384update,
|   &__archive_libc3_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
|   &__archive_libsystem_sha384init,
|   &__archive_libsystem_sha384update,
|   &__archive_libsystem_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
|   &__archive_nettle_sha384init,
|   &__archive_nettle_sha384update,
|   &__archive_nettle_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
|   &__archive_openssl_sha384init,
|   &__archive_openssl_sha384update,
|   &__archive_openssl_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
|   &__archive_windowsapi_sha384init,
|   &__archive_windowsapi_sha384update,
|   &__archive_windowsapi_sha384final,
| #elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
|   &__archive_stub_sha384init,
|   &__archive_stub_sha384update,
|   &__archive_stub_sha384final,
| #endif
| 
| /* SHA512 */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
|   &__archive_libc_sha512init,
|   &__archive_libc_sha512update,
|   &__archive_libc_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
|   &__archive_libc2_sha512init,
|   &__archive_libc2_sha512update,
|   &__archive_libc2_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
|   &__archive_libc3_sha512init,
|   &__archive_libc3_sha512update,
|   &__archive_libc3_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
|   &__archive_libmd_sha512init,
|   &__archive_libmd_sha512update,
|   &__archive_libmd_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
|   &__archive_libsystem_sha512init,
|   &__archive_libsystem_sha512update,
|   &__archive_libsystem_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
|   &__archive_nettle_sha512init,
|   &__archive_nettle_sha512update,
|   &__archive_nettle_sha512final,
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
|   &__archive_openssl_sha512init,
|   &__archive_openssl_sha512update,
|   &__archive_openssl_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
|   &__archive_windowsapi_sha512init,
|   &__archive_windowsapi_sha512update,
|   &__archive_windowsapi_sha512final
| #elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
|   &__archive_stub_sha512init,
|   &__archive_stub_sha512update,
|   &__archive_stub_sha512final
| #endif
| };
| 
| int
| main(int argc, char **argv)
| {
|   archive_sha512_ctx ctx;
|   archive_sha512_init(&ctx);
|   archive_sha512_update(&ctx, *argv, argc);
|   archive_sha512_final(&ctx, NULL);
|   return 0;
| }
| 
configure:17859: result: no
configure:17873: checking support for ARCHIVE_CRYPTO_SHA512_LIBC3
configure:17895: arm-linux-androideabi-gcc -o conftest    -I. -I. -I./libarchive  conftest.c -lz  >&5
In file included from conftest.c:206:0:
./libarchive/archive_crypto_private.h:78:18: fatal error: sha2.h: No such file or directory
 #include <sha2.h>
                  ^
compilation terminated.
configure:17895: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| #define ARCHIVE_SHA512_COMPILE_TEST
| #define ARCHIVE_CRYPTO_SHA512_LIBC3
| #define PLATFORM_CONFIG_H "check_crypto_md.h"
| 
| /*-
| * Copyright (c) 2003-2007 Tim Kientzle
| * Copyright (c) 2011 Andres Mejia
| * Copyright (c) 2011 Michihiro NAKAJIMA
| * All rights reserved.
| *
| * Redistribution and use in source and binary forms, with or without
| * modification, are permitted provided that the following conditions
| * are met:
| * 1. Redistributions of source code must retain the above copyright
| *    notice, this list of conditions and the following disclaimer.
| * 2. Redistributions in binary form must reproduce the above copyright
| *    notice, this list of conditions and the following disclaimer in the
| *    documentation and/or other materials provided with the distribution.
| *
| * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
| * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
| * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
| * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
| * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
| * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
| * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
| * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
| * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
| * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
| */
| 
| #include "archive_platform.h"
| 
| #include "archive.h"
| #include "archive_crypto_private.h"
| 
| /* In particular, force the configure probe to break if it tries
|  * to test a combination of OpenSSL and libmd. */
| #if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
| #error Cannot use both OpenSSL and libmd.
| #endif
| 
| /*
|  * Message digest functions for Windows platform.
|  */
| #if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
| 	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
| 	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| /*
|  * Initialize a Message digest.
|  */
| static int
| win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
| {
| 
| 	ctx->valid = 0;
| 	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
| 		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
| 			return (ARCHIVE_FAILED);
| 		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
| 			return (ARCHIVE_FAILED);
| 	}
| 
| 	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
| 		CryptReleaseContext(ctx->cryptProv, 0);
| 		return (ARCHIVE_FAILED);
| 	}
| 
| 	ctx->valid = 1;
| 	return (ARCHIVE_OK);
| }
| 
| /*
|  * Update a Message digest.
|  */
| static int
| win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
| {
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptHashData(ctx->hash,
| 		      (unsigned char *)(uintptr_t)buf,
| 		      (DWORD)len, 0);
| 	return (ARCHIVE_OK);
| }
| 
| static int
| win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
| {
| 	DWORD siglen = (DWORD)bufsize;
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
| 	CryptDestroyHash(ctx->hash);
| 	CryptReleaseContext(ctx->cryptProv, 0);
| 	ctx->valid = 0;
| 	return (ARCHIVE_OK);
| }
| 
| #endif /* defined(ARCHIVE_CRYPTO_*_WIN) */
| 
| 
| /* MD5 implementations */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
| 
| static int
| __archive_libc_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
| 
| static int
| __archive_libmd_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
| 
| static int
| __archive_libsystem_md5init(archive_md5_ctx *ctx)
| {
|   CC_MD5_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_MD5_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
| {
|   CC_MD5_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
| 
| static int
| __archive_nettle_md5init(archive_md5_ctx *ctx)
| {
|   md5_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   md5_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
| {
|   md5_digest(ctx, MD5_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
| 
| static int
| __archive_openssl_md5init(archive_md5_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_md5());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
| 
| static int
| __archive_windowsapi_md5init(archive_md5_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_MD5));
| }
| 
| static int
| __archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 16, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_md5init(archive_md5_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5final(archive_md5_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* RIPEMD160 implementations */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
| 
| static int
| __archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RMD160Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RMD160Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RMD160Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
| 
| static int
| __archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RIPEMD160_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RIPEMD160_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RIPEMD160_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
| 
| static int
| __archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   ripemd160_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   ripemd160_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
| 
| static int
| __archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_ripemd160());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #else
| 
| static int
| __archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA1 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
| 
| static int
| __archive_libc_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
| 
| static int
| __archive_libmd_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha1init(archive_sha1_ctx *ctx)
| {
|   CC_SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   CC_SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
| 
| static int
| __archive_nettle_sha1init(archive_sha1_ctx *ctx)
| {
|   sha1_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha1_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
| 
| static int
| __archive_openssl_sha1init(archive_sha1_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha1());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
| 
| static int
| __archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA1));
| }
| 
| static int
| __archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 20, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha1init(archive_sha1_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA256 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
| 
| static int
| __archive_libc_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
| 
| static int
| __archive_libc2_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
| 
| static int
| __archive_libc3_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
| 
| static int
| __archive_libmd_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha256init(archive_sha256_ctx *ctx)
| {
|   CC_SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   CC_SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
| 
| static int
| __archive_nettle_sha256init(archive_sha256_ctx *ctx)
| {
|   sha256_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha256_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
| 
| static int
| __archive_openssl_sha256init(archive_sha256_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha256());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
| 
| static int
| __archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_256));
| }
| 
| static int
| __archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 32, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha256init(archive_sha256_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA384 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
| 
| static int
| __archive_libc_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
| 
| static int
| __archive_libc2_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
| 
| static int
| __archive_libc3_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha384init(archive_sha384_ctx *ctx)
| {
|   CC_SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   CC_SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
| 
| static int
| __archive_nettle_sha384init(archive_sha384_ctx *ctx)
| {
|   sha384_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha384_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
| 
| static int
| __archive_openssl_sha384init(archive_sha384_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha384());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
| 
| static int
| __archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_384));
| }
| 
| static int
| __archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 48, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha384init(archive_sha384_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA512 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
| 
| static int
| __archive_libc_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
| 
| static int
| __archive_libc2_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
| 
| static int
| __archive_libc3_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
| 
| static int
| __archive_libmd_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha512init(archive_sha512_ctx *ctx)
| {
|   CC_SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   CC_SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
| 
| static int
| __archive_nettle_sha512init(archive_sha512_ctx *ctx)
| {
|   sha512_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha512_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
| 
| static int
| __archive_openssl_sha512init(archive_sha512_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha512());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| static int
| __archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_512));
| }
| 
| static int
| __archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 64, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha512init(archive_sha512_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* NOTE: Crypto functions are set based on availability and by the following
|  * order of preference.
|  * 1. libc
|  * 2. libc2
|  * 3. libc3
|  * 4. libSystem
|  * 5. Nettle
|  * 6. OpenSSL
|  * 7. libmd
|  * 8. Windows API
|  */
| const struct archive_crypto __archive_crypto =
| {
| /* MD5 */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
|   &__archive_libc_md5init,
|   &__archive_libc_md5update,
|   &__archive_libc_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
|   &__archive_libmd_md5init,
|   &__archive_libmd_md5update,
|   &__archive_libmd_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
|   &__archive_libsystem_md5init,
|   &__archive_libsystem_md5update,
|   &__archive_libsystem_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
|   &__archive_nettle_md5init,
|   &__archive_nettle_md5update,
|   &__archive_nettle_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
|   &__archive_openssl_md5init,
|   &__archive_openssl_md5update,
|   &__archive_openssl_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
|   &__archive_windowsapi_md5init,
|   &__archive_windowsapi_md5update,
|   &__archive_windowsapi_md5final,
| #elif !defined(ARCHIVE_MD5_COMPILE_TEST)
|   &__archive_stub_md5init,
|   &__archive_stub_md5update,
|   &__archive_stub_md5final,
| #endif
| 
| /* RIPEMD160 */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
|   &__archive_libc_ripemd160init,
|   &__archive_libc_ripemd160update,
|   &__archive_libc_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
|   &__archive_libmd_ripemd160init,
|   &__archive_libmd_ripemd160update,
|   &__archive_libmd_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
|   &__archive_nettle_ripemd160init,
|   &__archive_nettle_ripemd160update,
|   &__archive_nettle_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
|   &__archive_openssl_ripemd160init,
|   &__archive_openssl_ripemd160update,
|   &__archive_openssl_ripemd160final,
| #elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
|   &__archive_stub_ripemd160init,
|   &__archive_stub_ripemd160update,
|   &__archive_stub_ripemd160final,
| #endif
| 
| /* SHA1 */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
|   &__archive_libc_sha1init,
|   &__archive_libc_sha1update,
|   &__archive_libc_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
|   &__archive_libmd_sha1init,
|   &__archive_libmd_sha1update,
|   &__archive_libmd_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
|   &__archive_libsystem_sha1init,
|   &__archive_libsystem_sha1update,
|   &__archive_libsystem_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
|   &__archive_nettle_sha1init,
|   &__archive_nettle_sha1update,
|   &__archive_nettle_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
|   &__archive_openssl_sha1init,
|   &__archive_openssl_sha1update,
|   &__archive_openssl_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
|   &__archive_windowsapi_sha1init,
|   &__archive_windowsapi_sha1update,
|   &__archive_windowsapi_sha1final,
| #elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
|   &__archive_stub_sha1init,
|   &__archive_stub_sha1update,
|   &__archive_stub_sha1final,
| #endif
| 
| /* SHA256 */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
|   &__archive_libc_sha256init,
|   &__archive_libc_sha256update,
|   &__archive_libc_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
|   &__archive_libc2_sha256init,
|   &__archive_libc2_sha256update,
|   &__archive_libc2_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
|   &__archive_libc3_sha256init,
|   &__archive_libc3_sha256update,
|   &__archive_libc3_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
|   &__archive_libmd_sha256init,
|   &__archive_libmd_sha256update,
|   &__archive_libmd_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
|   &__archive_libsystem_sha256init,
|   &__archive_libsystem_sha256update,
|   &__archive_libsystem_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
|   &__archive_nettle_sha256init,
|   &__archive_nettle_sha256update,
|   &__archive_nettle_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
|   &__archive_openssl_sha256init,
|   &__archive_openssl_sha256update,
|   &__archive_openssl_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
|   &__archive_windowsapi_sha256init,
|   &__archive_windowsapi_sha256update,
|   &__archive_windowsapi_sha256final,
| #elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
|   &__archive_stub_sha256init,
|   &__archive_stub_sha256update,
|   &__archive_stub_sha256final,
| #endif
| 
| /* SHA384 */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
|   &__archive_libc_sha384init,
|   &__archive_libc_sha384update,
|   &__archive_libc_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
|   &__archive_libc2_sha384init,
|   &__archive_libc2_sha384update,
|   &__archive_libc2_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
|   &__archive_libc3_sha384init,
|   &__archive_libc3_sha384update,
|   &__archive_libc3_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
|   &__archive_libsystem_sha384init,
|   &__archive_libsystem_sha384update,
|   &__archive_libsystem_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
|   &__archive_nettle_sha384init,
|   &__archive_nettle_sha384update,
|   &__archive_nettle_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
|   &__archive_openssl_sha384init,
|   &__archive_openssl_sha384update,
|   &__archive_openssl_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
|   &__archive_windowsapi_sha384init,
|   &__archive_windowsapi_sha384update,
|   &__archive_windowsapi_sha384final,
| #elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
|   &__archive_stub_sha384init,
|   &__archive_stub_sha384update,
|   &__archive_stub_sha384final,
| #endif
| 
| /* SHA512 */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
|   &__archive_libc_sha512init,
|   &__archive_libc_sha512update,
|   &__archive_libc_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
|   &__archive_libc2_sha512init,
|   &__archive_libc2_sha512update,
|   &__archive_libc2_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
|   &__archive_libc3_sha512init,
|   &__archive_libc3_sha512update,
|   &__archive_libc3_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
|   &__archive_libmd_sha512init,
|   &__archive_libmd_sha512update,
|   &__archive_libmd_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
|   &__archive_libsystem_sha512init,
|   &__archive_libsystem_sha512update,
|   &__archive_libsystem_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
|   &__archive_nettle_sha512init,
|   &__archive_nettle_sha512update,
|   &__archive_nettle_sha512final,
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
|   &__archive_openssl_sha512init,
|   &__archive_openssl_sha512update,
|   &__archive_openssl_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
|   &__archive_windowsapi_sha512init,
|   &__archive_windowsapi_sha512update,
|   &__archive_windowsapi_sha512final
| #elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
|   &__archive_stub_sha512init,
|   &__archive_stub_sha512update,
|   &__archive_stub_sha512final
| #endif
| };
| 
| int
| main(int argc, char **argv)
| {
|   archive_sha512_ctx ctx;
|   archive_sha512_init(&ctx);
|   archive_sha512_update(&ctx, *argv, argc);
|   archive_sha512_final(&ctx, NULL);
|   return 0;
| }
| 
configure:17905: result: no
configure:17919: checking support for ARCHIVE_CRYPTO_SHA512_LIBSYSTEM
configure:17941: arm-linux-androideabi-gcc -o conftest    -I. -I. -I./libarchive  conftest.c -lz  >&5
In file included from conftest.c:206:0:
./libarchive/archive_crypto_private.h:112:39: fatal error: CommonCrypto/CommonDigest.h: No such file or directory
 #include <CommonCrypto/CommonDigest.h>
                                       ^
compilation terminated.
configure:17941: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| #define ARCHIVE_SHA512_COMPILE_TEST
| #define ARCHIVE_CRYPTO_SHA512_LIBSYSTEM
| #define PLATFORM_CONFIG_H "check_crypto_md.h"
| 
| /*-
| * Copyright (c) 2003-2007 Tim Kientzle
| * Copyright (c) 2011 Andres Mejia
| * Copyright (c) 2011 Michihiro NAKAJIMA
| * All rights reserved.
| *
| * Redistribution and use in source and binary forms, with or without
| * modification, are permitted provided that the following conditions
| * are met:
| * 1. Redistributions of source code must retain the above copyright
| *    notice, this list of conditions and the following disclaimer.
| * 2. Redistributions in binary form must reproduce the above copyright
| *    notice, this list of conditions and the following disclaimer in the
| *    documentation and/or other materials provided with the distribution.
| *
| * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
| * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
| * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
| * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
| * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
| * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
| * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
| * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
| * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
| * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
| */
| 
| #include "archive_platform.h"
| 
| #include "archive.h"
| #include "archive_crypto_private.h"
| 
| /* In particular, force the configure probe to break if it tries
|  * to test a combination of OpenSSL and libmd. */
| #if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
| #error Cannot use both OpenSSL and libmd.
| #endif
| 
| /*
|  * Message digest functions for Windows platform.
|  */
| #if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
| 	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
| 	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| /*
|  * Initialize a Message digest.
|  */
| static int
| win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
| {
| 
| 	ctx->valid = 0;
| 	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
| 		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
| 			return (ARCHIVE_FAILED);
| 		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
| 			return (ARCHIVE_FAILED);
| 	}
| 
| 	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
| 		CryptReleaseContext(ctx->cryptProv, 0);
| 		return (ARCHIVE_FAILED);
| 	}
| 
| 	ctx->valid = 1;
| 	return (ARCHIVE_OK);
| }
| 
| /*
|  * Update a Message digest.
|  */
| static int
| win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
| {
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptHashData(ctx->hash,
| 		      (unsigned char *)(uintptr_t)buf,
| 		      (DWORD)len, 0);
| 	return (ARCHIVE_OK);
| }
| 
| static int
| win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
| {
| 	DWORD siglen = (DWORD)bufsize;
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
| 	CryptDestroyHash(ctx->hash);
| 	CryptReleaseContext(ctx->cryptProv, 0);
| 	ctx->valid = 0;
| 	return (ARCHIVE_OK);
| }
| 
| #endif /* defined(ARCHIVE_CRYPTO_*_WIN) */
| 
| 
| /* MD5 implementations */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
| 
| static int
| __archive_libc_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
| 
| static int
| __archive_libmd_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
| 
| static int
| __archive_libsystem_md5init(archive_md5_ctx *ctx)
| {
|   CC_MD5_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_MD5_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
| {
|   CC_MD5_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
| 
| static int
| __archive_nettle_md5init(archive_md5_ctx *ctx)
| {
|   md5_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   md5_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
| {
|   md5_digest(ctx, MD5_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
| 
| static int
| __archive_openssl_md5init(archive_md5_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_md5());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
| 
| static int
| __archive_windowsapi_md5init(archive_md5_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_MD5));
| }
| 
| static int
| __archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 16, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_md5init(archive_md5_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5final(archive_md5_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* RIPEMD160 implementations */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
| 
| static int
| __archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RMD160Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RMD160Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RMD160Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
| 
| static int
| __archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RIPEMD160_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RIPEMD160_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RIPEMD160_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
| 
| static int
| __archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   ripemd160_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   ripemd160_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
| 
| static int
| __archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_ripemd160());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #else
| 
| static int
| __archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA1 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
| 
| static int
| __archive_libc_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
| 
| static int
| __archive_libmd_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha1init(archive_sha1_ctx *ctx)
| {
|   CC_SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   CC_SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
| 
| static int
| __archive_nettle_sha1init(archive_sha1_ctx *ctx)
| {
|   sha1_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha1_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
| 
| static int
| __archive_openssl_sha1init(archive_sha1_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha1());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
| 
| static int
| __archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA1));
| }
| 
| static int
| __archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 20, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha1init(archive_sha1_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA256 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
| 
| static int
| __archive_libc_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
| 
| static int
| __archive_libc2_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
| 
| static int
| __archive_libc3_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
| 
| static int
| __archive_libmd_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha256init(archive_sha256_ctx *ctx)
| {
|   CC_SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   CC_SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
| 
| static int
| __archive_nettle_sha256init(archive_sha256_ctx *ctx)
| {
|   sha256_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha256_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
| 
| static int
| __archive_openssl_sha256init(archive_sha256_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha256());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
| 
| static int
| __archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_256));
| }
| 
| static int
| __archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 32, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha256init(archive_sha256_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA384 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
| 
| static int
| __archive_libc_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
| 
| static int
| __archive_libc2_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
| 
| static int
| __archive_libc3_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha384init(archive_sha384_ctx *ctx)
| {
|   CC_SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   CC_SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
| 
| static int
| __archive_nettle_sha384init(archive_sha384_ctx *ctx)
| {
|   sha384_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha384_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
| 
| static int
| __archive_openssl_sha384init(archive_sha384_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha384());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
| 
| static int
| __archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_384));
| }
| 
| static int
| __archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 48, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha384init(archive_sha384_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA512 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
| 
| static int
| __archive_libc_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
| 
| static int
| __archive_libc2_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
| 
| static int
| __archive_libc3_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
| 
| static int
| __archive_libmd_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha512init(archive_sha512_ctx *ctx)
| {
|   CC_SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   CC_SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
| 
| static int
| __archive_nettle_sha512init(archive_sha512_ctx *ctx)
| {
|   sha512_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha512_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
| 
| static int
| __archive_openssl_sha512init(archive_sha512_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha512());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| static int
| __archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_512));
| }
| 
| static int
| __archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 64, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha512init(archive_sha512_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* NOTE: Crypto functions are set based on availability and by the following
|  * order of preference.
|  * 1. libc
|  * 2. libc2
|  * 3. libc3
|  * 4. libSystem
|  * 5. Nettle
|  * 6. OpenSSL
|  * 7. libmd
|  * 8. Windows API
|  */
| const struct archive_crypto __archive_crypto =
| {
| /* MD5 */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
|   &__archive_libc_md5init,
|   &__archive_libc_md5update,
|   &__archive_libc_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
|   &__archive_libmd_md5init,
|   &__archive_libmd_md5update,
|   &__archive_libmd_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
|   &__archive_libsystem_md5init,
|   &__archive_libsystem_md5update,
|   &__archive_libsystem_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
|   &__archive_nettle_md5init,
|   &__archive_nettle_md5update,
|   &__archive_nettle_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
|   &__archive_openssl_md5init,
|   &__archive_openssl_md5update,
|   &__archive_openssl_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
|   &__archive_windowsapi_md5init,
|   &__archive_windowsapi_md5update,
|   &__archive_windowsapi_md5final,
| #elif !defined(ARCHIVE_MD5_COMPILE_TEST)
|   &__archive_stub_md5init,
|   &__archive_stub_md5update,
|   &__archive_stub_md5final,
| #endif
| 
| /* RIPEMD160 */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
|   &__archive_libc_ripemd160init,
|   &__archive_libc_ripemd160update,
|   &__archive_libc_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
|   &__archive_libmd_ripemd160init,
|   &__archive_libmd_ripemd160update,
|   &__archive_libmd_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
|   &__archive_nettle_ripemd160init,
|   &__archive_nettle_ripemd160update,
|   &__archive_nettle_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
|   &__archive_openssl_ripemd160init,
|   &__archive_openssl_ripemd160update,
|   &__archive_openssl_ripemd160final,
| #elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
|   &__archive_stub_ripemd160init,
|   &__archive_stub_ripemd160update,
|   &__archive_stub_ripemd160final,
| #endif
| 
| /* SHA1 */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
|   &__archive_libc_sha1init,
|   &__archive_libc_sha1update,
|   &__archive_libc_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
|   &__archive_libmd_sha1init,
|   &__archive_libmd_sha1update,
|   &__archive_libmd_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
|   &__archive_libsystem_sha1init,
|   &__archive_libsystem_sha1update,
|   &__archive_libsystem_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
|   &__archive_nettle_sha1init,
|   &__archive_nettle_sha1update,
|   &__archive_nettle_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
|   &__archive_openssl_sha1init,
|   &__archive_openssl_sha1update,
|   &__archive_openssl_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
|   &__archive_windowsapi_sha1init,
|   &__archive_windowsapi_sha1update,
|   &__archive_windowsapi_sha1final,
| #elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
|   &__archive_stub_sha1init,
|   &__archive_stub_sha1update,
|   &__archive_stub_sha1final,
| #endif
| 
| /* SHA256 */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
|   &__archive_libc_sha256init,
|   &__archive_libc_sha256update,
|   &__archive_libc_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
|   &__archive_libc2_sha256init,
|   &__archive_libc2_sha256update,
|   &__archive_libc2_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
|   &__archive_libc3_sha256init,
|   &__archive_libc3_sha256update,
|   &__archive_libc3_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
|   &__archive_libmd_sha256init,
|   &__archive_libmd_sha256update,
|   &__archive_libmd_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
|   &__archive_libsystem_sha256init,
|   &__archive_libsystem_sha256update,
|   &__archive_libsystem_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
|   &__archive_nettle_sha256init,
|   &__archive_nettle_sha256update,
|   &__archive_nettle_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
|   &__archive_openssl_sha256init,
|   &__archive_openssl_sha256update,
|   &__archive_openssl_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
|   &__archive_windowsapi_sha256init,
|   &__archive_windowsapi_sha256update,
|   &__archive_windowsapi_sha256final,
| #elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
|   &__archive_stub_sha256init,
|   &__archive_stub_sha256update,
|   &__archive_stub_sha256final,
| #endif
| 
| /* SHA384 */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
|   &__archive_libc_sha384init,
|   &__archive_libc_sha384update,
|   &__archive_libc_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
|   &__archive_libc2_sha384init,
|   &__archive_libc2_sha384update,
|   &__archive_libc2_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
|   &__archive_libc3_sha384init,
|   &__archive_libc3_sha384update,
|   &__archive_libc3_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
|   &__archive_libsystem_sha384init,
|   &__archive_libsystem_sha384update,
|   &__archive_libsystem_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
|   &__archive_nettle_sha384init,
|   &__archive_nettle_sha384update,
|   &__archive_nettle_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
|   &__archive_openssl_sha384init,
|   &__archive_openssl_sha384update,
|   &__archive_openssl_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
|   &__archive_windowsapi_sha384init,
|   &__archive_windowsapi_sha384update,
|   &__archive_windowsapi_sha384final,
| #elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
|   &__archive_stub_sha384init,
|   &__archive_stub_sha384update,
|   &__archive_stub_sha384final,
| #endif
| 
| /* SHA512 */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
|   &__archive_libc_sha512init,
|   &__archive_libc_sha512update,
|   &__archive_libc_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
|   &__archive_libc2_sha512init,
|   &__archive_libc2_sha512update,
|   &__archive_libc2_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
|   &__archive_libc3_sha512init,
|   &__archive_libc3_sha512update,
|   &__archive_libc3_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
|   &__archive_libmd_sha512init,
|   &__archive_libmd_sha512update,
|   &__archive_libmd_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
|   &__archive_libsystem_sha512init,
|   &__archive_libsystem_sha512update,
|   &__archive_libsystem_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
|   &__archive_nettle_sha512init,
|   &__archive_nettle_sha512update,
|   &__archive_nettle_sha512final,
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
|   &__archive_openssl_sha512init,
|   &__archive_openssl_sha512update,
|   &__archive_openssl_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
|   &__archive_windowsapi_sha512init,
|   &__archive_windowsapi_sha512update,
|   &__archive_windowsapi_sha512final
| #elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
|   &__archive_stub_sha512init,
|   &__archive_stub_sha512update,
|   &__archive_stub_sha512final
| #endif
| };
| 
| int
| main(int argc, char **argv)
| {
|   archive_sha512_ctx ctx;
|   archive_sha512_init(&ctx);
|   archive_sha512_update(&ctx, *argv, argc);
|   archive_sha512_final(&ctx, NULL);
|   return 0;
| }
| 
configure:17951: result: no
configure:17967: checking nettle/md5.h usability
configure:17967: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:204:24: fatal error: nettle/md5.h: No such file or directory
 #include <nettle/md5.h>
                        ^
compilation terminated.
configure:17967: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <nettle/md5.h>
configure:17967: result: no
configure:17967: checking nettle/md5.h presence
configure:17967: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:171:24: fatal error: nettle/md5.h: No such file or directory
 #include <nettle/md5.h>
                        ^
compilation terminated.
configure:17967: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| #include <nettle/md5.h>
configure:17967: result: no
configure:17967: checking for nettle/md5.h
configure:17967: result: no
configure:17967: checking nettle/ripemd160.h usability
configure:17967: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:204:30: fatal error: nettle/ripemd160.h: No such file or directory
 #include <nettle/ripemd160.h>
                              ^
compilation terminated.
configure:17967: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <nettle/ripemd160.h>
configure:17967: result: no
configure:17967: checking nettle/ripemd160.h presence
configure:17967: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:171:30: fatal error: nettle/ripemd160.h: No such file or directory
 #include <nettle/ripemd160.h>
                              ^
compilation terminated.
configure:17967: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| #include <nettle/ripemd160.h>
configure:17967: result: no
configure:17967: checking for nettle/ripemd160.h
configure:17967: result: no
configure:17967: checking nettle/sha.h usability
configure:17967: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:204:24: fatal error: nettle/sha.h: No such file or directory
 #include <nettle/sha.h>
                        ^
compilation terminated.
configure:17967: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <nettle/sha.h>
configure:17967: result: no
configure:17967: checking nettle/sha.h presence
configure:17967: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:171:24: fatal error: nettle/sha.h: No such file or directory
 #include <nettle/sha.h>
                        ^
compilation terminated.
configure:17967: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| #include <nettle/sha.h>
configure:17967: result: no
configure:17967: checking for nettle/sha.h
configure:17967: result: no
configure:17978: checking for main in -lnettle
configure:17997: arm-linux-androideabi-gcc -o conftest     conftest.c -lnettle  -lz  >&5
/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld: error: cannot find -lnettle
collect2: error: ld returned 1 exit status
configure:17997: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| 
| int
| main ()
| {
| return main ();
|   ;
|   return 0;
| }
configure:18006: result: no
configure:18022: checking support for ARCHIVE_CRYPTO_MD5_NETTLE
configure:18044: arm-linux-androideabi-gcc -o conftest    -I. -I. -I./libarchive  conftest.c -lz  >&5
In file included from conftest.c:206:0:
./libarchive/archive_crypto_private.h:117:24: fatal error: nettle/md5.h: No such file or directory
 #include <nettle/md5.h>
                        ^
compilation terminated.
configure:18044: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| #define ARCHIVE_MD5_COMPILE_TEST
| #define ARCHIVE_CRYPTO_MD5_NETTLE
| #define PLATFORM_CONFIG_H "check_crypto_md.h"
| 
| /*-
| * Copyright (c) 2003-2007 Tim Kientzle
| * Copyright (c) 2011 Andres Mejia
| * Copyright (c) 2011 Michihiro NAKAJIMA
| * All rights reserved.
| *
| * Redistribution and use in source and binary forms, with or without
| * modification, are permitted provided that the following conditions
| * are met:
| * 1. Redistributions of source code must retain the above copyright
| *    notice, this list of conditions and the following disclaimer.
| * 2. Redistributions in binary form must reproduce the above copyright
| *    notice, this list of conditions and the following disclaimer in the
| *    documentation and/or other materials provided with the distribution.
| *
| * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
| * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
| * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
| * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
| * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
| * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
| * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
| * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
| * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
| * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
| */
| 
| #include "archive_platform.h"
| 
| #include "archive.h"
| #include "archive_crypto_private.h"
| 
| /* In particular, force the configure probe to break if it tries
|  * to test a combination of OpenSSL and libmd. */
| #if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
| #error Cannot use both OpenSSL and libmd.
| #endif
| 
| /*
|  * Message digest functions for Windows platform.
|  */
| #if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
| 	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
| 	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| /*
|  * Initialize a Message digest.
|  */
| static int
| win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
| {
| 
| 	ctx->valid = 0;
| 	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
| 		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
| 			return (ARCHIVE_FAILED);
| 		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
| 			return (ARCHIVE_FAILED);
| 	}
| 
| 	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
| 		CryptReleaseContext(ctx->cryptProv, 0);
| 		return (ARCHIVE_FAILED);
| 	}
| 
| 	ctx->valid = 1;
| 	return (ARCHIVE_OK);
| }
| 
| /*
|  * Update a Message digest.
|  */
| static int
| win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
| {
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptHashData(ctx->hash,
| 		      (unsigned char *)(uintptr_t)buf,
| 		      (DWORD)len, 0);
| 	return (ARCHIVE_OK);
| }
| 
| static int
| win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
| {
| 	DWORD siglen = (DWORD)bufsize;
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
| 	CryptDestroyHash(ctx->hash);
| 	CryptReleaseContext(ctx->cryptProv, 0);
| 	ctx->valid = 0;
| 	return (ARCHIVE_OK);
| }
| 
| #endif /* defined(ARCHIVE_CRYPTO_*_WIN) */
| 
| 
| /* MD5 implementations */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
| 
| static int
| __archive_libc_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
| 
| static int
| __archive_libmd_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
| 
| static int
| __archive_libsystem_md5init(archive_md5_ctx *ctx)
| {
|   CC_MD5_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_MD5_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
| {
|   CC_MD5_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
| 
| static int
| __archive_nettle_md5init(archive_md5_ctx *ctx)
| {
|   md5_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   md5_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
| {
|   md5_digest(ctx, MD5_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
| 
| static int
| __archive_openssl_md5init(archive_md5_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_md5());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
| 
| static int
| __archive_windowsapi_md5init(archive_md5_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_MD5));
| }
| 
| static int
| __archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 16, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_md5init(archive_md5_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5final(archive_md5_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* RIPEMD160 implementations */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
| 
| static int
| __archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RMD160Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RMD160Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RMD160Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
| 
| static int
| __archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RIPEMD160_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RIPEMD160_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RIPEMD160_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
| 
| static int
| __archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   ripemd160_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   ripemd160_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
| 
| static int
| __archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_ripemd160());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #else
| 
| static int
| __archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA1 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
| 
| static int
| __archive_libc_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
| 
| static int
| __archive_libmd_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha1init(archive_sha1_ctx *ctx)
| {
|   CC_SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   CC_SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
| 
| static int
| __archive_nettle_sha1init(archive_sha1_ctx *ctx)
| {
|   sha1_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha1_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
| 
| static int
| __archive_openssl_sha1init(archive_sha1_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha1());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
| 
| static int
| __archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA1));
| }
| 
| static int
| __archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 20, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha1init(archive_sha1_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA256 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
| 
| static int
| __archive_libc_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
| 
| static int
| __archive_libc2_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
| 
| static int
| __archive_libc3_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
| 
| static int
| __archive_libmd_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha256init(archive_sha256_ctx *ctx)
| {
|   CC_SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   CC_SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
| 
| static int
| __archive_nettle_sha256init(archive_sha256_ctx *ctx)
| {
|   sha256_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha256_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
| 
| static int
| __archive_openssl_sha256init(archive_sha256_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha256());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
| 
| static int
| __archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_256));
| }
| 
| static int
| __archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 32, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha256init(archive_sha256_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA384 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
| 
| static int
| __archive_libc_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
| 
| static int
| __archive_libc2_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
| 
| static int
| __archive_libc3_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha384init(archive_sha384_ctx *ctx)
| {
|   CC_SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   CC_SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
| 
| static int
| __archive_nettle_sha384init(archive_sha384_ctx *ctx)
| {
|   sha384_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha384_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
| 
| static int
| __archive_openssl_sha384init(archive_sha384_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha384());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
| 
| static int
| __archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_384));
| }
| 
| static int
| __archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 48, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha384init(archive_sha384_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA512 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
| 
| static int
| __archive_libc_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
| 
| static int
| __archive_libc2_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
| 
| static int
| __archive_libc3_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
| 
| static int
| __archive_libmd_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha512init(archive_sha512_ctx *ctx)
| {
|   CC_SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   CC_SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
| 
| static int
| __archive_nettle_sha512init(archive_sha512_ctx *ctx)
| {
|   sha512_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha512_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
| 
| static int
| __archive_openssl_sha512init(archive_sha512_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha512());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| static int
| __archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_512));
| }
| 
| static int
| __archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 64, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha512init(archive_sha512_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* NOTE: Crypto functions are set based on availability and by the following
|  * order of preference.
|  * 1. libc
|  * 2. libc2
|  * 3. libc3
|  * 4. libSystem
|  * 5. Nettle
|  * 6. OpenSSL
|  * 7. libmd
|  * 8. Windows API
|  */
| const struct archive_crypto __archive_crypto =
| {
| /* MD5 */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
|   &__archive_libc_md5init,
|   &__archive_libc_md5update,
|   &__archive_libc_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
|   &__archive_libmd_md5init,
|   &__archive_libmd_md5update,
|   &__archive_libmd_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
|   &__archive_libsystem_md5init,
|   &__archive_libsystem_md5update,
|   &__archive_libsystem_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
|   &__archive_nettle_md5init,
|   &__archive_nettle_md5update,
|   &__archive_nettle_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
|   &__archive_openssl_md5init,
|   &__archive_openssl_md5update,
|   &__archive_openssl_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
|   &__archive_windowsapi_md5init,
|   &__archive_windowsapi_md5update,
|   &__archive_windowsapi_md5final,
| #elif !defined(ARCHIVE_MD5_COMPILE_TEST)
|   &__archive_stub_md5init,
|   &__archive_stub_md5update,
|   &__archive_stub_md5final,
| #endif
| 
| /* RIPEMD160 */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
|   &__archive_libc_ripemd160init,
|   &__archive_libc_ripemd160update,
|   &__archive_libc_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
|   &__archive_libmd_ripemd160init,
|   &__archive_libmd_ripemd160update,
|   &__archive_libmd_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
|   &__archive_nettle_ripemd160init,
|   &__archive_nettle_ripemd160update,
|   &__archive_nettle_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
|   &__archive_openssl_ripemd160init,
|   &__archive_openssl_ripemd160update,
|   &__archive_openssl_ripemd160final,
| #elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
|   &__archive_stub_ripemd160init,
|   &__archive_stub_ripemd160update,
|   &__archive_stub_ripemd160final,
| #endif
| 
| /* SHA1 */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
|   &__archive_libc_sha1init,
|   &__archive_libc_sha1update,
|   &__archive_libc_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
|   &__archive_libmd_sha1init,
|   &__archive_libmd_sha1update,
|   &__archive_libmd_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
|   &__archive_libsystem_sha1init,
|   &__archive_libsystem_sha1update,
|   &__archive_libsystem_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
|   &__archive_nettle_sha1init,
|   &__archive_nettle_sha1update,
|   &__archive_nettle_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
|   &__archive_openssl_sha1init,
|   &__archive_openssl_sha1update,
|   &__archive_openssl_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
|   &__archive_windowsapi_sha1init,
|   &__archive_windowsapi_sha1update,
|   &__archive_windowsapi_sha1final,
| #elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
|   &__archive_stub_sha1init,
|   &__archive_stub_sha1update,
|   &__archive_stub_sha1final,
| #endif
| 
| /* SHA256 */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
|   &__archive_libc_sha256init,
|   &__archive_libc_sha256update,
|   &__archive_libc_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
|   &__archive_libc2_sha256init,
|   &__archive_libc2_sha256update,
|   &__archive_libc2_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
|   &__archive_libc3_sha256init,
|   &__archive_libc3_sha256update,
|   &__archive_libc3_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
|   &__archive_libmd_sha256init,
|   &__archive_libmd_sha256update,
|   &__archive_libmd_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
|   &__archive_libsystem_sha256init,
|   &__archive_libsystem_sha256update,
|   &__archive_libsystem_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
|   &__archive_nettle_sha256init,
|   &__archive_nettle_sha256update,
|   &__archive_nettle_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
|   &__archive_openssl_sha256init,
|   &__archive_openssl_sha256update,
|   &__archive_openssl_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
|   &__archive_windowsapi_sha256init,
|   &__archive_windowsapi_sha256update,
|   &__archive_windowsapi_sha256final,
| #elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
|   &__archive_stub_sha256init,
|   &__archive_stub_sha256update,
|   &__archive_stub_sha256final,
| #endif
| 
| /* SHA384 */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
|   &__archive_libc_sha384init,
|   &__archive_libc_sha384update,
|   &__archive_libc_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
|   &__archive_libc2_sha384init,
|   &__archive_libc2_sha384update,
|   &__archive_libc2_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
|   &__archive_libc3_sha384init,
|   &__archive_libc3_sha384update,
|   &__archive_libc3_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
|   &__archive_libsystem_sha384init,
|   &__archive_libsystem_sha384update,
|   &__archive_libsystem_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
|   &__archive_nettle_sha384init,
|   &__archive_nettle_sha384update,
|   &__archive_nettle_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
|   &__archive_openssl_sha384init,
|   &__archive_openssl_sha384update,
|   &__archive_openssl_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
|   &__archive_windowsapi_sha384init,
|   &__archive_windowsapi_sha384update,
|   &__archive_windowsapi_sha384final,
| #elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
|   &__archive_stub_sha384init,
|   &__archive_stub_sha384update,
|   &__archive_stub_sha384final,
| #endif
| 
| /* SHA512 */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
|   &__archive_libc_sha512init,
|   &__archive_libc_sha512update,
|   &__archive_libc_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
|   &__archive_libc2_sha512init,
|   &__archive_libc2_sha512update,
|   &__archive_libc2_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
|   &__archive_libc3_sha512init,
|   &__archive_libc3_sha512update,
|   &__archive_libc3_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
|   &__archive_libmd_sha512init,
|   &__archive_libmd_sha512update,
|   &__archive_libmd_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
|   &__archive_libsystem_sha512init,
|   &__archive_libsystem_sha512update,
|   &__archive_libsystem_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
|   &__archive_nettle_sha512init,
|   &__archive_nettle_sha512update,
|   &__archive_nettle_sha512final,
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
|   &__archive_openssl_sha512init,
|   &__archive_openssl_sha512update,
|   &__archive_openssl_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
|   &__archive_windowsapi_sha512init,
|   &__archive_windowsapi_sha512update,
|   &__archive_windowsapi_sha512final
| #elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
|   &__archive_stub_sha512init,
|   &__archive_stub_sha512update,
|   &__archive_stub_sha512final
| #endif
| };
| 
| int
| main(int argc, char **argv)
| {
|   archive_md5_ctx ctx;
|   archive_md5_init(&ctx);
|   archive_md5_update(&ctx, *argv, argc);
|   archive_md5_final(&ctx, NULL);
|   return 0;
| }
| 
configure:18054: result: no
configure:18068: checking support for ARCHIVE_CRYPTO_RMD160_NETTLE
configure:18090: arm-linux-androideabi-gcc -o conftest    -I. -I. -I./libarchive  conftest.c -lz  >&5
In file included from conftest.c:206:0:
./libarchive/archive_crypto_private.h:120:30: fatal error: nettle/ripemd160.h: No such file or directory
 #include <nettle/ripemd160.h>
                              ^
compilation terminated.
configure:18090: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| #define ARCHIVE_RMD160_COMPILE_TEST
| #define ARCHIVE_CRYPTO_RMD160_NETTLE
| #define PLATFORM_CONFIG_H "check_crypto_md.h"
| 
| /*-
| * Copyright (c) 2003-2007 Tim Kientzle
| * Copyright (c) 2011 Andres Mejia
| * Copyright (c) 2011 Michihiro NAKAJIMA
| * All rights reserved.
| *
| * Redistribution and use in source and binary forms, with or without
| * modification, are permitted provided that the following conditions
| * are met:
| * 1. Redistributions of source code must retain the above copyright
| *    notice, this list of conditions and the following disclaimer.
| * 2. Redistributions in binary form must reproduce the above copyright
| *    notice, this list of conditions and the following disclaimer in the
| *    documentation and/or other materials provided with the distribution.
| *
| * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
| * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
| * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
| * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
| * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
| * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
| * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
| * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
| * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
| * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
| */
| 
| #include "archive_platform.h"
| 
| #include "archive.h"
| #include "archive_crypto_private.h"
| 
| /* In particular, force the configure probe to break if it tries
|  * to test a combination of OpenSSL and libmd. */
| #if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
| #error Cannot use both OpenSSL and libmd.
| #endif
| 
| /*
|  * Message digest functions for Windows platform.
|  */
| #if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
| 	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
| 	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| /*
|  * Initialize a Message digest.
|  */
| static int
| win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
| {
| 
| 	ctx->valid = 0;
| 	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
| 		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
| 			return (ARCHIVE_FAILED);
| 		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
| 			return (ARCHIVE_FAILED);
| 	}
| 
| 	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
| 		CryptReleaseContext(ctx->cryptProv, 0);
| 		return (ARCHIVE_FAILED);
| 	}
| 
| 	ctx->valid = 1;
| 	return (ARCHIVE_OK);
| }
| 
| /*
|  * Update a Message digest.
|  */
| static int
| win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
| {
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptHashData(ctx->hash,
| 		      (unsigned char *)(uintptr_t)buf,
| 		      (DWORD)len, 0);
| 	return (ARCHIVE_OK);
| }
| 
| static int
| win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
| {
| 	DWORD siglen = (DWORD)bufsize;
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
| 	CryptDestroyHash(ctx->hash);
| 	CryptReleaseContext(ctx->cryptProv, 0);
| 	ctx->valid = 0;
| 	return (ARCHIVE_OK);
| }
| 
| #endif /* defined(ARCHIVE_CRYPTO_*_WIN) */
| 
| 
| /* MD5 implementations */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
| 
| static int
| __archive_libc_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
| 
| static int
| __archive_libmd_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
| 
| static int
| __archive_libsystem_md5init(archive_md5_ctx *ctx)
| {
|   CC_MD5_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_MD5_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
| {
|   CC_MD5_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
| 
| static int
| __archive_nettle_md5init(archive_md5_ctx *ctx)
| {
|   md5_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   md5_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
| {
|   md5_digest(ctx, MD5_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
| 
| static int
| __archive_openssl_md5init(archive_md5_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_md5());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
| 
| static int
| __archive_windowsapi_md5init(archive_md5_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_MD5));
| }
| 
| static int
| __archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 16, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_md5init(archive_md5_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5final(archive_md5_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* RIPEMD160 implementations */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
| 
| static int
| __archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RMD160Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RMD160Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RMD160Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
| 
| static int
| __archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RIPEMD160_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RIPEMD160_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RIPEMD160_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
| 
| static int
| __archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   ripemd160_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   ripemd160_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
| 
| static int
| __archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_ripemd160());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #else
| 
| static int
| __archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA1 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
| 
| static int
| __archive_libc_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
| 
| static int
| __archive_libmd_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha1init(archive_sha1_ctx *ctx)
| {
|   CC_SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   CC_SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
| 
| static int
| __archive_nettle_sha1init(archive_sha1_ctx *ctx)
| {
|   sha1_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha1_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
| 
| static int
| __archive_openssl_sha1init(archive_sha1_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha1());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
| 
| static int
| __archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA1));
| }
| 
| static int
| __archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 20, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha1init(archive_sha1_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA256 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
| 
| static int
| __archive_libc_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
| 
| static int
| __archive_libc2_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
| 
| static int
| __archive_libc3_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
| 
| static int
| __archive_libmd_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha256init(archive_sha256_ctx *ctx)
| {
|   CC_SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   CC_SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
| 
| static int
| __archive_nettle_sha256init(archive_sha256_ctx *ctx)
| {
|   sha256_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha256_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
| 
| static int
| __archive_openssl_sha256init(archive_sha256_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha256());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
| 
| static int
| __archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_256));
| }
| 
| static int
| __archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 32, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha256init(archive_sha256_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA384 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
| 
| static int
| __archive_libc_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
| 
| static int
| __archive_libc2_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
| 
| static int
| __archive_libc3_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha384init(archive_sha384_ctx *ctx)
| {
|   CC_SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   CC_SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
| 
| static int
| __archive_nettle_sha384init(archive_sha384_ctx *ctx)
| {
|   sha384_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha384_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
| 
| static int
| __archive_openssl_sha384init(archive_sha384_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha384());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
| 
| static int
| __archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_384));
| }
| 
| static int
| __archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 48, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha384init(archive_sha384_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA512 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
| 
| static int
| __archive_libc_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
| 
| static int
| __archive_libc2_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
| 
| static int
| __archive_libc3_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
| 
| static int
| __archive_libmd_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha512init(archive_sha512_ctx *ctx)
| {
|   CC_SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   CC_SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
| 
| static int
| __archive_nettle_sha512init(archive_sha512_ctx *ctx)
| {
|   sha512_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha512_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
| 
| static int
| __archive_openssl_sha512init(archive_sha512_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha512());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| static int
| __archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_512));
| }
| 
| static int
| __archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 64, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha512init(archive_sha512_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* NOTE: Crypto functions are set based on availability and by the following
|  * order of preference.
|  * 1. libc
|  * 2. libc2
|  * 3. libc3
|  * 4. libSystem
|  * 5. Nettle
|  * 6. OpenSSL
|  * 7. libmd
|  * 8. Windows API
|  */
| const struct archive_crypto __archive_crypto =
| {
| /* MD5 */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
|   &__archive_libc_md5init,
|   &__archive_libc_md5update,
|   &__archive_libc_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
|   &__archive_libmd_md5init,
|   &__archive_libmd_md5update,
|   &__archive_libmd_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
|   &__archive_libsystem_md5init,
|   &__archive_libsystem_md5update,
|   &__archive_libsystem_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
|   &__archive_nettle_md5init,
|   &__archive_nettle_md5update,
|   &__archive_nettle_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
|   &__archive_openssl_md5init,
|   &__archive_openssl_md5update,
|   &__archive_openssl_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
|   &__archive_windowsapi_md5init,
|   &__archive_windowsapi_md5update,
|   &__archive_windowsapi_md5final,
| #elif !defined(ARCHIVE_MD5_COMPILE_TEST)
|   &__archive_stub_md5init,
|   &__archive_stub_md5update,
|   &__archive_stub_md5final,
| #endif
| 
| /* RIPEMD160 */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
|   &__archive_libc_ripemd160init,
|   &__archive_libc_ripemd160update,
|   &__archive_libc_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
|   &__archive_libmd_ripemd160init,
|   &__archive_libmd_ripemd160update,
|   &__archive_libmd_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
|   &__archive_nettle_ripemd160init,
|   &__archive_nettle_ripemd160update,
|   &__archive_nettle_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
|   &__archive_openssl_ripemd160init,
|   &__archive_openssl_ripemd160update,
|   &__archive_openssl_ripemd160final,
| #elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
|   &__archive_stub_ripemd160init,
|   &__archive_stub_ripemd160update,
|   &__archive_stub_ripemd160final,
| #endif
| 
| /* SHA1 */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
|   &__archive_libc_sha1init,
|   &__archive_libc_sha1update,
|   &__archive_libc_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
|   &__archive_libmd_sha1init,
|   &__archive_libmd_sha1update,
|   &__archive_libmd_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
|   &__archive_libsystem_sha1init,
|   &__archive_libsystem_sha1update,
|   &__archive_libsystem_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
|   &__archive_nettle_sha1init,
|   &__archive_nettle_sha1update,
|   &__archive_nettle_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
|   &__archive_openssl_sha1init,
|   &__archive_openssl_sha1update,
|   &__archive_openssl_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
|   &__archive_windowsapi_sha1init,
|   &__archive_windowsapi_sha1update,
|   &__archive_windowsapi_sha1final,
| #elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
|   &__archive_stub_sha1init,
|   &__archive_stub_sha1update,
|   &__archive_stub_sha1final,
| #endif
| 
| /* SHA256 */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
|   &__archive_libc_sha256init,
|   &__archive_libc_sha256update,
|   &__archive_libc_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
|   &__archive_libc2_sha256init,
|   &__archive_libc2_sha256update,
|   &__archive_libc2_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
|   &__archive_libc3_sha256init,
|   &__archive_libc3_sha256update,
|   &__archive_libc3_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
|   &__archive_libmd_sha256init,
|   &__archive_libmd_sha256update,
|   &__archive_libmd_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
|   &__archive_libsystem_sha256init,
|   &__archive_libsystem_sha256update,
|   &__archive_libsystem_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
|   &__archive_nettle_sha256init,
|   &__archive_nettle_sha256update,
|   &__archive_nettle_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
|   &__archive_openssl_sha256init,
|   &__archive_openssl_sha256update,
|   &__archive_openssl_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
|   &__archive_windowsapi_sha256init,
|   &__archive_windowsapi_sha256update,
|   &__archive_windowsapi_sha256final,
| #elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
|   &__archive_stub_sha256init,
|   &__archive_stub_sha256update,
|   &__archive_stub_sha256final,
| #endif
| 
| /* SHA384 */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
|   &__archive_libc_sha384init,
|   &__archive_libc_sha384update,
|   &__archive_libc_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
|   &__archive_libc2_sha384init,
|   &__archive_libc2_sha384update,
|   &__archive_libc2_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
|   &__archive_libc3_sha384init,
|   &__archive_libc3_sha384update,
|   &__archive_libc3_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
|   &__archive_libsystem_sha384init,
|   &__archive_libsystem_sha384update,
|   &__archive_libsystem_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
|   &__archive_nettle_sha384init,
|   &__archive_nettle_sha384update,
|   &__archive_nettle_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
|   &__archive_openssl_sha384init,
|   &__archive_openssl_sha384update,
|   &__archive_openssl_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
|   &__archive_windowsapi_sha384init,
|   &__archive_windowsapi_sha384update,
|   &__archive_windowsapi_sha384final,
| #elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
|   &__archive_stub_sha384init,
|   &__archive_stub_sha384update,
|   &__archive_stub_sha384final,
| #endif
| 
| /* SHA512 */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
|   &__archive_libc_sha512init,
|   &__archive_libc_sha512update,
|   &__archive_libc_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
|   &__archive_libc2_sha512init,
|   &__archive_libc2_sha512update,
|   &__archive_libc2_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
|   &__archive_libc3_sha512init,
|   &__archive_libc3_sha512update,
|   &__archive_libc3_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
|   &__archive_libmd_sha512init,
|   &__archive_libmd_sha512update,
|   &__archive_libmd_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
|   &__archive_libsystem_sha512init,
|   &__archive_libsystem_sha512update,
|   &__archive_libsystem_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
|   &__archive_nettle_sha512init,
|   &__archive_nettle_sha512update,
|   &__archive_nettle_sha512final,
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
|   &__archive_openssl_sha512init,
|   &__archive_openssl_sha512update,
|   &__archive_openssl_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
|   &__archive_windowsapi_sha512init,
|   &__archive_windowsapi_sha512update,
|   &__archive_windowsapi_sha512final
| #elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
|   &__archive_stub_sha512init,
|   &__archive_stub_sha512update,
|   &__archive_stub_sha512final
| #endif
| };
| 
| int
| main(int argc, char **argv)
| {
|   archive_rmd160_ctx ctx;
|   archive_rmd160_init(&ctx);
|   archive_rmd160_update(&ctx, *argv, argc);
|   archive_rmd160_final(&ctx, NULL);
|   return 0;
| }
| 
configure:18100: result: no
configure:18114: checking support for ARCHIVE_CRYPTO_SHA1_NETTLE
configure:18136: arm-linux-androideabi-gcc -o conftest    -I. -I. -I./libarchive  conftest.c -lz  >&5
In file included from conftest.c:206:0:
./libarchive/archive_crypto_private.h:126:24: fatal error: nettle/sha.h: No such file or directory
 #include <nettle/sha.h>
                        ^
compilation terminated.
configure:18136: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| #define ARCHIVE_SHA1_COMPILE_TEST
| #define ARCHIVE_CRYPTO_SHA1_NETTLE
| #define PLATFORM_CONFIG_H "check_crypto_md.h"
| 
| /*-
| * Copyright (c) 2003-2007 Tim Kientzle
| * Copyright (c) 2011 Andres Mejia
| * Copyright (c) 2011 Michihiro NAKAJIMA
| * All rights reserved.
| *
| * Redistribution and use in source and binary forms, with or without
| * modification, are permitted provided that the following conditions
| * are met:
| * 1. Redistributions of source code must retain the above copyright
| *    notice, this list of conditions and the following disclaimer.
| * 2. Redistributions in binary form must reproduce the above copyright
| *    notice, this list of conditions and the following disclaimer in the
| *    documentation and/or other materials provided with the distribution.
| *
| * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
| * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
| * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
| * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
| * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
| * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
| * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
| * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
| * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
| * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
| */
| 
| #include "archive_platform.h"
| 
| #include "archive.h"
| #include "archive_crypto_private.h"
| 
| /* In particular, force the configure probe to break if it tries
|  * to test a combination of OpenSSL and libmd. */
| #if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
| #error Cannot use both OpenSSL and libmd.
| #endif
| 
| /*
|  * Message digest functions for Windows platform.
|  */
| #if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
| 	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
| 	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| /*
|  * Initialize a Message digest.
|  */
| static int
| win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
| {
| 
| 	ctx->valid = 0;
| 	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
| 		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
| 			return (ARCHIVE_FAILED);
| 		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
| 			return (ARCHIVE_FAILED);
| 	}
| 
| 	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
| 		CryptReleaseContext(ctx->cryptProv, 0);
| 		return (ARCHIVE_FAILED);
| 	}
| 
| 	ctx->valid = 1;
| 	return (ARCHIVE_OK);
| }
| 
| /*
|  * Update a Message digest.
|  */
| static int
| win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
| {
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptHashData(ctx->hash,
| 		      (unsigned char *)(uintptr_t)buf,
| 		      (DWORD)len, 0);
| 	return (ARCHIVE_OK);
| }
| 
| static int
| win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
| {
| 	DWORD siglen = (DWORD)bufsize;
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
| 	CryptDestroyHash(ctx->hash);
| 	CryptReleaseContext(ctx->cryptProv, 0);
| 	ctx->valid = 0;
| 	return (ARCHIVE_OK);
| }
| 
| #endif /* defined(ARCHIVE_CRYPTO_*_WIN) */
| 
| 
| /* MD5 implementations */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
| 
| static int
| __archive_libc_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
| 
| static int
| __archive_libmd_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
| 
| static int
| __archive_libsystem_md5init(archive_md5_ctx *ctx)
| {
|   CC_MD5_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_MD5_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
| {
|   CC_MD5_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
| 
| static int
| __archive_nettle_md5init(archive_md5_ctx *ctx)
| {
|   md5_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   md5_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
| {
|   md5_digest(ctx, MD5_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
| 
| static int
| __archive_openssl_md5init(archive_md5_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_md5());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
| 
| static int
| __archive_windowsapi_md5init(archive_md5_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_MD5));
| }
| 
| static int
| __archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 16, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_md5init(archive_md5_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5final(archive_md5_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* RIPEMD160 implementations */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
| 
| static int
| __archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RMD160Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RMD160Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RMD160Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
| 
| static int
| __archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RIPEMD160_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RIPEMD160_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RIPEMD160_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
| 
| static int
| __archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   ripemd160_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   ripemd160_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
| 
| static int
| __archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_ripemd160());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #else
| 
| static int
| __archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA1 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
| 
| static int
| __archive_libc_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
| 
| static int
| __archive_libmd_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha1init(archive_sha1_ctx *ctx)
| {
|   CC_SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   CC_SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
| 
| static int
| __archive_nettle_sha1init(archive_sha1_ctx *ctx)
| {
|   sha1_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha1_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
| 
| static int
| __archive_openssl_sha1init(archive_sha1_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha1());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
| 
| static int
| __archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA1));
| }
| 
| static int
| __archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 20, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha1init(archive_sha1_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA256 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
| 
| static int
| __archive_libc_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
| 
| static int
| __archive_libc2_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
| 
| static int
| __archive_libc3_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
| 
| static int
| __archive_libmd_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha256init(archive_sha256_ctx *ctx)
| {
|   CC_SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   CC_SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
| 
| static int
| __archive_nettle_sha256init(archive_sha256_ctx *ctx)
| {
|   sha256_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha256_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
| 
| static int
| __archive_openssl_sha256init(archive_sha256_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha256());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
| 
| static int
| __archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_256));
| }
| 
| static int
| __archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 32, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha256init(archive_sha256_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA384 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
| 
| static int
| __archive_libc_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
| 
| static int
| __archive_libc2_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
| 
| static int
| __archive_libc3_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha384init(archive_sha384_ctx *ctx)
| {
|   CC_SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   CC_SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
| 
| static int
| __archive_nettle_sha384init(archive_sha384_ctx *ctx)
| {
|   sha384_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha384_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
| 
| static int
| __archive_openssl_sha384init(archive_sha384_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha384());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
| 
| static int
| __archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_384));
| }
| 
| static int
| __archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 48, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha384init(archive_sha384_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA512 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
| 
| static int
| __archive_libc_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
| 
| static int
| __archive_libc2_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
| 
| static int
| __archive_libc3_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
| 
| static int
| __archive_libmd_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha512init(archive_sha512_ctx *ctx)
| {
|   CC_SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   CC_SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
| 
| static int
| __archive_nettle_sha512init(archive_sha512_ctx *ctx)
| {
|   sha512_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha512_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
| 
| static int
| __archive_openssl_sha512init(archive_sha512_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha512());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| static int
| __archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_512));
| }
| 
| static int
| __archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 64, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha512init(archive_sha512_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* NOTE: Crypto functions are set based on availability and by the following
|  * order of preference.
|  * 1. libc
|  * 2. libc2
|  * 3. libc3
|  * 4. libSystem
|  * 5. Nettle
|  * 6. OpenSSL
|  * 7. libmd
|  * 8. Windows API
|  */
| const struct archive_crypto __archive_crypto =
| {
| /* MD5 */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
|   &__archive_libc_md5init,
|   &__archive_libc_md5update,
|   &__archive_libc_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
|   &__archive_libmd_md5init,
|   &__archive_libmd_md5update,
|   &__archive_libmd_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
|   &__archive_libsystem_md5init,
|   &__archive_libsystem_md5update,
|   &__archive_libsystem_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
|   &__archive_nettle_md5init,
|   &__archive_nettle_md5update,
|   &__archive_nettle_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
|   &__archive_openssl_md5init,
|   &__archive_openssl_md5update,
|   &__archive_openssl_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
|   &__archive_windowsapi_md5init,
|   &__archive_windowsapi_md5update,
|   &__archive_windowsapi_md5final,
| #elif !defined(ARCHIVE_MD5_COMPILE_TEST)
|   &__archive_stub_md5init,
|   &__archive_stub_md5update,
|   &__archive_stub_md5final,
| #endif
| 
| /* RIPEMD160 */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
|   &__archive_libc_ripemd160init,
|   &__archive_libc_ripemd160update,
|   &__archive_libc_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
|   &__archive_libmd_ripemd160init,
|   &__archive_libmd_ripemd160update,
|   &__archive_libmd_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
|   &__archive_nettle_ripemd160init,
|   &__archive_nettle_ripemd160update,
|   &__archive_nettle_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
|   &__archive_openssl_ripemd160init,
|   &__archive_openssl_ripemd160update,
|   &__archive_openssl_ripemd160final,
| #elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
|   &__archive_stub_ripemd160init,
|   &__archive_stub_ripemd160update,
|   &__archive_stub_ripemd160final,
| #endif
| 
| /* SHA1 */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
|   &__archive_libc_sha1init,
|   &__archive_libc_sha1update,
|   &__archive_libc_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
|   &__archive_libmd_sha1init,
|   &__archive_libmd_sha1update,
|   &__archive_libmd_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
|   &__archive_libsystem_sha1init,
|   &__archive_libsystem_sha1update,
|   &__archive_libsystem_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
|   &__archive_nettle_sha1init,
|   &__archive_nettle_sha1update,
|   &__archive_nettle_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
|   &__archive_openssl_sha1init,
|   &__archive_openssl_sha1update,
|   &__archive_openssl_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
|   &__archive_windowsapi_sha1init,
|   &__archive_windowsapi_sha1update,
|   &__archive_windowsapi_sha1final,
| #elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
|   &__archive_stub_sha1init,
|   &__archive_stub_sha1update,
|   &__archive_stub_sha1final,
| #endif
| 
| /* SHA256 */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
|   &__archive_libc_sha256init,
|   &__archive_libc_sha256update,
|   &__archive_libc_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
|   &__archive_libc2_sha256init,
|   &__archive_libc2_sha256update,
|   &__archive_libc2_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
|   &__archive_libc3_sha256init,
|   &__archive_libc3_sha256update,
|   &__archive_libc3_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
|   &__archive_libmd_sha256init,
|   &__archive_libmd_sha256update,
|   &__archive_libmd_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
|   &__archive_libsystem_sha256init,
|   &__archive_libsystem_sha256update,
|   &__archive_libsystem_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
|   &__archive_nettle_sha256init,
|   &__archive_nettle_sha256update,
|   &__archive_nettle_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
|   &__archive_openssl_sha256init,
|   &__archive_openssl_sha256update,
|   &__archive_openssl_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
|   &__archive_windowsapi_sha256init,
|   &__archive_windowsapi_sha256update,
|   &__archive_windowsapi_sha256final,
| #elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
|   &__archive_stub_sha256init,
|   &__archive_stub_sha256update,
|   &__archive_stub_sha256final,
| #endif
| 
| /* SHA384 */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
|   &__archive_libc_sha384init,
|   &__archive_libc_sha384update,
|   &__archive_libc_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
|   &__archive_libc2_sha384init,
|   &__archive_libc2_sha384update,
|   &__archive_libc2_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
|   &__archive_libc3_sha384init,
|   &__archive_libc3_sha384update,
|   &__archive_libc3_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
|   &__archive_libsystem_sha384init,
|   &__archive_libsystem_sha384update,
|   &__archive_libsystem_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
|   &__archive_nettle_sha384init,
|   &__archive_nettle_sha384update,
|   &__archive_nettle_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
|   &__archive_openssl_sha384init,
|   &__archive_openssl_sha384update,
|   &__archive_openssl_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
|   &__archive_windowsapi_sha384init,
|   &__archive_windowsapi_sha384update,
|   &__archive_windowsapi_sha384final,
| #elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
|   &__archive_stub_sha384init,
|   &__archive_stub_sha384update,
|   &__archive_stub_sha384final,
| #endif
| 
| /* SHA512 */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
|   &__archive_libc_sha512init,
|   &__archive_libc_sha512update,
|   &__archive_libc_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
|   &__archive_libc2_sha512init,
|   &__archive_libc2_sha512update,
|   &__archive_libc2_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
|   &__archive_libc3_sha512init,
|   &__archive_libc3_sha512update,
|   &__archive_libc3_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
|   &__archive_libmd_sha512init,
|   &__archive_libmd_sha512update,
|   &__archive_libmd_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
|   &__archive_libsystem_sha512init,
|   &__archive_libsystem_sha512update,
|   &__archive_libsystem_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
|   &__archive_nettle_sha512init,
|   &__archive_nettle_sha512update,
|   &__archive_nettle_sha512final,
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
|   &__archive_openssl_sha512init,
|   &__archive_openssl_sha512update,
|   &__archive_openssl_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
|   &__archive_windowsapi_sha512init,
|   &__archive_windowsapi_sha512update,
|   &__archive_windowsapi_sha512final
| #elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
|   &__archive_stub_sha512init,
|   &__archive_stub_sha512update,
|   &__archive_stub_sha512final
| #endif
| };
| 
| int
| main(int argc, char **argv)
| {
|   archive_sha1_ctx ctx;
|   archive_sha1_init(&ctx);
|   archive_sha1_update(&ctx, *argv, argc);
|   archive_sha1_final(&ctx, NULL);
|   return 0;
| }
| 
configure:18146: result: no
configure:18160: checking support for ARCHIVE_CRYPTO_SHA256_NETTLE
configure:18182: arm-linux-androideabi-gcc -o conftest    -I. -I. -I./libarchive  conftest.c -lz  >&5
In file included from conftest.c:206:0:
./libarchive/archive_crypto_private.h:126:24: fatal error: nettle/sha.h: No such file or directory
 #include <nettle/sha.h>
                        ^
compilation terminated.
configure:18182: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| #define ARCHIVE_SHA256_COMPILE_TEST
| #define ARCHIVE_CRYPTO_SHA256_NETTLE
| #define PLATFORM_CONFIG_H "check_crypto_md.h"
| 
| /*-
| * Copyright (c) 2003-2007 Tim Kientzle
| * Copyright (c) 2011 Andres Mejia
| * Copyright (c) 2011 Michihiro NAKAJIMA
| * All rights reserved.
| *
| * Redistribution and use in source and binary forms, with or without
| * modification, are permitted provided that the following conditions
| * are met:
| * 1. Redistributions of source code must retain the above copyright
| *    notice, this list of conditions and the following disclaimer.
| * 2. Redistributions in binary form must reproduce the above copyright
| *    notice, this list of conditions and the following disclaimer in the
| *    documentation and/or other materials provided with the distribution.
| *
| * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
| * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
| * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
| * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
| * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
| * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
| * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
| * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
| * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
| * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
| */
| 
| #include "archive_platform.h"
| 
| #include "archive.h"
| #include "archive_crypto_private.h"
| 
| /* In particular, force the configure probe to break if it tries
|  * to test a combination of OpenSSL and libmd. */
| #if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
| #error Cannot use both OpenSSL and libmd.
| #endif
| 
| /*
|  * Message digest functions for Windows platform.
|  */
| #if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
| 	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
| 	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| /*
|  * Initialize a Message digest.
|  */
| static int
| win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
| {
| 
| 	ctx->valid = 0;
| 	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
| 		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
| 			return (ARCHIVE_FAILED);
| 		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
| 			return (ARCHIVE_FAILED);
| 	}
| 
| 	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
| 		CryptReleaseContext(ctx->cryptProv, 0);
| 		return (ARCHIVE_FAILED);
| 	}
| 
| 	ctx->valid = 1;
| 	return (ARCHIVE_OK);
| }
| 
| /*
|  * Update a Message digest.
|  */
| static int
| win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
| {
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptHashData(ctx->hash,
| 		      (unsigned char *)(uintptr_t)buf,
| 		      (DWORD)len, 0);
| 	return (ARCHIVE_OK);
| }
| 
| static int
| win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
| {
| 	DWORD siglen = (DWORD)bufsize;
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
| 	CryptDestroyHash(ctx->hash);
| 	CryptReleaseContext(ctx->cryptProv, 0);
| 	ctx->valid = 0;
| 	return (ARCHIVE_OK);
| }
| 
| #endif /* defined(ARCHIVE_CRYPTO_*_WIN) */
| 
| 
| /* MD5 implementations */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
| 
| static int
| __archive_libc_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
| 
| static int
| __archive_libmd_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
| 
| static int
| __archive_libsystem_md5init(archive_md5_ctx *ctx)
| {
|   CC_MD5_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_MD5_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
| {
|   CC_MD5_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
| 
| static int
| __archive_nettle_md5init(archive_md5_ctx *ctx)
| {
|   md5_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   md5_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
| {
|   md5_digest(ctx, MD5_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
| 
| static int
| __archive_openssl_md5init(archive_md5_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_md5());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
| 
| static int
| __archive_windowsapi_md5init(archive_md5_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_MD5));
| }
| 
| static int
| __archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 16, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_md5init(archive_md5_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5final(archive_md5_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* RIPEMD160 implementations */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
| 
| static int
| __archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RMD160Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RMD160Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RMD160Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
| 
| static int
| __archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RIPEMD160_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RIPEMD160_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RIPEMD160_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
| 
| static int
| __archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   ripemd160_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   ripemd160_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
| 
| static int
| __archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_ripemd160());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #else
| 
| static int
| __archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA1 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
| 
| static int
| __archive_libc_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
| 
| static int
| __archive_libmd_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha1init(archive_sha1_ctx *ctx)
| {
|   CC_SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   CC_SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
| 
| static int
| __archive_nettle_sha1init(archive_sha1_ctx *ctx)
| {
|   sha1_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha1_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
| 
| static int
| __archive_openssl_sha1init(archive_sha1_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha1());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
| 
| static int
| __archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA1));
| }
| 
| static int
| __archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 20, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha1init(archive_sha1_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA256 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
| 
| static int
| __archive_libc_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
| 
| static int
| __archive_libc2_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
| 
| static int
| __archive_libc3_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
| 
| static int
| __archive_libmd_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha256init(archive_sha256_ctx *ctx)
| {
|   CC_SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   CC_SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
| 
| static int
| __archive_nettle_sha256init(archive_sha256_ctx *ctx)
| {
|   sha256_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha256_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
| 
| static int
| __archive_openssl_sha256init(archive_sha256_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha256());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
| 
| static int
| __archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_256));
| }
| 
| static int
| __archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 32, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha256init(archive_sha256_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA384 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
| 
| static int
| __archive_libc_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
| 
| static int
| __archive_libc2_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
| 
| static int
| __archive_libc3_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha384init(archive_sha384_ctx *ctx)
| {
|   CC_SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   CC_SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
| 
| static int
| __archive_nettle_sha384init(archive_sha384_ctx *ctx)
| {
|   sha384_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha384_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
| 
| static int
| __archive_openssl_sha384init(archive_sha384_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha384());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
| 
| static int
| __archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_384));
| }
| 
| static int
| __archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 48, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha384init(archive_sha384_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA512 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
| 
| static int
| __archive_libc_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
| 
| static int
| __archive_libc2_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
| 
| static int
| __archive_libc3_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
| 
| static int
| __archive_libmd_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha512init(archive_sha512_ctx *ctx)
| {
|   CC_SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   CC_SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
| 
| static int
| __archive_nettle_sha512init(archive_sha512_ctx *ctx)
| {
|   sha512_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha512_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
| 
| static int
| __archive_openssl_sha512init(archive_sha512_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha512());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| static int
| __archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_512));
| }
| 
| static int
| __archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 64, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha512init(archive_sha512_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* NOTE: Crypto functions are set based on availability and by the following
|  * order of preference.
|  * 1. libc
|  * 2. libc2
|  * 3. libc3
|  * 4. libSystem
|  * 5. Nettle
|  * 6. OpenSSL
|  * 7. libmd
|  * 8. Windows API
|  */
| const struct archive_crypto __archive_crypto =
| {
| /* MD5 */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
|   &__archive_libc_md5init,
|   &__archive_libc_md5update,
|   &__archive_libc_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
|   &__archive_libmd_md5init,
|   &__archive_libmd_md5update,
|   &__archive_libmd_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
|   &__archive_libsystem_md5init,
|   &__archive_libsystem_md5update,
|   &__archive_libsystem_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
|   &__archive_nettle_md5init,
|   &__archive_nettle_md5update,
|   &__archive_nettle_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
|   &__archive_openssl_md5init,
|   &__archive_openssl_md5update,
|   &__archive_openssl_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
|   &__archive_windowsapi_md5init,
|   &__archive_windowsapi_md5update,
|   &__archive_windowsapi_md5final,
| #elif !defined(ARCHIVE_MD5_COMPILE_TEST)
|   &__archive_stub_md5init,
|   &__archive_stub_md5update,
|   &__archive_stub_md5final,
| #endif
| 
| /* RIPEMD160 */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
|   &__archive_libc_ripemd160init,
|   &__archive_libc_ripemd160update,
|   &__archive_libc_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
|   &__archive_libmd_ripemd160init,
|   &__archive_libmd_ripemd160update,
|   &__archive_libmd_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
|   &__archive_nettle_ripemd160init,
|   &__archive_nettle_ripemd160update,
|   &__archive_nettle_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
|   &__archive_openssl_ripemd160init,
|   &__archive_openssl_ripemd160update,
|   &__archive_openssl_ripemd160final,
| #elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
|   &__archive_stub_ripemd160init,
|   &__archive_stub_ripemd160update,
|   &__archive_stub_ripemd160final,
| #endif
| 
| /* SHA1 */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
|   &__archive_libc_sha1init,
|   &__archive_libc_sha1update,
|   &__archive_libc_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
|   &__archive_libmd_sha1init,
|   &__archive_libmd_sha1update,
|   &__archive_libmd_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
|   &__archive_libsystem_sha1init,
|   &__archive_libsystem_sha1update,
|   &__archive_libsystem_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
|   &__archive_nettle_sha1init,
|   &__archive_nettle_sha1update,
|   &__archive_nettle_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
|   &__archive_openssl_sha1init,
|   &__archive_openssl_sha1update,
|   &__archive_openssl_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
|   &__archive_windowsapi_sha1init,
|   &__archive_windowsapi_sha1update,
|   &__archive_windowsapi_sha1final,
| #elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
|   &__archive_stub_sha1init,
|   &__archive_stub_sha1update,
|   &__archive_stub_sha1final,
| #endif
| 
| /* SHA256 */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
|   &__archive_libc_sha256init,
|   &__archive_libc_sha256update,
|   &__archive_libc_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
|   &__archive_libc2_sha256init,
|   &__archive_libc2_sha256update,
|   &__archive_libc2_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
|   &__archive_libc3_sha256init,
|   &__archive_libc3_sha256update,
|   &__archive_libc3_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
|   &__archive_libmd_sha256init,
|   &__archive_libmd_sha256update,
|   &__archive_libmd_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
|   &__archive_libsystem_sha256init,
|   &__archive_libsystem_sha256update,
|   &__archive_libsystem_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
|   &__archive_nettle_sha256init,
|   &__archive_nettle_sha256update,
|   &__archive_nettle_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
|   &__archive_openssl_sha256init,
|   &__archive_openssl_sha256update,
|   &__archive_openssl_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
|   &__archive_windowsapi_sha256init,
|   &__archive_windowsapi_sha256update,
|   &__archive_windowsapi_sha256final,
| #elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
|   &__archive_stub_sha256init,
|   &__archive_stub_sha256update,
|   &__archive_stub_sha256final,
| #endif
| 
| /* SHA384 */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
|   &__archive_libc_sha384init,
|   &__archive_libc_sha384update,
|   &__archive_libc_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
|   &__archive_libc2_sha384init,
|   &__archive_libc2_sha384update,
|   &__archive_libc2_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
|   &__archive_libc3_sha384init,
|   &__archive_libc3_sha384update,
|   &__archive_libc3_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
|   &__archive_libsystem_sha384init,
|   &__archive_libsystem_sha384update,
|   &__archive_libsystem_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
|   &__archive_nettle_sha384init,
|   &__archive_nettle_sha384update,
|   &__archive_nettle_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
|   &__archive_openssl_sha384init,
|   &__archive_openssl_sha384update,
|   &__archive_openssl_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
|   &__archive_windowsapi_sha384init,
|   &__archive_windowsapi_sha384update,
|   &__archive_windowsapi_sha384final,
| #elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
|   &__archive_stub_sha384init,
|   &__archive_stub_sha384update,
|   &__archive_stub_sha384final,
| #endif
| 
| /* SHA512 */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
|   &__archive_libc_sha512init,
|   &__archive_libc_sha512update,
|   &__archive_libc_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
|   &__archive_libc2_sha512init,
|   &__archive_libc2_sha512update,
|   &__archive_libc2_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
|   &__archive_libc3_sha512init,
|   &__archive_libc3_sha512update,
|   &__archive_libc3_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
|   &__archive_libmd_sha512init,
|   &__archive_libmd_sha512update,
|   &__archive_libmd_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
|   &__archive_libsystem_sha512init,
|   &__archive_libsystem_sha512update,
|   &__archive_libsystem_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
|   &__archive_nettle_sha512init,
|   &__archive_nettle_sha512update,
|   &__archive_nettle_sha512final,
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
|   &__archive_openssl_sha512init,
|   &__archive_openssl_sha512update,
|   &__archive_openssl_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
|   &__archive_windowsapi_sha512init,
|   &__archive_windowsapi_sha512update,
|   &__archive_windowsapi_sha512final
| #elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
|   &__archive_stub_sha512init,
|   &__archive_stub_sha512update,
|   &__archive_stub_sha512final
| #endif
| };
| 
| int
| main(int argc, char **argv)
| {
|   archive_sha256_ctx ctx;
|   archive_sha256_init(&ctx);
|   archive_sha256_update(&ctx, *argv, argc);
|   archive_sha256_final(&ctx, NULL);
|   return 0;
| }
| 
configure:18192: result: no
configure:18206: checking support for ARCHIVE_CRYPTO_SHA384_NETTLE
configure:18228: arm-linux-androideabi-gcc -o conftest    -I. -I. -I./libarchive  conftest.c -lz  >&5
In file included from conftest.c:206:0:
./libarchive/archive_crypto_private.h:126:24: fatal error: nettle/sha.h: No such file or directory
 #include <nettle/sha.h>
                        ^
compilation terminated.
configure:18228: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| #define ARCHIVE_SHA384_COMPILE_TEST
| #define ARCHIVE_CRYPTO_SHA384_NETTLE
| #define PLATFORM_CONFIG_H "check_crypto_md.h"
| 
| /*-
| * Copyright (c) 2003-2007 Tim Kientzle
| * Copyright (c) 2011 Andres Mejia
| * Copyright (c) 2011 Michihiro NAKAJIMA
| * All rights reserved.
| *
| * Redistribution and use in source and binary forms, with or without
| * modification, are permitted provided that the following conditions
| * are met:
| * 1. Redistributions of source code must retain the above copyright
| *    notice, this list of conditions and the following disclaimer.
| * 2. Redistributions in binary form must reproduce the above copyright
| *    notice, this list of conditions and the following disclaimer in the
| *    documentation and/or other materials provided with the distribution.
| *
| * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
| * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
| * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
| * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
| * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
| * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
| * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
| * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
| * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
| * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
| */
| 
| #include "archive_platform.h"
| 
| #include "archive.h"
| #include "archive_crypto_private.h"
| 
| /* In particular, force the configure probe to break if it tries
|  * to test a combination of OpenSSL and libmd. */
| #if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
| #error Cannot use both OpenSSL and libmd.
| #endif
| 
| /*
|  * Message digest functions for Windows platform.
|  */
| #if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
| 	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
| 	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| /*
|  * Initialize a Message digest.
|  */
| static int
| win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
| {
| 
| 	ctx->valid = 0;
| 	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
| 		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
| 			return (ARCHIVE_FAILED);
| 		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
| 			return (ARCHIVE_FAILED);
| 	}
| 
| 	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
| 		CryptReleaseContext(ctx->cryptProv, 0);
| 		return (ARCHIVE_FAILED);
| 	}
| 
| 	ctx->valid = 1;
| 	return (ARCHIVE_OK);
| }
| 
| /*
|  * Update a Message digest.
|  */
| static int
| win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
| {
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptHashData(ctx->hash,
| 		      (unsigned char *)(uintptr_t)buf,
| 		      (DWORD)len, 0);
| 	return (ARCHIVE_OK);
| }
| 
| static int
| win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
| {
| 	DWORD siglen = (DWORD)bufsize;
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
| 	CryptDestroyHash(ctx->hash);
| 	CryptReleaseContext(ctx->cryptProv, 0);
| 	ctx->valid = 0;
| 	return (ARCHIVE_OK);
| }
| 
| #endif /* defined(ARCHIVE_CRYPTO_*_WIN) */
| 
| 
| /* MD5 implementations */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
| 
| static int
| __archive_libc_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
| 
| static int
| __archive_libmd_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
| 
| static int
| __archive_libsystem_md5init(archive_md5_ctx *ctx)
| {
|   CC_MD5_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_MD5_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
| {
|   CC_MD5_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
| 
| static int
| __archive_nettle_md5init(archive_md5_ctx *ctx)
| {
|   md5_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   md5_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
| {
|   md5_digest(ctx, MD5_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
| 
| static int
| __archive_openssl_md5init(archive_md5_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_md5());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
| 
| static int
| __archive_windowsapi_md5init(archive_md5_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_MD5));
| }
| 
| static int
| __archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 16, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_md5init(archive_md5_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5final(archive_md5_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* RIPEMD160 implementations */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
| 
| static int
| __archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RMD160Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RMD160Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RMD160Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
| 
| static int
| __archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RIPEMD160_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RIPEMD160_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RIPEMD160_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
| 
| static int
| __archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   ripemd160_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   ripemd160_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
| 
| static int
| __archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_ripemd160());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #else
| 
| static int
| __archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA1 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
| 
| static int
| __archive_libc_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
| 
| static int
| __archive_libmd_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha1init(archive_sha1_ctx *ctx)
| {
|   CC_SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   CC_SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
| 
| static int
| __archive_nettle_sha1init(archive_sha1_ctx *ctx)
| {
|   sha1_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha1_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
| 
| static int
| __archive_openssl_sha1init(archive_sha1_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha1());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
| 
| static int
| __archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA1));
| }
| 
| static int
| __archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 20, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha1init(archive_sha1_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA256 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
| 
| static int
| __archive_libc_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
| 
| static int
| __archive_libc2_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
| 
| static int
| __archive_libc3_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
| 
| static int
| __archive_libmd_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha256init(archive_sha256_ctx *ctx)
| {
|   CC_SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   CC_SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
| 
| static int
| __archive_nettle_sha256init(archive_sha256_ctx *ctx)
| {
|   sha256_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha256_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
| 
| static int
| __archive_openssl_sha256init(archive_sha256_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha256());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
| 
| static int
| __archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_256));
| }
| 
| static int
| __archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 32, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha256init(archive_sha256_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA384 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
| 
| static int
| __archive_libc_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
| 
| static int
| __archive_libc2_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
| 
| static int
| __archive_libc3_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha384init(archive_sha384_ctx *ctx)
| {
|   CC_SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   CC_SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
| 
| static int
| __archive_nettle_sha384init(archive_sha384_ctx *ctx)
| {
|   sha384_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha384_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
| 
| static int
| __archive_openssl_sha384init(archive_sha384_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha384());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
| 
| static int
| __archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_384));
| }
| 
| static int
| __archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 48, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha384init(archive_sha384_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA512 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
| 
| static int
| __archive_libc_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
| 
| static int
| __archive_libc2_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
| 
| static int
| __archive_libc3_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
| 
| static int
| __archive_libmd_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha512init(archive_sha512_ctx *ctx)
| {
|   CC_SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   CC_SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
| 
| static int
| __archive_nettle_sha512init(archive_sha512_ctx *ctx)
| {
|   sha512_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha512_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
| 
| static int
| __archive_openssl_sha512init(archive_sha512_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha512());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| static int
| __archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_512));
| }
| 
| static int
| __archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 64, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha512init(archive_sha512_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* NOTE: Crypto functions are set based on availability and by the following
|  * order of preference.
|  * 1. libc
|  * 2. libc2
|  * 3. libc3
|  * 4. libSystem
|  * 5. Nettle
|  * 6. OpenSSL
|  * 7. libmd
|  * 8. Windows API
|  */
| const struct archive_crypto __archive_crypto =
| {
| /* MD5 */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
|   &__archive_libc_md5init,
|   &__archive_libc_md5update,
|   &__archive_libc_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
|   &__archive_libmd_md5init,
|   &__archive_libmd_md5update,
|   &__archive_libmd_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
|   &__archive_libsystem_md5init,
|   &__archive_libsystem_md5update,
|   &__archive_libsystem_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
|   &__archive_nettle_md5init,
|   &__archive_nettle_md5update,
|   &__archive_nettle_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
|   &__archive_openssl_md5init,
|   &__archive_openssl_md5update,
|   &__archive_openssl_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
|   &__archive_windowsapi_md5init,
|   &__archive_windowsapi_md5update,
|   &__archive_windowsapi_md5final,
| #elif !defined(ARCHIVE_MD5_COMPILE_TEST)
|   &__archive_stub_md5init,
|   &__archive_stub_md5update,
|   &__archive_stub_md5final,
| #endif
| 
| /* RIPEMD160 */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
|   &__archive_libc_ripemd160init,
|   &__archive_libc_ripemd160update,
|   &__archive_libc_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
|   &__archive_libmd_ripemd160init,
|   &__archive_libmd_ripemd160update,
|   &__archive_libmd_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
|   &__archive_nettle_ripemd160init,
|   &__archive_nettle_ripemd160update,
|   &__archive_nettle_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
|   &__archive_openssl_ripemd160init,
|   &__archive_openssl_ripemd160update,
|   &__archive_openssl_ripemd160final,
| #elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
|   &__archive_stub_ripemd160init,
|   &__archive_stub_ripemd160update,
|   &__archive_stub_ripemd160final,
| #endif
| 
| /* SHA1 */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
|   &__archive_libc_sha1init,
|   &__archive_libc_sha1update,
|   &__archive_libc_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
|   &__archive_libmd_sha1init,
|   &__archive_libmd_sha1update,
|   &__archive_libmd_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
|   &__archive_libsystem_sha1init,
|   &__archive_libsystem_sha1update,
|   &__archive_libsystem_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
|   &__archive_nettle_sha1init,
|   &__archive_nettle_sha1update,
|   &__archive_nettle_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
|   &__archive_openssl_sha1init,
|   &__archive_openssl_sha1update,
|   &__archive_openssl_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
|   &__archive_windowsapi_sha1init,
|   &__archive_windowsapi_sha1update,
|   &__archive_windowsapi_sha1final,
| #elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
|   &__archive_stub_sha1init,
|   &__archive_stub_sha1update,
|   &__archive_stub_sha1final,
| #endif
| 
| /* SHA256 */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
|   &__archive_libc_sha256init,
|   &__archive_libc_sha256update,
|   &__archive_libc_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
|   &__archive_libc2_sha256init,
|   &__archive_libc2_sha256update,
|   &__archive_libc2_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
|   &__archive_libc3_sha256init,
|   &__archive_libc3_sha256update,
|   &__archive_libc3_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
|   &__archive_libmd_sha256init,
|   &__archive_libmd_sha256update,
|   &__archive_libmd_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
|   &__archive_libsystem_sha256init,
|   &__archive_libsystem_sha256update,
|   &__archive_libsystem_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
|   &__archive_nettle_sha256init,
|   &__archive_nettle_sha256update,
|   &__archive_nettle_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
|   &__archive_openssl_sha256init,
|   &__archive_openssl_sha256update,
|   &__archive_openssl_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
|   &__archive_windowsapi_sha256init,
|   &__archive_windowsapi_sha256update,
|   &__archive_windowsapi_sha256final,
| #elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
|   &__archive_stub_sha256init,
|   &__archive_stub_sha256update,
|   &__archive_stub_sha256final,
| #endif
| 
| /* SHA384 */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
|   &__archive_libc_sha384init,
|   &__archive_libc_sha384update,
|   &__archive_libc_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
|   &__archive_libc2_sha384init,
|   &__archive_libc2_sha384update,
|   &__archive_libc2_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
|   &__archive_libc3_sha384init,
|   &__archive_libc3_sha384update,
|   &__archive_libc3_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
|   &__archive_libsystem_sha384init,
|   &__archive_libsystem_sha384update,
|   &__archive_libsystem_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
|   &__archive_nettle_sha384init,
|   &__archive_nettle_sha384update,
|   &__archive_nettle_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
|   &__archive_openssl_sha384init,
|   &__archive_openssl_sha384update,
|   &__archive_openssl_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
|   &__archive_windowsapi_sha384init,
|   &__archive_windowsapi_sha384update,
|   &__archive_windowsapi_sha384final,
| #elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
|   &__archive_stub_sha384init,
|   &__archive_stub_sha384update,
|   &__archive_stub_sha384final,
| #endif
| 
| /* SHA512 */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
|   &__archive_libc_sha512init,
|   &__archive_libc_sha512update,
|   &__archive_libc_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
|   &__archive_libc2_sha512init,
|   &__archive_libc2_sha512update,
|   &__archive_libc2_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
|   &__archive_libc3_sha512init,
|   &__archive_libc3_sha512update,
|   &__archive_libc3_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
|   &__archive_libmd_sha512init,
|   &__archive_libmd_sha512update,
|   &__archive_libmd_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
|   &__archive_libsystem_sha512init,
|   &__archive_libsystem_sha512update,
|   &__archive_libsystem_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
|   &__archive_nettle_sha512init,
|   &__archive_nettle_sha512update,
|   &__archive_nettle_sha512final,
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
|   &__archive_openssl_sha512init,
|   &__archive_openssl_sha512update,
|   &__archive_openssl_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
|   &__archive_windowsapi_sha512init,
|   &__archive_windowsapi_sha512update,
|   &__archive_windowsapi_sha512final
| #elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
|   &__archive_stub_sha512init,
|   &__archive_stub_sha512update,
|   &__archive_stub_sha512final
| #endif
| };
| 
| int
| main(int argc, char **argv)
| {
|   archive_sha384_ctx ctx;
|   archive_sha384_init(&ctx);
|   archive_sha384_update(&ctx, *argv, argc);
|   archive_sha384_final(&ctx, NULL);
|   return 0;
| }
| 
configure:18238: result: no
configure:18252: checking support for ARCHIVE_CRYPTO_SHA512_NETTLE
configure:18274: arm-linux-androideabi-gcc -o conftest    -I. -I. -I./libarchive  conftest.c -lz  >&5
In file included from conftest.c:206:0:
./libarchive/archive_crypto_private.h:126:24: fatal error: nettle/sha.h: No such file or directory
 #include <nettle/sha.h>
                        ^
compilation terminated.
configure:18274: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| #define ARCHIVE_SHA512_COMPILE_TEST
| #define ARCHIVE_CRYPTO_SHA512_NETTLE
| #define PLATFORM_CONFIG_H "check_crypto_md.h"
| 
| /*-
| * Copyright (c) 2003-2007 Tim Kientzle
| * Copyright (c) 2011 Andres Mejia
| * Copyright (c) 2011 Michihiro NAKAJIMA
| * All rights reserved.
| *
| * Redistribution and use in source and binary forms, with or without
| * modification, are permitted provided that the following conditions
| * are met:
| * 1. Redistributions of source code must retain the above copyright
| *    notice, this list of conditions and the following disclaimer.
| * 2. Redistributions in binary form must reproduce the above copyright
| *    notice, this list of conditions and the following disclaimer in the
| *    documentation and/or other materials provided with the distribution.
| *
| * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
| * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
| * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
| * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
| * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
| * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
| * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
| * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
| * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
| * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
| */
| 
| #include "archive_platform.h"
| 
| #include "archive.h"
| #include "archive_crypto_private.h"
| 
| /* In particular, force the configure probe to break if it tries
|  * to test a combination of OpenSSL and libmd. */
| #if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
| #error Cannot use both OpenSSL and libmd.
| #endif
| 
| /*
|  * Message digest functions for Windows platform.
|  */
| #if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
| 	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
| 	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| /*
|  * Initialize a Message digest.
|  */
| static int
| win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
| {
| 
| 	ctx->valid = 0;
| 	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
| 		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
| 			return (ARCHIVE_FAILED);
| 		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
| 			return (ARCHIVE_FAILED);
| 	}
| 
| 	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
| 		CryptReleaseContext(ctx->cryptProv, 0);
| 		return (ARCHIVE_FAILED);
| 	}
| 
| 	ctx->valid = 1;
| 	return (ARCHIVE_OK);
| }
| 
| /*
|  * Update a Message digest.
|  */
| static int
| win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
| {
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptHashData(ctx->hash,
| 		      (unsigned char *)(uintptr_t)buf,
| 		      (DWORD)len, 0);
| 	return (ARCHIVE_OK);
| }
| 
| static int
| win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
| {
| 	DWORD siglen = (DWORD)bufsize;
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
| 	CryptDestroyHash(ctx->hash);
| 	CryptReleaseContext(ctx->cryptProv, 0);
| 	ctx->valid = 0;
| 	return (ARCHIVE_OK);
| }
| 
| #endif /* defined(ARCHIVE_CRYPTO_*_WIN) */
| 
| 
| /* MD5 implementations */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
| 
| static int
| __archive_libc_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
| 
| static int
| __archive_libmd_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
| 
| static int
| __archive_libsystem_md5init(archive_md5_ctx *ctx)
| {
|   CC_MD5_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_MD5_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
| {
|   CC_MD5_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
| 
| static int
| __archive_nettle_md5init(archive_md5_ctx *ctx)
| {
|   md5_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   md5_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
| {
|   md5_digest(ctx, MD5_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
| 
| static int
| __archive_openssl_md5init(archive_md5_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_md5());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
| 
| static int
| __archive_windowsapi_md5init(archive_md5_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_MD5));
| }
| 
| static int
| __archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 16, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_md5init(archive_md5_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5final(archive_md5_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* RIPEMD160 implementations */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
| 
| static int
| __archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RMD160Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RMD160Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RMD160Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
| 
| static int
| __archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RIPEMD160_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RIPEMD160_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RIPEMD160_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
| 
| static int
| __archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   ripemd160_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   ripemd160_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
| 
| static int
| __archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_ripemd160());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #else
| 
| static int
| __archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA1 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
| 
| static int
| __archive_libc_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
| 
| static int
| __archive_libmd_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha1init(archive_sha1_ctx *ctx)
| {
|   CC_SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   CC_SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
| 
| static int
| __archive_nettle_sha1init(archive_sha1_ctx *ctx)
| {
|   sha1_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha1_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
| 
| static int
| __archive_openssl_sha1init(archive_sha1_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha1());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
| 
| static int
| __archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA1));
| }
| 
| static int
| __archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 20, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha1init(archive_sha1_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA256 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
| 
| static int
| __archive_libc_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
| 
| static int
| __archive_libc2_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
| 
| static int
| __archive_libc3_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
| 
| static int
| __archive_libmd_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha256init(archive_sha256_ctx *ctx)
| {
|   CC_SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   CC_SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
| 
| static int
| __archive_nettle_sha256init(archive_sha256_ctx *ctx)
| {
|   sha256_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha256_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
| 
| static int
| __archive_openssl_sha256init(archive_sha256_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha256());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
| 
| static int
| __archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_256));
| }
| 
| static int
| __archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 32, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha256init(archive_sha256_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA384 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
| 
| static int
| __archive_libc_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
| 
| static int
| __archive_libc2_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
| 
| static int
| __archive_libc3_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha384init(archive_sha384_ctx *ctx)
| {
|   CC_SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   CC_SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
| 
| static int
| __archive_nettle_sha384init(archive_sha384_ctx *ctx)
| {
|   sha384_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha384_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
| 
| static int
| __archive_openssl_sha384init(archive_sha384_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha384());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
| 
| static int
| __archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_384));
| }
| 
| static int
| __archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 48, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha384init(archive_sha384_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA512 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
| 
| static int
| __archive_libc_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
| 
| static int
| __archive_libc2_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
| 
| static int
| __archive_libc3_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
| 
| static int
| __archive_libmd_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha512init(archive_sha512_ctx *ctx)
| {
|   CC_SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   CC_SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
| 
| static int
| __archive_nettle_sha512init(archive_sha512_ctx *ctx)
| {
|   sha512_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha512_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
| 
| static int
| __archive_openssl_sha512init(archive_sha512_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha512());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| static int
| __archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_512));
| }
| 
| static int
| __archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 64, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha512init(archive_sha512_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* NOTE: Crypto functions are set based on availability and by the following
|  * order of preference.
|  * 1. libc
|  * 2. libc2
|  * 3. libc3
|  * 4. libSystem
|  * 5. Nettle
|  * 6. OpenSSL
|  * 7. libmd
|  * 8. Windows API
|  */
| const struct archive_crypto __archive_crypto =
| {
| /* MD5 */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
|   &__archive_libc_md5init,
|   &__archive_libc_md5update,
|   &__archive_libc_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
|   &__archive_libmd_md5init,
|   &__archive_libmd_md5update,
|   &__archive_libmd_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
|   &__archive_libsystem_md5init,
|   &__archive_libsystem_md5update,
|   &__archive_libsystem_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
|   &__archive_nettle_md5init,
|   &__archive_nettle_md5update,
|   &__archive_nettle_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
|   &__archive_openssl_md5init,
|   &__archive_openssl_md5update,
|   &__archive_openssl_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
|   &__archive_windowsapi_md5init,
|   &__archive_windowsapi_md5update,
|   &__archive_windowsapi_md5final,
| #elif !defined(ARCHIVE_MD5_COMPILE_TEST)
|   &__archive_stub_md5init,
|   &__archive_stub_md5update,
|   &__archive_stub_md5final,
| #endif
| 
| /* RIPEMD160 */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
|   &__archive_libc_ripemd160init,
|   &__archive_libc_ripemd160update,
|   &__archive_libc_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
|   &__archive_libmd_ripemd160init,
|   &__archive_libmd_ripemd160update,
|   &__archive_libmd_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
|   &__archive_nettle_ripemd160init,
|   &__archive_nettle_ripemd160update,
|   &__archive_nettle_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
|   &__archive_openssl_ripemd160init,
|   &__archive_openssl_ripemd160update,
|   &__archive_openssl_ripemd160final,
| #elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
|   &__archive_stub_ripemd160init,
|   &__archive_stub_ripemd160update,
|   &__archive_stub_ripemd160final,
| #endif
| 
| /* SHA1 */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
|   &__archive_libc_sha1init,
|   &__archive_libc_sha1update,
|   &__archive_libc_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
|   &__archive_libmd_sha1init,
|   &__archive_libmd_sha1update,
|   &__archive_libmd_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
|   &__archive_libsystem_sha1init,
|   &__archive_libsystem_sha1update,
|   &__archive_libsystem_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
|   &__archive_nettle_sha1init,
|   &__archive_nettle_sha1update,
|   &__archive_nettle_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
|   &__archive_openssl_sha1init,
|   &__archive_openssl_sha1update,
|   &__archive_openssl_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
|   &__archive_windowsapi_sha1init,
|   &__archive_windowsapi_sha1update,
|   &__archive_windowsapi_sha1final,
| #elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
|   &__archive_stub_sha1init,
|   &__archive_stub_sha1update,
|   &__archive_stub_sha1final,
| #endif
| 
| /* SHA256 */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
|   &__archive_libc_sha256init,
|   &__archive_libc_sha256update,
|   &__archive_libc_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
|   &__archive_libc2_sha256init,
|   &__archive_libc2_sha256update,
|   &__archive_libc2_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
|   &__archive_libc3_sha256init,
|   &__archive_libc3_sha256update,
|   &__archive_libc3_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
|   &__archive_libmd_sha256init,
|   &__archive_libmd_sha256update,
|   &__archive_libmd_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
|   &__archive_libsystem_sha256init,
|   &__archive_libsystem_sha256update,
|   &__archive_libsystem_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
|   &__archive_nettle_sha256init,
|   &__archive_nettle_sha256update,
|   &__archive_nettle_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
|   &__archive_openssl_sha256init,
|   &__archive_openssl_sha256update,
|   &__archive_openssl_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
|   &__archive_windowsapi_sha256init,
|   &__archive_windowsapi_sha256update,
|   &__archive_windowsapi_sha256final,
| #elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
|   &__archive_stub_sha256init,
|   &__archive_stub_sha256update,
|   &__archive_stub_sha256final,
| #endif
| 
| /* SHA384 */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
|   &__archive_libc_sha384init,
|   &__archive_libc_sha384update,
|   &__archive_libc_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
|   &__archive_libc2_sha384init,
|   &__archive_libc2_sha384update,
|   &__archive_libc2_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
|   &__archive_libc3_sha384init,
|   &__archive_libc3_sha384update,
|   &__archive_libc3_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
|   &__archive_libsystem_sha384init,
|   &__archive_libsystem_sha384update,
|   &__archive_libsystem_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
|   &__archive_nettle_sha384init,
|   &__archive_nettle_sha384update,
|   &__archive_nettle_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
|   &__archive_openssl_sha384init,
|   &__archive_openssl_sha384update,
|   &__archive_openssl_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
|   &__archive_windowsapi_sha384init,
|   &__archive_windowsapi_sha384update,
|   &__archive_windowsapi_sha384final,
| #elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
|   &__archive_stub_sha384init,
|   &__archive_stub_sha384update,
|   &__archive_stub_sha384final,
| #endif
| 
| /* SHA512 */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
|   &__archive_libc_sha512init,
|   &__archive_libc_sha512update,
|   &__archive_libc_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
|   &__archive_libc2_sha512init,
|   &__archive_libc2_sha512update,
|   &__archive_libc2_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
|   &__archive_libc3_sha512init,
|   &__archive_libc3_sha512update,
|   &__archive_libc3_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
|   &__archive_libmd_sha512init,
|   &__archive_libmd_sha512update,
|   &__archive_libmd_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
|   &__archive_libsystem_sha512init,
|   &__archive_libsystem_sha512update,
|   &__archive_libsystem_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
|   &__archive_nettle_sha512init,
|   &__archive_nettle_sha512update,
|   &__archive_nettle_sha512final,
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
|   &__archive_openssl_sha512init,
|   &__archive_openssl_sha512update,
|   &__archive_openssl_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
|   &__archive_windowsapi_sha512init,
|   &__archive_windowsapi_sha512update,
|   &__archive_windowsapi_sha512final
| #elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
|   &__archive_stub_sha512init,
|   &__archive_stub_sha512update,
|   &__archive_stub_sha512final
| #endif
| };
| 
| int
| main(int argc, char **argv)
| {
|   archive_sha512_ctx ctx;
|   archive_sha512_init(&ctx);
|   archive_sha512_update(&ctx, *argv, argc);
|   archive_sha512_final(&ctx, NULL);
|   return 0;
| }
| 
configure:18284: result: no
configure:18300: checking openssl/evp.h usability
configure:18300: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:204:25: fatal error: openssl/evp.h: No such file or directory
 #include <openssl/evp.h>
                         ^
compilation terminated.
configure:18300: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <openssl/evp.h>
configure:18300: result: no
configure:18300: checking openssl/evp.h presence
configure:18300: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:171:25: fatal error: openssl/evp.h: No such file or directory
 #include <openssl/evp.h>
                         ^
compilation terminated.
configure:18300: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| #include <openssl/evp.h>
configure:18300: result: no
configure:18300: checking for openssl/evp.h
configure:18300: result: no
configure:18440: checking for main in -lcrypto
configure:18459: arm-linux-androideabi-gcc -o conftest     conftest.c -lcrypto  -lz  >&5
/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld: error: cannot find -lcrypto
collect2: error: ld returned 1 exit status
configure:18459: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| 
| int
| main ()
| {
| return main ();
|   ;
|   return 0;
| }
configure:18468: result: no
configure:18486: checking support for ARCHIVE_CRYPTO_MD5_OPENSSL
configure:18508: arm-linux-androideabi-gcc -o conftest    -I. -I. -I./libarchive  conftest.c -lz  >&5
In file included from conftest.c:206:0:
./libarchive/archive_crypto_private.h:137:25: fatal error: openssl/evp.h: No such file or directory
 #include <openssl/evp.h>
                         ^
compilation terminated.
configure:18508: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| #define ARCHIVE_MD5_COMPILE_TEST
| #define ARCHIVE_CRYPTO_MD5_OPENSSL
| #define PLATFORM_CONFIG_H "check_crypto_md.h"
| 
| /*-
| * Copyright (c) 2003-2007 Tim Kientzle
| * Copyright (c) 2011 Andres Mejia
| * Copyright (c) 2011 Michihiro NAKAJIMA
| * All rights reserved.
| *
| * Redistribution and use in source and binary forms, with or without
| * modification, are permitted provided that the following conditions
| * are met:
| * 1. Redistributions of source code must retain the above copyright
| *    notice, this list of conditions and the following disclaimer.
| * 2. Redistributions in binary form must reproduce the above copyright
| *    notice, this list of conditions and the following disclaimer in the
| *    documentation and/or other materials provided with the distribution.
| *
| * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
| * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
| * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
| * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
| * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
| * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
| * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
| * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
| * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
| * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
| */
| 
| #include "archive_platform.h"
| 
| #include "archive.h"
| #include "archive_crypto_private.h"
| 
| /* In particular, force the configure probe to break if it tries
|  * to test a combination of OpenSSL and libmd. */
| #if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
| #error Cannot use both OpenSSL and libmd.
| #endif
| 
| /*
|  * Message digest functions for Windows platform.
|  */
| #if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
| 	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
| 	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| /*
|  * Initialize a Message digest.
|  */
| static int
| win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
| {
| 
| 	ctx->valid = 0;
| 	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
| 		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
| 			return (ARCHIVE_FAILED);
| 		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
| 			return (ARCHIVE_FAILED);
| 	}
| 
| 	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
| 		CryptReleaseContext(ctx->cryptProv, 0);
| 		return (ARCHIVE_FAILED);
| 	}
| 
| 	ctx->valid = 1;
| 	return (ARCHIVE_OK);
| }
| 
| /*
|  * Update a Message digest.
|  */
| static int
| win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
| {
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptHashData(ctx->hash,
| 		      (unsigned char *)(uintptr_t)buf,
| 		      (DWORD)len, 0);
| 	return (ARCHIVE_OK);
| }
| 
| static int
| win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
| {
| 	DWORD siglen = (DWORD)bufsize;
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
| 	CryptDestroyHash(ctx->hash);
| 	CryptReleaseContext(ctx->cryptProv, 0);
| 	ctx->valid = 0;
| 	return (ARCHIVE_OK);
| }
| 
| #endif /* defined(ARCHIVE_CRYPTO_*_WIN) */
| 
| 
| /* MD5 implementations */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
| 
| static int
| __archive_libc_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
| 
| static int
| __archive_libmd_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
| 
| static int
| __archive_libsystem_md5init(archive_md5_ctx *ctx)
| {
|   CC_MD5_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_MD5_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
| {
|   CC_MD5_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
| 
| static int
| __archive_nettle_md5init(archive_md5_ctx *ctx)
| {
|   md5_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   md5_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
| {
|   md5_digest(ctx, MD5_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
| 
| static int
| __archive_openssl_md5init(archive_md5_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_md5());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
| 
| static int
| __archive_windowsapi_md5init(archive_md5_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_MD5));
| }
| 
| static int
| __archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 16, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_md5init(archive_md5_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5final(archive_md5_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* RIPEMD160 implementations */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
| 
| static int
| __archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RMD160Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RMD160Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RMD160Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
| 
| static int
| __archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RIPEMD160_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RIPEMD160_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RIPEMD160_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
| 
| static int
| __archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   ripemd160_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   ripemd160_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
| 
| static int
| __archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_ripemd160());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #else
| 
| static int
| __archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA1 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
| 
| static int
| __archive_libc_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
| 
| static int
| __archive_libmd_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha1init(archive_sha1_ctx *ctx)
| {
|   CC_SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   CC_SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
| 
| static int
| __archive_nettle_sha1init(archive_sha1_ctx *ctx)
| {
|   sha1_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha1_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
| 
| static int
| __archive_openssl_sha1init(archive_sha1_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha1());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
| 
| static int
| __archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA1));
| }
| 
| static int
| __archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 20, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha1init(archive_sha1_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA256 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
| 
| static int
| __archive_libc_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
| 
| static int
| __archive_libc2_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
| 
| static int
| __archive_libc3_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
| 
| static int
| __archive_libmd_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha256init(archive_sha256_ctx *ctx)
| {
|   CC_SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   CC_SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
| 
| static int
| __archive_nettle_sha256init(archive_sha256_ctx *ctx)
| {
|   sha256_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha256_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
| 
| static int
| __archive_openssl_sha256init(archive_sha256_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha256());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
| 
| static int
| __archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_256));
| }
| 
| static int
| __archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 32, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha256init(archive_sha256_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA384 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
| 
| static int
| __archive_libc_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
| 
| static int
| __archive_libc2_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
| 
| static int
| __archive_libc3_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha384init(archive_sha384_ctx *ctx)
| {
|   CC_SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   CC_SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
| 
| static int
| __archive_nettle_sha384init(archive_sha384_ctx *ctx)
| {
|   sha384_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha384_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
| 
| static int
| __archive_openssl_sha384init(archive_sha384_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha384());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
| 
| static int
| __archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_384));
| }
| 
| static int
| __archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 48, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha384init(archive_sha384_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA512 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
| 
| static int
| __archive_libc_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
| 
| static int
| __archive_libc2_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
| 
| static int
| __archive_libc3_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
| 
| static int
| __archive_libmd_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha512init(archive_sha512_ctx *ctx)
| {
|   CC_SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   CC_SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
| 
| static int
| __archive_nettle_sha512init(archive_sha512_ctx *ctx)
| {
|   sha512_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha512_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
| 
| static int
| __archive_openssl_sha512init(archive_sha512_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha512());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| static int
| __archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_512));
| }
| 
| static int
| __archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 64, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha512init(archive_sha512_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* NOTE: Crypto functions are set based on availability and by the following
|  * order of preference.
|  * 1. libc
|  * 2. libc2
|  * 3. libc3
|  * 4. libSystem
|  * 5. Nettle
|  * 6. OpenSSL
|  * 7. libmd
|  * 8. Windows API
|  */
| const struct archive_crypto __archive_crypto =
| {
| /* MD5 */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
|   &__archive_libc_md5init,
|   &__archive_libc_md5update,
|   &__archive_libc_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
|   &__archive_libmd_md5init,
|   &__archive_libmd_md5update,
|   &__archive_libmd_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
|   &__archive_libsystem_md5init,
|   &__archive_libsystem_md5update,
|   &__archive_libsystem_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
|   &__archive_nettle_md5init,
|   &__archive_nettle_md5update,
|   &__archive_nettle_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
|   &__archive_openssl_md5init,
|   &__archive_openssl_md5update,
|   &__archive_openssl_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
|   &__archive_windowsapi_md5init,
|   &__archive_windowsapi_md5update,
|   &__archive_windowsapi_md5final,
| #elif !defined(ARCHIVE_MD5_COMPILE_TEST)
|   &__archive_stub_md5init,
|   &__archive_stub_md5update,
|   &__archive_stub_md5final,
| #endif
| 
| /* RIPEMD160 */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
|   &__archive_libc_ripemd160init,
|   &__archive_libc_ripemd160update,
|   &__archive_libc_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
|   &__archive_libmd_ripemd160init,
|   &__archive_libmd_ripemd160update,
|   &__archive_libmd_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
|   &__archive_nettle_ripemd160init,
|   &__archive_nettle_ripemd160update,
|   &__archive_nettle_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
|   &__archive_openssl_ripemd160init,
|   &__archive_openssl_ripemd160update,
|   &__archive_openssl_ripemd160final,
| #elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
|   &__archive_stub_ripemd160init,
|   &__archive_stub_ripemd160update,
|   &__archive_stub_ripemd160final,
| #endif
| 
| /* SHA1 */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
|   &__archive_libc_sha1init,
|   &__archive_libc_sha1update,
|   &__archive_libc_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
|   &__archive_libmd_sha1init,
|   &__archive_libmd_sha1update,
|   &__archive_libmd_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
|   &__archive_libsystem_sha1init,
|   &__archive_libsystem_sha1update,
|   &__archive_libsystem_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
|   &__archive_nettle_sha1init,
|   &__archive_nettle_sha1update,
|   &__archive_nettle_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
|   &__archive_openssl_sha1init,
|   &__archive_openssl_sha1update,
|   &__archive_openssl_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
|   &__archive_windowsapi_sha1init,
|   &__archive_windowsapi_sha1update,
|   &__archive_windowsapi_sha1final,
| #elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
|   &__archive_stub_sha1init,
|   &__archive_stub_sha1update,
|   &__archive_stub_sha1final,
| #endif
| 
| /* SHA256 */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
|   &__archive_libc_sha256init,
|   &__archive_libc_sha256update,
|   &__archive_libc_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
|   &__archive_libc2_sha256init,
|   &__archive_libc2_sha256update,
|   &__archive_libc2_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
|   &__archive_libc3_sha256init,
|   &__archive_libc3_sha256update,
|   &__archive_libc3_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
|   &__archive_libmd_sha256init,
|   &__archive_libmd_sha256update,
|   &__archive_libmd_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
|   &__archive_libsystem_sha256init,
|   &__archive_libsystem_sha256update,
|   &__archive_libsystem_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
|   &__archive_nettle_sha256init,
|   &__archive_nettle_sha256update,
|   &__archive_nettle_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
|   &__archive_openssl_sha256init,
|   &__archive_openssl_sha256update,
|   &__archive_openssl_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
|   &__archive_windowsapi_sha256init,
|   &__archive_windowsapi_sha256update,
|   &__archive_windowsapi_sha256final,
| #elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
|   &__archive_stub_sha256init,
|   &__archive_stub_sha256update,
|   &__archive_stub_sha256final,
| #endif
| 
| /* SHA384 */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
|   &__archive_libc_sha384init,
|   &__archive_libc_sha384update,
|   &__archive_libc_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
|   &__archive_libc2_sha384init,
|   &__archive_libc2_sha384update,
|   &__archive_libc2_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
|   &__archive_libc3_sha384init,
|   &__archive_libc3_sha384update,
|   &__archive_libc3_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
|   &__archive_libsystem_sha384init,
|   &__archive_libsystem_sha384update,
|   &__archive_libsystem_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
|   &__archive_nettle_sha384init,
|   &__archive_nettle_sha384update,
|   &__archive_nettle_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
|   &__archive_openssl_sha384init,
|   &__archive_openssl_sha384update,
|   &__archive_openssl_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
|   &__archive_windowsapi_sha384init,
|   &__archive_windowsapi_sha384update,
|   &__archive_windowsapi_sha384final,
| #elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
|   &__archive_stub_sha384init,
|   &__archive_stub_sha384update,
|   &__archive_stub_sha384final,
| #endif
| 
| /* SHA512 */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
|   &__archive_libc_sha512init,
|   &__archive_libc_sha512update,
|   &__archive_libc_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
|   &__archive_libc2_sha512init,
|   &__archive_libc2_sha512update,
|   &__archive_libc2_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
|   &__archive_libc3_sha512init,
|   &__archive_libc3_sha512update,
|   &__archive_libc3_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
|   &__archive_libmd_sha512init,
|   &__archive_libmd_sha512update,
|   &__archive_libmd_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
|   &__archive_libsystem_sha512init,
|   &__archive_libsystem_sha512update,
|   &__archive_libsystem_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
|   &__archive_nettle_sha512init,
|   &__archive_nettle_sha512update,
|   &__archive_nettle_sha512final,
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
|   &__archive_openssl_sha512init,
|   &__archive_openssl_sha512update,
|   &__archive_openssl_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
|   &__archive_windowsapi_sha512init,
|   &__archive_windowsapi_sha512update,
|   &__archive_windowsapi_sha512final
| #elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
|   &__archive_stub_sha512init,
|   &__archive_stub_sha512update,
|   &__archive_stub_sha512final
| #endif
| };
| 
| int
| main(int argc, char **argv)
| {
|   archive_md5_ctx ctx;
|   archive_md5_init(&ctx);
|   archive_md5_update(&ctx, *argv, argc);
|   archive_md5_final(&ctx, NULL);
|   return 0;
| }
| 
configure:18518: result: no
configure:18532: checking support for ARCHIVE_CRYPTO_RMD160_OPENSSL
configure:18554: arm-linux-androideabi-gcc -o conftest    -I. -I. -I./libarchive  conftest.c -lz  >&5
In file included from conftest.c:206:0:
./libarchive/archive_crypto_private.h:137:25: fatal error: openssl/evp.h: No such file or directory
 #include <openssl/evp.h>
                         ^
compilation terminated.
configure:18554: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| #define ARCHIVE_RMD160_COMPILE_TEST
| #define ARCHIVE_CRYPTO_RMD160_OPENSSL
| #define PLATFORM_CONFIG_H "check_crypto_md.h"
| 
| /*-
| * Copyright (c) 2003-2007 Tim Kientzle
| * Copyright (c) 2011 Andres Mejia
| * Copyright (c) 2011 Michihiro NAKAJIMA
| * All rights reserved.
| *
| * Redistribution and use in source and binary forms, with or without
| * modification, are permitted provided that the following conditions
| * are met:
| * 1. Redistributions of source code must retain the above copyright
| *    notice, this list of conditions and the following disclaimer.
| * 2. Redistributions in binary form must reproduce the above copyright
| *    notice, this list of conditions and the following disclaimer in the
| *    documentation and/or other materials provided with the distribution.
| *
| * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
| * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
| * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
| * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
| * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
| * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
| * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
| * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
| * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
| * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
| */
| 
| #include "archive_platform.h"
| 
| #include "archive.h"
| #include "archive_crypto_private.h"
| 
| /* In particular, force the configure probe to break if it tries
|  * to test a combination of OpenSSL and libmd. */
| #if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
| #error Cannot use both OpenSSL and libmd.
| #endif
| 
| /*
|  * Message digest functions for Windows platform.
|  */
| #if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
| 	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
| 	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| /*
|  * Initialize a Message digest.
|  */
| static int
| win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
| {
| 
| 	ctx->valid = 0;
| 	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
| 		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
| 			return (ARCHIVE_FAILED);
| 		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
| 			return (ARCHIVE_FAILED);
| 	}
| 
| 	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
| 		CryptReleaseContext(ctx->cryptProv, 0);
| 		return (ARCHIVE_FAILED);
| 	}
| 
| 	ctx->valid = 1;
| 	return (ARCHIVE_OK);
| }
| 
| /*
|  * Update a Message digest.
|  */
| static int
| win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
| {
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptHashData(ctx->hash,
| 		      (unsigned char *)(uintptr_t)buf,
| 		      (DWORD)len, 0);
| 	return (ARCHIVE_OK);
| }
| 
| static int
| win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
| {
| 	DWORD siglen = (DWORD)bufsize;
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
| 	CryptDestroyHash(ctx->hash);
| 	CryptReleaseContext(ctx->cryptProv, 0);
| 	ctx->valid = 0;
| 	return (ARCHIVE_OK);
| }
| 
| #endif /* defined(ARCHIVE_CRYPTO_*_WIN) */
| 
| 
| /* MD5 implementations */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
| 
| static int
| __archive_libc_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
| 
| static int
| __archive_libmd_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
| 
| static int
| __archive_libsystem_md5init(archive_md5_ctx *ctx)
| {
|   CC_MD5_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_MD5_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
| {
|   CC_MD5_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
| 
| static int
| __archive_nettle_md5init(archive_md5_ctx *ctx)
| {
|   md5_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   md5_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
| {
|   md5_digest(ctx, MD5_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
| 
| static int
| __archive_openssl_md5init(archive_md5_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_md5());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
| 
| static int
| __archive_windowsapi_md5init(archive_md5_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_MD5));
| }
| 
| static int
| __archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 16, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_md5init(archive_md5_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5final(archive_md5_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* RIPEMD160 implementations */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
| 
| static int
| __archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RMD160Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RMD160Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RMD160Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
| 
| static int
| __archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RIPEMD160_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RIPEMD160_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RIPEMD160_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
| 
| static int
| __archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   ripemd160_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   ripemd160_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
| 
| static int
| __archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_ripemd160());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #else
| 
| static int
| __archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA1 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
| 
| static int
| __archive_libc_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
| 
| static int
| __archive_libmd_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha1init(archive_sha1_ctx *ctx)
| {
|   CC_SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   CC_SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
| 
| static int
| __archive_nettle_sha1init(archive_sha1_ctx *ctx)
| {
|   sha1_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha1_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
| 
| static int
| __archive_openssl_sha1init(archive_sha1_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha1());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
| 
| static int
| __archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA1));
| }
| 
| static int
| __archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 20, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha1init(archive_sha1_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA256 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
| 
| static int
| __archive_libc_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
| 
| static int
| __archive_libc2_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
| 
| static int
| __archive_libc3_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
| 
| static int
| __archive_libmd_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha256init(archive_sha256_ctx *ctx)
| {
|   CC_SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   CC_SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
| 
| static int
| __archive_nettle_sha256init(archive_sha256_ctx *ctx)
| {
|   sha256_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha256_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
| 
| static int
| __archive_openssl_sha256init(archive_sha256_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha256());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
| 
| static int
| __archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_256));
| }
| 
| static int
| __archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 32, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha256init(archive_sha256_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA384 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
| 
| static int
| __archive_libc_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
| 
| static int
| __archive_libc2_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
| 
| static int
| __archive_libc3_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha384init(archive_sha384_ctx *ctx)
| {
|   CC_SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   CC_SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
| 
| static int
| __archive_nettle_sha384init(archive_sha384_ctx *ctx)
| {
|   sha384_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha384_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
| 
| static int
| __archive_openssl_sha384init(archive_sha384_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha384());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
| 
| static int
| __archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_384));
| }
| 
| static int
| __archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 48, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha384init(archive_sha384_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA512 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
| 
| static int
| __archive_libc_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
| 
| static int
| __archive_libc2_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
| 
| static int
| __archive_libc3_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
| 
| static int
| __archive_libmd_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha512init(archive_sha512_ctx *ctx)
| {
|   CC_SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   CC_SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
| 
| static int
| __archive_nettle_sha512init(archive_sha512_ctx *ctx)
| {
|   sha512_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha512_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
| 
| static int
| __archive_openssl_sha512init(archive_sha512_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha512());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| static int
| __archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_512));
| }
| 
| static int
| __archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 64, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha512init(archive_sha512_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* NOTE: Crypto functions are set based on availability and by the following
|  * order of preference.
|  * 1. libc
|  * 2. libc2
|  * 3. libc3
|  * 4. libSystem
|  * 5. Nettle
|  * 6. OpenSSL
|  * 7. libmd
|  * 8. Windows API
|  */
| const struct archive_crypto __archive_crypto =
| {
| /* MD5 */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
|   &__archive_libc_md5init,
|   &__archive_libc_md5update,
|   &__archive_libc_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
|   &__archive_libmd_md5init,
|   &__archive_libmd_md5update,
|   &__archive_libmd_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
|   &__archive_libsystem_md5init,
|   &__archive_libsystem_md5update,
|   &__archive_libsystem_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
|   &__archive_nettle_md5init,
|   &__archive_nettle_md5update,
|   &__archive_nettle_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
|   &__archive_openssl_md5init,
|   &__archive_openssl_md5update,
|   &__archive_openssl_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
|   &__archive_windowsapi_md5init,
|   &__archive_windowsapi_md5update,
|   &__archive_windowsapi_md5final,
| #elif !defined(ARCHIVE_MD5_COMPILE_TEST)
|   &__archive_stub_md5init,
|   &__archive_stub_md5update,
|   &__archive_stub_md5final,
| #endif
| 
| /* RIPEMD160 */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
|   &__archive_libc_ripemd160init,
|   &__archive_libc_ripemd160update,
|   &__archive_libc_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
|   &__archive_libmd_ripemd160init,
|   &__archive_libmd_ripemd160update,
|   &__archive_libmd_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
|   &__archive_nettle_ripemd160init,
|   &__archive_nettle_ripemd160update,
|   &__archive_nettle_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
|   &__archive_openssl_ripemd160init,
|   &__archive_openssl_ripemd160update,
|   &__archive_openssl_ripemd160final,
| #elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
|   &__archive_stub_ripemd160init,
|   &__archive_stub_ripemd160update,
|   &__archive_stub_ripemd160final,
| #endif
| 
| /* SHA1 */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
|   &__archive_libc_sha1init,
|   &__archive_libc_sha1update,
|   &__archive_libc_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
|   &__archive_libmd_sha1init,
|   &__archive_libmd_sha1update,
|   &__archive_libmd_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
|   &__archive_libsystem_sha1init,
|   &__archive_libsystem_sha1update,
|   &__archive_libsystem_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
|   &__archive_nettle_sha1init,
|   &__archive_nettle_sha1update,
|   &__archive_nettle_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
|   &__archive_openssl_sha1init,
|   &__archive_openssl_sha1update,
|   &__archive_openssl_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
|   &__archive_windowsapi_sha1init,
|   &__archive_windowsapi_sha1update,
|   &__archive_windowsapi_sha1final,
| #elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
|   &__archive_stub_sha1init,
|   &__archive_stub_sha1update,
|   &__archive_stub_sha1final,
| #endif
| 
| /* SHA256 */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
|   &__archive_libc_sha256init,
|   &__archive_libc_sha256update,
|   &__archive_libc_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
|   &__archive_libc2_sha256init,
|   &__archive_libc2_sha256update,
|   &__archive_libc2_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
|   &__archive_libc3_sha256init,
|   &__archive_libc3_sha256update,
|   &__archive_libc3_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
|   &__archive_libmd_sha256init,
|   &__archive_libmd_sha256update,
|   &__archive_libmd_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
|   &__archive_libsystem_sha256init,
|   &__archive_libsystem_sha256update,
|   &__archive_libsystem_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
|   &__archive_nettle_sha256init,
|   &__archive_nettle_sha256update,
|   &__archive_nettle_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
|   &__archive_openssl_sha256init,
|   &__archive_openssl_sha256update,
|   &__archive_openssl_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
|   &__archive_windowsapi_sha256init,
|   &__archive_windowsapi_sha256update,
|   &__archive_windowsapi_sha256final,
| #elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
|   &__archive_stub_sha256init,
|   &__archive_stub_sha256update,
|   &__archive_stub_sha256final,
| #endif
| 
| /* SHA384 */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
|   &__archive_libc_sha384init,
|   &__archive_libc_sha384update,
|   &__archive_libc_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
|   &__archive_libc2_sha384init,
|   &__archive_libc2_sha384update,
|   &__archive_libc2_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
|   &__archive_libc3_sha384init,
|   &__archive_libc3_sha384update,
|   &__archive_libc3_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
|   &__archive_libsystem_sha384init,
|   &__archive_libsystem_sha384update,
|   &__archive_libsystem_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
|   &__archive_nettle_sha384init,
|   &__archive_nettle_sha384update,
|   &__archive_nettle_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
|   &__archive_openssl_sha384init,
|   &__archive_openssl_sha384update,
|   &__archive_openssl_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
|   &__archive_windowsapi_sha384init,
|   &__archive_windowsapi_sha384update,
|   &__archive_windowsapi_sha384final,
| #elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
|   &__archive_stub_sha384init,
|   &__archive_stub_sha384update,
|   &__archive_stub_sha384final,
| #endif
| 
| /* SHA512 */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
|   &__archive_libc_sha512init,
|   &__archive_libc_sha512update,
|   &__archive_libc_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
|   &__archive_libc2_sha512init,
|   &__archive_libc2_sha512update,
|   &__archive_libc2_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
|   &__archive_libc3_sha512init,
|   &__archive_libc3_sha512update,
|   &__archive_libc3_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
|   &__archive_libmd_sha512init,
|   &__archive_libmd_sha512update,
|   &__archive_libmd_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
|   &__archive_libsystem_sha512init,
|   &__archive_libsystem_sha512update,
|   &__archive_libsystem_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
|   &__archive_nettle_sha512init,
|   &__archive_nettle_sha512update,
|   &__archive_nettle_sha512final,
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
|   &__archive_openssl_sha512init,
|   &__archive_openssl_sha512update,
|   &__archive_openssl_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
|   &__archive_windowsapi_sha512init,
|   &__archive_windowsapi_sha512update,
|   &__archive_windowsapi_sha512final
| #elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
|   &__archive_stub_sha512init,
|   &__archive_stub_sha512update,
|   &__archive_stub_sha512final
| #endif
| };
| 
| int
| main(int argc, char **argv)
| {
|   archive_rmd160_ctx ctx;
|   archive_rmd160_init(&ctx);
|   archive_rmd160_update(&ctx, *argv, argc);
|   archive_rmd160_final(&ctx, NULL);
|   return 0;
| }
| 
configure:18564: result: no
configure:18578: checking support for ARCHIVE_CRYPTO_SHA1_OPENSSL
configure:18600: arm-linux-androideabi-gcc -o conftest    -I. -I. -I./libarchive  conftest.c -lz  >&5
In file included from conftest.c:206:0:
./libarchive/archive_crypto_private.h:137:25: fatal error: openssl/evp.h: No such file or directory
 #include <openssl/evp.h>
                         ^
compilation terminated.
configure:18600: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| #define ARCHIVE_SHA1_COMPILE_TEST
| #define ARCHIVE_CRYPTO_SHA1_OPENSSL
| #define PLATFORM_CONFIG_H "check_crypto_md.h"
| 
| /*-
| * Copyright (c) 2003-2007 Tim Kientzle
| * Copyright (c) 2011 Andres Mejia
| * Copyright (c) 2011 Michihiro NAKAJIMA
| * All rights reserved.
| *
| * Redistribution and use in source and binary forms, with or without
| * modification, are permitted provided that the following conditions
| * are met:
| * 1. Redistributions of source code must retain the above copyright
| *    notice, this list of conditions and the following disclaimer.
| * 2. Redistributions in binary form must reproduce the above copyright
| *    notice, this list of conditions and the following disclaimer in the
| *    documentation and/or other materials provided with the distribution.
| *
| * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
| * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
| * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
| * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
| * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
| * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
| * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
| * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
| * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
| * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
| */
| 
| #include "archive_platform.h"
| 
| #include "archive.h"
| #include "archive_crypto_private.h"
| 
| /* In particular, force the configure probe to break if it tries
|  * to test a combination of OpenSSL and libmd. */
| #if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
| #error Cannot use both OpenSSL and libmd.
| #endif
| 
| /*
|  * Message digest functions for Windows platform.
|  */
| #if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
| 	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
| 	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| /*
|  * Initialize a Message digest.
|  */
| static int
| win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
| {
| 
| 	ctx->valid = 0;
| 	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
| 		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
| 			return (ARCHIVE_FAILED);
| 		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
| 			return (ARCHIVE_FAILED);
| 	}
| 
| 	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
| 		CryptReleaseContext(ctx->cryptProv, 0);
| 		return (ARCHIVE_FAILED);
| 	}
| 
| 	ctx->valid = 1;
| 	return (ARCHIVE_OK);
| }
| 
| /*
|  * Update a Message digest.
|  */
| static int
| win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
| {
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptHashData(ctx->hash,
| 		      (unsigned char *)(uintptr_t)buf,
| 		      (DWORD)len, 0);
| 	return (ARCHIVE_OK);
| }
| 
| static int
| win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
| {
| 	DWORD siglen = (DWORD)bufsize;
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
| 	CryptDestroyHash(ctx->hash);
| 	CryptReleaseContext(ctx->cryptProv, 0);
| 	ctx->valid = 0;
| 	return (ARCHIVE_OK);
| }
| 
| #endif /* defined(ARCHIVE_CRYPTO_*_WIN) */
| 
| 
| /* MD5 implementations */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
| 
| static int
| __archive_libc_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
| 
| static int
| __archive_libmd_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
| 
| static int
| __archive_libsystem_md5init(archive_md5_ctx *ctx)
| {
|   CC_MD5_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_MD5_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
| {
|   CC_MD5_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
| 
| static int
| __archive_nettle_md5init(archive_md5_ctx *ctx)
| {
|   md5_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   md5_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
| {
|   md5_digest(ctx, MD5_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
| 
| static int
| __archive_openssl_md5init(archive_md5_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_md5());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
| 
| static int
| __archive_windowsapi_md5init(archive_md5_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_MD5));
| }
| 
| static int
| __archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 16, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_md5init(archive_md5_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5final(archive_md5_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* RIPEMD160 implementations */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
| 
| static int
| __archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RMD160Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RMD160Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RMD160Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
| 
| static int
| __archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RIPEMD160_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RIPEMD160_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RIPEMD160_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
| 
| static int
| __archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   ripemd160_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   ripemd160_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
| 
| static int
| __archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_ripemd160());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #else
| 
| static int
| __archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA1 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
| 
| static int
| __archive_libc_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
| 
| static int
| __archive_libmd_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha1init(archive_sha1_ctx *ctx)
| {
|   CC_SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   CC_SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
| 
| static int
| __archive_nettle_sha1init(archive_sha1_ctx *ctx)
| {
|   sha1_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha1_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
| 
| static int
| __archive_openssl_sha1init(archive_sha1_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha1());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
| 
| static int
| __archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA1));
| }
| 
| static int
| __archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 20, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha1init(archive_sha1_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA256 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
| 
| static int
| __archive_libc_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
| 
| static int
| __archive_libc2_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
| 
| static int
| __archive_libc3_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
| 
| static int
| __archive_libmd_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha256init(archive_sha256_ctx *ctx)
| {
|   CC_SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   CC_SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
| 
| static int
| __archive_nettle_sha256init(archive_sha256_ctx *ctx)
| {
|   sha256_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha256_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
| 
| static int
| __archive_openssl_sha256init(archive_sha256_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha256());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
| 
| static int
| __archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_256));
| }
| 
| static int
| __archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 32, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha256init(archive_sha256_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA384 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
| 
| static int
| __archive_libc_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
| 
| static int
| __archive_libc2_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
| 
| static int
| __archive_libc3_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha384init(archive_sha384_ctx *ctx)
| {
|   CC_SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   CC_SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
| 
| static int
| __archive_nettle_sha384init(archive_sha384_ctx *ctx)
| {
|   sha384_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha384_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
| 
| static int
| __archive_openssl_sha384init(archive_sha384_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha384());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
| 
| static int
| __archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_384));
| }
| 
| static int
| __archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 48, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha384init(archive_sha384_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA512 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
| 
| static int
| __archive_libc_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
| 
| static int
| __archive_libc2_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
| 
| static int
| __archive_libc3_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
| 
| static int
| __archive_libmd_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha512init(archive_sha512_ctx *ctx)
| {
|   CC_SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   CC_SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
| 
| static int
| __archive_nettle_sha512init(archive_sha512_ctx *ctx)
| {
|   sha512_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha512_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
| 
| static int
| __archive_openssl_sha512init(archive_sha512_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha512());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| static int
| __archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_512));
| }
| 
| static int
| __archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 64, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha512init(archive_sha512_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* NOTE: Crypto functions are set based on availability and by the following
|  * order of preference.
|  * 1. libc
|  * 2. libc2
|  * 3. libc3
|  * 4. libSystem
|  * 5. Nettle
|  * 6. OpenSSL
|  * 7. libmd
|  * 8. Windows API
|  */
| const struct archive_crypto __archive_crypto =
| {
| /* MD5 */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
|   &__archive_libc_md5init,
|   &__archive_libc_md5update,
|   &__archive_libc_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
|   &__archive_libmd_md5init,
|   &__archive_libmd_md5update,
|   &__archive_libmd_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
|   &__archive_libsystem_md5init,
|   &__archive_libsystem_md5update,
|   &__archive_libsystem_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
|   &__archive_nettle_md5init,
|   &__archive_nettle_md5update,
|   &__archive_nettle_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
|   &__archive_openssl_md5init,
|   &__archive_openssl_md5update,
|   &__archive_openssl_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
|   &__archive_windowsapi_md5init,
|   &__archive_windowsapi_md5update,
|   &__archive_windowsapi_md5final,
| #elif !defined(ARCHIVE_MD5_COMPILE_TEST)
|   &__archive_stub_md5init,
|   &__archive_stub_md5update,
|   &__archive_stub_md5final,
| #endif
| 
| /* RIPEMD160 */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
|   &__archive_libc_ripemd160init,
|   &__archive_libc_ripemd160update,
|   &__archive_libc_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
|   &__archive_libmd_ripemd160init,
|   &__archive_libmd_ripemd160update,
|   &__archive_libmd_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
|   &__archive_nettle_ripemd160init,
|   &__archive_nettle_ripemd160update,
|   &__archive_nettle_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
|   &__archive_openssl_ripemd160init,
|   &__archive_openssl_ripemd160update,
|   &__archive_openssl_ripemd160final,
| #elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
|   &__archive_stub_ripemd160init,
|   &__archive_stub_ripemd160update,
|   &__archive_stub_ripemd160final,
| #endif
| 
| /* SHA1 */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
|   &__archive_libc_sha1init,
|   &__archive_libc_sha1update,
|   &__archive_libc_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
|   &__archive_libmd_sha1init,
|   &__archive_libmd_sha1update,
|   &__archive_libmd_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
|   &__archive_libsystem_sha1init,
|   &__archive_libsystem_sha1update,
|   &__archive_libsystem_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
|   &__archive_nettle_sha1init,
|   &__archive_nettle_sha1update,
|   &__archive_nettle_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
|   &__archive_openssl_sha1init,
|   &__archive_openssl_sha1update,
|   &__archive_openssl_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
|   &__archive_windowsapi_sha1init,
|   &__archive_windowsapi_sha1update,
|   &__archive_windowsapi_sha1final,
| #elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
|   &__archive_stub_sha1init,
|   &__archive_stub_sha1update,
|   &__archive_stub_sha1final,
| #endif
| 
| /* SHA256 */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
|   &__archive_libc_sha256init,
|   &__archive_libc_sha256update,
|   &__archive_libc_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
|   &__archive_libc2_sha256init,
|   &__archive_libc2_sha256update,
|   &__archive_libc2_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
|   &__archive_libc3_sha256init,
|   &__archive_libc3_sha256update,
|   &__archive_libc3_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
|   &__archive_libmd_sha256init,
|   &__archive_libmd_sha256update,
|   &__archive_libmd_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
|   &__archive_libsystem_sha256init,
|   &__archive_libsystem_sha256update,
|   &__archive_libsystem_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
|   &__archive_nettle_sha256init,
|   &__archive_nettle_sha256update,
|   &__archive_nettle_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
|   &__archive_openssl_sha256init,
|   &__archive_openssl_sha256update,
|   &__archive_openssl_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
|   &__archive_windowsapi_sha256init,
|   &__archive_windowsapi_sha256update,
|   &__archive_windowsapi_sha256final,
| #elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
|   &__archive_stub_sha256init,
|   &__archive_stub_sha256update,
|   &__archive_stub_sha256final,
| #endif
| 
| /* SHA384 */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
|   &__archive_libc_sha384init,
|   &__archive_libc_sha384update,
|   &__archive_libc_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
|   &__archive_libc2_sha384init,
|   &__archive_libc2_sha384update,
|   &__archive_libc2_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
|   &__archive_libc3_sha384init,
|   &__archive_libc3_sha384update,
|   &__archive_libc3_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
|   &__archive_libsystem_sha384init,
|   &__archive_libsystem_sha384update,
|   &__archive_libsystem_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
|   &__archive_nettle_sha384init,
|   &__archive_nettle_sha384update,
|   &__archive_nettle_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
|   &__archive_openssl_sha384init,
|   &__archive_openssl_sha384update,
|   &__archive_openssl_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
|   &__archive_windowsapi_sha384init,
|   &__archive_windowsapi_sha384update,
|   &__archive_windowsapi_sha384final,
| #elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
|   &__archive_stub_sha384init,
|   &__archive_stub_sha384update,
|   &__archive_stub_sha384final,
| #endif
| 
| /* SHA512 */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
|   &__archive_libc_sha512init,
|   &__archive_libc_sha512update,
|   &__archive_libc_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
|   &__archive_libc2_sha512init,
|   &__archive_libc2_sha512update,
|   &__archive_libc2_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
|   &__archive_libc3_sha512init,
|   &__archive_libc3_sha512update,
|   &__archive_libc3_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
|   &__archive_libmd_sha512init,
|   &__archive_libmd_sha512update,
|   &__archive_libmd_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
|   &__archive_libsystem_sha512init,
|   &__archive_libsystem_sha512update,
|   &__archive_libsystem_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
|   &__archive_nettle_sha512init,
|   &__archive_nettle_sha512update,
|   &__archive_nettle_sha512final,
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
|   &__archive_openssl_sha512init,
|   &__archive_openssl_sha512update,
|   &__archive_openssl_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
|   &__archive_windowsapi_sha512init,
|   &__archive_windowsapi_sha512update,
|   &__archive_windowsapi_sha512final
| #elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
|   &__archive_stub_sha512init,
|   &__archive_stub_sha512update,
|   &__archive_stub_sha512final
| #endif
| };
| 
| int
| main(int argc, char **argv)
| {
|   archive_sha1_ctx ctx;
|   archive_sha1_init(&ctx);
|   archive_sha1_update(&ctx, *argv, argc);
|   archive_sha1_final(&ctx, NULL);
|   return 0;
| }
| 
configure:18610: result: no
configure:18624: checking support for ARCHIVE_CRYPTO_SHA256_OPENSSL
configure:18646: arm-linux-androideabi-gcc -o conftest    -I. -I. -I./libarchive  conftest.c -lz  >&5
In file included from conftest.c:206:0:
./libarchive/archive_crypto_private.h:137:25: fatal error: openssl/evp.h: No such file or directory
 #include <openssl/evp.h>
                         ^
compilation terminated.
configure:18646: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| #define ARCHIVE_SHA256_COMPILE_TEST
| #define ARCHIVE_CRYPTO_SHA256_OPENSSL
| #define PLATFORM_CONFIG_H "check_crypto_md.h"
| 
| /*-
| * Copyright (c) 2003-2007 Tim Kientzle
| * Copyright (c) 2011 Andres Mejia
| * Copyright (c) 2011 Michihiro NAKAJIMA
| * All rights reserved.
| *
| * Redistribution and use in source and binary forms, with or without
| * modification, are permitted provided that the following conditions
| * are met:
| * 1. Redistributions of source code must retain the above copyright
| *    notice, this list of conditions and the following disclaimer.
| * 2. Redistributions in binary form must reproduce the above copyright
| *    notice, this list of conditions and the following disclaimer in the
| *    documentation and/or other materials provided with the distribution.
| *
| * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
| * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
| * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
| * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
| * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
| * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
| * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
| * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
| * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
| * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
| */
| 
| #include "archive_platform.h"
| 
| #include "archive.h"
| #include "archive_crypto_private.h"
| 
| /* In particular, force the configure probe to break if it tries
|  * to test a combination of OpenSSL and libmd. */
| #if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
| #error Cannot use both OpenSSL and libmd.
| #endif
| 
| /*
|  * Message digest functions for Windows platform.
|  */
| #if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
| 	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
| 	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| /*
|  * Initialize a Message digest.
|  */
| static int
| win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
| {
| 
| 	ctx->valid = 0;
| 	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
| 		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
| 			return (ARCHIVE_FAILED);
| 		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
| 			return (ARCHIVE_FAILED);
| 	}
| 
| 	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
| 		CryptReleaseContext(ctx->cryptProv, 0);
| 		return (ARCHIVE_FAILED);
| 	}
| 
| 	ctx->valid = 1;
| 	return (ARCHIVE_OK);
| }
| 
| /*
|  * Update a Message digest.
|  */
| static int
| win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
| {
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptHashData(ctx->hash,
| 		      (unsigned char *)(uintptr_t)buf,
| 		      (DWORD)len, 0);
| 	return (ARCHIVE_OK);
| }
| 
| static int
| win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
| {
| 	DWORD siglen = (DWORD)bufsize;
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
| 	CryptDestroyHash(ctx->hash);
| 	CryptReleaseContext(ctx->cryptProv, 0);
| 	ctx->valid = 0;
| 	return (ARCHIVE_OK);
| }
| 
| #endif /* defined(ARCHIVE_CRYPTO_*_WIN) */
| 
| 
| /* MD5 implementations */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
| 
| static int
| __archive_libc_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
| 
| static int
| __archive_libmd_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
| 
| static int
| __archive_libsystem_md5init(archive_md5_ctx *ctx)
| {
|   CC_MD5_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_MD5_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
| {
|   CC_MD5_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
| 
| static int
| __archive_nettle_md5init(archive_md5_ctx *ctx)
| {
|   md5_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   md5_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
| {
|   md5_digest(ctx, MD5_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
| 
| static int
| __archive_openssl_md5init(archive_md5_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_md5());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
| 
| static int
| __archive_windowsapi_md5init(archive_md5_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_MD5));
| }
| 
| static int
| __archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 16, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_md5init(archive_md5_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5final(archive_md5_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* RIPEMD160 implementations */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
| 
| static int
| __archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RMD160Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RMD160Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RMD160Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
| 
| static int
| __archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RIPEMD160_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RIPEMD160_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RIPEMD160_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
| 
| static int
| __archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   ripemd160_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   ripemd160_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
| 
| static int
| __archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_ripemd160());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #else
| 
| static int
| __archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA1 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
| 
| static int
| __archive_libc_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
| 
| static int
| __archive_libmd_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha1init(archive_sha1_ctx *ctx)
| {
|   CC_SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   CC_SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
| 
| static int
| __archive_nettle_sha1init(archive_sha1_ctx *ctx)
| {
|   sha1_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha1_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
| 
| static int
| __archive_openssl_sha1init(archive_sha1_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha1());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
| 
| static int
| __archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA1));
| }
| 
| static int
| __archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 20, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha1init(archive_sha1_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA256 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
| 
| static int
| __archive_libc_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
| 
| static int
| __archive_libc2_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
| 
| static int
| __archive_libc3_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
| 
| static int
| __archive_libmd_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha256init(archive_sha256_ctx *ctx)
| {
|   CC_SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   CC_SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
| 
| static int
| __archive_nettle_sha256init(archive_sha256_ctx *ctx)
| {
|   sha256_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha256_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
| 
| static int
| __archive_openssl_sha256init(archive_sha256_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha256());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
| 
| static int
| __archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_256));
| }
| 
| static int
| __archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 32, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha256init(archive_sha256_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA384 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
| 
| static int
| __archive_libc_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
| 
| static int
| __archive_libc2_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
| 
| static int
| __archive_libc3_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha384init(archive_sha384_ctx *ctx)
| {
|   CC_SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   CC_SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
| 
| static int
| __archive_nettle_sha384init(archive_sha384_ctx *ctx)
| {
|   sha384_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha384_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
| 
| static int
| __archive_openssl_sha384init(archive_sha384_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha384());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
| 
| static int
| __archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_384));
| }
| 
| static int
| __archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 48, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha384init(archive_sha384_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA512 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
| 
| static int
| __archive_libc_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
| 
| static int
| __archive_libc2_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
| 
| static int
| __archive_libc3_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
| 
| static int
| __archive_libmd_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha512init(archive_sha512_ctx *ctx)
| {
|   CC_SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   CC_SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
| 
| static int
| __archive_nettle_sha512init(archive_sha512_ctx *ctx)
| {
|   sha512_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha512_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
| 
| static int
| __archive_openssl_sha512init(archive_sha512_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha512());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| static int
| __archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_512));
| }
| 
| static int
| __archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 64, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha512init(archive_sha512_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* NOTE: Crypto functions are set based on availability and by the following
|  * order of preference.
|  * 1. libc
|  * 2. libc2
|  * 3. libc3
|  * 4. libSystem
|  * 5. Nettle
|  * 6. OpenSSL
|  * 7. libmd
|  * 8. Windows API
|  */
| const struct archive_crypto __archive_crypto =
| {
| /* MD5 */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
|   &__archive_libc_md5init,
|   &__archive_libc_md5update,
|   &__archive_libc_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
|   &__archive_libmd_md5init,
|   &__archive_libmd_md5update,
|   &__archive_libmd_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
|   &__archive_libsystem_md5init,
|   &__archive_libsystem_md5update,
|   &__archive_libsystem_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
|   &__archive_nettle_md5init,
|   &__archive_nettle_md5update,
|   &__archive_nettle_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
|   &__archive_openssl_md5init,
|   &__archive_openssl_md5update,
|   &__archive_openssl_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
|   &__archive_windowsapi_md5init,
|   &__archive_windowsapi_md5update,
|   &__archive_windowsapi_md5final,
| #elif !defined(ARCHIVE_MD5_COMPILE_TEST)
|   &__archive_stub_md5init,
|   &__archive_stub_md5update,
|   &__archive_stub_md5final,
| #endif
| 
| /* RIPEMD160 */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
|   &__archive_libc_ripemd160init,
|   &__archive_libc_ripemd160update,
|   &__archive_libc_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
|   &__archive_libmd_ripemd160init,
|   &__archive_libmd_ripemd160update,
|   &__archive_libmd_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
|   &__archive_nettle_ripemd160init,
|   &__archive_nettle_ripemd160update,
|   &__archive_nettle_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
|   &__archive_openssl_ripemd160init,
|   &__archive_openssl_ripemd160update,
|   &__archive_openssl_ripemd160final,
| #elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
|   &__archive_stub_ripemd160init,
|   &__archive_stub_ripemd160update,
|   &__archive_stub_ripemd160final,
| #endif
| 
| /* SHA1 */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
|   &__archive_libc_sha1init,
|   &__archive_libc_sha1update,
|   &__archive_libc_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
|   &__archive_libmd_sha1init,
|   &__archive_libmd_sha1update,
|   &__archive_libmd_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
|   &__archive_libsystem_sha1init,
|   &__archive_libsystem_sha1update,
|   &__archive_libsystem_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
|   &__archive_nettle_sha1init,
|   &__archive_nettle_sha1update,
|   &__archive_nettle_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
|   &__archive_openssl_sha1init,
|   &__archive_openssl_sha1update,
|   &__archive_openssl_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
|   &__archive_windowsapi_sha1init,
|   &__archive_windowsapi_sha1update,
|   &__archive_windowsapi_sha1final,
| #elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
|   &__archive_stub_sha1init,
|   &__archive_stub_sha1update,
|   &__archive_stub_sha1final,
| #endif
| 
| /* SHA256 */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
|   &__archive_libc_sha256init,
|   &__archive_libc_sha256update,
|   &__archive_libc_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
|   &__archive_libc2_sha256init,
|   &__archive_libc2_sha256update,
|   &__archive_libc2_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
|   &__archive_libc3_sha256init,
|   &__archive_libc3_sha256update,
|   &__archive_libc3_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
|   &__archive_libmd_sha256init,
|   &__archive_libmd_sha256update,
|   &__archive_libmd_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
|   &__archive_libsystem_sha256init,
|   &__archive_libsystem_sha256update,
|   &__archive_libsystem_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
|   &__archive_nettle_sha256init,
|   &__archive_nettle_sha256update,
|   &__archive_nettle_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
|   &__archive_openssl_sha256init,
|   &__archive_openssl_sha256update,
|   &__archive_openssl_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
|   &__archive_windowsapi_sha256init,
|   &__archive_windowsapi_sha256update,
|   &__archive_windowsapi_sha256final,
| #elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
|   &__archive_stub_sha256init,
|   &__archive_stub_sha256update,
|   &__archive_stub_sha256final,
| #endif
| 
| /* SHA384 */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
|   &__archive_libc_sha384init,
|   &__archive_libc_sha384update,
|   &__archive_libc_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
|   &__archive_libc2_sha384init,
|   &__archive_libc2_sha384update,
|   &__archive_libc2_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
|   &__archive_libc3_sha384init,
|   &__archive_libc3_sha384update,
|   &__archive_libc3_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
|   &__archive_libsystem_sha384init,
|   &__archive_libsystem_sha384update,
|   &__archive_libsystem_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
|   &__archive_nettle_sha384init,
|   &__archive_nettle_sha384update,
|   &__archive_nettle_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
|   &__archive_openssl_sha384init,
|   &__archive_openssl_sha384update,
|   &__archive_openssl_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
|   &__archive_windowsapi_sha384init,
|   &__archive_windowsapi_sha384update,
|   &__archive_windowsapi_sha384final,
| #elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
|   &__archive_stub_sha384init,
|   &__archive_stub_sha384update,
|   &__archive_stub_sha384final,
| #endif
| 
| /* SHA512 */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
|   &__archive_libc_sha512init,
|   &__archive_libc_sha512update,
|   &__archive_libc_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
|   &__archive_libc2_sha512init,
|   &__archive_libc2_sha512update,
|   &__archive_libc2_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
|   &__archive_libc3_sha512init,
|   &__archive_libc3_sha512update,
|   &__archive_libc3_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
|   &__archive_libmd_sha512init,
|   &__archive_libmd_sha512update,
|   &__archive_libmd_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
|   &__archive_libsystem_sha512init,
|   &__archive_libsystem_sha512update,
|   &__archive_libsystem_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
|   &__archive_nettle_sha512init,
|   &__archive_nettle_sha512update,
|   &__archive_nettle_sha512final,
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
|   &__archive_openssl_sha512init,
|   &__archive_openssl_sha512update,
|   &__archive_openssl_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
|   &__archive_windowsapi_sha512init,
|   &__archive_windowsapi_sha512update,
|   &__archive_windowsapi_sha512final
| #elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
|   &__archive_stub_sha512init,
|   &__archive_stub_sha512update,
|   &__archive_stub_sha512final
| #endif
| };
| 
| int
| main(int argc, char **argv)
| {
|   archive_sha256_ctx ctx;
|   archive_sha256_init(&ctx);
|   archive_sha256_update(&ctx, *argv, argc);
|   archive_sha256_final(&ctx, NULL);
|   return 0;
| }
| 
configure:18656: result: no
configure:18670: checking support for ARCHIVE_CRYPTO_SHA384_OPENSSL
configure:18692: arm-linux-androideabi-gcc -o conftest    -I. -I. -I./libarchive  conftest.c -lz  >&5
In file included from conftest.c:206:0:
./libarchive/archive_crypto_private.h:137:25: fatal error: openssl/evp.h: No such file or directory
 #include <openssl/evp.h>
                         ^
compilation terminated.
configure:18692: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| #define ARCHIVE_SHA384_COMPILE_TEST
| #define ARCHIVE_CRYPTO_SHA384_OPENSSL
| #define PLATFORM_CONFIG_H "check_crypto_md.h"
| 
| /*-
| * Copyright (c) 2003-2007 Tim Kientzle
| * Copyright (c) 2011 Andres Mejia
| * Copyright (c) 2011 Michihiro NAKAJIMA
| * All rights reserved.
| *
| * Redistribution and use in source and binary forms, with or without
| * modification, are permitted provided that the following conditions
| * are met:
| * 1. Redistributions of source code must retain the above copyright
| *    notice, this list of conditions and the following disclaimer.
| * 2. Redistributions in binary form must reproduce the above copyright
| *    notice, this list of conditions and the following disclaimer in the
| *    documentation and/or other materials provided with the distribution.
| *
| * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
| * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
| * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
| * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
| * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
| * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
| * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
| * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
| * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
| * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
| */
| 
| #include "archive_platform.h"
| 
| #include "archive.h"
| #include "archive_crypto_private.h"
| 
| /* In particular, force the configure probe to break if it tries
|  * to test a combination of OpenSSL and libmd. */
| #if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
| #error Cannot use both OpenSSL and libmd.
| #endif
| 
| /*
|  * Message digest functions for Windows platform.
|  */
| #if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
| 	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
| 	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| /*
|  * Initialize a Message digest.
|  */
| static int
| win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
| {
| 
| 	ctx->valid = 0;
| 	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
| 		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
| 			return (ARCHIVE_FAILED);
| 		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
| 			return (ARCHIVE_FAILED);
| 	}
| 
| 	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
| 		CryptReleaseContext(ctx->cryptProv, 0);
| 		return (ARCHIVE_FAILED);
| 	}
| 
| 	ctx->valid = 1;
| 	return (ARCHIVE_OK);
| }
| 
| /*
|  * Update a Message digest.
|  */
| static int
| win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
| {
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptHashData(ctx->hash,
| 		      (unsigned char *)(uintptr_t)buf,
| 		      (DWORD)len, 0);
| 	return (ARCHIVE_OK);
| }
| 
| static int
| win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
| {
| 	DWORD siglen = (DWORD)bufsize;
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
| 	CryptDestroyHash(ctx->hash);
| 	CryptReleaseContext(ctx->cryptProv, 0);
| 	ctx->valid = 0;
| 	return (ARCHIVE_OK);
| }
| 
| #endif /* defined(ARCHIVE_CRYPTO_*_WIN) */
| 
| 
| /* MD5 implementations */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
| 
| static int
| __archive_libc_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
| 
| static int
| __archive_libmd_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
| 
| static int
| __archive_libsystem_md5init(archive_md5_ctx *ctx)
| {
|   CC_MD5_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_MD5_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
| {
|   CC_MD5_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
| 
| static int
| __archive_nettle_md5init(archive_md5_ctx *ctx)
| {
|   md5_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   md5_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
| {
|   md5_digest(ctx, MD5_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
| 
| static int
| __archive_openssl_md5init(archive_md5_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_md5());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
| 
| static int
| __archive_windowsapi_md5init(archive_md5_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_MD5));
| }
| 
| static int
| __archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 16, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_md5init(archive_md5_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5final(archive_md5_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* RIPEMD160 implementations */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
| 
| static int
| __archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RMD160Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RMD160Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RMD160Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
| 
| static int
| __archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RIPEMD160_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RIPEMD160_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RIPEMD160_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
| 
| static int
| __archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   ripemd160_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   ripemd160_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
| 
| static int
| __archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_ripemd160());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #else
| 
| static int
| __archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA1 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
| 
| static int
| __archive_libc_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
| 
| static int
| __archive_libmd_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha1init(archive_sha1_ctx *ctx)
| {
|   CC_SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   CC_SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
| 
| static int
| __archive_nettle_sha1init(archive_sha1_ctx *ctx)
| {
|   sha1_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha1_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
| 
| static int
| __archive_openssl_sha1init(archive_sha1_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha1());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
| 
| static int
| __archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA1));
| }
| 
| static int
| __archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 20, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha1init(archive_sha1_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA256 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
| 
| static int
| __archive_libc_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
| 
| static int
| __archive_libc2_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
| 
| static int
| __archive_libc3_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
| 
| static int
| __archive_libmd_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha256init(archive_sha256_ctx *ctx)
| {
|   CC_SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   CC_SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
| 
| static int
| __archive_nettle_sha256init(archive_sha256_ctx *ctx)
| {
|   sha256_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha256_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
| 
| static int
| __archive_openssl_sha256init(archive_sha256_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha256());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
| 
| static int
| __archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_256));
| }
| 
| static int
| __archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 32, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha256init(archive_sha256_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA384 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
| 
| static int
| __archive_libc_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
| 
| static int
| __archive_libc2_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
| 
| static int
| __archive_libc3_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha384init(archive_sha384_ctx *ctx)
| {
|   CC_SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   CC_SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
| 
| static int
| __archive_nettle_sha384init(archive_sha384_ctx *ctx)
| {
|   sha384_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha384_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
| 
| static int
| __archive_openssl_sha384init(archive_sha384_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha384());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
| 
| static int
| __archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_384));
| }
| 
| static int
| __archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 48, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha384init(archive_sha384_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA512 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
| 
| static int
| __archive_libc_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
| 
| static int
| __archive_libc2_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
| 
| static int
| __archive_libc3_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
| 
| static int
| __archive_libmd_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha512init(archive_sha512_ctx *ctx)
| {
|   CC_SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   CC_SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
| 
| static int
| __archive_nettle_sha512init(archive_sha512_ctx *ctx)
| {
|   sha512_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha512_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
| 
| static int
| __archive_openssl_sha512init(archive_sha512_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha512());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| static int
| __archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_512));
| }
| 
| static int
| __archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 64, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha512init(archive_sha512_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* NOTE: Crypto functions are set based on availability and by the following
|  * order of preference.
|  * 1. libc
|  * 2. libc2
|  * 3. libc3
|  * 4. libSystem
|  * 5. Nettle
|  * 6. OpenSSL
|  * 7. libmd
|  * 8. Windows API
|  */
| const struct archive_crypto __archive_crypto =
| {
| /* MD5 */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
|   &__archive_libc_md5init,
|   &__archive_libc_md5update,
|   &__archive_libc_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
|   &__archive_libmd_md5init,
|   &__archive_libmd_md5update,
|   &__archive_libmd_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
|   &__archive_libsystem_md5init,
|   &__archive_libsystem_md5update,
|   &__archive_libsystem_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
|   &__archive_nettle_md5init,
|   &__archive_nettle_md5update,
|   &__archive_nettle_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
|   &__archive_openssl_md5init,
|   &__archive_openssl_md5update,
|   &__archive_openssl_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
|   &__archive_windowsapi_md5init,
|   &__archive_windowsapi_md5update,
|   &__archive_windowsapi_md5final,
| #elif !defined(ARCHIVE_MD5_COMPILE_TEST)
|   &__archive_stub_md5init,
|   &__archive_stub_md5update,
|   &__archive_stub_md5final,
| #endif
| 
| /* RIPEMD160 */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
|   &__archive_libc_ripemd160init,
|   &__archive_libc_ripemd160update,
|   &__archive_libc_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
|   &__archive_libmd_ripemd160init,
|   &__archive_libmd_ripemd160update,
|   &__archive_libmd_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
|   &__archive_nettle_ripemd160init,
|   &__archive_nettle_ripemd160update,
|   &__archive_nettle_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
|   &__archive_openssl_ripemd160init,
|   &__archive_openssl_ripemd160update,
|   &__archive_openssl_ripemd160final,
| #elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
|   &__archive_stub_ripemd160init,
|   &__archive_stub_ripemd160update,
|   &__archive_stub_ripemd160final,
| #endif
| 
| /* SHA1 */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
|   &__archive_libc_sha1init,
|   &__archive_libc_sha1update,
|   &__archive_libc_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
|   &__archive_libmd_sha1init,
|   &__archive_libmd_sha1update,
|   &__archive_libmd_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
|   &__archive_libsystem_sha1init,
|   &__archive_libsystem_sha1update,
|   &__archive_libsystem_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
|   &__archive_nettle_sha1init,
|   &__archive_nettle_sha1update,
|   &__archive_nettle_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
|   &__archive_openssl_sha1init,
|   &__archive_openssl_sha1update,
|   &__archive_openssl_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
|   &__archive_windowsapi_sha1init,
|   &__archive_windowsapi_sha1update,
|   &__archive_windowsapi_sha1final,
| #elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
|   &__archive_stub_sha1init,
|   &__archive_stub_sha1update,
|   &__archive_stub_sha1final,
| #endif
| 
| /* SHA256 */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
|   &__archive_libc_sha256init,
|   &__archive_libc_sha256update,
|   &__archive_libc_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
|   &__archive_libc2_sha256init,
|   &__archive_libc2_sha256update,
|   &__archive_libc2_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
|   &__archive_libc3_sha256init,
|   &__archive_libc3_sha256update,
|   &__archive_libc3_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
|   &__archive_libmd_sha256init,
|   &__archive_libmd_sha256update,
|   &__archive_libmd_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
|   &__archive_libsystem_sha256init,
|   &__archive_libsystem_sha256update,
|   &__archive_libsystem_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
|   &__archive_nettle_sha256init,
|   &__archive_nettle_sha256update,
|   &__archive_nettle_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
|   &__archive_openssl_sha256init,
|   &__archive_openssl_sha256update,
|   &__archive_openssl_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
|   &__archive_windowsapi_sha256init,
|   &__archive_windowsapi_sha256update,
|   &__archive_windowsapi_sha256final,
| #elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
|   &__archive_stub_sha256init,
|   &__archive_stub_sha256update,
|   &__archive_stub_sha256final,
| #endif
| 
| /* SHA384 */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
|   &__archive_libc_sha384init,
|   &__archive_libc_sha384update,
|   &__archive_libc_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
|   &__archive_libc2_sha384init,
|   &__archive_libc2_sha384update,
|   &__archive_libc2_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
|   &__archive_libc3_sha384init,
|   &__archive_libc3_sha384update,
|   &__archive_libc3_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
|   &__archive_libsystem_sha384init,
|   &__archive_libsystem_sha384update,
|   &__archive_libsystem_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
|   &__archive_nettle_sha384init,
|   &__archive_nettle_sha384update,
|   &__archive_nettle_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
|   &__archive_openssl_sha384init,
|   &__archive_openssl_sha384update,
|   &__archive_openssl_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
|   &__archive_windowsapi_sha384init,
|   &__archive_windowsapi_sha384update,
|   &__archive_windowsapi_sha384final,
| #elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
|   &__archive_stub_sha384init,
|   &__archive_stub_sha384update,
|   &__archive_stub_sha384final,
| #endif
| 
| /* SHA512 */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
|   &__archive_libc_sha512init,
|   &__archive_libc_sha512update,
|   &__archive_libc_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
|   &__archive_libc2_sha512init,
|   &__archive_libc2_sha512update,
|   &__archive_libc2_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
|   &__archive_libc3_sha512init,
|   &__archive_libc3_sha512update,
|   &__archive_libc3_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
|   &__archive_libmd_sha512init,
|   &__archive_libmd_sha512update,
|   &__archive_libmd_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
|   &__archive_libsystem_sha512init,
|   &__archive_libsystem_sha512update,
|   &__archive_libsystem_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
|   &__archive_nettle_sha512init,
|   &__archive_nettle_sha512update,
|   &__archive_nettle_sha512final,
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
|   &__archive_openssl_sha512init,
|   &__archive_openssl_sha512update,
|   &__archive_openssl_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
|   &__archive_windowsapi_sha512init,
|   &__archive_windowsapi_sha512update,
|   &__archive_windowsapi_sha512final
| #elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
|   &__archive_stub_sha512init,
|   &__archive_stub_sha512update,
|   &__archive_stub_sha512final
| #endif
| };
| 
| int
| main(int argc, char **argv)
| {
|   archive_sha384_ctx ctx;
|   archive_sha384_init(&ctx);
|   archive_sha384_update(&ctx, *argv, argc);
|   archive_sha384_final(&ctx, NULL);
|   return 0;
| }
| 
configure:18702: result: no
configure:18716: checking support for ARCHIVE_CRYPTO_SHA512_OPENSSL
configure:18738: arm-linux-androideabi-gcc -o conftest    -I. -I. -I./libarchive  conftest.c -lz  >&5
In file included from conftest.c:206:0:
./libarchive/archive_crypto_private.h:137:25: fatal error: openssl/evp.h: No such file or directory
 #include <openssl/evp.h>
                         ^
compilation terminated.
configure:18738: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| #define ARCHIVE_SHA512_COMPILE_TEST
| #define ARCHIVE_CRYPTO_SHA512_OPENSSL
| #define PLATFORM_CONFIG_H "check_crypto_md.h"
| 
| /*-
| * Copyright (c) 2003-2007 Tim Kientzle
| * Copyright (c) 2011 Andres Mejia
| * Copyright (c) 2011 Michihiro NAKAJIMA
| * All rights reserved.
| *
| * Redistribution and use in source and binary forms, with or without
| * modification, are permitted provided that the following conditions
| * are met:
| * 1. Redistributions of source code must retain the above copyright
| *    notice, this list of conditions and the following disclaimer.
| * 2. Redistributions in binary form must reproduce the above copyright
| *    notice, this list of conditions and the following disclaimer in the
| *    documentation and/or other materials provided with the distribution.
| *
| * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
| * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
| * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
| * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
| * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
| * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
| * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
| * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
| * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
| * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
| */
| 
| #include "archive_platform.h"
| 
| #include "archive.h"
| #include "archive_crypto_private.h"
| 
| /* In particular, force the configure probe to break if it tries
|  * to test a combination of OpenSSL and libmd. */
| #if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
| #error Cannot use both OpenSSL and libmd.
| #endif
| 
| /*
|  * Message digest functions for Windows platform.
|  */
| #if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
| 	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
| 	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| /*
|  * Initialize a Message digest.
|  */
| static int
| win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
| {
| 
| 	ctx->valid = 0;
| 	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
| 		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
| 			return (ARCHIVE_FAILED);
| 		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
| 			return (ARCHIVE_FAILED);
| 	}
| 
| 	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
| 		CryptReleaseContext(ctx->cryptProv, 0);
| 		return (ARCHIVE_FAILED);
| 	}
| 
| 	ctx->valid = 1;
| 	return (ARCHIVE_OK);
| }
| 
| /*
|  * Update a Message digest.
|  */
| static int
| win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
| {
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptHashData(ctx->hash,
| 		      (unsigned char *)(uintptr_t)buf,
| 		      (DWORD)len, 0);
| 	return (ARCHIVE_OK);
| }
| 
| static int
| win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
| {
| 	DWORD siglen = (DWORD)bufsize;
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
| 	CryptDestroyHash(ctx->hash);
| 	CryptReleaseContext(ctx->cryptProv, 0);
| 	ctx->valid = 0;
| 	return (ARCHIVE_OK);
| }
| 
| #endif /* defined(ARCHIVE_CRYPTO_*_WIN) */
| 
| 
| /* MD5 implementations */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
| 
| static int
| __archive_libc_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
| 
| static int
| __archive_libmd_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
| 
| static int
| __archive_libsystem_md5init(archive_md5_ctx *ctx)
| {
|   CC_MD5_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_MD5_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
| {
|   CC_MD5_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
| 
| static int
| __archive_nettle_md5init(archive_md5_ctx *ctx)
| {
|   md5_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   md5_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
| {
|   md5_digest(ctx, MD5_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
| 
| static int
| __archive_openssl_md5init(archive_md5_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_md5());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
| 
| static int
| __archive_windowsapi_md5init(archive_md5_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_MD5));
| }
| 
| static int
| __archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 16, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_md5init(archive_md5_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5final(archive_md5_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* RIPEMD160 implementations */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
| 
| static int
| __archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RMD160Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RMD160Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RMD160Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
| 
| static int
| __archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RIPEMD160_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RIPEMD160_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RIPEMD160_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
| 
| static int
| __archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   ripemd160_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   ripemd160_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
| 
| static int
| __archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_ripemd160());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #else
| 
| static int
| __archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA1 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
| 
| static int
| __archive_libc_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
| 
| static int
| __archive_libmd_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha1init(archive_sha1_ctx *ctx)
| {
|   CC_SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   CC_SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
| 
| static int
| __archive_nettle_sha1init(archive_sha1_ctx *ctx)
| {
|   sha1_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha1_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
| 
| static int
| __archive_openssl_sha1init(archive_sha1_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha1());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
| 
| static int
| __archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA1));
| }
| 
| static int
| __archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 20, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha1init(archive_sha1_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA256 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
| 
| static int
| __archive_libc_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
| 
| static int
| __archive_libc2_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
| 
| static int
| __archive_libc3_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
| 
| static int
| __archive_libmd_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha256init(archive_sha256_ctx *ctx)
| {
|   CC_SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   CC_SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
| 
| static int
| __archive_nettle_sha256init(archive_sha256_ctx *ctx)
| {
|   sha256_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha256_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
| 
| static int
| __archive_openssl_sha256init(archive_sha256_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha256());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
| 
| static int
| __archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_256));
| }
| 
| static int
| __archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 32, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha256init(archive_sha256_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA384 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
| 
| static int
| __archive_libc_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
| 
| static int
| __archive_libc2_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
| 
| static int
| __archive_libc3_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha384init(archive_sha384_ctx *ctx)
| {
|   CC_SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   CC_SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
| 
| static int
| __archive_nettle_sha384init(archive_sha384_ctx *ctx)
| {
|   sha384_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha384_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
| 
| static int
| __archive_openssl_sha384init(archive_sha384_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha384());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
| 
| static int
| __archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_384));
| }
| 
| static int
| __archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 48, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha384init(archive_sha384_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA512 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
| 
| static int
| __archive_libc_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
| 
| static int
| __archive_libc2_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
| 
| static int
| __archive_libc3_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
| 
| static int
| __archive_libmd_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha512init(archive_sha512_ctx *ctx)
| {
|   CC_SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   CC_SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
| 
| static int
| __archive_nettle_sha512init(archive_sha512_ctx *ctx)
| {
|   sha512_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha512_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
| 
| static int
| __archive_openssl_sha512init(archive_sha512_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha512());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| static int
| __archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_512));
| }
| 
| static int
| __archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 64, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha512init(archive_sha512_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* NOTE: Crypto functions are set based on availability and by the following
|  * order of preference.
|  * 1. libc
|  * 2. libc2
|  * 3. libc3
|  * 4. libSystem
|  * 5. Nettle
|  * 6. OpenSSL
|  * 7. libmd
|  * 8. Windows API
|  */
| const struct archive_crypto __archive_crypto =
| {
| /* MD5 */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
|   &__archive_libc_md5init,
|   &__archive_libc_md5update,
|   &__archive_libc_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
|   &__archive_libmd_md5init,
|   &__archive_libmd_md5update,
|   &__archive_libmd_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
|   &__archive_libsystem_md5init,
|   &__archive_libsystem_md5update,
|   &__archive_libsystem_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
|   &__archive_nettle_md5init,
|   &__archive_nettle_md5update,
|   &__archive_nettle_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
|   &__archive_openssl_md5init,
|   &__archive_openssl_md5update,
|   &__archive_openssl_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
|   &__archive_windowsapi_md5init,
|   &__archive_windowsapi_md5update,
|   &__archive_windowsapi_md5final,
| #elif !defined(ARCHIVE_MD5_COMPILE_TEST)
|   &__archive_stub_md5init,
|   &__archive_stub_md5update,
|   &__archive_stub_md5final,
| #endif
| 
| /* RIPEMD160 */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
|   &__archive_libc_ripemd160init,
|   &__archive_libc_ripemd160update,
|   &__archive_libc_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
|   &__archive_libmd_ripemd160init,
|   &__archive_libmd_ripemd160update,
|   &__archive_libmd_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
|   &__archive_nettle_ripemd160init,
|   &__archive_nettle_ripemd160update,
|   &__archive_nettle_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
|   &__archive_openssl_ripemd160init,
|   &__archive_openssl_ripemd160update,
|   &__archive_openssl_ripemd160final,
| #elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
|   &__archive_stub_ripemd160init,
|   &__archive_stub_ripemd160update,
|   &__archive_stub_ripemd160final,
| #endif
| 
| /* SHA1 */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
|   &__archive_libc_sha1init,
|   &__archive_libc_sha1update,
|   &__archive_libc_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
|   &__archive_libmd_sha1init,
|   &__archive_libmd_sha1update,
|   &__archive_libmd_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
|   &__archive_libsystem_sha1init,
|   &__archive_libsystem_sha1update,
|   &__archive_libsystem_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
|   &__archive_nettle_sha1init,
|   &__archive_nettle_sha1update,
|   &__archive_nettle_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
|   &__archive_openssl_sha1init,
|   &__archive_openssl_sha1update,
|   &__archive_openssl_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
|   &__archive_windowsapi_sha1init,
|   &__archive_windowsapi_sha1update,
|   &__archive_windowsapi_sha1final,
| #elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
|   &__archive_stub_sha1init,
|   &__archive_stub_sha1update,
|   &__archive_stub_sha1final,
| #endif
| 
| /* SHA256 */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
|   &__archive_libc_sha256init,
|   &__archive_libc_sha256update,
|   &__archive_libc_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
|   &__archive_libc2_sha256init,
|   &__archive_libc2_sha256update,
|   &__archive_libc2_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
|   &__archive_libc3_sha256init,
|   &__archive_libc3_sha256update,
|   &__archive_libc3_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
|   &__archive_libmd_sha256init,
|   &__archive_libmd_sha256update,
|   &__archive_libmd_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
|   &__archive_libsystem_sha256init,
|   &__archive_libsystem_sha256update,
|   &__archive_libsystem_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
|   &__archive_nettle_sha256init,
|   &__archive_nettle_sha256update,
|   &__archive_nettle_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
|   &__archive_openssl_sha256init,
|   &__archive_openssl_sha256update,
|   &__archive_openssl_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
|   &__archive_windowsapi_sha256init,
|   &__archive_windowsapi_sha256update,
|   &__archive_windowsapi_sha256final,
| #elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
|   &__archive_stub_sha256init,
|   &__archive_stub_sha256update,
|   &__archive_stub_sha256final,
| #endif
| 
| /* SHA384 */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
|   &__archive_libc_sha384init,
|   &__archive_libc_sha384update,
|   &__archive_libc_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
|   &__archive_libc2_sha384init,
|   &__archive_libc2_sha384update,
|   &__archive_libc2_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
|   &__archive_libc3_sha384init,
|   &__archive_libc3_sha384update,
|   &__archive_libc3_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
|   &__archive_libsystem_sha384init,
|   &__archive_libsystem_sha384update,
|   &__archive_libsystem_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
|   &__archive_nettle_sha384init,
|   &__archive_nettle_sha384update,
|   &__archive_nettle_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
|   &__archive_openssl_sha384init,
|   &__archive_openssl_sha384update,
|   &__archive_openssl_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
|   &__archive_windowsapi_sha384init,
|   &__archive_windowsapi_sha384update,
|   &__archive_windowsapi_sha384final,
| #elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
|   &__archive_stub_sha384init,
|   &__archive_stub_sha384update,
|   &__archive_stub_sha384final,
| #endif
| 
| /* SHA512 */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
|   &__archive_libc_sha512init,
|   &__archive_libc_sha512update,
|   &__archive_libc_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
|   &__archive_libc2_sha512init,
|   &__archive_libc2_sha512update,
|   &__archive_libc2_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
|   &__archive_libc3_sha512init,
|   &__archive_libc3_sha512update,
|   &__archive_libc3_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
|   &__archive_libmd_sha512init,
|   &__archive_libmd_sha512update,
|   &__archive_libmd_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
|   &__archive_libsystem_sha512init,
|   &__archive_libsystem_sha512update,
|   &__archive_libsystem_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
|   &__archive_nettle_sha512init,
|   &__archive_nettle_sha512update,
|   &__archive_nettle_sha512final,
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
|   &__archive_openssl_sha512init,
|   &__archive_openssl_sha512update,
|   &__archive_openssl_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
|   &__archive_windowsapi_sha512init,
|   &__archive_windowsapi_sha512update,
|   &__archive_windowsapi_sha512final
| #elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
|   &__archive_stub_sha512init,
|   &__archive_stub_sha512update,
|   &__archive_stub_sha512final
| #endif
| };
| 
| int
| main(int argc, char **argv)
| {
|   archive_sha512_ctx ctx;
|   archive_sha512_init(&ctx);
|   archive_sha512_update(&ctx, *argv, argc);
|   archive_sha512_final(&ctx, NULL);
|   return 0;
| }
| 
configure:18748: result: no
configure:18767: checking md5.h usability
configure:18767: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:204:17: fatal error: md5.h: No such file or directory
 #include <md5.h>
                 ^
compilation terminated.
configure:18767: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <md5.h>
configure:18767: result: no
configure:18767: checking md5.h presence
configure:18767: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:171:17: fatal error: md5.h: No such file or directory
 #include <md5.h>
                 ^
compilation terminated.
configure:18767: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| #include <md5.h>
configure:18767: result: no
configure:18767: checking for md5.h
configure:18767: result: no
configure:18767: checking ripemd.h usability
configure:18767: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:204:20: fatal error: ripemd.h: No such file or directory
 #include <ripemd.h>
                    ^
compilation terminated.
configure:18767: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <ripemd.h>
configure:18767: result: no
configure:18767: checking ripemd.h presence
configure:18767: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:171:20: fatal error: ripemd.h: No such file or directory
 #include <ripemd.h>
                    ^
compilation terminated.
configure:18767: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| #include <ripemd.h>
configure:18767: result: no
configure:18767: checking for ripemd.h
configure:18767: result: no
configure:18767: checking sha.h usability
configure:18767: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:204:17: fatal error: sha.h: No such file or directory
 #include <sha.h>
                 ^
compilation terminated.
configure:18767: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <sha.h>
configure:18767: result: no
configure:18767: checking sha.h presence
configure:18767: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:171:17: fatal error: sha.h: No such file or directory
 #include <sha.h>
                 ^
compilation terminated.
configure:18767: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| #include <sha.h>
configure:18767: result: no
configure:18767: checking for sha.h
configure:18767: result: no
configure:18767: checking sha256.h usability
configure:18767: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:204:20: fatal error: sha256.h: No such file or directory
 #include <sha256.h>
                    ^
compilation terminated.
configure:18767: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <sha256.h>
configure:18767: result: no
configure:18767: checking sha256.h presence
configure:18767: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:171:20: fatal error: sha256.h: No such file or directory
 #include <sha256.h>
                    ^
compilation terminated.
configure:18767: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| #include <sha256.h>
configure:18767: result: no
configure:18767: checking for sha256.h
configure:18767: result: no
configure:18767: checking sha512.h usability
configure:18767: arm-linux-androideabi-gcc -c    conftest.c >&5
conftest.c:204:20: fatal error: sha512.h: No such file or directory
 #include <sha512.h>
                    ^
compilation terminated.
configure:18767: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| #include <stdio.h>
| #ifdef HAVE_SYS_TYPES_H
| # include <sys/types.h>
| #endif
| #ifdef HAVE_SYS_STAT_H
| # include <sys/stat.h>
| #endif
| #ifdef STDC_HEADERS
| # include <stdlib.h>
| # include <stddef.h>
| #else
| # ifdef HAVE_STDLIB_H
| #  include <stdlib.h>
| # endif
| #endif
| #ifdef HAVE_STRING_H
| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
| #  include <memory.h>
| # endif
| # include <string.h>
| #endif
| #ifdef HAVE_STRINGS_H
| # include <strings.h>
| #endif
| #ifdef HAVE_INTTYPES_H
| # include <inttypes.h>
| #endif
| #ifdef HAVE_STDINT_H
| # include <stdint.h>
| #endif
| #ifdef HAVE_UNISTD_H
| # include <unistd.h>
| #endif
| #include <sha512.h>
configure:18767: result: no
configure:18767: checking sha512.h presence
configure:18767: arm-linux-androideabi-gcc -E  conftest.c
conftest.c:171:20: fatal error: sha512.h: No such file or directory
 #include <sha512.h>
                    ^
compilation terminated.
configure:18767: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| #include <sha512.h>
configure:18767: result: no
configure:18767: checking for sha512.h
configure:18767: result: no
configure:18778: checking for main in -lmd
configure:18797: arm-linux-androideabi-gcc -o conftest     conftest.c -lmd  -lz  >&5
/tmp/toolchain/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld: error: cannot find -lmd
collect2: error: ld returned 1 exit status
configure:18797: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| 
| int
| main ()
| {
| return main ();
|   ;
|   return 0;
| }
configure:18806: result: no
configure:18822: checking support for ARCHIVE_CRYPTO_MD5_LIBMD
configure:18844: arm-linux-androideabi-gcc -o conftest    -I. -I. -I./libarchive  conftest.c -lz  >&5
In file included from conftest.c:206:0:
./libarchive/archive_crypto_private.h:91:17: fatal error: md5.h: No such file or directory
 #include <md5.h>
                 ^
compilation terminated.
configure:18844: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| #define ARCHIVE_MD5_COMPILE_TEST
| #define ARCHIVE_CRYPTO_MD5_LIBMD
| #define PLATFORM_CONFIG_H "check_crypto_md.h"
| 
| /*-
| * Copyright (c) 2003-2007 Tim Kientzle
| * Copyright (c) 2011 Andres Mejia
| * Copyright (c) 2011 Michihiro NAKAJIMA
| * All rights reserved.
| *
| * Redistribution and use in source and binary forms, with or without
| * modification, are permitted provided that the following conditions
| * are met:
| * 1. Redistributions of source code must retain the above copyright
| *    notice, this list of conditions and the following disclaimer.
| * 2. Redistributions in binary form must reproduce the above copyright
| *    notice, this list of conditions and the following disclaimer in the
| *    documentation and/or other materials provided with the distribution.
| *
| * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
| * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
| * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
| * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
| * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
| * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
| * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
| * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
| * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
| * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
| */
| 
| #include "archive_platform.h"
| 
| #include "archive.h"
| #include "archive_crypto_private.h"
| 
| /* In particular, force the configure probe to break if it tries
|  * to test a combination of OpenSSL and libmd. */
| #if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
| #error Cannot use both OpenSSL and libmd.
| #endif
| 
| /*
|  * Message digest functions for Windows platform.
|  */
| #if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
| 	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
| 	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| /*
|  * Initialize a Message digest.
|  */
| static int
| win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
| {
| 
| 	ctx->valid = 0;
| 	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
| 		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
| 			return (ARCHIVE_FAILED);
| 		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
| 			return (ARCHIVE_FAILED);
| 	}
| 
| 	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
| 		CryptReleaseContext(ctx->cryptProv, 0);
| 		return (ARCHIVE_FAILED);
| 	}
| 
| 	ctx->valid = 1;
| 	return (ARCHIVE_OK);
| }
| 
| /*
|  * Update a Message digest.
|  */
| static int
| win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
| {
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptHashData(ctx->hash,
| 		      (unsigned char *)(uintptr_t)buf,
| 		      (DWORD)len, 0);
| 	return (ARCHIVE_OK);
| }
| 
| static int
| win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
| {
| 	DWORD siglen = (DWORD)bufsize;
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
| 	CryptDestroyHash(ctx->hash);
| 	CryptReleaseContext(ctx->cryptProv, 0);
| 	ctx->valid = 0;
| 	return (ARCHIVE_OK);
| }
| 
| #endif /* defined(ARCHIVE_CRYPTO_*_WIN) */
| 
| 
| /* MD5 implementations */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
| 
| static int
| __archive_libc_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
| 
| static int
| __archive_libmd_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
| 
| static int
| __archive_libsystem_md5init(archive_md5_ctx *ctx)
| {
|   CC_MD5_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_MD5_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
| {
|   CC_MD5_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
| 
| static int
| __archive_nettle_md5init(archive_md5_ctx *ctx)
| {
|   md5_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   md5_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
| {
|   md5_digest(ctx, MD5_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
| 
| static int
| __archive_openssl_md5init(archive_md5_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_md5());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
| 
| static int
| __archive_windowsapi_md5init(archive_md5_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_MD5));
| }
| 
| static int
| __archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 16, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_md5init(archive_md5_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5final(archive_md5_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* RIPEMD160 implementations */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
| 
| static int
| __archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RMD160Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RMD160Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RMD160Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
| 
| static int
| __archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RIPEMD160_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RIPEMD160_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RIPEMD160_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
| 
| static int
| __archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   ripemd160_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   ripemd160_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
| 
| static int
| __archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_ripemd160());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #else
| 
| static int
| __archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA1 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
| 
| static int
| __archive_libc_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
| 
| static int
| __archive_libmd_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha1init(archive_sha1_ctx *ctx)
| {
|   CC_SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   CC_SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
| 
| static int
| __archive_nettle_sha1init(archive_sha1_ctx *ctx)
| {
|   sha1_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha1_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
| 
| static int
| __archive_openssl_sha1init(archive_sha1_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha1());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
| 
| static int
| __archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA1));
| }
| 
| static int
| __archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 20, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha1init(archive_sha1_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA256 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
| 
| static int
| __archive_libc_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
| 
| static int
| __archive_libc2_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
| 
| static int
| __archive_libc3_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
| 
| static int
| __archive_libmd_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha256init(archive_sha256_ctx *ctx)
| {
|   CC_SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   CC_SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
| 
| static int
| __archive_nettle_sha256init(archive_sha256_ctx *ctx)
| {
|   sha256_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha256_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
| 
| static int
| __archive_openssl_sha256init(archive_sha256_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha256());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
| 
| static int
| __archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_256));
| }
| 
| static int
| __archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 32, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha256init(archive_sha256_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA384 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
| 
| static int
| __archive_libc_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
| 
| static int
| __archive_libc2_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
| 
| static int
| __archive_libc3_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha384init(archive_sha384_ctx *ctx)
| {
|   CC_SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   CC_SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
| 
| static int
| __archive_nettle_sha384init(archive_sha384_ctx *ctx)
| {
|   sha384_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha384_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
| 
| static int
| __archive_openssl_sha384init(archive_sha384_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha384());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
| 
| static int
| __archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_384));
| }
| 
| static int
| __archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 48, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha384init(archive_sha384_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA512 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
| 
| static int
| __archive_libc_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
| 
| static int
| __archive_libc2_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
| 
| static int
| __archive_libc3_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
| 
| static int
| __archive_libmd_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha512init(archive_sha512_ctx *ctx)
| {
|   CC_SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   CC_SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
| 
| static int
| __archive_nettle_sha512init(archive_sha512_ctx *ctx)
| {
|   sha512_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha512_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
| 
| static int
| __archive_openssl_sha512init(archive_sha512_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha512());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| static int
| __archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_512));
| }
| 
| static int
| __archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 64, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha512init(archive_sha512_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* NOTE: Crypto functions are set based on availability and by the following
|  * order of preference.
|  * 1. libc
|  * 2. libc2
|  * 3. libc3
|  * 4. libSystem
|  * 5. Nettle
|  * 6. OpenSSL
|  * 7. libmd
|  * 8. Windows API
|  */
| const struct archive_crypto __archive_crypto =
| {
| /* MD5 */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
|   &__archive_libc_md5init,
|   &__archive_libc_md5update,
|   &__archive_libc_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
|   &__archive_libmd_md5init,
|   &__archive_libmd_md5update,
|   &__archive_libmd_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
|   &__archive_libsystem_md5init,
|   &__archive_libsystem_md5update,
|   &__archive_libsystem_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
|   &__archive_nettle_md5init,
|   &__archive_nettle_md5update,
|   &__archive_nettle_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
|   &__archive_openssl_md5init,
|   &__archive_openssl_md5update,
|   &__archive_openssl_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
|   &__archive_windowsapi_md5init,
|   &__archive_windowsapi_md5update,
|   &__archive_windowsapi_md5final,
| #elif !defined(ARCHIVE_MD5_COMPILE_TEST)
|   &__archive_stub_md5init,
|   &__archive_stub_md5update,
|   &__archive_stub_md5final,
| #endif
| 
| /* RIPEMD160 */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
|   &__archive_libc_ripemd160init,
|   &__archive_libc_ripemd160update,
|   &__archive_libc_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
|   &__archive_libmd_ripemd160init,
|   &__archive_libmd_ripemd160update,
|   &__archive_libmd_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
|   &__archive_nettle_ripemd160init,
|   &__archive_nettle_ripemd160update,
|   &__archive_nettle_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
|   &__archive_openssl_ripemd160init,
|   &__archive_openssl_ripemd160update,
|   &__archive_openssl_ripemd160final,
| #elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
|   &__archive_stub_ripemd160init,
|   &__archive_stub_ripemd160update,
|   &__archive_stub_ripemd160final,
| #endif
| 
| /* SHA1 */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
|   &__archive_libc_sha1init,
|   &__archive_libc_sha1update,
|   &__archive_libc_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
|   &__archive_libmd_sha1init,
|   &__archive_libmd_sha1update,
|   &__archive_libmd_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
|   &__archive_libsystem_sha1init,
|   &__archive_libsystem_sha1update,
|   &__archive_libsystem_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
|   &__archive_nettle_sha1init,
|   &__archive_nettle_sha1update,
|   &__archive_nettle_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
|   &__archive_openssl_sha1init,
|   &__archive_openssl_sha1update,
|   &__archive_openssl_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
|   &__archive_windowsapi_sha1init,
|   &__archive_windowsapi_sha1update,
|   &__archive_windowsapi_sha1final,
| #elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
|   &__archive_stub_sha1init,
|   &__archive_stub_sha1update,
|   &__archive_stub_sha1final,
| #endif
| 
| /* SHA256 */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
|   &__archive_libc_sha256init,
|   &__archive_libc_sha256update,
|   &__archive_libc_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
|   &__archive_libc2_sha256init,
|   &__archive_libc2_sha256update,
|   &__archive_libc2_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
|   &__archive_libc3_sha256init,
|   &__archive_libc3_sha256update,
|   &__archive_libc3_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
|   &__archive_libmd_sha256init,
|   &__archive_libmd_sha256update,
|   &__archive_libmd_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
|   &__archive_libsystem_sha256init,
|   &__archive_libsystem_sha256update,
|   &__archive_libsystem_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
|   &__archive_nettle_sha256init,
|   &__archive_nettle_sha256update,
|   &__archive_nettle_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
|   &__archive_openssl_sha256init,
|   &__archive_openssl_sha256update,
|   &__archive_openssl_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
|   &__archive_windowsapi_sha256init,
|   &__archive_windowsapi_sha256update,
|   &__archive_windowsapi_sha256final,
| #elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
|   &__archive_stub_sha256init,
|   &__archive_stub_sha256update,
|   &__archive_stub_sha256final,
| #endif
| 
| /* SHA384 */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
|   &__archive_libc_sha384init,
|   &__archive_libc_sha384update,
|   &__archive_libc_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
|   &__archive_libc2_sha384init,
|   &__archive_libc2_sha384update,
|   &__archive_libc2_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
|   &__archive_libc3_sha384init,
|   &__archive_libc3_sha384update,
|   &__archive_libc3_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
|   &__archive_libsystem_sha384init,
|   &__archive_libsystem_sha384update,
|   &__archive_libsystem_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
|   &__archive_nettle_sha384init,
|   &__archive_nettle_sha384update,
|   &__archive_nettle_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
|   &__archive_openssl_sha384init,
|   &__archive_openssl_sha384update,
|   &__archive_openssl_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
|   &__archive_windowsapi_sha384init,
|   &__archive_windowsapi_sha384update,
|   &__archive_windowsapi_sha384final,
| #elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
|   &__archive_stub_sha384init,
|   &__archive_stub_sha384update,
|   &__archive_stub_sha384final,
| #endif
| 
| /* SHA512 */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
|   &__archive_libc_sha512init,
|   &__archive_libc_sha512update,
|   &__archive_libc_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
|   &__archive_libc2_sha512init,
|   &__archive_libc2_sha512update,
|   &__archive_libc2_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
|   &__archive_libc3_sha512init,
|   &__archive_libc3_sha512update,
|   &__archive_libc3_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
|   &__archive_libmd_sha512init,
|   &__archive_libmd_sha512update,
|   &__archive_libmd_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
|   &__archive_libsystem_sha512init,
|   &__archive_libsystem_sha512update,
|   &__archive_libsystem_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
|   &__archive_nettle_sha512init,
|   &__archive_nettle_sha512update,
|   &__archive_nettle_sha512final,
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
|   &__archive_openssl_sha512init,
|   &__archive_openssl_sha512update,
|   &__archive_openssl_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
|   &__archive_windowsapi_sha512init,
|   &__archive_windowsapi_sha512update,
|   &__archive_windowsapi_sha512final
| #elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
|   &__archive_stub_sha512init,
|   &__archive_stub_sha512update,
|   &__archive_stub_sha512final
| #endif
| };
| 
| int
| main(int argc, char **argv)
| {
|   archive_md5_ctx ctx;
|   archive_md5_init(&ctx);
|   archive_md5_update(&ctx, *argv, argc);
|   archive_md5_final(&ctx, NULL);
|   return 0;
| }
| 
configure:18854: result: no
configure:18868: checking support for ARCHIVE_CRYPTO_RMD160_LIBMD
configure:18890: arm-linux-androideabi-gcc -o conftest    -I. -I. -I./libarchive  conftest.c -lz  >&5
In file included from conftest.c:206:0:
./libarchive/archive_crypto_private.h:94:20: fatal error: ripemd.h: No such file or directory
 #include <ripemd.h>
                    ^
compilation terminated.
configure:18890: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| #define ARCHIVE_RMD160_COMPILE_TEST
| #define ARCHIVE_CRYPTO_RMD160_LIBMD
| #define PLATFORM_CONFIG_H "check_crypto_md.h"
| 
| /*-
| * Copyright (c) 2003-2007 Tim Kientzle
| * Copyright (c) 2011 Andres Mejia
| * Copyright (c) 2011 Michihiro NAKAJIMA
| * All rights reserved.
| *
| * Redistribution and use in source and binary forms, with or without
| * modification, are permitted provided that the following conditions
| * are met:
| * 1. Redistributions of source code must retain the above copyright
| *    notice, this list of conditions and the following disclaimer.
| * 2. Redistributions in binary form must reproduce the above copyright
| *    notice, this list of conditions and the following disclaimer in the
| *    documentation and/or other materials provided with the distribution.
| *
| * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
| * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
| * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
| * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
| * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
| * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
| * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
| * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
| * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
| * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
| */
| 
| #include "archive_platform.h"
| 
| #include "archive.h"
| #include "archive_crypto_private.h"
| 
| /* In particular, force the configure probe to break if it tries
|  * to test a combination of OpenSSL and libmd. */
| #if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
| #error Cannot use both OpenSSL and libmd.
| #endif
| 
| /*
|  * Message digest functions for Windows platform.
|  */
| #if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
| 	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
| 	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| /*
|  * Initialize a Message digest.
|  */
| static int
| win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
| {
| 
| 	ctx->valid = 0;
| 	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
| 		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
| 			return (ARCHIVE_FAILED);
| 		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
| 			return (ARCHIVE_FAILED);
| 	}
| 
| 	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
| 		CryptReleaseContext(ctx->cryptProv, 0);
| 		return (ARCHIVE_FAILED);
| 	}
| 
| 	ctx->valid = 1;
| 	return (ARCHIVE_OK);
| }
| 
| /*
|  * Update a Message digest.
|  */
| static int
| win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
| {
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptHashData(ctx->hash,
| 		      (unsigned char *)(uintptr_t)buf,
| 		      (DWORD)len, 0);
| 	return (ARCHIVE_OK);
| }
| 
| static int
| win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
| {
| 	DWORD siglen = (DWORD)bufsize;
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
| 	CryptDestroyHash(ctx->hash);
| 	CryptReleaseContext(ctx->cryptProv, 0);
| 	ctx->valid = 0;
| 	return (ARCHIVE_OK);
| }
| 
| #endif /* defined(ARCHIVE_CRYPTO_*_WIN) */
| 
| 
| /* MD5 implementations */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
| 
| static int
| __archive_libc_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
| 
| static int
| __archive_libmd_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
| 
| static int
| __archive_libsystem_md5init(archive_md5_ctx *ctx)
| {
|   CC_MD5_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_MD5_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
| {
|   CC_MD5_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
| 
| static int
| __archive_nettle_md5init(archive_md5_ctx *ctx)
| {
|   md5_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   md5_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
| {
|   md5_digest(ctx, MD5_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
| 
| static int
| __archive_openssl_md5init(archive_md5_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_md5());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
| 
| static int
| __archive_windowsapi_md5init(archive_md5_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_MD5));
| }
| 
| static int
| __archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 16, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_md5init(archive_md5_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5final(archive_md5_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* RIPEMD160 implementations */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
| 
| static int
| __archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RMD160Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RMD160Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RMD160Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
| 
| static int
| __archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RIPEMD160_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RIPEMD160_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RIPEMD160_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
| 
| static int
| __archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   ripemd160_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   ripemd160_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
| 
| static int
| __archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_ripemd160());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #else
| 
| static int
| __archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA1 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
| 
| static int
| __archive_libc_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
| 
| static int
| __archive_libmd_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha1init(archive_sha1_ctx *ctx)
| {
|   CC_SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   CC_SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
| 
| static int
| __archive_nettle_sha1init(archive_sha1_ctx *ctx)
| {
|   sha1_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha1_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
| 
| static int
| __archive_openssl_sha1init(archive_sha1_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha1());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
| 
| static int
| __archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA1));
| }
| 
| static int
| __archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 20, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha1init(archive_sha1_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA256 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
| 
| static int
| __archive_libc_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
| 
| static int
| __archive_libc2_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
| 
| static int
| __archive_libc3_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
| 
| static int
| __archive_libmd_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha256init(archive_sha256_ctx *ctx)
| {
|   CC_SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   CC_SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
| 
| static int
| __archive_nettle_sha256init(archive_sha256_ctx *ctx)
| {
|   sha256_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha256_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
| 
| static int
| __archive_openssl_sha256init(archive_sha256_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha256());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
| 
| static int
| __archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_256));
| }
| 
| static int
| __archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 32, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha256init(archive_sha256_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA384 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
| 
| static int
| __archive_libc_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
| 
| static int
| __archive_libc2_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
| 
| static int
| __archive_libc3_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha384init(archive_sha384_ctx *ctx)
| {
|   CC_SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   CC_SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
| 
| static int
| __archive_nettle_sha384init(archive_sha384_ctx *ctx)
| {
|   sha384_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha384_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
| 
| static int
| __archive_openssl_sha384init(archive_sha384_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha384());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
| 
| static int
| __archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_384));
| }
| 
| static int
| __archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 48, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha384init(archive_sha384_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA512 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
| 
| static int
| __archive_libc_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
| 
| static int
| __archive_libc2_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
| 
| static int
| __archive_libc3_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
| 
| static int
| __archive_libmd_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha512init(archive_sha512_ctx *ctx)
| {
|   CC_SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   CC_SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
| 
| static int
| __archive_nettle_sha512init(archive_sha512_ctx *ctx)
| {
|   sha512_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha512_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
| 
| static int
| __archive_openssl_sha512init(archive_sha512_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha512());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| static int
| __archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_512));
| }
| 
| static int
| __archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 64, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha512init(archive_sha512_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* NOTE: Crypto functions are set based on availability and by the following
|  * order of preference.
|  * 1. libc
|  * 2. libc2
|  * 3. libc3
|  * 4. libSystem
|  * 5. Nettle
|  * 6. OpenSSL
|  * 7. libmd
|  * 8. Windows API
|  */
| const struct archive_crypto __archive_crypto =
| {
| /* MD5 */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
|   &__archive_libc_md5init,
|   &__archive_libc_md5update,
|   &__archive_libc_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
|   &__archive_libmd_md5init,
|   &__archive_libmd_md5update,
|   &__archive_libmd_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
|   &__archive_libsystem_md5init,
|   &__archive_libsystem_md5update,
|   &__archive_libsystem_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
|   &__archive_nettle_md5init,
|   &__archive_nettle_md5update,
|   &__archive_nettle_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
|   &__archive_openssl_md5init,
|   &__archive_openssl_md5update,
|   &__archive_openssl_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
|   &__archive_windowsapi_md5init,
|   &__archive_windowsapi_md5update,
|   &__archive_windowsapi_md5final,
| #elif !defined(ARCHIVE_MD5_COMPILE_TEST)
|   &__archive_stub_md5init,
|   &__archive_stub_md5update,
|   &__archive_stub_md5final,
| #endif
| 
| /* RIPEMD160 */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
|   &__archive_libc_ripemd160init,
|   &__archive_libc_ripemd160update,
|   &__archive_libc_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
|   &__archive_libmd_ripemd160init,
|   &__archive_libmd_ripemd160update,
|   &__archive_libmd_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
|   &__archive_nettle_ripemd160init,
|   &__archive_nettle_ripemd160update,
|   &__archive_nettle_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
|   &__archive_openssl_ripemd160init,
|   &__archive_openssl_ripemd160update,
|   &__archive_openssl_ripemd160final,
| #elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
|   &__archive_stub_ripemd160init,
|   &__archive_stub_ripemd160update,
|   &__archive_stub_ripemd160final,
| #endif
| 
| /* SHA1 */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
|   &__archive_libc_sha1init,
|   &__archive_libc_sha1update,
|   &__archive_libc_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
|   &__archive_libmd_sha1init,
|   &__archive_libmd_sha1update,
|   &__archive_libmd_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
|   &__archive_libsystem_sha1init,
|   &__archive_libsystem_sha1update,
|   &__archive_libsystem_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
|   &__archive_nettle_sha1init,
|   &__archive_nettle_sha1update,
|   &__archive_nettle_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
|   &__archive_openssl_sha1init,
|   &__archive_openssl_sha1update,
|   &__archive_openssl_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
|   &__archive_windowsapi_sha1init,
|   &__archive_windowsapi_sha1update,
|   &__archive_windowsapi_sha1final,
| #elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
|   &__archive_stub_sha1init,
|   &__archive_stub_sha1update,
|   &__archive_stub_sha1final,
| #endif
| 
| /* SHA256 */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
|   &__archive_libc_sha256init,
|   &__archive_libc_sha256update,
|   &__archive_libc_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
|   &__archive_libc2_sha256init,
|   &__archive_libc2_sha256update,
|   &__archive_libc2_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
|   &__archive_libc3_sha256init,
|   &__archive_libc3_sha256update,
|   &__archive_libc3_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
|   &__archive_libmd_sha256init,
|   &__archive_libmd_sha256update,
|   &__archive_libmd_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
|   &__archive_libsystem_sha256init,
|   &__archive_libsystem_sha256update,
|   &__archive_libsystem_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
|   &__archive_nettle_sha256init,
|   &__archive_nettle_sha256update,
|   &__archive_nettle_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
|   &__archive_openssl_sha256init,
|   &__archive_openssl_sha256update,
|   &__archive_openssl_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
|   &__archive_windowsapi_sha256init,
|   &__archive_windowsapi_sha256update,
|   &__archive_windowsapi_sha256final,
| #elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
|   &__archive_stub_sha256init,
|   &__archive_stub_sha256update,
|   &__archive_stub_sha256final,
| #endif
| 
| /* SHA384 */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
|   &__archive_libc_sha384init,
|   &__archive_libc_sha384update,
|   &__archive_libc_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
|   &__archive_libc2_sha384init,
|   &__archive_libc2_sha384update,
|   &__archive_libc2_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
|   &__archive_libc3_sha384init,
|   &__archive_libc3_sha384update,
|   &__archive_libc3_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
|   &__archive_libsystem_sha384init,
|   &__archive_libsystem_sha384update,
|   &__archive_libsystem_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
|   &__archive_nettle_sha384init,
|   &__archive_nettle_sha384update,
|   &__archive_nettle_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
|   &__archive_openssl_sha384init,
|   &__archive_openssl_sha384update,
|   &__archive_openssl_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
|   &__archive_windowsapi_sha384init,
|   &__archive_windowsapi_sha384update,
|   &__archive_windowsapi_sha384final,
| #elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
|   &__archive_stub_sha384init,
|   &__archive_stub_sha384update,
|   &__archive_stub_sha384final,
| #endif
| 
| /* SHA512 */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
|   &__archive_libc_sha512init,
|   &__archive_libc_sha512update,
|   &__archive_libc_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
|   &__archive_libc2_sha512init,
|   &__archive_libc2_sha512update,
|   &__archive_libc2_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
|   &__archive_libc3_sha512init,
|   &__archive_libc3_sha512update,
|   &__archive_libc3_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
|   &__archive_libmd_sha512init,
|   &__archive_libmd_sha512update,
|   &__archive_libmd_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
|   &__archive_libsystem_sha512init,
|   &__archive_libsystem_sha512update,
|   &__archive_libsystem_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
|   &__archive_nettle_sha512init,
|   &__archive_nettle_sha512update,
|   &__archive_nettle_sha512final,
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
|   &__archive_openssl_sha512init,
|   &__archive_openssl_sha512update,
|   &__archive_openssl_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
|   &__archive_windowsapi_sha512init,
|   &__archive_windowsapi_sha512update,
|   &__archive_windowsapi_sha512final
| #elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
|   &__archive_stub_sha512init,
|   &__archive_stub_sha512update,
|   &__archive_stub_sha512final
| #endif
| };
| 
| int
| main(int argc, char **argv)
| {
|   archive_rmd160_ctx ctx;
|   archive_rmd160_init(&ctx);
|   archive_rmd160_update(&ctx, *argv, argc);
|   archive_rmd160_final(&ctx, NULL);
|   return 0;
| }
| 
configure:18900: result: no
configure:18914: checking support for ARCHIVE_CRYPTO_SHA1_LIBMD
configure:18936: arm-linux-androideabi-gcc -o conftest    -I. -I. -I./libarchive  conftest.c -lz  >&5
In file included from conftest.c:206:0:
./libarchive/archive_crypto_private.h:97:17: fatal error: sha.h: No such file or directory
 #include <sha.h>
                 ^
compilation terminated.
configure:18936: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| #define ARCHIVE_SHA1_COMPILE_TEST
| #define ARCHIVE_CRYPTO_SHA1_LIBMD
| #define PLATFORM_CONFIG_H "check_crypto_md.h"
| 
| /*-
| * Copyright (c) 2003-2007 Tim Kientzle
| * Copyright (c) 2011 Andres Mejia
| * Copyright (c) 2011 Michihiro NAKAJIMA
| * All rights reserved.
| *
| * Redistribution and use in source and binary forms, with or without
| * modification, are permitted provided that the following conditions
| * are met:
| * 1. Redistributions of source code must retain the above copyright
| *    notice, this list of conditions and the following disclaimer.
| * 2. Redistributions in binary form must reproduce the above copyright
| *    notice, this list of conditions and the following disclaimer in the
| *    documentation and/or other materials provided with the distribution.
| *
| * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
| * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
| * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
| * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
| * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
| * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
| * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
| * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
| * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
| * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
| */
| 
| #include "archive_platform.h"
| 
| #include "archive.h"
| #include "archive_crypto_private.h"
| 
| /* In particular, force the configure probe to break if it tries
|  * to test a combination of OpenSSL and libmd. */
| #if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
| #error Cannot use both OpenSSL and libmd.
| #endif
| 
| /*
|  * Message digest functions for Windows platform.
|  */
| #if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
| 	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
| 	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| /*
|  * Initialize a Message digest.
|  */
| static int
| win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
| {
| 
| 	ctx->valid = 0;
| 	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
| 		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
| 			return (ARCHIVE_FAILED);
| 		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
| 			return (ARCHIVE_FAILED);
| 	}
| 
| 	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
| 		CryptReleaseContext(ctx->cryptProv, 0);
| 		return (ARCHIVE_FAILED);
| 	}
| 
| 	ctx->valid = 1;
| 	return (ARCHIVE_OK);
| }
| 
| /*
|  * Update a Message digest.
|  */
| static int
| win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
| {
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptHashData(ctx->hash,
| 		      (unsigned char *)(uintptr_t)buf,
| 		      (DWORD)len, 0);
| 	return (ARCHIVE_OK);
| }
| 
| static int
| win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
| {
| 	DWORD siglen = (DWORD)bufsize;
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
| 	CryptDestroyHash(ctx->hash);
| 	CryptReleaseContext(ctx->cryptProv, 0);
| 	ctx->valid = 0;
| 	return (ARCHIVE_OK);
| }
| 
| #endif /* defined(ARCHIVE_CRYPTO_*_WIN) */
| 
| 
| /* MD5 implementations */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
| 
| static int
| __archive_libc_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
| 
| static int
| __archive_libmd_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
| 
| static int
| __archive_libsystem_md5init(archive_md5_ctx *ctx)
| {
|   CC_MD5_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_MD5_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
| {
|   CC_MD5_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
| 
| static int
| __archive_nettle_md5init(archive_md5_ctx *ctx)
| {
|   md5_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   md5_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
| {
|   md5_digest(ctx, MD5_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
| 
| static int
| __archive_openssl_md5init(archive_md5_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_md5());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
| 
| static int
| __archive_windowsapi_md5init(archive_md5_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_MD5));
| }
| 
| static int
| __archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 16, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_md5init(archive_md5_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5final(archive_md5_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* RIPEMD160 implementations */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
| 
| static int
| __archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RMD160Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RMD160Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RMD160Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
| 
| static int
| __archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RIPEMD160_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RIPEMD160_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RIPEMD160_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
| 
| static int
| __archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   ripemd160_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   ripemd160_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
| 
| static int
| __archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_ripemd160());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #else
| 
| static int
| __archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA1 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
| 
| static int
| __archive_libc_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
| 
| static int
| __archive_libmd_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha1init(archive_sha1_ctx *ctx)
| {
|   CC_SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   CC_SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
| 
| static int
| __archive_nettle_sha1init(archive_sha1_ctx *ctx)
| {
|   sha1_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha1_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
| 
| static int
| __archive_openssl_sha1init(archive_sha1_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha1());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
| 
| static int
| __archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA1));
| }
| 
| static int
| __archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 20, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha1init(archive_sha1_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA256 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
| 
| static int
| __archive_libc_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
| 
| static int
| __archive_libc2_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
| 
| static int
| __archive_libc3_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
| 
| static int
| __archive_libmd_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha256init(archive_sha256_ctx *ctx)
| {
|   CC_SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   CC_SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
| 
| static int
| __archive_nettle_sha256init(archive_sha256_ctx *ctx)
| {
|   sha256_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha256_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
| 
| static int
| __archive_openssl_sha256init(archive_sha256_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha256());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
| 
| static int
| __archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_256));
| }
| 
| static int
| __archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 32, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha256init(archive_sha256_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA384 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
| 
| static int
| __archive_libc_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
| 
| static int
| __archive_libc2_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
| 
| static int
| __archive_libc3_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha384init(archive_sha384_ctx *ctx)
| {
|   CC_SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   CC_SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
| 
| static int
| __archive_nettle_sha384init(archive_sha384_ctx *ctx)
| {
|   sha384_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha384_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
| 
| static int
| __archive_openssl_sha384init(archive_sha384_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha384());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
| 
| static int
| __archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_384));
| }
| 
| static int
| __archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 48, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha384init(archive_sha384_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA512 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
| 
| static int
| __archive_libc_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
| 
| static int
| __archive_libc2_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
| 
| static int
| __archive_libc3_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
| 
| static int
| __archive_libmd_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha512init(archive_sha512_ctx *ctx)
| {
|   CC_SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   CC_SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
| 
| static int
| __archive_nettle_sha512init(archive_sha512_ctx *ctx)
| {
|   sha512_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha512_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
| 
| static int
| __archive_openssl_sha512init(archive_sha512_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha512());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| static int
| __archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_512));
| }
| 
| static int
| __archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 64, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha512init(archive_sha512_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* NOTE: Crypto functions are set based on availability and by the following
|  * order of preference.
|  * 1. libc
|  * 2. libc2
|  * 3. libc3
|  * 4. libSystem
|  * 5. Nettle
|  * 6. OpenSSL
|  * 7. libmd
|  * 8. Windows API
|  */
| const struct archive_crypto __archive_crypto =
| {
| /* MD5 */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
|   &__archive_libc_md5init,
|   &__archive_libc_md5update,
|   &__archive_libc_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
|   &__archive_libmd_md5init,
|   &__archive_libmd_md5update,
|   &__archive_libmd_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
|   &__archive_libsystem_md5init,
|   &__archive_libsystem_md5update,
|   &__archive_libsystem_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
|   &__archive_nettle_md5init,
|   &__archive_nettle_md5update,
|   &__archive_nettle_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
|   &__archive_openssl_md5init,
|   &__archive_openssl_md5update,
|   &__archive_openssl_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
|   &__archive_windowsapi_md5init,
|   &__archive_windowsapi_md5update,
|   &__archive_windowsapi_md5final,
| #elif !defined(ARCHIVE_MD5_COMPILE_TEST)
|   &__archive_stub_md5init,
|   &__archive_stub_md5update,
|   &__archive_stub_md5final,
| #endif
| 
| /* RIPEMD160 */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
|   &__archive_libc_ripemd160init,
|   &__archive_libc_ripemd160update,
|   &__archive_libc_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
|   &__archive_libmd_ripemd160init,
|   &__archive_libmd_ripemd160update,
|   &__archive_libmd_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
|   &__archive_nettle_ripemd160init,
|   &__archive_nettle_ripemd160update,
|   &__archive_nettle_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
|   &__archive_openssl_ripemd160init,
|   &__archive_openssl_ripemd160update,
|   &__archive_openssl_ripemd160final,
| #elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
|   &__archive_stub_ripemd160init,
|   &__archive_stub_ripemd160update,
|   &__archive_stub_ripemd160final,
| #endif
| 
| /* SHA1 */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
|   &__archive_libc_sha1init,
|   &__archive_libc_sha1update,
|   &__archive_libc_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
|   &__archive_libmd_sha1init,
|   &__archive_libmd_sha1update,
|   &__archive_libmd_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
|   &__archive_libsystem_sha1init,
|   &__archive_libsystem_sha1update,
|   &__archive_libsystem_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
|   &__archive_nettle_sha1init,
|   &__archive_nettle_sha1update,
|   &__archive_nettle_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
|   &__archive_openssl_sha1init,
|   &__archive_openssl_sha1update,
|   &__archive_openssl_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
|   &__archive_windowsapi_sha1init,
|   &__archive_windowsapi_sha1update,
|   &__archive_windowsapi_sha1final,
| #elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
|   &__archive_stub_sha1init,
|   &__archive_stub_sha1update,
|   &__archive_stub_sha1final,
| #endif
| 
| /* SHA256 */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
|   &__archive_libc_sha256init,
|   &__archive_libc_sha256update,
|   &__archive_libc_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
|   &__archive_libc2_sha256init,
|   &__archive_libc2_sha256update,
|   &__archive_libc2_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
|   &__archive_libc3_sha256init,
|   &__archive_libc3_sha256update,
|   &__archive_libc3_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
|   &__archive_libmd_sha256init,
|   &__archive_libmd_sha256update,
|   &__archive_libmd_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
|   &__archive_libsystem_sha256init,
|   &__archive_libsystem_sha256update,
|   &__archive_libsystem_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
|   &__archive_nettle_sha256init,
|   &__archive_nettle_sha256update,
|   &__archive_nettle_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
|   &__archive_openssl_sha256init,
|   &__archive_openssl_sha256update,
|   &__archive_openssl_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
|   &__archive_windowsapi_sha256init,
|   &__archive_windowsapi_sha256update,
|   &__archive_windowsapi_sha256final,
| #elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
|   &__archive_stub_sha256init,
|   &__archive_stub_sha256update,
|   &__archive_stub_sha256final,
| #endif
| 
| /* SHA384 */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
|   &__archive_libc_sha384init,
|   &__archive_libc_sha384update,
|   &__archive_libc_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
|   &__archive_libc2_sha384init,
|   &__archive_libc2_sha384update,
|   &__archive_libc2_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
|   &__archive_libc3_sha384init,
|   &__archive_libc3_sha384update,
|   &__archive_libc3_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
|   &__archive_libsystem_sha384init,
|   &__archive_libsystem_sha384update,
|   &__archive_libsystem_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
|   &__archive_nettle_sha384init,
|   &__archive_nettle_sha384update,
|   &__archive_nettle_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
|   &__archive_openssl_sha384init,
|   &__archive_openssl_sha384update,
|   &__archive_openssl_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
|   &__archive_windowsapi_sha384init,
|   &__archive_windowsapi_sha384update,
|   &__archive_windowsapi_sha384final,
| #elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
|   &__archive_stub_sha384init,
|   &__archive_stub_sha384update,
|   &__archive_stub_sha384final,
| #endif
| 
| /* SHA512 */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
|   &__archive_libc_sha512init,
|   &__archive_libc_sha512update,
|   &__archive_libc_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
|   &__archive_libc2_sha512init,
|   &__archive_libc2_sha512update,
|   &__archive_libc2_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
|   &__archive_libc3_sha512init,
|   &__archive_libc3_sha512update,
|   &__archive_libc3_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
|   &__archive_libmd_sha512init,
|   &__archive_libmd_sha512update,
|   &__archive_libmd_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
|   &__archive_libsystem_sha512init,
|   &__archive_libsystem_sha512update,
|   &__archive_libsystem_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
|   &__archive_nettle_sha512init,
|   &__archive_nettle_sha512update,
|   &__archive_nettle_sha512final,
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
|   &__archive_openssl_sha512init,
|   &__archive_openssl_sha512update,
|   &__archive_openssl_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
|   &__archive_windowsapi_sha512init,
|   &__archive_windowsapi_sha512update,
|   &__archive_windowsapi_sha512final
| #elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
|   &__archive_stub_sha512init,
|   &__archive_stub_sha512update,
|   &__archive_stub_sha512final
| #endif
| };
| 
| int
| main(int argc, char **argv)
| {
|   archive_sha1_ctx ctx;
|   archive_sha1_init(&ctx);
|   archive_sha1_update(&ctx, *argv, argc);
|   archive_sha1_final(&ctx, NULL);
|   return 0;
| }
| 
configure:18946: result: no
configure:18960: checking support for ARCHIVE_CRYPTO_SHA256_LIBMD
configure:18982: arm-linux-androideabi-gcc -o conftest    -I. -I. -I./libarchive  conftest.c -lz  >&5
In file included from conftest.c:206:0:
./libarchive/archive_crypto_private.h:100:20: fatal error: sha256.h: No such file or directory
 #include <sha256.h>
                    ^
compilation terminated.
configure:18982: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| #define ARCHIVE_SHA256_COMPILE_TEST
| #define ARCHIVE_CRYPTO_SHA256_LIBMD
| #define PLATFORM_CONFIG_H "check_crypto_md.h"
| 
| /*-
| * Copyright (c) 2003-2007 Tim Kientzle
| * Copyright (c) 2011 Andres Mejia
| * Copyright (c) 2011 Michihiro NAKAJIMA
| * All rights reserved.
| *
| * Redistribution and use in source and binary forms, with or without
| * modification, are permitted provided that the following conditions
| * are met:
| * 1. Redistributions of source code must retain the above copyright
| *    notice, this list of conditions and the following disclaimer.
| * 2. Redistributions in binary form must reproduce the above copyright
| *    notice, this list of conditions and the following disclaimer in the
| *    documentation and/or other materials provided with the distribution.
| *
| * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
| * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
| * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
| * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
| * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
| * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
| * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
| * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
| * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
| * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
| */
| 
| #include "archive_platform.h"
| 
| #include "archive.h"
| #include "archive_crypto_private.h"
| 
| /* In particular, force the configure probe to break if it tries
|  * to test a combination of OpenSSL and libmd. */
| #if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
| #error Cannot use both OpenSSL and libmd.
| #endif
| 
| /*
|  * Message digest functions for Windows platform.
|  */
| #if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
| 	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
| 	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| /*
|  * Initialize a Message digest.
|  */
| static int
| win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
| {
| 
| 	ctx->valid = 0;
| 	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
| 		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
| 			return (ARCHIVE_FAILED);
| 		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
| 			return (ARCHIVE_FAILED);
| 	}
| 
| 	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
| 		CryptReleaseContext(ctx->cryptProv, 0);
| 		return (ARCHIVE_FAILED);
| 	}
| 
| 	ctx->valid = 1;
| 	return (ARCHIVE_OK);
| }
| 
| /*
|  * Update a Message digest.
|  */
| static int
| win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
| {
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptHashData(ctx->hash,
| 		      (unsigned char *)(uintptr_t)buf,
| 		      (DWORD)len, 0);
| 	return (ARCHIVE_OK);
| }
| 
| static int
| win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
| {
| 	DWORD siglen = (DWORD)bufsize;
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
| 	CryptDestroyHash(ctx->hash);
| 	CryptReleaseContext(ctx->cryptProv, 0);
| 	ctx->valid = 0;
| 	return (ARCHIVE_OK);
| }
| 
| #endif /* defined(ARCHIVE_CRYPTO_*_WIN) */
| 
| 
| /* MD5 implementations */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
| 
| static int
| __archive_libc_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
| 
| static int
| __archive_libmd_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
| 
| static int
| __archive_libsystem_md5init(archive_md5_ctx *ctx)
| {
|   CC_MD5_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_MD5_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
| {
|   CC_MD5_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
| 
| static int
| __archive_nettle_md5init(archive_md5_ctx *ctx)
| {
|   md5_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   md5_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
| {
|   md5_digest(ctx, MD5_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
| 
| static int
| __archive_openssl_md5init(archive_md5_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_md5());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
| 
| static int
| __archive_windowsapi_md5init(archive_md5_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_MD5));
| }
| 
| static int
| __archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 16, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_md5init(archive_md5_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5final(archive_md5_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* RIPEMD160 implementations */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
| 
| static int
| __archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RMD160Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RMD160Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RMD160Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
| 
| static int
| __archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RIPEMD160_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RIPEMD160_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RIPEMD160_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
| 
| static int
| __archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   ripemd160_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   ripemd160_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
| 
| static int
| __archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_ripemd160());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #else
| 
| static int
| __archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA1 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
| 
| static int
| __archive_libc_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
| 
| static int
| __archive_libmd_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha1init(archive_sha1_ctx *ctx)
| {
|   CC_SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   CC_SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
| 
| static int
| __archive_nettle_sha1init(archive_sha1_ctx *ctx)
| {
|   sha1_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha1_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
| 
| static int
| __archive_openssl_sha1init(archive_sha1_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha1());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
| 
| static int
| __archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA1));
| }
| 
| static int
| __archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 20, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha1init(archive_sha1_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA256 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
| 
| static int
| __archive_libc_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
| 
| static int
| __archive_libc2_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
| 
| static int
| __archive_libc3_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
| 
| static int
| __archive_libmd_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha256init(archive_sha256_ctx *ctx)
| {
|   CC_SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   CC_SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
| 
| static int
| __archive_nettle_sha256init(archive_sha256_ctx *ctx)
| {
|   sha256_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha256_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
| 
| static int
| __archive_openssl_sha256init(archive_sha256_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha256());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
| 
| static int
| __archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_256));
| }
| 
| static int
| __archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 32, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha256init(archive_sha256_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA384 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
| 
| static int
| __archive_libc_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
| 
| static int
| __archive_libc2_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
| 
| static int
| __archive_libc3_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha384init(archive_sha384_ctx *ctx)
| {
|   CC_SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   CC_SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
| 
| static int
| __archive_nettle_sha384init(archive_sha384_ctx *ctx)
| {
|   sha384_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha384_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
| 
| static int
| __archive_openssl_sha384init(archive_sha384_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha384());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
| 
| static int
| __archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_384));
| }
| 
| static int
| __archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 48, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha384init(archive_sha384_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA512 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
| 
| static int
| __archive_libc_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
| 
| static int
| __archive_libc2_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
| 
| static int
| __archive_libc3_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
| 
| static int
| __archive_libmd_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha512init(archive_sha512_ctx *ctx)
| {
|   CC_SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   CC_SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
| 
| static int
| __archive_nettle_sha512init(archive_sha512_ctx *ctx)
| {
|   sha512_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha512_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
| 
| static int
| __archive_openssl_sha512init(archive_sha512_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha512());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| static int
| __archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_512));
| }
| 
| static int
| __archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 64, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha512init(archive_sha512_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* NOTE: Crypto functions are set based on availability and by the following
|  * order of preference.
|  * 1. libc
|  * 2. libc2
|  * 3. libc3
|  * 4. libSystem
|  * 5. Nettle
|  * 6. OpenSSL
|  * 7. libmd
|  * 8. Windows API
|  */
| const struct archive_crypto __archive_crypto =
| {
| /* MD5 */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
|   &__archive_libc_md5init,
|   &__archive_libc_md5update,
|   &__archive_libc_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
|   &__archive_libmd_md5init,
|   &__archive_libmd_md5update,
|   &__archive_libmd_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
|   &__archive_libsystem_md5init,
|   &__archive_libsystem_md5update,
|   &__archive_libsystem_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
|   &__archive_nettle_md5init,
|   &__archive_nettle_md5update,
|   &__archive_nettle_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
|   &__archive_openssl_md5init,
|   &__archive_openssl_md5update,
|   &__archive_openssl_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
|   &__archive_windowsapi_md5init,
|   &__archive_windowsapi_md5update,
|   &__archive_windowsapi_md5final,
| #elif !defined(ARCHIVE_MD5_COMPILE_TEST)
|   &__archive_stub_md5init,
|   &__archive_stub_md5update,
|   &__archive_stub_md5final,
| #endif
| 
| /* RIPEMD160 */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
|   &__archive_libc_ripemd160init,
|   &__archive_libc_ripemd160update,
|   &__archive_libc_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
|   &__archive_libmd_ripemd160init,
|   &__archive_libmd_ripemd160update,
|   &__archive_libmd_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
|   &__archive_nettle_ripemd160init,
|   &__archive_nettle_ripemd160update,
|   &__archive_nettle_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
|   &__archive_openssl_ripemd160init,
|   &__archive_openssl_ripemd160update,
|   &__archive_openssl_ripemd160final,
| #elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
|   &__archive_stub_ripemd160init,
|   &__archive_stub_ripemd160update,
|   &__archive_stub_ripemd160final,
| #endif
| 
| /* SHA1 */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
|   &__archive_libc_sha1init,
|   &__archive_libc_sha1update,
|   &__archive_libc_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
|   &__archive_libmd_sha1init,
|   &__archive_libmd_sha1update,
|   &__archive_libmd_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
|   &__archive_libsystem_sha1init,
|   &__archive_libsystem_sha1update,
|   &__archive_libsystem_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
|   &__archive_nettle_sha1init,
|   &__archive_nettle_sha1update,
|   &__archive_nettle_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
|   &__archive_openssl_sha1init,
|   &__archive_openssl_sha1update,
|   &__archive_openssl_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
|   &__archive_windowsapi_sha1init,
|   &__archive_windowsapi_sha1update,
|   &__archive_windowsapi_sha1final,
| #elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
|   &__archive_stub_sha1init,
|   &__archive_stub_sha1update,
|   &__archive_stub_sha1final,
| #endif
| 
| /* SHA256 */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
|   &__archive_libc_sha256init,
|   &__archive_libc_sha256update,
|   &__archive_libc_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
|   &__archive_libc2_sha256init,
|   &__archive_libc2_sha256update,
|   &__archive_libc2_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
|   &__archive_libc3_sha256init,
|   &__archive_libc3_sha256update,
|   &__archive_libc3_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
|   &__archive_libmd_sha256init,
|   &__archive_libmd_sha256update,
|   &__archive_libmd_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
|   &__archive_libsystem_sha256init,
|   &__archive_libsystem_sha256update,
|   &__archive_libsystem_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
|   &__archive_nettle_sha256init,
|   &__archive_nettle_sha256update,
|   &__archive_nettle_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
|   &__archive_openssl_sha256init,
|   &__archive_openssl_sha256update,
|   &__archive_openssl_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
|   &__archive_windowsapi_sha256init,
|   &__archive_windowsapi_sha256update,
|   &__archive_windowsapi_sha256final,
| #elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
|   &__archive_stub_sha256init,
|   &__archive_stub_sha256update,
|   &__archive_stub_sha256final,
| #endif
| 
| /* SHA384 */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
|   &__archive_libc_sha384init,
|   &__archive_libc_sha384update,
|   &__archive_libc_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
|   &__archive_libc2_sha384init,
|   &__archive_libc2_sha384update,
|   &__archive_libc2_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
|   &__archive_libc3_sha384init,
|   &__archive_libc3_sha384update,
|   &__archive_libc3_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
|   &__archive_libsystem_sha384init,
|   &__archive_libsystem_sha384update,
|   &__archive_libsystem_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
|   &__archive_nettle_sha384init,
|   &__archive_nettle_sha384update,
|   &__archive_nettle_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
|   &__archive_openssl_sha384init,
|   &__archive_openssl_sha384update,
|   &__archive_openssl_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
|   &__archive_windowsapi_sha384init,
|   &__archive_windowsapi_sha384update,
|   &__archive_windowsapi_sha384final,
| #elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
|   &__archive_stub_sha384init,
|   &__archive_stub_sha384update,
|   &__archive_stub_sha384final,
| #endif
| 
| /* SHA512 */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
|   &__archive_libc_sha512init,
|   &__archive_libc_sha512update,
|   &__archive_libc_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
|   &__archive_libc2_sha512init,
|   &__archive_libc2_sha512update,
|   &__archive_libc2_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
|   &__archive_libc3_sha512init,
|   &__archive_libc3_sha512update,
|   &__archive_libc3_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
|   &__archive_libmd_sha512init,
|   &__archive_libmd_sha512update,
|   &__archive_libmd_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
|   &__archive_libsystem_sha512init,
|   &__archive_libsystem_sha512update,
|   &__archive_libsystem_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
|   &__archive_nettle_sha512init,
|   &__archive_nettle_sha512update,
|   &__archive_nettle_sha512final,
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
|   &__archive_openssl_sha512init,
|   &__archive_openssl_sha512update,
|   &__archive_openssl_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
|   &__archive_windowsapi_sha512init,
|   &__archive_windowsapi_sha512update,
|   &__archive_windowsapi_sha512final
| #elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
|   &__archive_stub_sha512init,
|   &__archive_stub_sha512update,
|   &__archive_stub_sha512final
| #endif
| };
| 
| int
| main(int argc, char **argv)
| {
|   archive_sha256_ctx ctx;
|   archive_sha256_init(&ctx);
|   archive_sha256_update(&ctx, *argv, argc);
|   archive_sha256_final(&ctx, NULL);
|   return 0;
| }
| 
configure:18992: result: no
configure:19006: checking support for ARCHIVE_CRYPTO_SHA512_LIBMD
configure:19028: arm-linux-androideabi-gcc -o conftest    -I. -I. -I./libarchive  conftest.c -lz  >&5
In file included from conftest.c:206:0:
./libarchive/archive_crypto_private.h:103:20: fatal error: sha512.h: No such file or directory
 #include <sha512.h>
                    ^
compilation terminated.
configure:19028: $? = 1
configure: failed program was:
| /* confdefs.h */
| #define PACKAGE_NAME "libarchive"
| #define PACKAGE_TARNAME "libarchive"
| #define PACKAGE_VERSION "3.1.2"
| #define PACKAGE_STRING "libarchive 3.1.2"
| #define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
| #define PACKAGE_URL ""
| #define PACKAGE "libarchive"
| #define VERSION "3.1.2"
| #define LIBARCHIVE_VERSION_STRING "3.1.2"
| #define LIBARCHIVE_VERSION_NUMBER "3001002"
| #define BSDCPIO_VERSION_STRING "3.1.2"
| #define BSDTAR_VERSION_STRING "3.1.2"
| #define STDC_HEADERS 1
| #define HAVE_SYS_TYPES_H 1
| #define HAVE_SYS_STAT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_MEMORY_H 1
| #define HAVE_STRINGS_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_UNISTD_H 1
| #define __EXTENSIONS__ 1
| #define _ALL_SOURCE 1
| #define _GNU_SOURCE 1
| #define _POSIX_PTHREAD_SEMANTICS 1
| #define _TANDEM_SOURCE 1
| #define HAVE_DLFCN_H 1
| #define LT_OBJDIR ".libs/"
| #define HAVE_DIRENT_H 1
| #define HAVE_SYS_WAIT_H 1
| #define HAVE_CTYPE_H 1
| #define HAVE_ERRNO_H 1
| #define HAVE_FCNTL_H 1
| #define HAVE_GRP_H 1
| #define HAVE_INTTYPES_H 1
| #define HAVE_LIMITS_H 1
| #define HAVE_LINUX_FIEMAP_H 1
| #define HAVE_LINUX_FS_H 1
| #define HAVE_LINUX_MAGIC_H 1
| #define HAVE_LINUX_TYPES_H 1
| #define HAVE_LOCALE_H 1
| #define HAVE_PATHS_H 1
| #define HAVE_POLL_H 1
| #define HAVE_PWD_H 1
| #define HAVE_SIGNAL_H 1
| #define HAVE_STDARG_H 1
| #define HAVE_STDINT_H 1
| #define HAVE_STDLIB_H 1
| #define HAVE_STRING_H 1
| #define HAVE_SYS_CDEFS_H 1
| #define HAVE_SYS_IOCTL_H 1
| #define HAVE_SYS_MOUNT_H 1
| #define HAVE_SYS_PARAM_H 1
| #define HAVE_SYS_POLL_H 1
| #define HAVE_SYS_SELECT_H 1
| #define HAVE_SYS_STATFS_H 1
| #define HAVE_SYS_STATVFS_H 1
| #define HAVE_SYS_TIME_H 1
| #define HAVE_SYS_UTIME_H 1
| #define HAVE_SYS_UTSNAME_H 1
| #define HAVE_SYS_VFS_H 1
| #define HAVE_TIME_H 1
| #define HAVE_UNISTD_H 1
| #define HAVE_UTIME_H 1
| #define HAVE_WCHAR_H 1
| #define HAVE_WCTYPE_H 1
| #define HAVE_ZLIB_H 1
| #define HAVE_LIBZ 1
| #define HAVE_REGEX_H 1
| #define HAVE_STRUCT_TM_TM_GMTOFF 1
| #define HAVE_STRUCT_STAT_ST_BLKSIZE 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_UNSIGNED_LONG_LONG 1
| #define HAVE_UNSIGNED_LONG_LONG_INT 1
| #define HAVE_LONG_LONG_INT 1
| #define HAVE_INTMAX_T 1
| #define HAVE_UINTMAX_T 1
| #define HAVE_DECL_SIZE_MAX 1
| #define HAVE_DECL_INT64_MAX 1
| #define HAVE_DECL_INT64_MIN 1
| #define HAVE_DECL_UINT64_MAX 1
| #define HAVE_DECL_UINT32_MAX 1
| #define HAVE_DECL_SSIZE_MAX 1
| #define HAVE_EILSEQ 1
| #define HAVE_WCHAR_T 1
| #define SIZEOF_WCHAR_T 4
| #define TIME_WITH_SYS_TIME 1
| #define HAVE_FSEEKO 1
| #define HAVE_LSTAT_EMPTY_STRING_BUG 1
| #define HAVE_STAT_EMPTY_STRING_BUG 1
| #define HAVE_DECL_STRERROR_R 1
| #define HAVE_STRERROR_R 1
| #define HAVE_STRFTIME 1
| #define HAVE_VPRINTF 1
| #define HAVE_CHOWN 1
| #define HAVE_CHROOT 1
| #define HAVE_CTIME_R 1
| #define HAVE_DIRFD 1
| #define HAVE_FCHDIR 1
| #define HAVE_FCHMOD 1
| #define HAVE_FCHOWN 1
| #define HAVE_FCNTL 1
| #define HAVE_FDOPENDIR 1
| #define HAVE_FORK 1
| #define HAVE_FSTAT 1
| #define HAVE_FSTATAT 1
| #define HAVE_FSTATFS 1
| #define HAVE_FSTATVFS 1
| #define HAVE_FTRUNCATE 1
| #define HAVE_FUTIMENS 1
| #define HAVE_GETEUID 1
| #define HAVE_GETPID 1
| #define HAVE_GETPWNAM_R 1
| #define HAVE_GETPWUID_R 1
| #define HAVE_GMTIME_R 1
| #define HAVE_LCHOWN 1
| #define HAVE_LINK 1
| #define HAVE_LOCALTIME_R 1
| #define HAVE_LSTAT 1
| #define HAVE_MBRTOWC 1
| #define HAVE_MEMMOVE 1
| #define HAVE_MEMSET 1
| #define HAVE_MKDIR 1
| #define HAVE_MKFIFO 1
| #define HAVE_MKNOD 1
| #define HAVE_MKSTEMP 1
| #define HAVE_OPENAT 1
| #define HAVE_PIPE 1
| #define HAVE_POLL 1
| #define HAVE_READLINK 1
| #define HAVE_READLINKAT 1
| #define HAVE_SELECT 1
| #define HAVE_SETENV 1
| #define HAVE_SETLOCALE 1
| #define HAVE_SIGACTION 1
| #define HAVE_STATFS 1
| #define HAVE_STATVFS 1
| #define HAVE_STRCHR 1
| #define HAVE_STRDUP 1
| #define HAVE_STRERROR 1
| #define HAVE_STRRCHR 1
| #define HAVE_SYMLINK 1
| #define HAVE_TIMEGM 1
| #define HAVE_TZSET 1
| #define HAVE_UNSETENV 1
| #define HAVE_UTIME 1
| #define HAVE_UTIMENSAT 1
| #define HAVE_UTIMES 1
| #define HAVE_VFORK 1
| #define HAVE_WCRTOMB 1
| #define HAVE_WCSCMP 1
| #define HAVE_WCSCPY 1
| #define HAVE_WCSLEN 1
| #define HAVE_WCTOMB 1
| #define HAVE_WMEMCMP 1
| #define HAVE_WMEMCPY 1
| #define HAVE_READDIR_R 1
| #define HAVE_SYS_XATTR_H 1
| #define HAVE_FGETXATTR 1
| #define HAVE_FLISTXATTR 1
| #define HAVE_FSETXATTR 1
| #define HAVE_GETXATTR 1
| #define HAVE_LGETXATTR 1
| #define HAVE_LISTXATTR 1
| #define HAVE_LLISTXATTR 1
| #define HAVE_LSETXATTR 1
| #define HAVE_DECL_EXTATTR_NAMESPACE_USER 0
| /* end confdefs.h.  */
| 
| #define ARCHIVE_SHA512_COMPILE_TEST
| #define ARCHIVE_CRYPTO_SHA512_LIBMD
| #define PLATFORM_CONFIG_H "check_crypto_md.h"
| 
| /*-
| * Copyright (c) 2003-2007 Tim Kientzle
| * Copyright (c) 2011 Andres Mejia
| * Copyright (c) 2011 Michihiro NAKAJIMA
| * All rights reserved.
| *
| * Redistribution and use in source and binary forms, with or without
| * modification, are permitted provided that the following conditions
| * are met:
| * 1. Redistributions of source code must retain the above copyright
| *    notice, this list of conditions and the following disclaimer.
| * 2. Redistributions in binary form must reproduce the above copyright
| *    notice, this list of conditions and the following disclaimer in the
| *    documentation and/or other materials provided with the distribution.
| *
| * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
| * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
| * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
| * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
| * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
| * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
| * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
| * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
| * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
| * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
| */
| 
| #include "archive_platform.h"
| 
| #include "archive.h"
| #include "archive_crypto_private.h"
| 
| /* In particular, force the configure probe to break if it tries
|  * to test a combination of OpenSSL and libmd. */
| #if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
| #error Cannot use both OpenSSL and libmd.
| #endif
| 
| /*
|  * Message digest functions for Windows platform.
|  */
| #if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
| 	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
| 	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
| 	defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| /*
|  * Initialize a Message digest.
|  */
| static int
| win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
| {
| 
| 	ctx->valid = 0;
| 	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
| 		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
| 			return (ARCHIVE_FAILED);
| 		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
| 		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
| 			return (ARCHIVE_FAILED);
| 	}
| 
| 	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
| 		CryptReleaseContext(ctx->cryptProv, 0);
| 		return (ARCHIVE_FAILED);
| 	}
| 
| 	ctx->valid = 1;
| 	return (ARCHIVE_OK);
| }
| 
| /*
|  * Update a Message digest.
|  */
| static int
| win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
| {
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptHashData(ctx->hash,
| 		      (unsigned char *)(uintptr_t)buf,
| 		      (DWORD)len, 0);
| 	return (ARCHIVE_OK);
| }
| 
| static int
| win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
| {
| 	DWORD siglen = (DWORD)bufsize;
| 
| 	if (!ctx->valid)
| 		return (ARCHIVE_FAILED);
| 
| 	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
| 	CryptDestroyHash(ctx->hash);
| 	CryptReleaseContext(ctx->cryptProv, 0);
| 	ctx->valid = 0;
| 	return (ARCHIVE_OK);
| }
| 
| #endif /* defined(ARCHIVE_CRYPTO_*_WIN) */
| 
| 
| /* MD5 implementations */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
| 
| static int
| __archive_libc_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
| 
| static int
| __archive_libmd_md5init(archive_md5_ctx *ctx)
| {
|   MD5Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   MD5Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
| {
|   MD5Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
| 
| static int
| __archive_libsystem_md5init(archive_md5_ctx *ctx)
| {
|   CC_MD5_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_MD5_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
| {
|   CC_MD5_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
| 
| static int
| __archive_nettle_md5init(archive_md5_ctx *ctx)
| {
|   md5_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   md5_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
| {
|   md5_digest(ctx, MD5_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
| 
| static int
| __archive_openssl_md5init(archive_md5_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_md5());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
| 
| static int
| __archive_windowsapi_md5init(archive_md5_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_MD5));
| }
| 
| static int
| __archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 16, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_md5init(archive_md5_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_md5final(archive_md5_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* RIPEMD160 implementations */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
| 
| static int
| __archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RMD160Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RMD160Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RMD160Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
| 
| static int
| __archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   RIPEMD160_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   RIPEMD160_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   RIPEMD160_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
| 
| static int
| __archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   ripemd160_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   ripemd160_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
| 
| static int
| __archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_ripemd160());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #else
| 
| static int
| __archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA1 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
| 
| static int
| __archive_libc_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
| 
| static int
| __archive_libmd_sha1init(archive_sha1_ctx *ctx)
| {
|   SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha1init(archive_sha1_ctx *ctx)
| {
|   CC_SHA1_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA1_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   CC_SHA1_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
| 
| static int
| __archive_nettle_sha1init(archive_sha1_ctx *ctx)
| {
|   sha1_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha1_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
| 
| static int
| __archive_openssl_sha1init(archive_sha1_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha1());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
|    * this is meant to cope with that. Real fix is probably to fix
|    * archive_write_set_format_xar.c
|    */
|   if (ctx->digest)
|     EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
| 
| static int
| __archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA1));
| }
| 
| static int
| __archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 20, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha1init(archive_sha1_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA256 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
| 
| static int
| __archive_libc_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
| 
| static int
| __archive_libc2_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
| 
| static int
| __archive_libc3_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
| 
| static int
| __archive_libmd_sha256init(archive_sha256_ctx *ctx)
| {
|   SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha256init(archive_sha256_ctx *ctx)
| {
|   CC_SHA256_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA256_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   CC_SHA256_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
| 
| static int
| __archive_nettle_sha256init(archive_sha256_ctx *ctx)
| {
|   sha256_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha256_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
| 
| static int
| __archive_openssl_sha256init(archive_sha256_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha256());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
| 
| static int
| __archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_256));
| }
| 
| static int
| __archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 32, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha256init(archive_sha256_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA384 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
| 
| static int
| __archive_libc_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
| 
| static int
| __archive_libc2_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
| 
| static int
| __archive_libc3_sha384init(archive_sha384_ctx *ctx)
| {
|   SHA384Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA384Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   SHA384Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha384init(archive_sha384_ctx *ctx)
| {
|   CC_SHA384_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA384_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   CC_SHA384_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
| 
| static int
| __archive_nettle_sha384init(archive_sha384_ctx *ctx)
| {
|   sha384_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha384_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
| 
| static int
| __archive_openssl_sha384init(archive_sha384_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha384());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
| 
| static int
| __archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_384));
| }
| 
| static int
| __archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 48, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha384init(archive_sha384_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* SHA512 implementations */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
| 
| static int
| __archive_libc_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
| 
| static int
| __archive_libc2_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
| 
| static int
| __archive_libc3_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
| 
| static int
| __archive_libmd_sha512init(archive_sha512_ctx *ctx)
| {
|   SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
| 
| static int
| __archive_libsystem_sha512init(archive_sha512_ctx *ctx)
| {
|   CC_SHA512_Init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   CC_SHA512_Update(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   CC_SHA512_Final(md, ctx);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
| 
| static int
| __archive_nettle_sha512init(archive_sha512_ctx *ctx)
| {
|   sha512_init(ctx);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   sha512_update(ctx, insize, indata);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
| 
| static int
| __archive_openssl_sha512init(archive_sha512_ctx *ctx)
| {
|   EVP_DigestInit(ctx, EVP_sha512());
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   EVP_DigestUpdate(ctx, indata, insize);
|   return (ARCHIVE_OK);
| }
| 
| static int
| __archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   EVP_DigestFinal(ctx, md, NULL);
|   return (ARCHIVE_OK);
| }
| 
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
| 
| static int
| __archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
| {
|   return (win_crypto_init(ctx, CALG_SHA_512));
| }
| 
| static int
| __archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
|   return (win_crypto_Update(ctx, indata, insize));
| }
| 
| static int
| __archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
| {
|   return (win_crypto_Final(md, 64, ctx));
| }
| 
| #else
| 
| static int
| __archive_stub_sha512init(archive_sha512_ctx *ctx)
| {
| 	(void)ctx; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
|     size_t insize)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)indata; /* UNUSED */
| 	(void)insize; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| static int
| __archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
| {
| 	(void)ctx; /* UNUSED */
| 	(void)md; /* UNUSED */
| 	return (ARCHIVE_FAILED);
| }
| 
| #endif
| 
| /* NOTE: Crypto functions are set based on availability and by the following
|  * order of preference.
|  * 1. libc
|  * 2. libc2
|  * 3. libc3
|  * 4. libSystem
|  * 5. Nettle
|  * 6. OpenSSL
|  * 7. libmd
|  * 8. Windows API
|  */
| const struct archive_crypto __archive_crypto =
| {
| /* MD5 */
| #if defined(ARCHIVE_CRYPTO_MD5_LIBC)
|   &__archive_libc_md5init,
|   &__archive_libc_md5update,
|   &__archive_libc_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
|   &__archive_libmd_md5init,
|   &__archive_libmd_md5update,
|   &__archive_libmd_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
|   &__archive_libsystem_md5init,
|   &__archive_libsystem_md5update,
|   &__archive_libsystem_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
|   &__archive_nettle_md5init,
|   &__archive_nettle_md5update,
|   &__archive_nettle_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
|   &__archive_openssl_md5init,
|   &__archive_openssl_md5update,
|   &__archive_openssl_md5final,
| #elif defined(ARCHIVE_CRYPTO_MD5_WIN)
|   &__archive_windowsapi_md5init,
|   &__archive_windowsapi_md5update,
|   &__archive_windowsapi_md5final,
| #elif !defined(ARCHIVE_MD5_COMPILE_TEST)
|   &__archive_stub_md5init,
|   &__archive_stub_md5update,
|   &__archive_stub_md5final,
| #endif
| 
| /* RIPEMD160 */
| #if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
|   &__archive_libc_ripemd160init,
|   &__archive_libc_ripemd160update,
|   &__archive_libc_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
|   &__archive_libmd_ripemd160init,
|   &__archive_libmd_ripemd160update,
|   &__archive_libmd_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
|   &__archive_nettle_ripemd160init,
|   &__archive_nettle_ripemd160update,
|   &__archive_nettle_ripemd160final,
| #elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
|   &__archive_openssl_ripemd160init,
|   &__archive_openssl_ripemd160update,
|   &__archive_openssl_ripemd160final,
| #elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
|   &__archive_stub_ripemd160init,
|   &__archive_stub_ripemd160update,
|   &__archive_stub_ripemd160final,
| #endif
| 
| /* SHA1 */
| #if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
|   &__archive_libc_sha1init,
|   &__archive_libc_sha1update,
|   &__archive_libc_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
|   &__archive_libmd_sha1init,
|   &__archive_libmd_sha1update,
|   &__archive_libmd_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
|   &__archive_libsystem_sha1init,
|   &__archive_libsystem_sha1update,
|   &__archive_libsystem_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
|   &__archive_nettle_sha1init,
|   &__archive_nettle_sha1update,
|   &__archive_nettle_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
|   &__archive_openssl_sha1init,
|   &__archive_openssl_sha1update,
|   &__archive_openssl_sha1final,
| #elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
|   &__archive_windowsapi_sha1init,
|   &__archive_windowsapi_sha1update,
|   &__archive_windowsapi_sha1final,
| #elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
|   &__archive_stub_sha1init,
|   &__archive_stub_sha1update,
|   &__archive_stub_sha1final,
| #endif
| 
| /* SHA256 */
| #if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
|   &__archive_libc_sha256init,
|   &__archive_libc_sha256update,
|   &__archive_libc_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
|   &__archive_libc2_sha256init,
|   &__archive_libc2_sha256update,
|   &__archive_libc2_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
|   &__archive_libc3_sha256init,
|   &__archive_libc3_sha256update,
|   &__archive_libc3_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
|   &__archive_libmd_sha256init,
|   &__archive_libmd_sha256update,
|   &__archive_libmd_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
|   &__archive_libsystem_sha256init,
|   &__archive_libsystem_sha256update,
|   &__archive_libsystem_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
|   &__archive_nettle_sha256init,
|   &__archive_nettle_sha256update,
|   &__archive_nettle_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
|   &__archive_openssl_sha256init,
|   &__archive_openssl_sha256update,
|   &__archive_openssl_sha256final,
| #elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
|   &__archive_windowsapi_sha256init,
|   &__archive_windowsapi_sha256update,
|   &__archive_windowsapi_sha256final,
| #elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
|   &__archive_stub_sha256init,
|   &__archive_stub_sha256update,
|   &__archive_stub_sha256final,
| #endif
| 
| /* SHA384 */
| #if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
|   &__archive_libc_sha384init,
|   &__archive_libc_sha384update,
|   &__archive_libc_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
|   &__archive_libc2_sha384init,
|   &__archive_libc2_sha384update,
|   &__archive_libc2_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
|   &__archive_libc3_sha384init,
|   &__archive_libc3_sha384update,
|   &__archive_libc3_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
|   &__archive_libsystem_sha384init,
|   &__archive_libsystem_sha384update,
|   &__archive_libsystem_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
|   &__archive_nettle_sha384init,
|   &__archive_nettle_sha384update,
|   &__archive_nettle_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
|   &__archive_openssl_sha384init,
|   &__archive_openssl_sha384update,
|   &__archive_openssl_sha384final,
| #elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
|   &__archive_windowsapi_sha384init,
|   &__archive_windowsapi_sha384update,
|   &__archive_windowsapi_sha384final,
| #elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
|   &__archive_stub_sha384init,
|   &__archive_stub_sha384update,
|   &__archive_stub_sha384final,
| #endif
| 
| /* SHA512 */
| #if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
|   &__archive_libc_sha512init,
|   &__archive_libc_sha512update,
|   &__archive_libc_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
|   &__archive_libc2_sha512init,
|   &__archive_libc2_sha512update,
|   &__archive_libc2_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
|   &__archive_libc3_sha512init,
|   &__archive_libc3_sha512update,
|   &__archive_libc3_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
|   &__archive_libmd_sha512init,
|   &__archive_libmd_sha512update,
|   &__archive_libmd_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
|   &__archive_libsystem_sha512init,
|   &__archive_libsystem_sha512update,
|   &__archive_libsystem_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
|   &__archive_nettle_sha512init,
|   &__archive_nettle_sha512update,
|   &__archive_nettle_sha512final,
| #elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
|   &__archive_openssl_sha512init,
|   &__archive_openssl_sha512update,
|   &__archive_openssl_sha512final
| #elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
|   &__archive_windowsapi_sha512init,
|   &__archive_windowsapi_sha512update,
|   &__archive_windowsapi_sha512final
| #elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
|   &__archive_stub_sha512init,
|   &__archive_stub_sha512update,
|   &__archive_stub_sha512final
| #endif
| };
| 
| int
| main(int argc, char **argv)
| {
|   archive_sha512_ctx ctx;
|   archive_sha512_init(&ctx);
|   archive_sha512_update(&ctx, *argv, argc);
|   archive_sha512_final(&ctx, NULL);
|   return 0;
| }
| 
configure:19038: result: no
configure:19400: creating ./config.status

## ---------------------- ##
## Running config.status. ##
## ---------------------- ##

This file was extended by libarchive config.status 3.1.2, which was
generated by GNU Autoconf 2.69.  Invocation command line was

  CONFIG_FILES    = 
  CONFIG_HEADERS  = 
  CONFIG_LINKS    = 
  CONFIG_COMMANDS = 
  $ ./config.status 

on 8847e89226ca

config.status:1252: creating Makefile
config.status:1252: creating build/pkgconfig/libarchive.pc
config.status:1252: creating config.h
config.status:1481: executing depfiles commands
config.status:1481: executing libtool commands

## ---------------- ##
## Cache variables. ##
## ---------------- ##

ac_cv_build=x86_64-unknown-linux-gnu
ac_cv_c_compiler_gnu=yes
ac_cv_c_const=yes
ac_cv_c_int16_t=yes
ac_cv_c_int32_t=yes
ac_cv_c_int64_t=yes
ac_cv_c_uint16_t=yes
ac_cv_c_uint32_t=yes
ac_cv_c_uint64_t=yes
ac_cv_c_uint8_t=yes
ac_cv_env_CC_set=set
ac_cv_env_CC_value=arm-linux-androideabi-gcc
ac_cv_env_CFLAGS_set=set
ac_cv_env_CFLAGS_value=' '
ac_cv_env_CPPFLAGS_set=set
ac_cv_env_CPPFLAGS_value=
ac_cv_env_CPP_set=
ac_cv_env_CPP_value=
ac_cv_env_LDFLAGS_set=set
ac_cv_env_LDFLAGS_value=
ac_cv_env_LIBS_set=
ac_cv_env_LIBS_value=
ac_cv_env_build_alias_set=
ac_cv_env_build_alias_value=
ac_cv_env_host_alias_set=set
ac_cv_env_host_alias_value=x86_64-unknown-linux
ac_cv_env_target_alias_set=
ac_cv_env_target_alias_value=
ac_cv_func_CreateHardLinkA=no
ac_cv_func__ctime64_s=no
ac_cv_func__doprnt=no
ac_cv_func__fseeki64=no
ac_cv_func__get_timezone=no
ac_cv_func__localtime64_s=no
ac_cv_func__mkgmtime64=no
ac_cv_func_acl_create_entry=no
ac_cv_func_acl_get_link=no
ac_cv_func_acl_get_link_np=no
ac_cv_func_acl_get_perm=no
ac_cv_func_acl_get_perm_np=no
ac_cv_func_acl_init=no
ac_cv_func_acl_set_fd=no
ac_cv_func_acl_set_fd_np=no
ac_cv_func_acl_set_file=no
ac_cv_func_chflags=no
ac_cv_func_chown=yes
ac_cv_func_chroot=yes
ac_cv_func_ctime_r=yes
ac_cv_func_cygwin_conv_path=no
ac_cv_func_dirfd=yes
ac_cv_func_extattr_get_file=no
ac_cv_func_extattr_list_file=no
ac_cv_func_extattr_set_fd=no
ac_cv_func_extattr_set_file=no
ac_cv_func_fchdir=yes
ac_cv_func_fchflags=no
ac_cv_func_fchmod=yes
ac_cv_func_fchown=yes
ac_cv_func_fcntl=yes
ac_cv_func_fdopendir=yes
ac_cv_func_fgetea=no
ac_cv_func_fgetxattr=yes
ac_cv_func_flistea=no
ac_cv_func_flistxattr=yes
ac_cv_func_fork=yes
ac_cv_func_fsetea=no
ac_cv_func_fsetxattr=yes
ac_cv_func_fstat=yes
ac_cv_func_fstatat=yes
ac_cv_func_fstatfs=yes
ac_cv_func_fstatvfs=yes
ac_cv_func_ftruncate=yes
ac_cv_func_futimens=yes
ac_cv_func_futimes=no
ac_cv_func_futimesat=no
ac_cv_func_getea=no
ac_cv_func_geteuid=yes
ac_cv_func_getgrgid_r=no
ac_cv_func_getgrnam_r=no
ac_cv_func_getpid=yes
ac_cv_func_getpwnam_r=yes
ac_cv_func_getpwuid_r=yes
ac_cv_func_getvfsbyname=no
ac_cv_func_getxattr=yes
ac_cv_func_gmtime_r=yes
ac_cv_func_lchflags=no
ac_cv_func_lchmod=no
ac_cv_func_lchown=yes
ac_cv_func_lgetea=no
ac_cv_func_lgetxattr=yes
ac_cv_func_link=yes
ac_cv_func_listea=no
ac_cv_func_listxattr=yes
ac_cv_func_llistea=no
ac_cv_func_llistxattr=yes
ac_cv_func_localtime_r=yes
ac_cv_func_lsetea=no
ac_cv_func_lsetxattr=yes
ac_cv_func_lstat=yes
ac_cv_func_lstat_dereferences_slashed_symlink=no
ac_cv_func_lstat_empty_string_bug=yes
ac_cv_func_lutimes=no
ac_cv_func_mbrtowc=yes
ac_cv_func_memcmp_working=no
ac_cv_func_memmove=yes
ac_cv_func_memset=yes
ac_cv_func_mkdir=yes
ac_cv_func_mkfifo=yes
ac_cv_func_mknod=yes
ac_cv_func_mkstemp=yes
ac_cv_func_nl_langinfo=no
ac_cv_func_openat=yes
ac_cv_func_pipe=yes
ac_cv_func_poll=yes
ac_cv_func_posix_spawnp=no
ac_cv_func_readlink=yes
ac_cv_func_readlinkat=yes
ac_cv_func_regcomp=yes
ac_cv_func_select=yes
ac_cv_func_setenv=yes
ac_cv_func_setlocale=yes
ac_cv_func_sigaction=yes
ac_cv_func_stat_empty_string_bug=yes
ac_cv_func_statfs=yes
ac_cv_func_statvfs=yes
ac_cv_func_strchr=yes
ac_cv_func_strdup=yes
ac_cv_func_strerror=yes
ac_cv_func_strerror_r=yes
ac_cv_func_strerror_r_char_p=no
ac_cv_func_strftime=yes
ac_cv_func_strncpy_s=no
ac_cv_func_strrchr=yes
ac_cv_func_symlink=yes
ac_cv_func_timegm=yes
ac_cv_func_tzset=yes
ac_cv_func_unsetenv=yes
ac_cv_func_utime=yes
ac_cv_func_utimensat=yes
ac_cv_func_utimes=yes
ac_cv_func_vfork=yes
ac_cv_func_vprintf=yes
ac_cv_func_wcrtomb=yes
ac_cv_func_wcscmp=yes
ac_cv_func_wcscpy=yes
ac_cv_func_wcslen=yes
ac_cv_func_wctomb=yes
ac_cv_func_wmemcmp=yes
ac_cv_func_wmemcpy=yes
ac_cv_have_decl_ACL_USER=no
ac_cv_have_decl_D_MD_ORDER=no
ac_cv_have_decl_EFTYPE=no
ac_cv_have_decl_EILSEQ=yes
ac_cv_have_decl_EXT2_IOC_GETFLAGS=no
ac_cv_have_decl_EXTATTR_NAMESPACE_USER=no
ac_cv_have_decl_INT64_MAX=yes
ac_cv_have_decl_INT64_MIN=yes
ac_cv_have_decl_SIZE_MAX=yes
ac_cv_have_decl_SSIZE_MAX=yes
ac_cv_have_decl_UINT32_MAX=yes
ac_cv_have_decl_UINT64_MAX=yes
ac_cv_have_decl_strerror_r=yes
ac_cv_header_acl_libacl_h=no
ac_cv_header_attr_xattr_h=no
ac_cv_header_bzlib_h=no
ac_cv_header_copyfile_h=no
ac_cv_header_ctype_h=yes
ac_cv_header_dirent_dirent_h=yes
ac_cv_header_dlfcn_h=yes
ac_cv_header_errno_h=yes
ac_cv_header_expat_h=no
ac_cv_header_ext2fs_ext2_fs_h=no
ac_cv_header_fcntl_h=yes
ac_cv_header_grp_h=yes
ac_cv_header_iconv_h=no
ac_cv_header_inttypes_h=yes
ac_cv_header_io_h=no
ac_cv_header_langinfo_h=no
ac_cv_header_limits_h=yes
ac_cv_header_linux_fiemap_h=yes
ac_cv_header_linux_fs_h=yes
ac_cv_header_linux_magic_h=yes
ac_cv_header_linux_types_h=yes
ac_cv_header_locale_h=yes
ac_cv_header_lzma_h=no
ac_cv_header_lzmadec_h=no
ac_cv_header_lzo_lzo1x_h=no
ac_cv_header_lzo_lzoconf_h=no
ac_cv_header_md5_h=no
ac_cv_header_memory_h=yes
ac_cv_header_minix_config_h=no
ac_cv_header_nettle_md5_h=no
ac_cv_header_nettle_ripemd160_h=no
ac_cv_header_nettle_sha_h=no
ac_cv_header_openssl_evp_h=no
ac_cv_header_paths_h=yes
ac_cv_header_poll_h=yes
ac_cv_header_pwd_h=yes
ac_cv_header_regex_h=yes
ac_cv_header_ripemd_h=no
ac_cv_header_sha256_h=no
ac_cv_header_sha512_h=no
ac_cv_header_sha_h=no
ac_cv_header_signal_h=yes
ac_cv_header_spawn_h=no
ac_cv_header_stdarg_h=yes
ac_cv_header_stdc=yes
ac_cv_header_stdint_h=yes
ac_cv_header_stdlib_h=yes
ac_cv_header_string_h=yes
ac_cv_header_strings_h=yes
ac_cv_header_sys_acl_h=no
ac_cv_header_sys_cdefs_h=yes
ac_cv_header_sys_ea_h=no
ac_cv_header_sys_extattr_h=no
ac_cv_header_sys_ioctl_h=yes
ac_cv_header_sys_mkdev_h=no
ac_cv_header_sys_mount_h=yes
ac_cv_header_sys_param_h=yes
ac_cv_header_sys_poll_h=yes
ac_cv_header_sys_select_h=yes
ac_cv_header_sys_stat_h=yes
ac_cv_header_sys_statfs_h=yes
ac_cv_header_sys_statvfs_h=yes
ac_cv_header_sys_time_h=yes
ac_cv_header_sys_types_h=yes
ac_cv_header_sys_types_h_makedev=yes
ac_cv_header_sys_utime_h=yes
ac_cv_header_sys_utsname_h=yes
ac_cv_header_sys_vfs_h=yes
ac_cv_header_sys_wait_h=yes
ac_cv_header_sys_xattr_h=yes
ac_cv_header_time=yes
ac_cv_header_time_h=yes
ac_cv_header_unistd_h=yes
ac_cv_header_utime_h=yes
ac_cv_header_wchar_h=yes
ac_cv_header_wctype_h=yes
ac_cv_header_wincrypt_h=no
ac_cv_header_windows_h=no
ac_cv_header_winioctl_h=no
ac_cv_header_zlib_h=yes
ac_cv_host=x86_64-unknown-linux-gnu
ac_cv_lib_acl_acl_get_file=no
ac_cv_lib_attr_setxattr=no
ac_cv_lib_bz2_BZ2_bzDecompressInit=no
ac_cv_lib_crypto_main=no
ac_cv_lib_expat_XML_ParserCreate=no
ac_cv_lib_lzma_lzma_stream_decoder=no
ac_cv_lib_lzmadec_lzmadec_decode=no
ac_cv_lib_lzo2_lzo1x_decompress_safe=no
ac_cv_lib_md_main=no
ac_cv_lib_nettle_main=no
ac_cv_lib_z_inflate=yes
ac_cv_member_struct_dirent_d_namlen=no
ac_cv_member_struct_stat_st_birthtime=no
ac_cv_member_struct_stat_st_birthtimespec_tv_nsec=no
ac_cv_member_struct_stat_st_blksize=yes
ac_cv_member_struct_stat_st_flags=no
ac_cv_member_struct_stat_st_mtim_tv_nsec=no
ac_cv_member_struct_stat_st_mtime_n=no
ac_cv_member_struct_stat_st_mtime_usec=no
ac_cv_member_struct_stat_st_mtimespec_tv_nsec=no
ac_cv_member_struct_stat_st_umtime=no
ac_cv_member_struct_statfs_f_namemax=no
ac_cv_member_struct_statvfs_f_iosize=no
ac_cv_member_struct_tm___tm_gmtoff=no
ac_cv_member_struct_tm_tm_gmtoff=yes
ac_cv_objext=o
ac_cv_path_EGREP='/usr/sbin/grep -E'
ac_cv_path_FGREP='/usr/sbin/grep -F'
ac_cv_path_GREP=/usr/sbin/grep
ac_cv_path_SED=/usr/sbin/sed
ac_cv_path_install='/usr/bin/install -c'
ac_cv_path_mkdir=/usr/sbin/mkdir
ac_cv_prog_AWK=gawk
ac_cv_prog_CC=arm-linux-androideabi-gcc
ac_cv_prog_CPP='arm-linux-androideabi-gcc -E'
ac_cv_prog_DLLTOOL=dlltool
ac_cv_prog_OBJDUMP=objdump
ac_cv_prog_STRIP=strip
ac_cv_prog_ac_ct_AR=ar
ac_cv_prog_ac_ct_RANLIB=ranlib
ac_cv_prog_ac_ct_STRIP=strip
ac_cv_prog_cc_arm_linux_androideabi_gcc_c_o=yes
ac_cv_prog_cc_c89=
ac_cv_prog_cc_g=yes
ac_cv_prog_gcc_traditional=no
ac_cv_prog_make_make_set=yes
ac_cv_safe_to_define___extensions__=yes
ac_cv_search_opendir='none required'
ac_cv_sizeof_wchar_t=4
ac_cv_sys_file_offset_bits=unknown
ac_cv_sys_large_files=unknown
ac_cv_sys_largefile_CC=no
ac_cv_sys_largefile_source=no
ac_cv_type_acl_permset_t=no
ac_cv_type_id_t=yes
ac_cv_type_intmax_t=yes
ac_cv_type_long_long_int=yes
ac_cv_type_mode_t=yes
ac_cv_type_off_t=yes
ac_cv_type_size_t=yes
ac_cv_type_uintmax_t=yes
ac_cv_type_uintptr_t=yes
ac_cv_type_unsigned_long_long=yes
ac_cv_type_unsigned_long_long_int=yes
ac_cv_type_wchar_t=yes
acl_cv_hardcode_direct=no
acl_cv_hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
acl_cv_hardcode_libdir_separator=
acl_cv_hardcode_minus_L=no
acl_cv_libext=a
acl_cv_libname_spec='lib$name'
acl_cv_library_names_spec='$libname$shrext'
acl_cv_path_LD='/tmp/toolchain/arm-linux-androideabi/bin/ld -m elf_i386'
acl_cv_prog_gnu_ld=yes
acl_cv_rpath=done
acl_cv_shlibext=so
acl_cv_wl=-Wl,
am_cv_CC_dependencies_compiler_type=gcc3
am_cv_func_iconv='no, consider installing GNU libiconv'
am_cv_lib_iconv=no
am_cv_make_support_nested_variables=yes
la_cv_type_uid_t=yes
lt_cv_ar_at_file=@
lt_cv_archive_cmds_need_lc=no
lt_cv_deplibs_check_method=pass_all
lt_cv_file_magic_cmd='$MAGIC_CMD'
lt_cv_file_magic_test_file=
lt_cv_ld_reload_flag=-r
lt_cv_nm_interface='BSD nm'
lt_cv_objdir=.libs
lt_cv_path_LD=/tmp/toolchain/arm-linux-androideabi/bin/ld
lt_cv_path_NM='/usr/sbin/nm -B'
lt_cv_path_mainfest_tool=no
lt_cv_prog_compiler_c_o=yes
lt_cv_prog_compiler_pic='-fPIC -DPIC'
lt_cv_prog_compiler_pic_works=yes
lt_cv_prog_compiler_rtti_exceptions=no
lt_cv_prog_compiler_static_works=yes
lt_cv_prog_gnu_ld=yes
lt_cv_sharedlib_from_linklib_cmd='printf %s\n'
lt_cv_shlibpath_overrides_runpath=yes
lt_cv_sys_global_symbol_pipe='sed -n -e '\''s/^.*[	 ]\([ABCDGIRSTW][ABCDGIRSTW]*\)[	 ][	 ]*\([_A-Za-z][_A-Za-z0-9]*\)$/\1 \2 \2/p'\'' | sed '\''/ __gnu_lto/d'\'''
lt_cv_sys_global_symbol_to_c_name_address='sed -n -e '\''s/^: \([^ ]*\)[ ]*$/  {\"\1\", (void *) 0},/p'\'' -e '\''s/^[ABCDGIRSTW]* \([^ ]*\) \([^ ]*\)$/  {"\2", (void *) \&\2},/p'\'''
lt_cv_sys_global_symbol_to_c_name_address_lib_prefix='sed -n -e '\''s/^: \([^ ]*\)[ ]*$/  {\"\1\", (void *) 0},/p'\'' -e '\''s/^[ABCDGIRSTW]* \([^ ]*\) \(lib[^ ]*\)$/  {"\2", (void *) \&\2},/p'\'' -e '\''s/^[ABCDGIRSTW]* \([^ ]*\) \([^ ]*\)$/  {"lib\2", (void *) \&\2},/p'\'''
lt_cv_sys_global_symbol_to_cdecl='sed -n -e '\''s/^T .* \(.*\)$/extern int \1();/p'\'' -e '\''s/^[ABCDGIRSTW]* .* \(.*\)$/extern char \1;/p'\'''
lt_cv_sys_max_cmd_len=1572864
lt_cv_to_host_file_cmd=func_convert_file_noop
lt_cv_to_tool_file_cmd=func_convert_file_noop

## ----------------- ##
## Output variables. ##
## ----------------- ##

ACLOCAL='${SHELL} /tmp/libarchive/src/libarchive-3.1.2/build/autoconf/missing --run aclocal-1.11'
AMDEPBACKSLASH='\'
AMDEP_FALSE='#'
AMDEP_TRUE=''
AMTAR='$${TAR-tar}'
AM_BACKSLASH='\'
AM_DEFAULT_V='$(AM_DEFAULT_VERBOSITY)'
AM_DEFAULT_VERBOSITY='0'
AM_V='$(V)'
AR='ar'
ARCHIVE_LIBTOOL_VERSION='14:2:1'
AS='as'
AUTOCONF='${SHELL} /tmp/libarchive/src/libarchive-3.1.2/build/autoconf/missing --run autoconf'
AUTOHEADER='${SHELL} /tmp/libarchive/src/libarchive-3.1.2/build/autoconf/missing --run autoheader'
AUTOMAKE='${SHELL} /tmp/libarchive/src/libarchive-3.1.2/build/autoconf/missing --run automake-1.11'
AWK='gawk'
BSDCPIO_VERSION_STRING='3.1.2'
BSDTAR_VERSION_STRING='3.1.2'
BUILD_BSDCPIO_FALSE='#'
BUILD_BSDCPIO_TRUE=''
BUILD_BSDTAR_FALSE='#'
BUILD_BSDTAR_TRUE=''
CC='arm-linux-androideabi-gcc'
CCDEPMODE='depmode=gcc3'
CFLAGS=' '
CPP='arm-linux-androideabi-gcc -E'
CPPFLAGS=''
CYGPATH_W='echo'
DEFS='-DHAVE_CONFIG_H'
DEPDIR='.deps'
DLLTOOL='dlltool'
DSYMUTIL=''
DUMPBIN=''
ECHO_C=''
ECHO_N='-n'
ECHO_T=''
EGREP='/usr/sbin/grep -E'
EXEEXT=''
FGREP='/usr/sbin/grep -F'
GREP='/usr/sbin/grep'
INC_CYGWIN_FILES_FALSE=''
INC_CYGWIN_FILES_TRUE='#'
INC_WINDOWS_FILES_FALSE=''
INC_WINDOWS_FILES_TRUE='#'
INSTALL_DATA='${INSTALL} -m 644'
INSTALL_PROGRAM='${INSTALL}'
INSTALL_SCRIPT='${INSTALL}'
INSTALL_STRIP_PROGRAM='$(install_sh) -c -s'
LD='/tmp/toolchain/arm-linux-androideabi/bin/ld -m elf_i386'
LDFLAGS=''
LIBARCHIVE_VERSION_NUMBER='3001002'
LIBARCHIVE_VERSION_STRING='3.1.2'
LIBICONV=''
LIBOBJS=' ${LIBOBJDIR}memcmp$U.o ${LIBOBJDIR}lstat$U.o ${LIBOBJDIR}stat$U.o'
LIBS='-lz '
LIBTOOL='$(SHELL) $(top_builddir)/libtool'
LIPO=''
LN_S='ln -s'
LTLIBICONV=''
LTLIBOBJS=' ${LIBOBJDIR}memcmp$U.lo ${LIBOBJDIR}lstat$U.lo ${LIBOBJDIR}stat$U.lo'
MAKEINFO='${SHELL} /tmp/libarchive/src/libarchive-3.1.2/build/autoconf/missing --run makeinfo'
MANIFEST_TOOL=':'
MKDIR_P='/usr/sbin/mkdir -p'
NM='/usr/sbin/nm -B'
NMEDIT=''
OBJDUMP='objdump'
OBJEXT='o'
OTOOL64=''
OTOOL=''
PACKAGE='libarchive'
PACKAGE_BUGREPORT='libarchive-discuss@googlegroups.com'
PACKAGE_NAME='libarchive'
PACKAGE_STRING='libarchive 3.1.2'
PACKAGE_TARNAME='libarchive'
PACKAGE_URL=''
PACKAGE_VERSION='3.1.2'
PATH_SEPARATOR=':'
PLATFORMCPPFLAGS=''
RANLIB='ranlib'
SED='/usr/sbin/sed'
SET_MAKE=''
SHELL='/bin/sh'
STATIC_BSDCPIO_FALSE='#'
STATIC_BSDCPIO_TRUE=''
STATIC_BSDTAR_FALSE='#'
STATIC_BSDTAR_TRUE=''
STRIP='strip'
VERSION='3.1.2'
XML2_CONFIG=''
ac_ct_AR='ar'
ac_ct_CC=''
ac_ct_DUMPBIN=''
am__EXEEXT_FALSE=''
am__EXEEXT_TRUE='#'
am__fastdepCC_FALSE='#'
am__fastdepCC_TRUE=''
am__include='include'
am__isrc=''
am__leading_dot='.'
am__nodep='_no'
am__quote=''
am__tar='$${TAR-tar} chof - "$$tardir"'
am__untar='$${TAR-tar} xf -'
bindir='${exec_prefix}/bin'
build='x86_64-unknown-linux-gnu'
build_alias=''
build_cpu='x86_64'
build_os='linux-gnu'
build_vendor='unknown'
datadir='${datarootdir}'
datarootdir='${prefix}/share'
docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
dvidir='${docdir}'
exec_prefix='${prefix}'
host='x86_64-unknown-linux-gnu'
host_alias='x86_64-unknown-linux'
host_cpu='x86_64'
host_os='linux-gnu'
host_vendor='unknown'
htmldir='${docdir}'
includedir='${prefix}/include'
infodir='${datarootdir}/info'
install_sh='${SHELL} /tmp/libarchive/src/libarchive-3.1.2/build/autoconf/install-sh'
libdir='${exec_prefix}/lib'
libexecdir='${exec_prefix}/libexec'
localedir='${datarootdir}/locale'
localstatedir='${prefix}/var'
mandir='${datarootdir}/man'
mkdir_p='/usr/sbin/mkdir -p'
oldincludedir='/usr/include'
pdfdir='${docdir}'
prefix='/usr'
program_transform_name='s,x,x,'
psdir='${docdir}'
sbindir='${exec_prefix}/sbin'
sharedstatedir='${prefix}/com'
sysconfdir='${prefix}/etc'
target_alias=''

## ----------- ##
## confdefs.h. ##
## ----------- ##

/* confdefs.h */
#define PACKAGE_NAME "libarchive"
#define PACKAGE_TARNAME "libarchive"
#define PACKAGE_VERSION "3.1.2"
#define PACKAGE_STRING "libarchive 3.1.2"
#define PACKAGE_BUGREPORT "libarchive-discuss@googlegroups.com"
#define PACKAGE_URL ""
#define PACKAGE "libarchive"
#define VERSION "3.1.2"
#define LIBARCHIVE_VERSION_STRING "3.1.2"
#define LIBARCHIVE_VERSION_NUMBER "3001002"
#define BSDCPIO_VERSION_STRING "3.1.2"
#define BSDTAR_VERSION_STRING "3.1.2"
#define STDC_HEADERS 1
#define HAVE_SYS_TYPES_H 1
#define HAVE_SYS_STAT_H 1
#define HAVE_STDLIB_H 1
#define HAVE_STRING_H 1
#define HAVE_MEMORY_H 1
#define HAVE_STRINGS_H 1
#define HAVE_INTTYPES_H 1
#define HAVE_STDINT_H 1
#define HAVE_UNISTD_H 1
#define __EXTENSIONS__ 1
#define _ALL_SOURCE 1
#define _GNU_SOURCE 1
#define _POSIX_PTHREAD_SEMANTICS 1
#define _TANDEM_SOURCE 1
#define HAVE_DLFCN_H 1
#define LT_OBJDIR ".libs/"
#define HAVE_DIRENT_H 1
#define HAVE_SYS_WAIT_H 1
#define HAVE_CTYPE_H 1
#define HAVE_ERRNO_H 1
#define HAVE_FCNTL_H 1
#define HAVE_GRP_H 1
#define HAVE_INTTYPES_H 1
#define HAVE_LIMITS_H 1
#define HAVE_LINUX_FIEMAP_H 1
#define HAVE_LINUX_FS_H 1
#define HAVE_LINUX_MAGIC_H 1
#define HAVE_LINUX_TYPES_H 1
#define HAVE_LOCALE_H 1
#define HAVE_PATHS_H 1
#define HAVE_POLL_H 1
#define HAVE_PWD_H 1
#define HAVE_SIGNAL_H 1
#define HAVE_STDARG_H 1
#define HAVE_STDINT_H 1
#define HAVE_STDLIB_H 1
#define HAVE_STRING_H 1
#define HAVE_SYS_CDEFS_H 1
#define HAVE_SYS_IOCTL_H 1
#define HAVE_SYS_MOUNT_H 1
#define HAVE_SYS_PARAM_H 1
#define HAVE_SYS_POLL_H 1
#define HAVE_SYS_SELECT_H 1
#define HAVE_SYS_STATFS_H 1
#define HAVE_SYS_STATVFS_H 1
#define HAVE_SYS_TIME_H 1
#define HAVE_SYS_UTIME_H 1
#define HAVE_SYS_UTSNAME_H 1
#define HAVE_SYS_VFS_H 1
#define HAVE_TIME_H 1
#define HAVE_UNISTD_H 1
#define HAVE_UTIME_H 1
#define HAVE_WCHAR_H 1
#define HAVE_WCTYPE_H 1
#define HAVE_ZLIB_H 1
#define HAVE_LIBZ 1
#define HAVE_REGEX_H 1
#define HAVE_STRUCT_TM_TM_GMTOFF 1
#define HAVE_STRUCT_STAT_ST_BLKSIZE 1
#define HAVE_UINTMAX_T 1
#define HAVE_UNSIGNED_LONG_LONG 1
#define HAVE_UNSIGNED_LONG_LONG_INT 1
#define HAVE_LONG_LONG_INT 1
#define HAVE_INTMAX_T 1
#define HAVE_UINTMAX_T 1
#define HAVE_DECL_SIZE_MAX 1
#define HAVE_DECL_INT64_MAX 1
#define HAVE_DECL_INT64_MIN 1
#define HAVE_DECL_UINT64_MAX 1
#define HAVE_DECL_UINT32_MAX 1
#define HAVE_DECL_SSIZE_MAX 1
#define HAVE_EILSEQ 1
#define HAVE_WCHAR_T 1
#define SIZEOF_WCHAR_T 4
#define TIME_WITH_SYS_TIME 1
#define HAVE_FSEEKO 1
#define HAVE_LSTAT_EMPTY_STRING_BUG 1
#define HAVE_STAT_EMPTY_STRING_BUG 1
#define HAVE_DECL_STRERROR_R 1
#define HAVE_STRERROR_R 1
#define HAVE_STRFTIME 1
#define HAVE_VPRINTF 1
#define HAVE_CHOWN 1
#define HAVE_CHROOT 1
#define HAVE_CTIME_R 1
#define HAVE_DIRFD 1
#define HAVE_FCHDIR 1
#define HAVE_FCHMOD 1
#define HAVE_FCHOWN 1
#define HAVE_FCNTL 1
#define HAVE_FDOPENDIR 1
#define HAVE_FORK 1
#define HAVE_FSTAT 1
#define HAVE_FSTATAT 1
#define HAVE_FSTATFS 1
#define HAVE_FSTATVFS 1
#define HAVE_FTRUNCATE 1
#define HAVE_FUTIMENS 1
#define HAVE_GETEUID 1
#define HAVE_GETPID 1
#define HAVE_GETPWNAM_R 1
#define HAVE_GETPWUID_R 1
#define HAVE_GMTIME_R 1
#define HAVE_LCHOWN 1
#define HAVE_LINK 1
#define HAVE_LOCALTIME_R 1
#define HAVE_LSTAT 1
#define HAVE_MBRTOWC 1
#define HAVE_MEMMOVE 1
#define HAVE_MEMSET 1
#define HAVE_MKDIR 1
#define HAVE_MKFIFO 1
#define HAVE_MKNOD 1
#define HAVE_MKSTEMP 1
#define HAVE_OPENAT 1
#define HAVE_PIPE 1
#define HAVE_POLL 1
#define HAVE_READLINK 1
#define HAVE_READLINKAT 1
#define HAVE_SELECT 1
#define HAVE_SETENV 1
#define HAVE_SETLOCALE 1
#define HAVE_SIGACTION 1
#define HAVE_STATFS 1
#define HAVE_STATVFS 1
#define HAVE_STRCHR 1
#define HAVE_STRDUP 1
#define HAVE_STRERROR 1
#define HAVE_STRRCHR 1
#define HAVE_SYMLINK 1
#define HAVE_TIMEGM 1
#define HAVE_TZSET 1
#define HAVE_UNSETENV 1
#define HAVE_UTIME 1
#define HAVE_UTIMENSAT 1
#define HAVE_UTIMES 1
#define HAVE_VFORK 1
#define HAVE_WCRTOMB 1
#define HAVE_WCSCMP 1
#define HAVE_WCSCPY 1
#define HAVE_WCSLEN 1
#define HAVE_WCTOMB 1
#define HAVE_WMEMCMP 1
#define HAVE_WMEMCPY 1
#define HAVE_READDIR_R 1
#define HAVE_SYS_XATTR_H 1
#define HAVE_FGETXATTR 1
#define HAVE_FLISTXATTR 1
#define HAVE_FSETXATTR 1
#define HAVE_GETXATTR 1
#define HAVE_LGETXATTR 1
#define HAVE_LISTXATTR 1
#define HAVE_LLISTXATTR 1
#define HAVE_LSETXATTR 1
#define HAVE_DECL_EXTATTR_NAMESPACE_USER 0

configure: exit 0

===> Finished printing config.logs></pre></code>
        </body></html>
